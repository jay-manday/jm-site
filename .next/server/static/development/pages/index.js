module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = require('../../../ssr-module-cache.js');
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./buffer":
/*!***************************!*\
  !*** external "./buffer" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./buffer");

/***/ }),

/***/ "./buffer.js":
/*!******************************!*\
  !*** external "./buffer.js" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./buffer.js");

/***/ }),

/***/ "./components/About.jsx":
/*!******************************!*\
  !*** ./components/About.jsx ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rebass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rebass */ "rebass");
/* harmony import */ var rebass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rebass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "styled-components");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! grid-styled */ "grid-styled");
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(grid_styled__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _SectionTitle_SectionTitle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SectionTitle/SectionTitle */ "./components/SectionTitle/SectionTitle.jsx");

var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/About.jsx";

function _templateObject2() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  display: float;\n  font-size: 16px;\n  line-height: 24px;\n  text-decoration: none;\n}\n\n  background-color: black;\n  font-family: 'GrotesqueMT';\n  text-decoration: none;\n  display: float;\n  line-height: 40px;\n  font-size: 32px;\n  font-weight: 300;\n  color: white;\n  margin: 0;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  display: inline-block;\n  word-wrap: break-word;\n  font-size: 16px;\n  overflow-wrap: break-word;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n}\n\n  display:inline-block;\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n  padding: 0px;\n  margin: 0px;\n  color: white;\n\n  :hover {\n    color: red;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}







var About = function About() {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Flex"], {
    wrap: true,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 8
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    w: [1 / 4],
    p: [3, 4],
    pl: [2, 4],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 9
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_SectionTitle_SectionTitle__WEBPACK_IMPORTED_MODULE_5__["default"], {
    title: "about",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 10
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    w: [3 / 4],
    p: [2, 3],
    pl: [2, 3],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    width: [1],
    f: 3,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14
    },
    __self: this
  }, "I am a designer & engineer, currently:", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("br", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16
    },
    __self: this
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("br", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 17
    },
    __self: this
  }), "Investigating geospatial blockchain applications with ", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    href: "https://foam.space/",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19
    },
    __self: this
  }, " FOAM "), ".", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("br", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20
    },
    __self: this
  }), "Research Assistant at the \xA0", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    href: "https://urbansystemslab.com",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 22
    },
    __self: this
  }, "Urban\xA0Systems\xA0Lab"), " at\xA0", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    href: "https://newschool.edu/",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 23
    },
    __self: this
  }, "Parsons"), "."), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    py: [2, 3],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 26
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    width: [1],
    f: 3,
    pt: 3,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27
    },
    __self: this
  }, "School of Art + Design at Purchase"), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    width: [1],
    f: 3,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 30
    },
    __self: this
  }, "B.S. in Visual Arts and Mathematics", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("br", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 32
    },
    __self: this
  }))), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    pb: 3,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 36
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    width: [1],
    f: 3,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37
    },
    __self: this
  }, "jmandel1027@gmail.com ", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("br", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 38
    },
    __self: this
  }))), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 41
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    width: [1],
    f: 3,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    href: "https://d2w9rnfcy7mm78.cloudfront.net/1835707/large_101396e0eaa2e09220180303-4-13yb594.jpg",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43
    },
    __self: this
  }, "Resum\xE9")))));
};

/* harmony default export */ __webpack_exports__["default"] = (About);
var LinkStyle = styled_components__WEBPACK_IMPORTED_MODULE_3___default.a.a(_templateObject());
var AboutType = styled_components__WEBPACK_IMPORTED_MODULE_3___default()(rebass__WEBPACK_IMPORTED_MODULE_2__["Text"])(_templateObject2());

/***/ }),

/***/ "./components/Colophon.jsx":
/*!*********************************!*\
  !*** ./components/Colophon.jsx ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ "styled-components");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! grid-styled */ "grid-styled");
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(grid_styled__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _SectionTitle_SectionTitle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SectionTitle/SectionTitle */ "./components/SectionTitle/SectionTitle.jsx");
/* harmony import */ var _ContactIcons_ContactIcons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ContactIcons/ContactIcons */ "./components/ContactIcons/ContactIcons.jsx");

var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/Colophon.jsx";

function _templateObject2() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n}\n  :link {\n    color: #ffffff;\n  }\n  :active {\n    color: #ffffff;\n  }\n\n  :visited {\n    color: #ffffff;\n  }\n  :hover {\n    color: red;\n  }\n\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  font-size: 18px;\n  line-height: 20px;\n  text-decoration: none;\n}\n\n  background-color: black;\n  font-family: 'GrotesqueMT';\n  text-decoration: none;\n  line-height: 40px;\n  font-size: 32px;\n  font-weight: 300;\n  color: white;\n  margin: 0;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}







var Colophon = function Colophon() {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_3__["Flex"], {
    wrap: true,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 8
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_3__["Box"], {
    w: [1 / 4],
    p: [2, 3],
    pl: [2, 4],
    pt: [3, 4],
    mt: [0, 1],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 9
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_SectionTitle_SectionTitle__WEBPACK_IMPORTED_MODULE_4__["default"], {
    title: "colophon",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 10
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_3__["Box"], {
    w: 3 / 4,
    p: [2, 3],
    pl: [2, 3],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14
    },
    __self: this
  }, "set with \xA0", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    href: "https://www.bertholdtypes.com/font/akzidenz-grotesk/proplus/",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15
    },
    __self: this
  }, "akzidenz grotesk")), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19
    },
    __self: this
  }, "this site is built with \xA0", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    href: "https://reactjs.org/",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20
    },
    __self: this
  }, "react")), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 24
    },
    __self: this
  }, "hosted with \xA0", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    href: "https://zeit.co/now",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 25
    },
    __self: this
  }, "now"), "\xA0 and"), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(AboutType, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 30
    },
    __self: this
  }, "seeded on \xA0", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    href: "dat://jmandel-jaymanday.hashbase.io/",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 32
    },
    __self: this
  }, "dat")), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_3__["Flex"], {
    wrap: true,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 36
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_ContactIcons_ContactIcons__WEBPACK_IMPORTED_MODULE_5__["default"], {
    width: 45,
    height: 45,
    url: "https://www.linkedin.com/in/jason-mandel-960a39103/",
    image: "https://d2w9rnfcy7mm78.cloudfront.net/2138316/original_3a3e994d9cc235aff7e8f7ecf64a0101.png",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37
    },
    __self: this
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_ContactIcons_ContactIcons__WEBPACK_IMPORTED_MODULE_5__["default"], {
    width: 45,
    height: 45,
    url: "https://twitter.com/jaymanday",
    image: "https://d2w9rnfcy7mm78.cloudfront.net/1222973/original_a59c38ae69092fab601f6e88ba9a6d7f.png",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42
    },
    __self: this
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_ContactIcons_ContactIcons__WEBPACK_IMPORTED_MODULE_5__["default"], {
    width: 45,
    height: 45,
    url: "https://github.com/jay-manday",
    image: "https://d2w9rnfcy7mm78.cloudfront.net/1221844/original_713585cf2c09a83a4a06d0757b1a2fc3.png",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 48
    },
    __self: this
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_ContactIcons_ContactIcons__WEBPACK_IMPORTED_MODULE_5__["default"], {
    width: 55,
    height: 55,
    url: "https://www.are.na/jason-mandel-1484367816/channels",
    image: "https://d2w9rnfcy7mm78.cloudfront.net/1222957/original_e951a05eb73d4494cd78c92da928ec71.png",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 54
    },
    __self: this
  }))));
};

/* harmony default export */ __webpack_exports__["default"] = (Colophon);
var AboutType = styled_components__WEBPACK_IMPORTED_MODULE_2___default.a.h2(_templateObject());
var LinkStyle = styled_components__WEBPACK_IMPORTED_MODULE_2___default.a.a(_templateObject2());

/***/ }),

/***/ "./components/ContactIcons/ContactIcons.jsx":
/*!**************************************************!*\
  !*** ./components/ContactIcons/ContactIcons.jsx ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! grid-styled */ "grid-styled");
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(grid_styled__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rebass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rebass */ "rebass");
/* harmony import */ var rebass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rebass__WEBPACK_IMPORTED_MODULE_2__);
var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/ContactIcons/ContactIcons.jsx";




var ContactIcons = function ContactIcons(props) {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    width: props.width,
    height: props.height,
    pr: 2,
    pt: 1,
    pb: 1,
    ml: props.margin,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 6
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", {
    href: props.url,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 7
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(rebass__WEBPACK_IMPORTED_MODULE_2__["Image"], {
    src: props.image,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 8
    },
    __self: this
  })));
};

/* harmony default export */ __webpack_exports__["default"] = (ContactIcons);

/***/ }),

/***/ "./components/NavTitle/NavTitle.jsx":
/*!******************************************!*\
  !*** ./components/NavTitle/NavTitle.jsx ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next */ "./node_modules/next/dist/server/next.js");
/* harmony import */ var next__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "styled-components");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_3__);

var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/NavTitle/NavTitle.jsx";

function _templateObject2() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n  @media (max-width: 50em) {\n    display: none;\n  }\n\n  display: inline-block;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n  @media (max-width: 48em) {\n    font-size: 20px;\n    display:inline-block;\n    text-decoration: underline;\n    text-decoration-color: #0000ee;\n    padding-bottom: 0px;\n  }\n    :hover {\n      color: red;\n    }\n\n    display:inline-block;\n    text-decoration: underline;\n    text-decoration-color: #0000ee;\n    font-family: 'GrotesqueMT-Italic';\n    font-weight: normal;\n    font-size: 32px;\n    color: white;\n    padding-bottom: 5px;\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}





var NavTitle = function NavTitle() {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    to: '/',
    __source: {
      fileName: _jsxFileName,
      lineNumber: 7
    },
    __self: this
  }, "J", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Spanned, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 8
    },
    __self: this
  }, "ason"), " Mandel");
};

/* harmony default export */ __webpack_exports__["default"] = (NavTitle);
var LinkStyle = styled_components__WEBPACK_IMPORTED_MODULE_3___default()(next__WEBPACK_IMPORTED_MODULE_2__["Link"])(_templateObject());
var Spanned = styled_components__WEBPACK_IMPORTED_MODULE_3___default.a.span(_templateObject2());

/***/ }),

/***/ "./components/Navigation.jsx":
/*!***********************************!*\
  !*** ./components/Navigation.jsx ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! grid-styled */ "grid-styled");
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(grid_styled__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _NavTitle_NavTitle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NavTitle/NavTitle */ "./components/NavTitle/NavTitle.jsx");
/* harmony import */ var _SectionTitle_SectionTitle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SectionTitle/SectionTitle */ "./components/SectionTitle/SectionTitle.jsx");
var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/Navigation.jsx";




var data = [{
  id: 1,
  name: 'about'
}, {
  id: 2,
  name: 'work'
}, {
  id: 3,
  name: 'writings'
}];

var Navigation = function Navigation() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Flex"], {
    wrap: true,
    align: "baseline",
    justify: "space-around",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    w: [1 / 4],
    pt: [3, 4],
    pb: [3, 4],
    pl: [2, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_NavTitle_NavTitle__WEBPACK_IMPORTED_MODULE_2__["default"], {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15
    },
    __self: this
  })), data.map(function (item, id) {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
      key: id,
      w: [1 / 4],
      p: [3, 4],
      pl: [2, 3],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 18
      },
      __self: this
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_SectionTitle_SectionTitle__WEBPACK_IMPORTED_MODULE_3__["default"], {
      title: item.name,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 19
      },
      __self: this
    }));
  }));
};

/* harmony default export */ __webpack_exports__["default"] = (Navigation);

/***/ }),

/***/ "./components/SectionTitle/SectionTitle.jsx":
/*!**************************************************!*\
  !*** ./components/SectionTitle/SectionTitle.jsx ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "react-router-dom");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "styled-components");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_3__);

var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/SectionTitle/SectionTitle.jsx";

function _templateObject2() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  display:inline-block;\n  line-height: 24px;\n  font-size: 20px;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n}\n  :hover {\n    color: red;\n  }\n  display:inline-block;\n  text-decoration: underline;\n    text-decoration-color: #0000ee;\n  background-color: black;\n  font-family: 'GrotesqueMT';\n  font-size: 32px;\n  font-weight: 300;\n  color: white;\n  margin: 0;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}





var SectionTitle = function SectionTitle(props) {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(LinkStyle, {
    to: "/".concat(props.title),
    __source: {
      fileName: _jsxFileName,
      lineNumber: 6
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(TitleStyle, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 7
    },
    __self: this
  }, props.title));
};

/* harmony default export */ __webpack_exports__["default"] = (SectionTitle);
var LinkStyle = styled_components__WEBPACK_IMPORTED_MODULE_3___default()(react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Link"])(_templateObject());
var TitleStyle = styled_components__WEBPACK_IMPORTED_MODULE_3___default.a.p(_templateObject2());

/***/ }),

/***/ "./components/SketchWrapper/SketchWrapper.jsx":
/*!****************************************************!*\
  !*** ./components/SketchWrapper/SketchWrapper.jsx ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-router-dom */ "react-router-dom");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! grid-styled */ "grid-styled");
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(grid_styled__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! styled-components */ "styled-components");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var react_p5_wrapper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-p5-wrapper */ "react-p5-wrapper");
/* harmony import */ var react_p5_wrapper__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(react_p5_wrapper__WEBPACK_IMPORTED_MODULE_11__);







var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/SketchWrapper/SketchWrapper.jsx";

function _templateObject3() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  display:inline-block;\n  font-size: 1em;\n}\n  font-family: GrotesqueMT;\n  font-style: italic;\n  font-size: 1.5em;\n  color: white;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  margin: 0;\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  display:inline-block;\n  font-size: 1.25em;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n\n}\n  :hover {\n    color: red;\n  }\n\n  font-family: GrotesqueMT;\n  font-style: italic;\n  font-size: 2em;\n  color: white;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n  margin: 0;\n\n  display:inline-block;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n  color: white;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  margin: 0px;\n\n  :hover {\n    color: red;\n  }\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}







var SketchWrapper =
/*#__PURE__*/
function (_React$Component) {
  Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_6__["default"])(SketchWrapper, _React$Component);

  function SketchWrapper(props) {
    var _this;

    Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, SketchWrapper);

    _this = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(SketchWrapper).call(this, props));
    _this.updateDimensions = _this.updateDimensions.bind(Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__["default"])(_this));
    _this.state = {
      ready: false,
      width: undefined,
      heigh: undefined
    };
    return _this;
  }

  Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(SketchWrapper, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var height = document.getElementById('canvas').clientWidth;
      var width = document.getElementById('canvas').clientWidth;
      window.addEventListener('Resize', this.updateDimensions);
      console.log("mounted P5Wrapper");
      this.setState({
        ready: true,
        width: width,
        height: height
      });
    }
  }, {
    key: "updateDimensions",
    value: function updateDimensions(width, height) {
      console.log("updating dimensions: ".concat(window.innerWidth));
      this.setState({
        height: height,
        width: width
      });
      console.log("changed");
    }
  }, {
    key: "compnentWillUnmount",
    value: function compnentWillUnmount() {
      window.removeEventListener('Resize', this.updateDimensions);
      console.log("removed event listener");
    }
  }, {
    key: "render",
    value: function render() {
      console.log("rendered P5Wrapper");
      return react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_9__["Box"], {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 46
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(StyledSketch, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 48
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_9__["Box"], {
        w: 1,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 49
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement("div", {
        className: "canvas-wrapper",
        id: "canvas",
        __source: {
          fileName: _jsxFileName,
          lineNumber: 50
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_8__["Link"], {
        to: this.props.href,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 51
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(react_p5_wrapper__WEBPACK_IMPORTED_MODULE_11___default.a, {
        sketch: this.props.sketch,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 52
        },
        __self: this
      }))))), react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_9__["Box"], {
        pt: 3,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 58
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_8__["Link"], {
        to: this.props.href,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 59
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(TitleStyle, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 60
        },
        __self: this
      }, this.props.title))), react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_9__["Box"], {
        pt: 1,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 66
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(SubStyle, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 67
        },
        __self: this
      }, this.props.medium)));
    }
  }]);

  return SketchWrapper;
}(react__WEBPACK_IMPORTED_MODULE_7___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (SketchWrapper);
var StyledSketch = styled_components__WEBPACK_IMPORTED_MODULE_10___default.a.div(_templateObject());
var TitleStyle = styled_components__WEBPACK_IMPORTED_MODULE_10___default.a.h1(_templateObject2());
var SubStyle = styled_components__WEBPACK_IMPORTED_MODULE_10___default.a.h1(_templateObject3());

/***/ }),

/***/ "./components/Sketches/Clock.jsx":
/*!***************************************!*\
  !*** ./components/Sketches/Clock.jsx ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Clock; });
function Clock(p) {
  var doc = document.getElementById('canvas'); // Hours

  var t = 0.05;

  var x1 = function x1(t) {
    return p.sin(t / 3.14) * doc.clientWidth / 10 + p.sin(-t / 42) * 20;
  };

  var y1 = function y1(t) {
    return p.cos(t / 3.14) * doc.clientWidth / 5;
  };

  var x2 = function x2(t) {
    return p.sin(t / 3.14) * doc.clientWidth / 5 + p.sin(-t) * 2;
  };

  var y2 = function y2(t) {
    return p.cos(t / 3.14) * doc.clientWidth / 10 + p.cos(t / 24) + 2;
  }; // Minutes


  var aX = doc.clientWidth / 20;
  var aY = doc.clientWidth / 20;
  var bX = doc.clientWidth / 2 - 20;
  var bY = doc.clientWidth / 20;
  var cX = doc.clientWidth / 2 - 20;
  var cY = doc.clientWidth / 2 - 20;
  var dX = doc.clientWidth / 20;
  var dY = doc.clientWidth / 2 - 20;
  var lineXa = new Array(60);
  var lineYa = new Array(60);
  var lineXb = new Array(60);
  var lineYb = new Array(60); // Seconds

  var cx, cy;
  var secR;

  p.setup = function () {
    p.createCanvas(doc.clientWidth, doc.clientWidth);
    p.stroke(255);

    for (var i = 0; i < 60; i++) {
      if (i % 4 === 0) {
        lineXa[i] = p.random(aX, bX);
        lineYa[i] = p.random(aY, bY);
        lineXb[i] = p.random(bX, cX);
        lineYb[i] = p.random(bY, cY);
      }

      if (i % 4 === 1) {
        lineXa[i] = p.random(bX, cX);
        lineYa[i] = p.random(bY, cY);
        lineXb[i] = p.random(dX, cX);
        lineYb[i] = p.random(dY, cY);
      }

      if (i % 4 === 2) {
        lineXa[i] = p.random(dX, cX);
        lineYa[i] = p.random(cY, dY);
        lineXb[i] = p.random(aX, dX);
        lineYb[i] = p.random(aY, dY);
      }

      if (i % 4 === 3) {
        lineXa[i] = p.random(aX, dX);
        lineYa[i] = p.random(aY, dY);
        lineXb[i] = p.random(aX, bX);
        lineYb[i] = p.random(aY, bY);
      }
    }
  };

  p.windowResized = function () {
    p.resizeCanvas(doc.clientWidth, doc.clientWidth);
  };

  p.draw = function () {
    p.background(0); // hours

    p.stroke(225);
    p.strokeWeight(2);
    p.translate(doc.clientWidth / 4, doc.clientWidth / 4);

    for (var _i = 0; _i < p.hour(); _i++) {
      p.line(x1(t - _i), y1(t - _i), x2(t + _i), y2(t + _i));
    }

    t += 0.05; // minutes
    //translate(doc.clientWidth/9, doc.clientWidth/8);

    p.stroke(225);
    p.strokeWeight(1);

    for (var _i2 = 0; _i2 < p.minute(); _i2++) {
      p.line(lineXa[_i2], lineYa[_i2], lineXb[_i2], lineYb[_i2]);
    } // Seconds
    // subtract HALF_PI to make them start at the top


    var r = p.min(doc.clientWidth, doc.clientWidth);
    secR = r * 0.18;
    cx = doc.clientWidth - doc.clientWidth / 2;
    cy = doc.clientWidth - doc.clientWidth / 2;
    var s = p.map(p.second(), 0, 60, 0, p.TWO_PI) - p.HALF_PI; // Draw the hands of the clock

    p.stroke(225);
    p.strokeWeight(2);

    for (var i = 0; i < doc.clientWidth / 6; i += 20) {
      // Seconds all linked to clock in middle of grd
      p.line(cx, cy, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
      p.line(cx + doc.clientWidth / 6, cy, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
      p.line(cx + doc.clientWidth / 6, cy - doc.clientWidth / 6, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
      p.line(cx - doc.clientWidth / 6, cy, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
      p.line(cx, cy + doc.clientWidth / 6, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
      p.line(cx, cy - doc.clientWidth / 6, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
      p.line(cx - doc.clientWidth / 6, cy - doc.clientWidth / 6, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
      p.line(cx - doc.clientWidth / 6, cy + doc.clientWidth / 6, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
      p.line(cx + doc.clientWidth / 6, cy + doc.clientWidth / 6, cx + p.cos(s) * secR, cy + p.sin(s) * secR);
    }
  };
}

/***/ }),

/***/ "./components/Work.jsx":
/*!*****************************!*\
  !*** ./components/Work.jsx ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! grid-styled */ "grid-styled");
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(grid_styled__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _SectionTitle_SectionTitle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SectionTitle/SectionTitle */ "./components/SectionTitle/SectionTitle.jsx");
/* harmony import */ var _WorkItems_WorkItems__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WorkItems/WorkItems */ "./components/WorkItems/WorkItems.jsx");
/* harmony import */ var _SketchWrapper_SketchWrapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SketchWrapper/SketchWrapper */ "./components/SketchWrapper/SketchWrapper.jsx");
/* harmony import */ var _Sketches_Clock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Sketches/Clock */ "./components/Sketches/Clock.jsx");
var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/Work.jsx";







var Work = function Work() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Flex"], {
    wrap: true,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 9
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    w: [1 / 4],
    pt: [3, 4],
    pb: [3, 4],
    pl: [2, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 10
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_SectionTitle_SectionTitle__WEBPACK_IMPORTED_MODULE_2__["default"], {
    title: "work",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 11
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Grid"], {
    width: 3 / 4,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Flex"], {
    wrap: true,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    w: [1, 1 / 2, 1 / 3],
    p: [2, 3],
    pl: [2, 3],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_WorkItems_WorkItems__WEBPACK_IMPORTED_MODULE_3__["default"], {
    href: "/work/foam",
    img: "https://d2w9rnfcy7mm78.cloudfront.net/2111176/large_425ea424d82a29c1ac59d70eb7d4fa00.png",
    title: 'FOAM',
    medium: 'Product Design & Engineering',
    site: '2018',
    __source: {
      fileName: _jsxFileName,
      lineNumber: 17
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    w: [1, 1 / 2, 1 / 3],
    p: [2, 3],
    pl: [2, 3],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 25
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_WorkItems_WorkItems__WEBPACK_IMPORTED_MODULE_3__["default"], {
    href: "/work/urban-systems",
    img: "https://d2w9rnfcy7mm78.cloudfront.net/2138198/large_251a389cfa80552a3b60cbc1c7f7e1f7.png",
    title: 'Urban Systems Lab',
    medium: 'Strategizing Urban Resiliency',
    site: '2018',
    __source: {
      fileName: _jsxFileName,
      lineNumber: 26
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    w: [1, 1 / 2, 1 / 3],
    p: [2, 3],
    pl: [2, 3],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 34
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_WorkItems_WorkItems__WEBPACK_IMPORTED_MODULE_3__["default"], {
    href: "/work/graphics",
    img: "https://d2w9rnfcy7mm78.cloudfront.net/1219626/large_634b313d842272ccff0523507d676ab8.jpg",
    title: 'Graphics',
    medium: '2016 - 2018',
    site: ' ',
    __source: {
      fileName: _jsxFileName,
      lineNumber: 35
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    w: [1, 1 / 2, 1 / 3],
    p: [2, 3],
    pl: [2, 3],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 44
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_WorkItems_WorkItems__WEBPACK_IMPORTED_MODULE_3__["default"], {
    href: "/work/the-multi",
    img: "https://d2w9rnfcy7mm78.cloudfront.net/1450245/original_4f1645b374101daf0f70fcb0013b7c2b.png",
    title: 'The Multi 18',
    medium: 'design conference',
    site: '2017 - 2018',
    __source: {
      fileName: _jsxFileName,
      lineNumber: 45
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    w: [1, 1 / 2, 1 / 3],
    p: [2, 3],
    pl: [2, 3],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 53
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_SketchWrapper_SketchWrapper__WEBPACK_IMPORTED_MODULE_4__["default"], {
    href: "/work/contingent-clock",
    classID: 'SketchWrapper',
    className: 'sketch',
    sketch: _Sketches_Clock__WEBPACK_IMPORTED_MODULE_5__["default"],
    title: 'Contingent Clock',
    medium: 'Chance and Code',
    site: "2016",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 54
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_1__["Box"], {
    w: [1, 1 / 2, 1 / 3],
    p: [2, 3],
    pl: [2, 3],
    pt: [3, 4],
    __source: {
      fileName: _jsxFileName,
      lineNumber: 65
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_WorkItems_WorkItems__WEBPACK_IMPORTED_MODULE_3__["default"], {
    href: "/work/paper-score-three",
    img: "https://d2w9rnfcy7mm78.cloudfront.net/1156854/original_7ea09cc794c5a2b2c9ec4ab1702d9bc7.jpg",
    title: 'Paper Score #3',
    medium: 'paper, piezos, & pure data',
    site: 'Neuberger Museum, 2016',
    __source: {
      fileName: _jsxFileName,
      lineNumber: 66
    },
    __self: this
  })))));
};

/* harmony default export */ __webpack_exports__["default"] = (Work);

/***/ }),

/***/ "./components/WorkItems/WorkItems.jsx":
/*!********************************************!*\
  !*** ./components/WorkItems/WorkItems.jsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "react-router-dom");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "styled-components");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! grid-styled */ "grid-styled");
/* harmony import */ var grid_styled__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(grid_styled__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var rebass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rebass */ "rebass");
/* harmony import */ var rebass__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(rebass__WEBPACK_IMPORTED_MODULE_5__);

var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/components/WorkItems/WorkItems.jsx";

function _templateObject2() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  display:inline-block;\n  font-size: 16px;\n}\n  font-family: GrotesqueMT;\n  font-style: italic;\n  font-size: 24px;\n  color: white;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  margin: 0;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n@media (max-width: 48em) {\n  display:inline-block;\n  font-size: 20px;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n\n}\n  :hover {\n    color: red;\n  }\n\n  font-family: GrotesqueMT;\n  font-style: italic;\n  font-size: 32px;\n  color: white;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n  margin: 0;\n\n  display:inline-block;\n  text-decoration: underline;\n  text-decoration-color: #0000ee;\n  color: white;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  margin: 0px;\n\n  :hover {\n    color: red;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}







var WorkItems = function WorkItems(props) {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 9
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Link"], {
    to: props.href,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 10
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(rebass__WEBPACK_IMPORTED_MODULE_5__["Image"], {
    src: props.img,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 11
    },
    __self: this
  })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    pt: 3,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Link"], {
    to: props.href,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(TitleStyle, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 17
    },
    __self: this
  }, props.title))), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    pt: 1,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 23
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(SubStyle, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 24
    },
    __self: this
  }, props.medium)), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(grid_styled__WEBPACK_IMPORTED_MODULE_4__["Box"], {
    pt: 1,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 29
    },
    __self: this
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(SubStyle, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 30
    },
    __self: this
  }, props.site)));
};

/* harmony default export */ __webpack_exports__["default"] = (WorkItems);
var TitleStyle = styled_components__WEBPACK_IMPORTED_MODULE_3___default.a.h1(_templateObject());
var SubStyle = styled_components__WEBPACK_IMPORTED_MODULE_3___default.a.h1(_templateObject2());

/***/ }),

/***/ "./console":
/*!****************************!*\
  !*** external "./console" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./console");

/***/ }),

/***/ "./console.js":
/*!*******************************!*\
  !*** external "./console.js" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./console.js");

/***/ }),

/***/ "./dns":
/*!************************!*\
  !*** external "./dns" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./dns");

/***/ }),

/***/ "./dns.js":
/*!***************************!*\
  !*** external "./dns.js" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./dns.js");

/***/ }),

/***/ "./empty":
/*!**************************!*\
  !*** external "./empty" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./empty");

/***/ }),

/***/ "./empty.js":
/*!*****************************!*\
  !*** external "./empty.js" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./empty.js");

/***/ }),

/***/ "./net":
/*!************************!*\
  !*** external "./net" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./net");

/***/ }),

/***/ "./net.js":
/*!***************************!*\
  !*** external "./net.js" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./net.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/core-js/array/is-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/core-js/array/is-array.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js/library/fn/array/is-array */ "core-js/library/fn/array/is-array");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js/library/fn/get-iterator */ "core-js/library/fn/get-iterator");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/arrayWithHoles.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/arrayWithHoles.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Array$isArray = __webpack_require__(/*! ../core-js/array/is-array */ "./node_modules/@babel/runtime-corejs2/core-js/array/is-array.js");

function _arrayWithHoles(arr) {
  if (_Array$isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/interopRequireDefault.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/interopRequireDefault.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/iterableToArrayLimit.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/iterableToArrayLimit.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _getIterator = __webpack_require__(/*! ../core-js/get-iterator */ "./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js");

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = _getIterator(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/nonIterableRest.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/nonIterableRest.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/slicedToArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/slicedToArray.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime-corejs2/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime-corejs2/helpers/iterableToArrayLimit.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime-corejs2/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _getPrototypeOf; });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inherits; });
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _possibleConstructorReturn; });
/* harmony import */ var _helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/esm/typeof */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && (Object(_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Object(_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _setPrototypeOf; });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _taggedTemplateLiteral; });
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

/***/ }),

/***/ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _typeof; });
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "./node_modules/next/dist/build/entries.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/build/entries.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(/*! path */ "path");
const querystring_1 = __webpack_require__(/*! querystring */ "querystring");
const constants_1 = __webpack_require__(/*! ../lib/constants */ "./node_modules/next/dist/lib/constants.js");
function createPagesMapping(pagePaths, extensions) {
    const pages = pagePaths.reduce((result, pagePath) => {
        const page = `/${pagePath.replace(new RegExp(`\\.+(${extensions.join('|')})$`), '').replace(/\\/g, '/')}`.replace(/\/index$/, '');
        result[page === '' ? '/' : page] = path_1.join(constants_1.PAGES_DIR_ALIAS, pagePath).replace(/\\/g, '/');
        return result;
    }, {});
    pages['/_app'] = pages['/_app'] || 'next/dist/pages/_app';
    pages['/_error'] = pages['/_error'] || 'next/dist/pages/_error';
    pages['/_document'] = pages['/_document'] || 'next/dist/pages/_document';
    return pages;
}
exports.createPagesMapping = createPagesMapping;
function createEntrypoints(pages, target, buildId, config) {
    const client = {};
    const server = {};
    const defaultServerlessOptions = {
        absoluteAppPath: pages['/_app'],
        absoluteDocumentPath: pages['/_document'],
        absoluteErrorPath: pages['/_error'],
        distDir: constants_1.DOT_NEXT_ALIAS,
        buildId,
        assetPrefix: config.assetPrefix,
        generateEtags: config.generateEtags
    };
    Object.keys(pages).forEach((page) => {
        const absolutePagePath = pages[page];
        const bundleFile = page === '/' ? '/index.js' : `${page}.js`;
        const bundlePath = path_1.join('static', buildId, 'pages', bundleFile);
        if (target === 'serverless') {
            const serverlessLoaderOptions = Object.assign({ page, absolutePagePath }, defaultServerlessOptions);
            server[path_1.join('pages', bundleFile)] = `next-serverless-loader?${querystring_1.stringify(serverlessLoaderOptions)}!`;
        }
        else if (target === 'server') {
            server[bundlePath] = [absolutePagePath];
        }
        if (page === '/_document') {
            return;
        }
        client[bundlePath] = `next-client-pages-loader?${querystring_1.stringify({ page, absolutePagePath })}!`;
    });
    return {
        client,
        server
    };
}
exports.createEntrypoints = createEntrypoints;


/***/ }),

/***/ "./node_modules/next/dist/build/output/exit.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/build/output/exit.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function onExit(fn) {
    function exit(signal = '') {
        try {
            if (listeners.length) {
                fn();
            }
        }
        finally {
            while (listeners.length) {
                const { event, handler } = listeners.shift();
                process.removeListener(event, handler);
            }
            if (signal) {
                process.kill(process.pid, signal);
            }
        }
    }
    const listeners = [
        { event: 'SIGINT', handler: () => exit('SIGINT') },
        { event: 'SIGHUP', handler: () => exit('SIGHUP') },
        { event: 'SIGQUIT', handler: () => exit('SIGQUIT') },
        { event: 'SIGTERM', handler: () => exit('SIGTERM') },
        {
            event: 'uncaughtException',
            handler: () => {
                exit();
                process.exit(1);
            },
        },
        { event: 'exit', handler: () => exit() },
    ];
    for (const { event, handler } of listeners) {
        process.on(event, handler);
    }
}
exports.onExit = onExit;


/***/ }),

/***/ "./node_modules/next/dist/build/output/index.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/build/output/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const unistore_1 = __importDefault(__webpack_require__(/*! unistore */ "unistore"));
const store_1 = __webpack_require__(/*! ./store */ "./node_modules/next/dist/build/output/store.js");
const format_webpack_messages_1 = __importDefault(__webpack_require__(/*! ../../client/dev-error-overlay/format-webpack-messages */ "./node_modules/next/dist/client/dev-error-overlay/format-webpack-messages.js"));
function startedDevelopmentServer(appUrl) {
    store_1.store.setState({ appUrl });
}
exports.startedDevelopmentServer = startedDevelopmentServer;
let previousClient = null;
let previousServer = null;
var WebpackStatusPhase;
(function (WebpackStatusPhase) {
    WebpackStatusPhase[WebpackStatusPhase["COMPILING"] = 1] = "COMPILING";
    WebpackStatusPhase[WebpackStatusPhase["COMPILED_WITH_ERRORS"] = 2] = "COMPILED_WITH_ERRORS";
    WebpackStatusPhase[WebpackStatusPhase["COMPILED_WITH_WARNINGS"] = 3] = "COMPILED_WITH_WARNINGS";
    WebpackStatusPhase[WebpackStatusPhase["COMPILED"] = 4] = "COMPILED";
})(WebpackStatusPhase || (WebpackStatusPhase = {}));
function getWebpackStatusPhase(status) {
    if (status.loading) {
        return WebpackStatusPhase.COMPILING;
    }
    if (status.errors) {
        return WebpackStatusPhase.COMPILED_WITH_ERRORS;
    }
    if (status.warnings) {
        return WebpackStatusPhase.COMPILED_WITH_WARNINGS;
    }
    return WebpackStatusPhase.COMPILED;
}
const webpackStore = unistore_1.default();
webpackStore.subscribe(state => {
    const { client, server } = state;
    const [{ status }] = [
        { status: client, phase: getWebpackStatusPhase(client) },
        { status: server, phase: getWebpackStatusPhase(server) },
    ].sort((a, b) => a.phase.valueOf() - b.phase.valueOf());
    const { bootstrap: bootstrapping, appUrl } = store_1.store.getState();
    if (bootstrapping && status.loading) {
        return;
    }
    let nextStoreState = Object.assign({ bootstrap: false, appUrl: appUrl }, status);
    store_1.store.setState(nextStoreState, true);
});
function watchCompiler(client, server) {
    if (previousClient === client && previousServer === server) {
        return;
    }
    webpackStore.setState({
        client: { loading: true },
        server: { loading: true },
    });
    function tapCompiler(key, compiler, onEvent) {
        compiler.hooks.invalid.tap(`NextJsInvalid-${key}`, () => {
            onEvent({ loading: true });
        });
        compiler.hooks.done.tap(`NextJsDone-${key}`, (stats) => {
            const { errors, warnings } = format_webpack_messages_1.default(stats.toJson({ all: false, warnings: true, errors: true }));
            onEvent({
                loading: false,
                errors: errors && errors.length ? errors : null,
                warnings: warnings && warnings.length ? warnings : null,
            });
        });
    }
    tapCompiler('client', client, status => webpackStore.setState({ client: status }));
    tapCompiler('server', server, status => webpackStore.setState({ server: status }));
    previousClient = client;
    previousServer = server;
}
exports.watchCompiler = watchCompiler;


/***/ }),

/***/ "./node_modules/next/dist/build/output/store.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/build/output/store.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "chalk"));
const unistore_1 = __importDefault(__webpack_require__(/*! unistore */ "unistore"));
const readline_1 = __importDefault(__webpack_require__(/*! readline */ "readline"));
const exit_1 = __webpack_require__(/*! ./exit */ "./node_modules/next/dist/build/output/exit.js");
exports.store = unistore_1.default({ appUrl: null, bootstrap: true });
process.stdout.write('\n'.repeat(process.stdout.rows || 1));
process.stdout.write('\u001b[?25l');
exit_1.onExit(() => {
    process.stdout.write('\u001b[?25h');
});
exports.store.subscribe(state => {
    readline_1.default.cursorTo(process.stdout, 0, 0);
    readline_1.default.clearScreenDown(process.stdout);
    if (state.bootstrap) {
        console.log(chalk_1.default.cyan('Starting the development server ...'));
        if (state.appUrl) {
            console.log();
            console.log(`  > Waiting on ${state.appUrl}`);
        }
        return;
    }
    if (state.loading) {
        console.log('Compiling ...');
        return;
    }
    if (state.errors) {
        console.log(chalk_1.default.red('Failed to compile.'));
        console.log();
        console.log(state.errors[0]);
        return;
    }
    if (state.warnings) {
        console.log(chalk_1.default.yellow('Compiled with warnings.'));
        console.log();
        console.log(state.warnings.join('\n\n'));
        return;
    }
    console.log(chalk_1.default.green('Compiled successfully!'));
    if (state.appUrl) {
        console.log();
        console.log(`  > Ready on ${state.appUrl}`);
    }
    console.log();
    console.log('Note that pages will be compiled when you first load them.');
});


/***/ }),

/***/ "./node_modules/next/dist/build/webpack-config.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/build/webpack-config.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const webpack_1 = __importDefault(__webpack_require__(/*! webpack */ "./node_modules/webpack/lib/webpack.js"));
const resolve_1 = __importDefault(__webpack_require__(/*! resolve */ "resolve"));
const case_sensitive_paths_webpack_plugin_1 = __importDefault(__webpack_require__(/*! case-sensitive-paths-webpack-plugin */ "case-sensitive-paths-webpack-plugin"));
const nextjs_ssr_import_1 = __importDefault(__webpack_require__(/*! ./webpack/plugins/nextjs-ssr-import */ "./node_modules/next/dist/build/webpack/plugins/nextjs-ssr-import.js"));
const nextjs_ssr_module_cache_1 = __importDefault(__webpack_require__(/*! ./webpack/plugins/nextjs-ssr-module-cache */ "./node_modules/next/dist/build/webpack/plugins/nextjs-ssr-module-cache.js"));
const nextjs_require_cache_hot_reloader_1 = __importDefault(__webpack_require__(/*! ./webpack/plugins/nextjs-require-cache-hot-reloader */ "./node_modules/next/dist/build/webpack/plugins/nextjs-require-cache-hot-reloader.js"));
const unlink_file_plugin_1 = __importDefault(__webpack_require__(/*! ./webpack/plugins/unlink-file-plugin */ "./node_modules/next/dist/build/webpack/plugins/unlink-file-plugin.js"));
const pages_manifest_plugin_1 = __importDefault(__webpack_require__(/*! ./webpack/plugins/pages-manifest-plugin */ "./node_modules/next/dist/build/webpack/plugins/pages-manifest-plugin.js"));
const build_manifest_plugin_1 = __importDefault(__webpack_require__(/*! ./webpack/plugins/build-manifest-plugin */ "./node_modules/next/dist/build/webpack/plugins/build-manifest-plugin.js"));
const chunk_names_plugin_1 = __importDefault(__webpack_require__(/*! ./webpack/plugins/chunk-names-plugin */ "./node_modules/next/dist/build/webpack/plugins/chunk-names-plugin.js"));
const react_loadable_plugin_1 = __webpack_require__(/*! ./webpack/plugins/react-loadable-plugin */ "./node_modules/next/dist/build/webpack/plugins/react-loadable-plugin.js");
const constants_1 = __webpack_require__(/*! next-server/constants */ "next-server/constants");
const constants_2 = __webpack_require__(/*! ../lib/constants */ "./node_modules/next/dist/lib/constants.js");
const autodll_webpack_plugin_1 = __importDefault(__webpack_require__(/*! autodll-webpack-plugin */ "autodll-webpack-plugin"));
const cjs_js_1 = __importDefault(__webpack_require__(/*! ./webpack/plugins/terser-webpack-plugin/src/cjs.js */ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/cjs.js"));
const serverless_plugin_1 = __webpack_require__(/*! ./webpack/plugins/serverless-plugin */ "./node_modules/next/dist/build/webpack/plugins/serverless-plugin.js");
function getBaseWebpackConfig(dir, { dev = false, isServer = false, buildId, config, target = 'server', entrypoints }) {
    const defaultLoaders = {
        babel: {
            loader: 'next-babel-loader',
            options: { dev, isServer, cwd: dir }
        },
        // Backwards compat
        hotSelfAccept: {
            loader: 'noop-loader'
        }
    };
    // Support for NODE_PATH
    const nodePathList = (process.env.NODE_PATH || '')
        .split(process.platform === 'win32' ? ';' : ':')
        .filter((p) => !!p);
    const distDir = path_1.default.join(dir, config.distDir);
    const outputDir = target === 'serverless' ? 'serverless' : constants_1.SERVER_DIRECTORY;
    const outputPath = path_1.default.join(distDir, isServer ? outputDir : '');
    const totalPages = Object.keys(entrypoints).length;
    const clientEntries = !isServer ? {
        // Backwards compatibility
        'main.js': [],
        [constants_1.CLIENT_STATIC_FILES_RUNTIME_MAIN]: [
            path_1.default.join(constants_2.NEXT_PROJECT_ROOT_DIST_CLIENT, (dev ? `next-dev` : 'next'))
        ].filter(Boolean)
    } : undefined;
    const resolveConfig = {
        // Disable .mjs for node_modules bundling
        extensions: isServer ? ['.wasm', '.js', '.mjs', '.jsx', '.json'] : ['.wasm', '.mjs', '.js', '.jsx', '.json'],
        modules: [
            'node_modules',
            ...nodePathList // Support for NODE_PATH environment variable
        ],
        alias: {
            next: constants_2.NEXT_PROJECT_ROOT,
            [constants_2.PAGES_DIR_ALIAS]: path_1.default.join(dir, 'pages'),
            [constants_2.DOT_NEXT_ALIAS]: distDir
        },
        mainFields: isServer ? ['main', 'module'] : ['browser', 'module', 'main']
    };
    const webpackMode = dev ? 'development' : 'production';
    const terserPluginConfig = {
        parallel: true,
        sourceMap: false,
        cache: true,
        cacheKeys: (keys) => {
            // path changes per build because we add buildId
            // because the input is already hashed the path is not needed
            delete keys.path;
            return keys;
        }
    };
    let webpackConfig = {
        mode: webpackMode,
        devtool: dev ? 'cheap-module-source-map' : false,
        name: isServer ? 'server' : 'client',
        target: isServer ? 'node' : 'web',
        externals: isServer && target !== 'serverless' ? [
            (context, request, callback) => {
                const notExternalModules = ['next/app', 'next/document', 'next/link', 'next/router', 'next/error', 'http-status', 'string-hash', 'hoist-non-react-statics', 'htmlescape'];
                if (notExternalModules.indexOf(request) !== -1) {
                    return callback();
                }
                resolve_1.default(request, { basedir: context, preserveSymlinks: true }, (err, res) => {
                    if (err) {
                        return callback();
                    }
                    if (!res) {
                        return callback();
                    }
                    // Default pages have to be transpiled
                    if (res.match(/next[/\\]dist[/\\]/) || res.match(/node_modules[/\\]@babel[/\\]runtime[/\\]/) || res.match(/node_modules[/\\]@babel[/\\]runtime-corejs2[/\\]/)) {
                        return callback();
                    }
                    // Webpack itself has to be compiled because it doesn't always use module relative paths
                    if (res.match(/node_modules[/\\]webpack/) || res.match(/node_modules[/\\]css-loader/)) {
                        return callback();
                    }
                    // styled-jsx has to be transpiled
                    if (res.match(/node_modules[/\\]styled-jsx/)) {
                        return callback();
                    }
                    if (res.match(/node_modules[/\\].*\.js$/)) {
                        return callback(undefined, `commonjs ${request}`);
                    }
                    callback();
                });
            }
        ] : [
        // When the serverless target is used all node_modules will be compiled into the output bundles
        // So that the serverless bundles have 0 runtime dependencies
        ],
        optimization: isServer ? {
            splitChunks: false,
            minimizer: target === 'serverless' ? [
                new cjs_js_1.default(Object.assign({}, terserPluginConfig, { terserOptions: {
                        compress: false,
                        mangle: false,
                        module: false,
                        keep_classnames: true,
                        keep_fnames: true
                    } }))
            ] : undefined
        } : {
            runtimeChunk: {
                name: constants_1.CLIENT_STATIC_FILES_RUNTIME_WEBPACK
            },
            splitChunks: dev ? {
                cacheGroups: {
                    default: false,
                    vendors: false
                }
            } : {
                chunks: 'all',
                cacheGroups: {
                    default: false,
                    vendors: false,
                    commons: {
                        name: 'commons',
                        chunks: 'all',
                        minChunks: totalPages > 2 ? totalPages * 0.5 : 2
                    },
                    react: {
                        name: 'commons',
                        chunks: 'all',
                        test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/
                    }
                }
            },
            minimizer: !dev ? [
                new cjs_js_1.default(Object.assign({}, terserPluginConfig, { terserOptions: {
                        safari10: true
                    } }))
            ] : undefined,
        },
        recordsPath: path_1.default.join(outputPath, 'records.json'),
        context: dir,
        // Kept as function to be backwards compatible
        entry: async () => {
            return Object.assign({}, clientEntries ? clientEntries : {}, entrypoints);
        },
        output: {
            path: outputPath,
            filename: ({ chunk }) => {
                // Use `[name]-[contenthash].js` in production
                if (!dev && (chunk.name === constants_1.CLIENT_STATIC_FILES_RUNTIME_MAIN || chunk.name === constants_1.CLIENT_STATIC_FILES_RUNTIME_WEBPACK)) {
                    return chunk.name.replace(/\.js$/, '-[contenthash].js');
                }
                return '[name]';
            },
            libraryTarget: isServer ? 'commonjs2' : 'jsonp',
            hotUpdateChunkFilename: 'static/webpack/[id].[hash].hot-update.js',
            hotUpdateMainFilename: 'static/webpack/[hash].hot-update.json',
            // This saves chunks with the name given via `import()`
            chunkFilename: isServer ? `${dev ? '[name]' : '[name].[contenthash]'}.js` : `static/chunks/${dev ? '[name]' : '[name].[contenthash]'}.js`,
            strictModuleExceptionHandling: true,
            crossOriginLoading: config.crossOrigin,
            futureEmitAssets: !dev,
            webassemblyModuleFilename: 'static/wasm/[modulehash].wasm'
        },
        performance: { hints: false },
        resolve: resolveConfig,
        resolveLoader: {
            modules: [
                constants_2.NEXT_PROJECT_ROOT_NODE_MODULES,
                'node_modules',
                path_1.default.join(__dirname, 'webpack', 'loaders'),
                ...nodePathList // Support for NODE_PATH environment variable
            ]
        },
        module: {
            rules: [
                {
                    test: /\.(js|mjs|jsx)$/,
                    include: [dir, /next-server[\\/]dist[\\/]lib/],
                    exclude: (path) => {
                        if (/next-server[\\/]dist[\\/]lib/.test(path)) {
                            return false;
                        }
                        return /node_modules/.test(path);
                    },
                    use: defaultLoaders.babel
                }
            ].filter(Boolean)
        },
        plugins: [
            target === 'serverless' && isServer && new serverless_plugin_1.ServerlessPlugin(),
            // Precompile react / react-dom for development, speeding up webpack
            dev && !isServer && new autodll_webpack_plugin_1.default({
                filename: '[name]_[hash].js',
                path: './static/development/dll',
                context: dir,
                entry: {
                    dll: [
                        'react',
                        'react-dom'
                    ]
                },
                config: {
                    mode: webpackMode,
                    resolve: resolveConfig
                }
            }),
            // This plugin makes sure `output.filename` is used for entry chunks
            new chunk_names_plugin_1.default(),
            !isServer && new react_loadable_plugin_1.ReactLoadablePlugin({
                filename: constants_1.REACT_LOADABLE_MANIFEST
            }),
            // Even though require.cache is server only we have to clear assets from both compilations
            // This is because the client compilation generates the build manifest that's used on the server side
            dev && new nextjs_require_cache_hot_reloader_1.default(),
            dev && !isServer && new webpack_1.default.HotModuleReplacementPlugin(),
            dev && new webpack_1.default.NoEmitOnErrorsPlugin(),
            dev && new unlink_file_plugin_1.default(),
            dev && new case_sensitive_paths_webpack_plugin_1.default(),
            !dev && new webpack_1.default.HashedModuleIdsPlugin(),
            // Removes server/client code by minifier
            new webpack_1.default.DefinePlugin(Object.assign({}, (Object.keys(config.env).reduce((acc, key) => {
                if (/^(?:NODE_.+)|(?:__.+)$/i.test(key)) {
                    throw new Error(`The key "${key}" under "env" in next.config.js is not allowed. https://err.sh/zeit/next.js/env-key-not-allowed`);
                }
                return Object.assign({}, acc, { [`process.env.${key}`]: JSON.stringify(config.env[key]) });
            }, {})), { 'process.crossOrigin': JSON.stringify(config.crossOrigin), 'process.browser': JSON.stringify(!isServer) })),
            // This is used in client/dev-error-overlay/hot-dev-client.js to replace the dist directory
            !isServer && dev && new webpack_1.default.DefinePlugin({
                'process.env.__NEXT_DIST_DIR': JSON.stringify(distDir)
            }),
            target !== 'serverless' && isServer && new pages_manifest_plugin_1.default(),
            !isServer && new build_manifest_plugin_1.default(),
            isServer && new nextjs_ssr_import_1.default(),
            target !== 'serverless' && isServer && new nextjs_ssr_module_cache_1.default({ outputPath }),
            !dev && new webpack_1.default.IgnorePlugin({
                checkResource: (resource) => {
                    return /react-is/.test(resource);
                },
                checkContext: (context) => {
                    return /next-server[\\/]dist[\\/]/.test(context) || /next[\\/]dist[\\/]/.test(context);
                }
            })
        ].filter(Boolean)
    };
    if (typeof config.webpack === 'function') {
        webpackConfig = config.webpack(webpackConfig, { dir, dev, isServer, buildId, config, defaultLoaders, totalPages });
    }
    // Backwards compat for `main.js` entry key
    const originalEntry = webpackConfig.entry;
    if (typeof originalEntry !== 'undefined') {
        webpackConfig.entry = async () => {
            const entry = typeof originalEntry === 'function' ? await originalEntry() : originalEntry;
            if (entry && typeof entry !== 'string' && !Array.isArray(entry)) {
                // Server compilation doesn't have main.js
                if (typeof entry['main.js'] !== 'undefined') {
                    entry[constants_1.CLIENT_STATIC_FILES_RUNTIME_MAIN] = [
                        ...entry['main.js'],
                        ...entry[constants_1.CLIENT_STATIC_FILES_RUNTIME_MAIN]
                    ];
                    delete entry['main.js'];
                }
            }
            return entry;
        };
    }
    return webpackConfig;
}
exports.default = getBaseWebpackConfig;

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/build-manifest-plugin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/build-manifest-plugin.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const webpack_sources_1 = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const constants_1 = __webpack_require__(/*! next-server/constants */ "next-server/constants");
// This plugin creates a build-manifest.json for all assets that are being output
// It has a mapping of "entry" filename to real filename. Because the real filename can be hashed in production
class BuildManifestPlugin {
    apply(compiler) {
        compiler.hooks.emit.tapAsync('NextJsBuildManifest', (compilation, callback) => {
            const { chunks } = compilation;
            const assetMap = { devFiles: [], pages: {} };
            const mainJsChunk = chunks.find((c) => c.name === constants_1.CLIENT_STATIC_FILES_RUNTIME_MAIN);
            const mainJsFiles = mainJsChunk && mainJsChunk.files.length > 0 ? mainJsChunk.files.filter((file) => /\.js$/.test(file)) : [];
            for (const filePath of Object.keys(compilation.assets)) {
                const path = filePath.replace(/\\/g, '/');
                if (/^static\/development\/dll\//.test(path)) {
                    assetMap.devFiles.push(path);
                }
            }
            // compilation.entrypoints is a Map object, so iterating over it 0 is the key and 1 is the value
            for (const [, entrypoint] of compilation.entrypoints.entries()) {
                const result = constants_1.ROUTE_NAME_REGEX.exec(entrypoint.name);
                if (!result) {
                    continue;
                }
                const pagePath = result[1];
                if (!pagePath) {
                    continue;
                }
                const filesForEntry = [];
                for (const chunk of entrypoint.chunks) {
                    // If there's no name or no files
                    if (!chunk.name || !chunk.files) {
                        continue;
                    }
                    for (const file of chunk.files) {
                        if (/\.map$/.test(file) || /\.hot-update\.js$/.test(file)) {
                            continue;
                        }
                        // Only `.js` and `.css` files are added for now. In the future we can also handle other file types.
                        if (!/\.js$/.test(file) && !/\.css$/.test(file)) {
                            continue;
                        }
                        // The page bundles are manually added to _document.js as they need extra properties
                        if (constants_1.IS_BUNDLED_PAGE_REGEX.exec(file)) {
                            continue;
                        }
                        filesForEntry.push(file.replace(/\\/g, '/'));
                    }
                }
                assetMap.pages[`/${pagePath.replace(/\\/g, '/')}`] = [...filesForEntry, ...mainJsFiles];
            }
            if (typeof assetMap.pages['/index'] !== 'undefined') {
                assetMap.pages['/'] = assetMap.pages['/index'];
            }
            compilation.assets[constants_1.BUILD_MANIFEST] = new webpack_sources_1.RawSource(JSON.stringify(assetMap, null, 2));
            callback();
        });
    }
}
exports.default = BuildManifestPlugin;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/chunk-names-plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/chunk-names-plugin.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// This plugin mirrors webpack 3 `filename` and `chunkfilename` behavior
// This fixes https://github.com/webpack/webpack/issues/6598
// This plugin is based on https://github.com/researchgate/webpack/commit/2f28947fa0c63ccbb18f39c0098bd791a2c37090
class ChunkNamesPlugin {
    apply(compiler) {
        compiler.hooks.compilation.tap('NextJsChunkNamesPlugin', (compilation) => {
            compilation.chunkTemplate.hooks.renderManifest.intercept({
                register(tapInfo) {
                    if (tapInfo.name === 'JavascriptModulesPlugin') {
                        const originalMethod = tapInfo.fn;
                        tapInfo.fn = (result, options) => {
                            let filenameTemplate;
                            const chunk = options.chunk;
                            const outputOptions = options.outputOptions;
                            if (chunk.filenameTemplate) {
                                filenameTemplate = chunk.filenameTemplate;
                            }
                            else if (chunk.hasEntryModule()) {
                                filenameTemplate = outputOptions.filename;
                            }
                            else {
                                filenameTemplate = outputOptions.chunkFilename;
                            }
                            options.chunk.filenameTemplate = filenameTemplate;
                            return originalMethod(result, options);
                        };
                    }
                    return tapInfo;
                }
            });
        });
    }
}
exports.default = ChunkNamesPlugin;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/nextjs-require-cache-hot-reloader.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/nextjs-require-cache-hot-reloader.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function deleteCache(path) {
    delete __webpack_require__.c[path];
}
// This plugin flushes require.cache after emitting the files. Providing 'hot reloading' of server files.
class NextJsRequireCacheHotReloader {
    constructor() {
        this.prevAssets = null;
    }
    apply(compiler) {
        compiler.hooks.afterEmit.tapAsync('NextJsRequireCacheHotReloader', (compilation, callback) => {
            const { assets } = compilation;
            if (this.prevAssets) {
                for (const f of Object.keys(assets)) {
                    deleteCache(assets[f].existsAt);
                }
                for (const f of Object.keys(this.prevAssets)) {
                    if (!assets[f]) {
                        deleteCache(this.prevAssets[f].existsAt);
                    }
                }
            }
            this.prevAssets = assets;
            callback();
        });
    }
}
exports.default = NextJsRequireCacheHotReloader;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/nextjs-ssr-import.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/nextjs-ssr-import.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(/*! path */ "path");
// This plugin modifies the require-ensure code generated by Webpack
// to work with Next.js SSR
class NextJsSsrImportPlugin {
    apply(compiler) {
        compiler.hooks.compilation.tap('NextJsSSRImport', (compilation) => {
            compilation.mainTemplate.hooks.requireEnsure.tap('NextJsSSRImport', (code, chunk) => {
                // Update to load chunks from our custom chunks directory
                const outputPath = path_1.resolve('/');
                const pagePath = path_1.join('/', path_1.dirname(chunk.name));
                const relativePathToBaseDir = path_1.relative(pagePath, outputPath);
                // Make sure even in windows, the path looks like in unix
                // Node.js require system will convert it accordingly
                const relativePathToBaseDirNormalized = relativePathToBaseDir.replace(/\\/g, '/');
                return code.replace('require("./"', `require("${relativePathToBaseDirNormalized}/"`).replace('readFile(join(__dirname', `readFile(join(__dirname, "${relativePathToBaseDirNormalized}"`);
            });
        });
    }
}
exports.default = NextJsSsrImportPlugin;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/nextjs-ssr-module-cache.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/nextjs-ssr-module-cache.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_1 = __importDefault(__webpack_require__(/*! webpack */ "./node_modules/webpack/lib/webpack.js"));
const webpack_sources_1 = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const path_1 = __webpack_require__(/*! path */ "path");
const constants_1 = __webpack_require__(/*! next-server/constants */ "next-server/constants");
const SSR_MODULE_CACHE_FILENAME = 'ssr-module-cache.js';
// By default webpack keeps initialized modules per-module.
// This means that if you have 2 entrypoints loaded into the same app
// they will *not* share the same instance
// This creates many issues when developers / libraries rely on the singleton pattern
// As this pattern assumes every module will have 1 instance
// This plugin overrides webpack's code generation step to replace `installedModules`
// The replacement is a require for a file that's also generated here that only exports an empty object
// Because of Node.js's single instance modules this makes webpack share all initialized instances
// Do note that this module is only geared towards the `node` compilation target.
// For the client side compilation we use `runtimeChunk: 'single'`
class NextJsSsrImportPlugin {
    constructor(options) {
        this.options = options;
    }
    apply(compiler) {
        const { outputPath } = this.options;
        compiler.hooks.emit.tapAsync('NextJsSSRModuleCache', (compilation, callback) => {
            compilation.assets[SSR_MODULE_CACHE_FILENAME] = new webpack_sources_1.RawSource(`
      /* This cache is used by webpack for instantiated modules */
      module.exports = {}
      `);
            callback();
        });
        compiler.hooks.compilation.tap('NextJsSSRModuleCache', (compilation) => {
            compilation.mainTemplate.hooks.localVars.intercept({
                register(tapInfo) {
                    if (tapInfo.name === 'MainTemplate') {
                        const originalFn = tapInfo.fn;
                        tapInfo.fn = (source, chunk) => {
                            // If the chunk is not part of the pages directory we have to keep the original behavior,
                            // otherwise webpack will error out when the file is used before the compilation finishes
                            // this is the case with mini-css-extract-plugin
                            if (!constants_1.IS_BUNDLED_PAGE_REGEX.exec(chunk.name) && chunk.name !== 'error-debug.js') {
                                return originalFn(source, chunk);
                            }
                            const pagePath = path_1.join(outputPath, path_1.dirname(chunk.name));
                            let relativePathToBaseDir = path_1.relative(pagePath, path_1.join(outputPath, SSR_MODULE_CACHE_FILENAME));
                            if (chunk.name === 'error-debug.js') {
                                relativePathToBaseDir = `./${relativePathToBaseDir}`;
                            }
                            // Make sure even in windows, the path looks like in unix
                            // Node.js require system will convert it accordingly
                            const relativePathToBaseDirNormalized = relativePathToBaseDir.replace(/\\/g, '/');
                            return webpack_1.default.Template.asString([
                                source,
                                '// The module cache',
                                `var installedModules = require('${relativePathToBaseDirNormalized}');`
                            ]);
                        };
                    }
                    return tapInfo;
                }
            });
        });
    }
}
exports.default = NextJsSsrImportPlugin;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/pages-manifest-plugin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/pages-manifest-plugin.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const webpack_sources_1 = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const constants_1 = __webpack_require__(/*! next-server/constants */ "next-server/constants");
// This plugin creates a pages-manifest.json from page entrypoints.
// This is used for mapping paths like `/` to `.next/server/static/<buildid>/pages/index.js` when doing SSR
// It's also used by next export to provide defaultPathMap
class PagesManifestPlugin {
    apply(compiler) {
        compiler.hooks.emit.tap('NextJsPagesManifest', (compilation) => {
            const { entries } = compilation;
            const pages = {};
            for (const entry of entries) {
                const result = constants_1.ROUTE_NAME_REGEX.exec(entry.name);
                if (!result) {
                    continue;
                }
                const pagePath = result[1];
                if (!pagePath) {
                    continue;
                }
                const { name } = entry;
                // Write filename, replace any backslashes in path (on windows) with forwardslashes for cross-platform consistency.
                pages[`/${pagePath.replace(/\\/g, '/')}`] = name.replace(/\\/g, '/');
            }
            if (typeof pages['/index'] !== 'undefined') {
                pages['/'] = pages['/index'];
            }
            compilation.assets[constants_1.PAGES_MANIFEST] = new webpack_sources_1.RawSource(JSON.stringify(pages));
        });
    }
}
exports.default = PagesManifestPlugin;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/react-loadable-plugin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/react-loadable-plugin.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
COPYRIGHT (c) 2017-present James Kyle <me@thejameskyle.com>
 MIT License
 Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
 The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWAR
*/
// Implementation of this PR: https://github.com/jamiebuilds/react-loadable/pull/132
// Modified to strip out unneeded results for Next's specific use case
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = __importDefault(__webpack_require__(/*! url */ "url"));
function buildManifest(compiler, compilation) {
    let context = compiler.options.context;
    let manifest = {};
    compilation.chunks.forEach(chunk => {
        chunk.files.forEach(file => {
            for (const module of chunk.modulesIterable) {
                let id = module.id;
                let name = typeof module.libIdent === 'function' ? module.libIdent({ context }) : null;
                // If it doesn't end in `.js` Next.js can't handle it right now.
                if (!file.match(/\.js$/) || !file.match(/^static\/chunks\//)) {
                    return;
                }
                let publicPath = url_1.default.resolve(compilation.outputOptions.publicPath || '', file);
                let currentModule = module;
                if (module.constructor.name === 'ConcatenatedModule') {
                    currentModule = module.rootModule;
                }
                if (!manifest[currentModule.rawRequest]) {
                    manifest[currentModule.rawRequest] = [];
                }
                manifest[currentModule.rawRequest].push({ id, name, file, publicPath });
            }
        });
    });
    return manifest;
}
class ReactLoadablePlugin {
    constructor(opts = {}) {
        this.filename = opts.filename;
    }
    apply(compiler) {
        compiler.hooks.emit.tapAsync('ReactLoadableManifest', (compilation, callback) => {
            const manifest = buildManifest(compiler, compilation);
            var json = JSON.stringify(manifest, null, 2);
            compilation.assets[this.filename] = {
                source() {
                    return json;
                },
                size() {
                    return json.length;
                }
            };
            callback();
        });
    }
}
exports.ReactLoadablePlugin = ReactLoadablePlugin;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/serverless-plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/serverless-plugin.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GraphHelpers_1 = __importDefault(__webpack_require__(/*! webpack/lib/GraphHelpers */ "./node_modules/webpack/lib/GraphHelpers.js"));
/**
 * Makes sure there are no dynamic chunks when the target is serverless
 * The dynamic chunks are integrated back into their parent chunk
 * This is to make sure there is a single render bundle instead of that bundle importing dynamic chunks
 */
class ServerlessPlugin {
    apply(compiler) {
        compiler.hooks.compilation.tap('ServerlessPlugin', compilation => {
            compilation.hooks.optimizeChunksBasic.tap('ServerlessPlugin', chunks => {
                chunks.forEach((chunk) => {
                    // If chunk is not an entry point skip them
                    if (chunk.hasEntryModule()) {
                        const dynamicChunks = chunk.getAllAsyncChunks();
                        if (dynamicChunks.size !== 0) {
                            for (const dynamicChunk of dynamicChunks) {
                                for (const module of dynamicChunk.modulesIterable) {
                                    GraphHelpers_1.default.connectChunkAndModule(chunk, module);
                                }
                            }
                        }
                    }
                });
            });
        });
    }
}
exports.ServerlessPlugin = ServerlessPlugin;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src sync recursive":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src sync ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src sync recursive";

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/TaskRunner.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/TaskRunner.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(__webpack_require__(/*! os */ "os"));
const cacache_1 = __importDefault(__webpack_require__(/*! cacache */ "cacache"));
const find_cache_dir_1 = __importDefault(__webpack_require__(/*! find-cache-dir */ "find-cache-dir"));
const worker_farm_1 = __importDefault(__webpack_require__(/*! worker-farm */ "worker-farm"));
const serialize_javascript_1 = __importDefault(__webpack_require__(/*! serialize-javascript */ "serialize-javascript"));
const minify_1 = __importDefault(__webpack_require__(/*! ./minify */ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/minify.js"));
const worker = /*require.resolve*/(/*! ./worker */ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/worker.js");
class TaskRunner {
    constructor(options = {}) {
        const { cache, parallel } = options;
        this.cacheDir =
            cache === true ? find_cache_dir_1.default({ name: 'terser-webpack-plugin' }) : cache;
        // In some cases cpus() returns undefined
        // https://github.com/nodejs/node/issues/19022
        const cpus = os_1.default.cpus() || { length: 1 };
        this.maxConcurrentWorkers =
            parallel === true
                ? cpus.length - 1
                : Math.min(Number(parallel) || 0, cpus.length - 1);
    }
    run(tasks, callback) {
        /* istanbul ignore if */
        if (!tasks.length) {
            callback(null, []);
            return;
        }
        if (this.maxConcurrentWorkers > 1) {
            const workerOptions = process.platform === 'win32'
                ? {
                    maxConcurrentWorkers: this.maxConcurrentWorkers,
                    maxConcurrentCallsPerWorker: 1,
                }
                : { maxConcurrentWorkers: this.maxConcurrentWorkers };
            this.workers = worker_farm_1.default(workerOptions, worker);
            this.boundWorkers = (options, cb) => {
                try {
                    this.workers(serialize_javascript_1.default(options), cb);
                }
                catch (error) {
                    // worker-farm can fail with ENOMEM or something else
                    cb(error);
                }
            };
        }
        else {
            this.boundWorkers = (options, cb) => {
                try {
                    cb(null, minify_1.default(options));
                }
                catch (error) {
                    cb(error);
                }
            };
        }
        let toRun = tasks.length;
        const results = [];
        const step = (index, data) => {
            toRun -= 1;
            results[index] = data;
            if (!toRun) {
                callback(null, results);
            }
        };
        tasks.forEach((task, index) => {
            const enqueue = () => {
                this.boundWorkers(task, (error, data) => {
                    const result = error ? { error } : data;
                    const done = () => step(index, result);
                    if (this.cacheDir && !result.error) {
                        cacache_1.default
                            .put(this.cacheDir, serialize_javascript_1.default(task.cacheKeys), JSON.stringify(data))
                            .then(done, done);
                    }
                    else {
                        done();
                    }
                });
            };
            if (this.cacheDir) {
                cacache_1.default
                    .get(this.cacheDir, serialize_javascript_1.default(task.cacheKeys))
                    .then(({ data }) => step(index, JSON.parse(data)), enqueue);
            }
            else {
                enqueue();
            }
        });
    }
    exit() {
        if (this.workers) {
            worker_farm_1.default.end(this.workers);
        }
    }
}
exports.default = TaskRunner;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/cjs.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/cjs.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const plugin = __webpack_require__(/*! ./index */ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/index.js");
module.exports = plugin.default;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable
  no-param-reassign
*/
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "crypto"));
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const source_map_1 = __webpack_require__(/*! source-map */ "source-map");
const webpack_sources_1 = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const RequestShortener_1 = __importDefault(__webpack_require__(/*! webpack/lib/RequestShortener */ "./node_modules/webpack/lib/RequestShortener.js"));
const ModuleFilenameHelpers_1 = __importDefault(__webpack_require__(/*! webpack/lib/ModuleFilenameHelpers */ "./node_modules/webpack/lib/ModuleFilenameHelpers.js"));
// import validateOptions from 'schema-utils';
const serialize_javascript_1 = __importDefault(__webpack_require__(/*! serialize-javascript */ "serialize-javascript"));
const package_json_1 = __importDefault(__webpack_require__(/*! terser/package.json */ "./node_modules/terser/package.json"));
const TaskRunner_1 = __importDefault(__webpack_require__(/*! ./TaskRunner */ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/TaskRunner.js"));
const warningRegex = /\[.+:([0-9]+),([0-9]+)\]/;
class TerserPlugin {
    constructor(options = {}) {
        // validateOptions(schema, options, 'Terser Plugin');
        const { minify, terserOptions = {}, test = /\.m?js(\?.*)?$/i, chunkFilter = () => true, warningsFilter = () => true, extractComments = false, sourceMap = false, cache = false, cacheKeys = (defaultCacheKeys) => defaultCacheKeys, parallel = false, include, exclude, } = options;
        this.options = {
            test,
            chunkFilter,
            warningsFilter,
            extractComments,
            sourceMap,
            cache,
            cacheKeys,
            parallel,
            include,
            exclude,
            minify,
            terserOptions: Object.assign({ output: {
                    comments: extractComments
                        ? false
                        : /^\**!|@preserve|@license|@cc_on/i,
                } }, terserOptions),
        };
    }
    static isSourceMap(input) {
        // All required options for `new SourceMapConsumer(...options)`
        // https://github.com/mozilla/source-map#new-sourcemapconsumerrawsourcemap
        return Boolean(input &&
            input.version &&
            input.sources &&
            Array.isArray(input.sources) &&
            typeof input.mappings === 'string');
    }
    static buildSourceMap(inputSourceMap) {
        if (!inputSourceMap || !TerserPlugin.isSourceMap(inputSourceMap)) {
            return null;
        }
        return new source_map_1.SourceMapConsumer(inputSourceMap);
    }
    static buildError(err, file, sourceMap, requestShortener) {
        // Handling error which should have line, col, filename and message
        if (err.line) {
            const original = sourceMap &&
                sourceMap.originalPositionFor({
                    line: err.line,
                    column: err.col,
                });
            if (original && original.source && requestShortener) {
                return new Error(`${file} from Terser\n${err.message} [${requestShortener.shorten(original.source)}:${original.line},${original.column}][${file}:${err.line},${err.col}]`);
            }
            return new Error(`${file} from Terser\n${err.message} [${file}:${err.line},${err.col}]`);
        }
        else if (err.stack) {
            return new Error(`${file} from Terser\n${err.stack}`);
        }
        return new Error(`${file} from Terser\n${err.message}`);
    }
    static buildWarning(warning, file, sourceMap, requestShortener, warningsFilter) {
        let warningMessage = warning;
        let locationMessage = '';
        let source = null;
        if (sourceMap) {
            const match = warningRegex.exec(warning);
            if (match) {
                const line = +match[1];
                const column = +match[2];
                const original = sourceMap.originalPositionFor({
                    line,
                    column,
                });
                if (original &&
                    original.source &&
                    original.source !== file &&
                    requestShortener) {
                    ({ source } = original);
                    warningMessage = `${warningMessage.replace(warningRegex, '')}`;
                    locationMessage = `[${requestShortener.shorten(original.source)}:${original.line},${original.column}]`;
                }
            }
        }
        if (warningsFilter && !warningsFilter(warning, source)) {
            return null;
        }
        return `Terser Plugin: ${warningMessage}${locationMessage}`;
    }
    apply(compiler) {
        const buildModuleFn = (moduleArg) => {
            // to get detailed location info about errors
            moduleArg.useSourceMap = true;
        };
        const optimizeFn = (compilation, chunks, callback) => {
            const taskRunner = new TaskRunner_1.default({
                cache: this.options.cache,
                parallel: this.options.parallel,
            });
            const processedAssets = new WeakSet();
            const tasks = [];
            const { chunkFilter } = this.options;
            Array.from(chunks)
                .filter((chunk) => chunkFilter && chunkFilter(chunk))
                .reduce((acc, chunk) => acc.concat(chunk.files || []), [])
                .concat(compilation.additionalChunkAssets || [])
                .filter(ModuleFilenameHelpers_1.default.matchObject.bind(null, this.options))
                .forEach((file) => {
                let inputSourceMap;
                const asset = compilation.assets[file];
                if (processedAssets.has(asset)) {
                    return;
                }
                try {
                    let input;
                    if (this.options.sourceMap && asset.sourceAndMap) {
                        const { source, map } = asset.sourceAndMap();
                        input = source;
                        if (TerserPlugin.isSourceMap(map)) {
                            inputSourceMap = map;
                        }
                        else {
                            inputSourceMap = map;
                            compilation.warnings.push(new Error(`${file} contains invalid source map`));
                        }
                    }
                    else {
                        input = asset.source();
                        inputSourceMap = null;
                    }
                    // Handling comment extraction
                    let commentsFile = false;
                    if (this.options.extractComments) {
                        commentsFile =
                            this.options.extractComments.filename || `${file}.LICENSE`;
                        if (typeof commentsFile === 'function') {
                            commentsFile = commentsFile(file);
                        }
                    }
                    const task = {
                        file,
                        input,
                        inputSourceMap,
                        commentsFile,
                        extractComments: this.options.extractComments,
                        terserOptions: this.options.terserOptions,
                        minify: this.options.minify,
                    };
                    if (this.options.cache) {
                        const defaultCacheKeys = {
                            terser: package_json_1.default.version,
                            // eslint-disable-next-line global-require
                            'terser-webpack-plugin': '1.2.2',
                            'terser-webpack-plugin-options': this.options,
                            hash: crypto_1.default
                                .createHash('md4')
                                .update(input)
                                .digest('hex'),
                        };
                        task.cacheKeys = this.options.cacheKeys(defaultCacheKeys, file);
                    }
                    tasks.push(task);
                }
                catch (error) {
                    compilation.errors.push(TerserPlugin.buildError(error, file, TerserPlugin.buildSourceMap(inputSourceMap), new RequestShortener_1.default(compiler.context)));
                }
            });
            taskRunner.run(tasks, (tasksError, results) => {
                if (tasksError) {
                    compilation.errors.push(tasksError);
                    return;
                }
                results.forEach((data, index) => {
                    const { file, input, inputSourceMap, commentsFile } = tasks[index];
                    const { error, map, code, warnings } = data;
                    let { extractedComments } = data;
                    let sourceMap = null;
                    if (error || (warnings && warnings.length > 0)) {
                        sourceMap = TerserPlugin.buildSourceMap(inputSourceMap);
                    }
                    // Handling results
                    // Error case: add errors, and go to next file
                    if (error) {
                        compilation.errors.push(TerserPlugin.buildError(error, file, sourceMap, new RequestShortener_1.default(compiler.context)));
                        return;
                    }
                    let outputSource;
                    if (map) {
                        outputSource = new webpack_sources_1.SourceMapSource(code, file, JSON.parse(map), input, inputSourceMap);
                    }
                    else {
                        outputSource = new webpack_sources_1.RawSource(code);
                    }
                    // Write extracted comments to commentsFile
                    if (commentsFile &&
                        extractedComments &&
                        extractedComments.length > 0) {
                        if (commentsFile in compilation.assets) {
                            const commentsFileSource = compilation.assets[commentsFile].source();
                            extractedComments = extractedComments.filter((comment) => !commentsFileSource.includes(comment));
                        }
                        if (extractedComments.length > 0) {
                            // Add a banner to the original file
                            if (this.options.extractComments.banner !== false) {
                                let banner = this.options.extractComments.banner ||
                                    `For license information please see ${path_1.default.posix.basename(commentsFile)}`;
                                if (typeof banner === 'function') {
                                    banner = banner(commentsFile);
                                }
                                if (banner) {
                                    outputSource = new webpack_sources_1.ConcatSource(`/*! ${banner} */\n`, outputSource);
                                }
                            }
                            const commentsSource = new webpack_sources_1.RawSource(`${extractedComments.join('\n\n')}\n`);
                            if (commentsFile in compilation.assets) {
                                // commentsFile already exists, append new comments...
                                if (compilation.assets[commentsFile] instanceof webpack_sources_1.ConcatSource) {
                                    compilation.assets[commentsFile].add('\n');
                                    compilation.assets[commentsFile].add(commentsSource);
                                }
                                else {
                                    compilation.assets[commentsFile] = new webpack_sources_1.ConcatSource(compilation.assets[commentsFile], '\n', commentsSource);
                                }
                            }
                            else {
                                compilation.assets[commentsFile] = commentsSource;
                            }
                        }
                    }
                    // Updating assets
                    processedAssets.add((compilation.assets[file] = outputSource));
                    // Handling warnings
                    if (warnings && warnings.length > 0) {
                        warnings.forEach((warning) => {
                            const builtWarning = TerserPlugin.buildWarning(warning, file, sourceMap, new RequestShortener_1.default(compiler.context), this.options.warningsFilter);
                            if (builtWarning) {
                                compilation.warnings.push(builtWarning);
                            }
                        });
                    }
                });
                taskRunner.exit();
                callback();
            });
        };
        const plugin = { name: this.constructor.name };
        compiler.hooks.compilation.tap(plugin, (compilation) => {
            if (this.options.sourceMap) {
                compilation.hooks.buildModule.tap(plugin, buildModuleFn);
            }
            const { mainTemplate, chunkTemplate } = compilation;
            // Regenerate `contenthash` for minified assets
            for (const template of [mainTemplate, chunkTemplate]) {
                template.hooks.hashForChunk.tap(plugin, (hash) => {
                    const data = serialize_javascript_1.default({
                        terser: package_json_1.default.version,
                        terserOptions: this.options.terserOptions,
                    });
                    hash.update('TerserPlugin');
                    hash.update(data);
                });
            }
            compilation.hooks.optimizeChunkAssets.tapAsync(plugin, optimizeFn.bind(this, compilation));
        });
    }
}
exports.default = TerserPlugin;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/minify.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/minify.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable
  arrow-body-style
*/
const terser_1 = __webpack_require__(/*! terser */ "terser");
const buildTerserOptions = ({ ecma, warnings, parse = {}, compress = {}, mangle, module, output, toplevel, nameCache, ie8, 
/* eslint-disable camelcase */
keep_classnames, keep_fnames, 
/* eslint-enable camelcase */
safari10, } = {}) => ({
    ecma,
    warnings,
    parse: Object.assign({}, parse),
    compress: typeof compress === 'boolean' ? compress : Object.assign({}, compress),
    // eslint-disable-next-line no-nested-ternary
    mangle: mangle == null
        ? true
        : typeof mangle === 'boolean'
            ? mangle
            : Object.assign({}, mangle),
    output: Object.assign({ shebang: true, comments: false, beautify: false, semicolons: true }, output),
    module,
    // Ignoring sourceMap from options
    sourceMap: null,
    toplevel,
    nameCache,
    ie8,
    keep_classnames,
    keep_fnames,
    safari10,
});
const buildComments = (options, terserOptions, extractedComments) => {
    const condition = {};
    const commentsOpts = terserOptions.output.comments;
    // Use /^\**!|@preserve|@license|@cc_on/i RegExp
    if (typeof options.extractComments === 'boolean') {
        condition.preserve = commentsOpts;
        condition.extract = /^\**!|@preserve|@license|@cc_on/i;
    }
    else if (typeof options.extractComments === 'string' ||
        options.extractComments instanceof RegExp) {
        // extractComments specifies the extract condition and commentsOpts specifies the preserve condition
        condition.preserve = commentsOpts;
        condition.extract = options.extractComments;
    }
    else if (typeof options.extractComments === 'function') {
        condition.preserve = commentsOpts;
        condition.extract = options.extractComments;
    }
    else if (Object.prototype.hasOwnProperty.call(options.extractComments, 'condition')) {
        // Extract condition is given in extractComments.condition
        condition.preserve = commentsOpts;
        condition.extract = options.extractComments.condition;
    }
    else {
        // No extract condition is given. Extract comments that match commentsOpts instead of preserving them
        condition.preserve = false;
        condition.extract = commentsOpts;
    }
    // Ensure that both conditions are functions
    ['preserve', 'extract'].forEach((key) => {
        let regexStr;
        let regex;
        switch (typeof condition[key]) {
            case 'boolean':
                condition[key] = condition[key] ? () => true : () => false;
                break;
            case 'function':
                break;
            case 'string':
                if (condition[key] === 'all') {
                    condition[key] = () => true;
                    break;
                }
                if (condition[key] === 'some') {
                    condition[key] = (astNode, comment) => {
                        return (comment.type === 'comment2' &&
                            /^\**!|@preserve|@license|@cc_on/i.test(comment.value));
                    };
                    break;
                }
                regexStr = condition[key];
                condition[key] = (astNode, comment) => {
                    return new RegExp(regexStr).test(comment.value);
                };
                break;
            default:
                regex = condition[key];
                condition[key] = (astNode, comment) => regex.test(comment.value);
        }
    });
    // Redefine the comments function to extract and preserve
    // comments according to the two conditions
    return (astNode, comment) => {
        if (condition.extract(astNode, comment)) {
            const commentText = comment.type === 'comment2'
                ? `/*${comment.value}*/`
                : `//${comment.value}`;
            // Don't include duplicate comments
            if (!extractedComments.includes(commentText)) {
                extractedComments.push(commentText);
            }
        }
        return condition.preserve(astNode, comment);
    };
};
const minify = (options) => {
    const { file, input, inputSourceMap, extractComments, minify: minifyFn, } = options;
    if (minifyFn) {
        return minifyFn({ [file]: input }, inputSourceMap);
    }
    // Copy terser options
    const terserOptions = buildTerserOptions(options.terserOptions);
    // Add source map data
    if (inputSourceMap) {
        terserOptions.sourceMap = {
            content: inputSourceMap,
        };
    }
    const extractedComments = [];
    if (extractComments) {
        terserOptions.output.comments = buildComments(options, terserOptions, extractedComments);
    }
    const { error, map, code, warnings } = terser_1.minify({ [file]: input }, terserOptions);
    return { error, map, code, warnings, extractedComments };
};
exports.default = minify;


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/worker.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/worker.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, __filename, __dirname) {
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const minify_1 = __importDefault(__webpack_require__(/*! ./minify */ "./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src/minify.js"));
module.exports = (options, callback) => {
    try {
        // 'use strict' => this === undefined (Clean Scope)
        // Safer for possible security issues, albeit not critical at all here
        // eslint-disable-next-line no-new-func, no-param-reassign
        options = new Function('exports', 'require', 'module', '__filename', '__dirname', `'use strict'\nreturn ${options}`)(exports, __webpack_require__("./node_modules/next/dist/build/webpack/plugins/terser-webpack-plugin/src sync recursive"), module, __filename, __dirname);
        callback(null, minify_1.default(options));
    }
    catch (errors) {
        callback(errors);
    }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), "/index.js", "/"))

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/plugins/unlink-file-plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/plugins/unlink-file-plugin.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(/*! path */ "path");
const promisify_1 = __importDefault(__webpack_require__(/*! ../../../lib/promisify */ "./node_modules/next/dist/lib/promisify.js"));
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const constants_1 = __webpack_require__(/*! next-server/constants */ "next-server/constants");
const unlink = promisify_1.default(fs_1.default.unlink);
// Makes sure removed pages are removed from `.next` in development
class UnlinkFilePlugin {
    constructor() {
        this.prevAssets = {};
    }
    apply(compiler) {
        compiler.hooks.afterEmit.tapAsync('NextJsUnlinkRemovedPages', (compilation, callback) => {
            const removed = Object.keys(this.prevAssets)
                .filter((a) => constants_1.IS_BUNDLED_PAGE_REGEX.test(a) && !compilation.assets[a]);
            this.prevAssets = compilation.assets;
            Promise.all(removed.map(async (f) => {
                const path = path_1.join(compiler.outputPath, f);
                try {
                    await unlink(path);
                }
                catch (err) {
                    if (err.code === 'ENOENT')
                        return;
                    throw err;
                }
            }))
                .then(() => callback(), callback);
        });
    }
}
exports.default = UnlinkFilePlugin;


/***/ }),

/***/ "./node_modules/next/dist/client/dev-error-overlay/format-webpack-messages.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev-error-overlay/format-webpack-messages.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
MIT License

Copyright (c) 2015-present, Facebook, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime-corejs2/helpers/interopRequireDefault */ "./node_modules/@babel/runtime-corejs2/helpers/interopRequireDefault.js");

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime-corejs2/helpers/slicedToArray */ "./node_modules/@babel/runtime-corejs2/helpers/slicedToArray.js"));

var friendlySyntaxErrorLabel = 'Syntax error:';

function isLikelyASyntaxError(message) {
  return message.indexOf(friendlySyntaxErrorLabel) !== -1;
} // Cleans up webpack error messages.
// eslint-disable-next-line no-unused-vars


function formatMessage(message, isError) {
  var lines = message.split('\n'); // Strip Webpack-added headers off errors/warnings
  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js

  lines = lines.filter(function (line) {
    return !/Module [A-z ]+\(from/.test(line);
  }); // Transform parsing error into syntax error
  // TODO: move this to our ESLint formatter?

  lines = lines.map(function (line) {
    var parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);

    if (!parsingError) {
      return line;
    }

    var _parsingError = (0, _slicedToArray2.default)(parsingError, 4),
        errorLine = _parsingError[1],
        errorColumn = _parsingError[2],
        errorMessage = _parsingError[3];

    return "".concat(friendlySyntaxErrorLabel, " ").concat(errorMessage, " (").concat(errorLine, ":").concat(errorColumn, ")");
  });
  message = lines.join('\n'); // Smoosh syntax errors (commonly found in CSS)

  message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, "".concat(friendlySyntaxErrorLabel, " $3 ($1:$2)\n")); // Remove columns from ESLint formatter output (we added these for more
  // accurate syntax errors)

  message = message.replace(/Line (\d+):\d+:/g, 'Line $1:'); // Clean up export errors

  message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
  message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
  message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
  lines = message.split('\n'); // Remove leading newline

  if (lines.length > 2 && lines[1].trim() === '') {
    lines.splice(1, 1);
  } // Clean up file name


  lines[0] = lines[0].replace(/^(.*) \d+:\d+-\d+$/, '$1'); // Cleans up verbose "module not found" messages for files and packages.

  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {
    lines = [lines[0], lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:')];
  }

  message = lines.join('\n'); // Internal stacks are generally useless so we strip them... with the
  // exception of stacks containing `webpack:` because they're normally
  // from user code generated by Webpack. For more information see
  // https://github.com/facebook/create-react-app/pull/1050

  message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, ''); // at ... ...:x:y

  message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, ''); // at <anonymous>

  lines = message.split('\n'); // Remove duplicated newlines

  lines = lines.filter(function (line, index, arr) {
    return index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim();
  }); // Reassemble the message

  message = lines.join('\n');
  return message.trim();
}

function formatWebpackMessages(json) {
  var formattedErrors = json.errors.map(function (message) {
    return formatMessage(message, true);
  });
  var formattedWarnings = json.warnings.map(function (message) {
    return formatMessage(message, false);
  });
  var result = {
    errors: formattedErrors,
    warnings: formattedWarnings
  };

  if (result.errors.some(isLikelyASyntaxError)) {
    // If there are any syntax errors, show just them.
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }

  return result;
}

module.exports = formatWebpackMessages;

/***/ }),

/***/ "./node_modules/next/dist/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/lib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(/*! path */ "path");
exports.NEXT_PROJECT_ROOT = path_1.join(__dirname, '..', '..');
exports.NEXT_PROJECT_ROOT_DIST = path_1.join(exports.NEXT_PROJECT_ROOT, 'dist');
exports.NEXT_PROJECT_ROOT_NODE_MODULES = path_1.join(exports.NEXT_PROJECT_ROOT, 'node_modules');
exports.DEFAULT_PAGES_DIR = path_1.join(exports.NEXT_PROJECT_ROOT_DIST, 'pages');
exports.NEXT_PROJECT_ROOT_DIST_CLIENT = path_1.join(exports.NEXT_PROJECT_ROOT_DIST, 'client');
exports.NEXT_PROJECT_ROOT_DIST_SERVER = path_1.join(exports.NEXT_PROJECT_ROOT_DIST, 'server');
// Because on Windows absolute paths in the generated code can break because of numbers, eg 1 in the path,
// we have to use a private alias
exports.PAGES_DIR_ALIAS = 'private-next-pages';
exports.DOT_NEXT_ALIAS = 'private-dot-next';

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/lib/promisify.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/lib/promisify.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');
module.exports = function promisify(original) {
    // Names to create an object from in case the callback receives multiple
    // arguments, e.g. ['stdout', 'stderr'] for child_process.exec.
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    return function fn(...args) {
        return new Promise((resolve, reject) => {
            try {
                original.call(this, ...args, (err, ...values) => {
                    if (err) {
                        reject(err);
                    }
                    else if (argumentNames !== undefined && values.length > 1) {
                        const obj = {};
                        for (var i = 0; i < argumentNames.length; i++) {
                            obj[argumentNames[i]] = values[i];
                        }
                        resolve(obj);
                    }
                    else {
                        resolve(values[0]);
                    }
                });
            }
            catch (err) {
                reject(err);
            }
        });
    };
};


/***/ }),

/***/ "./node_modules/next/dist/server sync recursive":
/*!********************************************!*\
  !*** ./node_modules/next/dist/server sync ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/next/dist/server sync recursive";

/***/ }),

/***/ "./node_modules/next/dist/server/error-debug.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/server/error-debug.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(/*! react */ "react"));
const head_1 = __importDefault(__webpack_require__(/*! next-server/head */ "next-server/head"));
// This component is only rendered on the server side.
function ErrorDebug({ error, info }) {
    return (react_1.default.createElement("div", { style: exports.styles.errorDebug },
        react_1.default.createElement(head_1.default, null,
            react_1.default.createElement("meta", { name: 'viewport', content: 'width=device-width, initial-scale=1.0' })),
        react_1.default.createElement(StackTrace, { error: error, info: info })));
}
exports.default = ErrorDebug;
const StackTrace = ({ error: { name, message, stack }, info }) => (react_1.default.createElement("div", null,
    react_1.default.createElement("div", { style: exports.styles.heading }, message || name),
    react_1.default.createElement("pre", { style: exports.styles.stack }, stack),
    info && react_1.default.createElement("pre", { style: exports.styles.stack }, info.componentStack)));
exports.styles = {
    errorDebug: {
        background: '#ffffff',
        boxSizing: 'border-box',
        overflow: 'auto',
        padding: '24px',
        position: 'fixed',
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        zIndex: 9999,
        color: '#000000'
    },
    stack: {
        fontFamily: '"SF Mono", "Roboto Mono", "Fira Mono", consolas, menlo-regular, monospace',
        fontSize: '13px',
        lineHeight: '18px',
        color: '#777',
        margin: 0,
        whiteSpace: 'pre-wrap',
        wordWrap: 'break-word',
        marginTop: '16px'
    },
    heading: {
        fontFamily: '-apple-system, system-ui, BlinkMacSystemFont, Roboto, "Segoe UI", "Fira Sans", Avenir, "Helvetica Neue", "Lucida Grande", sans-serif',
        fontSize: '20px',
        fontWeight: '400',
        lineHeight: '28px',
        color: '#000000',
        marginBottom: '0px',
        marginTop: '0px'
    }
};


/***/ }),

/***/ "./node_modules/next/dist/server/hot-reloader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/server/hot-reloader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(/*! path */ "path");
const webpack_dev_middleware_1 = __importDefault(__webpack_require__(/*! webpack-dev-middleware */ "./node_modules/webpack-dev-middleware/index.js"));
const webpack_hot_middleware_1 = __importDefault(__webpack_require__(/*! webpack-hot-middleware */ "./node_modules/webpack-hot-middleware/middleware.js"));
const error_overlay_middleware_1 = __importDefault(__webpack_require__(/*! ./lib/error-overlay-middleware */ "./node_modules/next/dist/server/lib/error-overlay-middleware.js"));
const del_1 = __importDefault(__webpack_require__(/*! del */ "del"));
const on_demand_entry_handler_1 = __importStar(__webpack_require__(/*! ./on-demand-entry-handler */ "./node_modules/next/dist/server/on-demand-entry-handler.js"));
const webpack_1 = __importDefault(__webpack_require__(/*! webpack */ "./node_modules/webpack/lib/webpack.js"));
const webpack_config_1 = __importDefault(__webpack_require__(/*! ../build/webpack-config */ "./node_modules/next/dist/build/webpack-config.js"));
const constants_1 = __webpack_require__(/*! next-server/constants */ "next-server/constants");
const router_1 = __webpack_require__(/*! next-server/dist/server/router */ "next-server/dist/server/router");
const glob_1 = __importDefault(__webpack_require__(/*! glob */ "glob"));
const util_1 = __webpack_require__(/*! util */ "util");
const entries_1 = __webpack_require__(/*! ../build/entries */ "./node_modules/next/dist/build/entries.js");
const output_1 = __webpack_require__(/*! ../build/output */ "./node_modules/next/dist/build/output/index.js");
const glob = util_1.promisify(glob_1.default);
async function renderScriptError(res, error) {
    // Asks CDNs and others to not to cache the errored page
    res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');
    if (error.code === 'ENOENT' || error.message === 'INVALID_BUILD_ID') {
        res.statusCode = 404;
        res.end('404 - Not Found');
        return;
    }
    console.error(error.stack);
    res.statusCode = 500;
    res.end('500 - Internal Error');
}
exports.renderScriptError = renderScriptError;
function addCorsSupport(req, res) {
    if (!req.headers.origin) {
        return { preflight: false };
    }
    res.setHeader('Access-Control-Allow-Origin', req.headers.origin);
    res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');
    // Based on https://github.com/primus/access-control/blob/4cf1bc0e54b086c91e6aa44fb14966fa5ef7549c/index.js#L158
    if (req.headers['access-control-request-headers']) {
        res.setHeader('Access-Control-Allow-Headers', req.headers['access-control-request-headers']);
    }
    if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return { preflight: true };
    }
    return { preflight: false };
}
const matchNextPageBundleRequest = router_1.route('/_next/static/:buildId/pages/:path*.js(.map)?');
// Recursively look up the issuer till it ends up at the root
function findEntryModule(issuer) {
    if (issuer.issuer) {
        return findEntryModule(issuer.issuer);
    }
    return issuer;
}
function erroredPages(compilation, options = { enhanceName: (name) => name }) {
    const failedPages = {};
    for (const error of compilation.errors) {
        const entryModule = findEntryModule(error.origin);
        const { name } = entryModule;
        if (!name) {
            continue;
        }
        // Only pages have to be reloaded
        if (!constants_1.IS_BUNDLED_PAGE_REGEX.test(name)) {
            continue;
        }
        const enhancedName = options.enhanceName(name);
        if (!failedPages[enhancedName]) {
            failedPages[enhancedName] = [];
        }
        failedPages[enhancedName].push(error);
    }
    return failedPages;
}
class HotReloader {
    constructor(dir, { config, buildId } = {}) {
        this.buildId = buildId;
        this.dir = dir;
        this.middlewares = [];
        this.webpackDevMiddleware = null;
        this.webpackHotMiddleware = null;
        this.initialized = false;
        this.stats = null;
        this.serverPrevDocumentHash = null;
        this.config = config;
    }
    async run(req, res, parsedUrl) {
        // Usually CORS support is not needed for the hot-reloader (this is dev only feature)
        // With when the app runs for multi-zones support behind a proxy,
        // the current page is trying to access this URL via assetPrefix.
        // That's when the CORS support is needed.
        const { preflight } = addCorsSupport(req, res);
        if (preflight) {
            return;
        }
        // When a request comes in that is a page bundle, e.g. /_next/static/<buildid>/pages/index.js
        // we have to compile the page using on-demand-entries, this middleware will handle doing that
        // by adding the page to on-demand-entries, waiting till it's done
        // and then the bundle will be served like usual by the actual route in server/index.js
        const handlePageBundleRequest = async (res, parsedUrl) => {
            const { pathname } = parsedUrl;
            const params = matchNextPageBundleRequest(pathname);
            if (!params) {
                return {};
            }
            if (params.buildId !== this.buildId) {
                return;
            }
            const page = `/${params.path.join('/')}`;
            if (page === '/_error' || constants_1.BLOCKED_PAGES.indexOf(page) === -1) {
                try {
                    await this.ensurePage(page);
                }
                catch (error) {
                    await renderScriptError(res, error);
                    return { finished: true };
                }
                const errors = await this.getCompilationErrors(page);
                if (errors.length > 0) {
                    await renderScriptError(res, errors[0]);
                    return { finished: true };
                }
            }
            return {};
        };
        const { finished } = await handlePageBundleRequest(res, parsedUrl);
        for (const fn of this.middlewares) {
            await new Promise((resolve, reject) => {
                fn(req, res, (err) => {
                    if (err)
                        return reject(err);
                    resolve();
                });
            });
        }
        return { finished };
    }
    async clean() {
        return del_1.default(path_1.join(this.dir, this.config.distDir), { force: true });
    }
    async getWebpackConfig() {
        const pagePaths = await glob(`+(_app|_document).+(${this.config.pageExtensions.join('|')})`, { cwd: path_1.join(this.dir, 'pages') });
        const pages = entries_1.createPagesMapping(pagePaths, this.config.pageExtensions);
        const entrypoints = entries_1.createEntrypoints(pages, 'server', this.buildId, this.config);
        return [
            webpack_config_1.default(this.dir, { dev: true, isServer: false, config: this.config, buildId: this.buildId, entrypoints: entrypoints.client }),
            webpack_config_1.default(this.dir, { dev: true, isServer: true, config: this.config, buildId: this.buildId, entrypoints: entrypoints.server })
        ];
    }
    async start() {
        await this.clean();
        const configs = await this.getWebpackConfig();
        const multiCompiler = webpack_1.default(configs);
        const buildTools = await this.prepareBuildTools(multiCompiler);
        this.assignBuildTools(buildTools);
        this.stats = (await this.waitUntilValid()).stats[0];
    }
    async stop(webpackDevMiddleware) {
        const middleware = webpackDevMiddleware || this.webpackDevMiddleware;
        if (middleware) {
            return new Promise((resolve, reject) => {
                middleware.close((err) => {
                    if (err)
                        return reject(err);
                    resolve();
                });
            });
        }
    }
    async reload() {
        this.stats = null;
        await this.clean();
        const configs = await this.getWebpackConfig();
        const compiler = webpack_1.default(configs);
        const buildTools = await this.prepareBuildTools(compiler);
        this.stats = await this.waitUntilValid(buildTools.webpackDevMiddleware);
        const oldWebpackDevMiddleware = this.webpackDevMiddleware;
        this.assignBuildTools(buildTools);
        await this.stop(oldWebpackDevMiddleware);
    }
    assignBuildTools({ webpackDevMiddleware, webpackHotMiddleware, onDemandEntries }) {
        this.webpackDevMiddleware = webpackDevMiddleware;
        this.webpackHotMiddleware = webpackHotMiddleware;
        this.onDemandEntries = onDemandEntries;
        this.middlewares = [
            webpackDevMiddleware,
            webpackHotMiddleware,
            error_overlay_middleware_1.default({ dir: this.dir }),
            onDemandEntries.middleware()
        ];
    }
    async prepareBuildTools(multiCompiler) {
        output_1.watchCompiler(multiCompiler.compilers[0], multiCompiler.compilers[1]);
        // This plugin watches for changes to _document.js and notifies the client side that it should reload the page
        multiCompiler.compilers[1].hooks.done.tap('NextjsHotReloaderForServer', (stats) => {
            if (!this.initialized) {
                return;
            }
            const { compilation } = stats;
            // We only watch `_document` for changes on the server compilation
            // the rest of the files will be triggered by the client compilation
            const documentChunk = compilation.chunks.find(c => c.name === path_1.normalize(`static/${this.buildId}/pages/_document.js`));
            // If the document chunk can't be found we do nothing
            if (!documentChunk) {
                console.warn('_document.js chunk not found');
                return;
            }
            // Initial value
            if (this.serverPrevDocumentHash === null) {
                this.serverPrevDocumentHash = documentChunk.hash;
                return;
            }
            // If _document.js didn't change we don't trigger a reload
            if (documentChunk.hash === this.serverPrevDocumentHash) {
                return;
            }
            // Notify reload to reload the page, as _document.js was changed (different hash)
            this.send('reloadPage');
            this.serverPrevDocumentHash = documentChunk.hash;
        });
        multiCompiler.compilers[0].hooks.done.tap('NextjsHotReloaderForClient', (stats) => {
            const { compilation } = stats;
            const chunkNames = new Set(compilation.chunks
                .map((c) => c.name)
                .filter(name => constants_1.IS_BUNDLED_PAGE_REGEX.test(name)));
            if (this.initialized) {
                // detect chunks which have to be replaced with a new template
                // e.g, pages/index.js <-> pages/_error.js
                const addedPages = diff(chunkNames, this.prevChunkNames);
                const removedPages = diff(this.prevChunkNames, chunkNames);
                if (addedPages.size > 0) {
                    for (const addedPage of addedPages) {
                        let page = '/' + constants_1.ROUTE_NAME_REGEX.exec(addedPage)[1].replace(/\\/g, '/');
                        page = page === '/index' ? '/' : page;
                        this.send('addedPage', page);
                    }
                }
                if (removedPages.size > 0) {
                    for (const removedPage of removedPages) {
                        let page = '/' + constants_1.ROUTE_NAME_REGEX.exec(removedPage)[1].replace(/\\/g, '/');
                        page = page === '/index' ? '/' : page;
                        this.send('removedPage', page);
                    }
                }
            }
            this.initialized = true;
            this.stats = stats;
            this.prevChunkNames = chunkNames;
        });
        // We don’t watch .git/ .next/ and node_modules for changes
        const ignored = [
            /[\\/]\.git[\\/]/,
            /[\\/]\.next[\\/]/,
            /[\\/]node_modules[\\/]/
        ];
        let webpackDevMiddlewareConfig = {
            publicPath: `/_next/static/webpack`,
            noInfo: true,
            logLevel: 'silent',
            watchOptions: { ignored },
            writeToDisk: true
        };
        if (this.config.webpackDevMiddleware) {
            console.log(`> Using "webpackDevMiddleware" config function defined in ${this.config.configOrigin}.`);
            webpackDevMiddlewareConfig = this.config.webpackDevMiddleware(webpackDevMiddlewareConfig);
        }
        const webpackDevMiddleware = webpack_dev_middleware_1.default(multiCompiler, webpackDevMiddlewareConfig);
        const webpackHotMiddleware = webpack_hot_middleware_1.default(multiCompiler.compilers[0], {
            path: '/_next/webpack-hmr',
            log: false,
            heartbeat: 2500
        });
        const onDemandEntries = on_demand_entry_handler_1.default(webpackDevMiddleware, multiCompiler, Object.assign({ dir: this.dir, buildId: this.buildId, reload: this.reload.bind(this), pageExtensions: this.config.pageExtensions }, this.config.onDemandEntries));
        return {
            webpackDevMiddleware,
            webpackHotMiddleware,
            onDemandEntries
        };
    }
    waitUntilValid(webpackDevMiddleware) {
        const middleware = webpackDevMiddleware || this.webpackDevMiddleware;
        return new Promise((resolve) => {
            middleware.waitUntilValid(resolve);
        });
    }
    async getCompilationErrors(page) {
        const normalizedPage = on_demand_entry_handler_1.normalizePage(page);
        // When we are reloading, we need to wait until it's reloaded properly.
        await this.onDemandEntries.waitUntilReloaded();
        if (this.stats.hasErrors()) {
            const { compilation } = this.stats;
            const failedPages = erroredPages(compilation, {
                enhanceName(name) {
                    return '/' + constants_1.ROUTE_NAME_REGEX.exec(name)[1];
                }
            });
            // If there is an error related to the requesting page we display it instead of the first error
            if (failedPages[normalizedPage] && failedPages[normalizedPage].length > 0) {
                return failedPages[normalizedPage];
            }
            // If none were found we still have to show the other errors
            return this.stats.compilation.errors;
        }
        return [];
    }
    send(action, ...args) {
        this.webpackHotMiddleware.publish({ action, data: args });
    }
    async ensurePage(page) {
        // Make sure we don't re-build or dispose prebuilt pages
        if (page !== '/_error' && constants_1.BLOCKED_PAGES.indexOf(page) !== -1) {
            return;
        }
        await this.onDemandEntries.ensurePage(page);
    }
}
exports.default = HotReloader;
function diff(a, b) {
    return new Set([...a].filter((v) => !b.has(v)));
}


/***/ }),

/***/ "./node_modules/next/dist/server/lib/error-overlay-middleware.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/server/lib/error-overlay-middleware.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = __importDefault(__webpack_require__(/*! url */ "url"));
const launch_editor_1 = __importDefault(__webpack_require__(/*! launch-editor */ "launch-editor"));
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
function errorOverlayMiddleware(options) {
    return (req, res, next) => {
        if (req.url.startsWith('/_next/development/open-stack-frame-in-editor')) {
            const query = url_1.default.parse(req.url, true).query;
            const lineNumber = parseInt(query.lineNumber, 10) || 1;
            const colNumber = parseInt(query.colNumber, 10) || 1;
            let resolvedFileName = query.fileName;
            if (!fs_1.default.existsSync(resolvedFileName)) {
                resolvedFileName = path_1.default.join(options.dir, resolvedFileName);
            }
            launch_editor_1.default(`${resolvedFileName}:${lineNumber}:${colNumber}`);
            res.end();
        }
        else {
            next();
        }
    };
}
exports.default = errorOverlayMiddleware;


/***/ }),

/***/ "./node_modules/next/dist/server/next-dev-server.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/server/next-dev-server.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const next_server_1 = __importDefault(__webpack_require__(/*! next-server/dist/server/next-server */ "next-server/dist/server/next-server"));
const path_1 = __webpack_require__(/*! path */ "path");
const hot_reloader_1 = __importDefault(__webpack_require__(/*! ./hot-reloader */ "./node_modules/next/dist/server/hot-reloader.js"));
const router_1 = __webpack_require__(/*! next-server/dist/server/router */ "next-server/dist/server/router");
const constants_1 = __webpack_require__(/*! next-server/constants */ "next-server/constants");
const error_debug_1 = __importDefault(__webpack_require__(/*! ./error-debug */ "./node_modules/next/dist/server/error-debug.js"));
class DevServer extends next_server_1.default {
    constructor(options) {
        super(options);
        this.renderOpts.dev = true;
        this.renderOpts.ErrorDebug = error_debug_1.default;
        this.devReady = new Promise(resolve => {
            this.setDevReady = resolve;
        });
    }
    currentPhase() {
        return constants_1.PHASE_DEVELOPMENT_SERVER;
    }
    readBuildId() {
        return 'development';
    }
    async addExportPathMapRoutes() {
        // Makes `next export` exportPathMap work in development mode.
        // So that the user doesn't have to define a custom server reading the exportPathMap
        if (this.nextConfig.exportPathMap) {
            console.log('Defining routes from exportPathMap');
            const exportPathMap = await this.nextConfig.exportPathMap({}, { dev: true, dir: this.dir, outDir: null, distDir: this.distDir, buildId: this.buildId }); // In development we can't give a default path mapping
            for (const path in exportPathMap) {
                const { page, query = {} } = exportPathMap[path];
                // We use unshift so that we're sure the routes is defined before Next's default routes
                this.router.add({
                    match: router_1.route(path),
                    fn: async (req, res, params, parsedUrl) => {
                        const { query: urlQuery } = parsedUrl;
                        Object.keys(urlQuery)
                            .filter(key => query[key] === undefined)
                            .forEach(key => console.warn(`Url defines a query parameter '${key}' that is missing in exportPathMap`));
                        const mergedQuery = Object.assign({}, urlQuery, query);
                        await this.render(req, res, page, mergedQuery, parsedUrl);
                    }
                });
            }
        }
    }
    async prepare() {
        this.hotReloader = new hot_reloader_1.default(this.dir, { config: this.nextConfig, buildId: this.buildId });
        await super.prepare();
        await this.addExportPathMapRoutes();
        await this.hotReloader.start();
        this.setDevReady();
    }
    async close() {
        if (this.hotReloader) {
            await this.hotReloader.stop();
        }
    }
    async run(req, res, parsedUrl) {
        await this.devReady;
        const { finished } = await this.hotReloader.run(req, res, parsedUrl);
        if (finished) {
            return;
        }
        return super.run(req, res, parsedUrl);
    }
    generateRoutes() {
        const routes = super.generateRoutes();
        // In development we expose all compiled files for react-error-overlay's line show feature
        // We use unshift so that we're sure the routes is defined before Next's default routes
        routes.unshift({
            match: router_1.route('/_next/development/:path*'),
            fn: async (req, res, params) => {
                const p = path_1.join(this.distDir, ...(params.path || []));
                await this.serveStatic(req, res, p);
            }
        });
        return routes;
    }
    async renderToHTML(req, res, pathname, query, options) {
        const compilationErr = await this.getCompilationError(pathname);
        if (compilationErr) {
            res.statusCode = 500;
            return this.renderErrorToHTML(compilationErr, req, res, pathname, query);
        }
        // In dev mode we use on demand entries to compile the page before rendering
        try {
            await this.hotReloader.ensurePage(pathname);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                res.statusCode = 404;
                return this.renderErrorToHTML(null, req, res, pathname, query);
            }
            if (!this.quiet)
                console.error(err);
        }
        return super.renderToHTML(req, res, pathname, query, options);
    }
    async renderErrorToHTML(err, req, res, pathname, query) {
        await this.hotReloader.ensurePage('/_error');
        const compilationErr = await this.getCompilationError(pathname);
        if (compilationErr) {
            res.statusCode = 500;
            return super.renderErrorToHTML(compilationErr, req, res, pathname, query);
        }
        try {
            const out = await super.renderErrorToHTML(err, req, res, pathname, query);
            return out;
        }
        catch (err2) {
            if (!this.quiet)
                console.error(err2);
            res.statusCode = 500;
            return super.renderErrorToHTML(err2, req, res, pathname, query);
        }
    }
    sendHTML(req, res, html) {
        // In dev, we should not cache pages for any reason.
        res.setHeader('Cache-Control', 'no-store, must-revalidate');
        return super.sendHTML(req, res, html);
    }
    setImmutableAssetCacheControl(res) {
        res.setHeader('Cache-Control', 'no-store, must-revalidate');
    }
    async getCompilationError(page) {
        const errors = await this.hotReloader.getCompilationErrors(page);
        if (errors.length === 0)
            return;
        // Return the very first error we found.
        return errors[0];
    }
}
exports.default = DevServer;


/***/ }),

/***/ "./node_modules/next/dist/server/next.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/server/next.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This file is used for when users run `require('next')`
module.exports = (options) => {
    if (options.dev) {
        const Server = __webpack_require__(/*! ./next-dev-server */ "./node_modules/next/dist/server/next-dev-server.js").default;
        return new Server(options);
    }
    const next = __webpack_require__(/*! next-server */ "next-server");
    return next(options);
};


/***/ }),

/***/ "./node_modules/next/dist/server/on-demand-entry-handler.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/server/on-demand-entry-handler.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const DynamicEntryPlugin_1 = __importDefault(__webpack_require__(/*! webpack/lib/DynamicEntryPlugin */ "./node_modules/webpack/lib/DynamicEntryPlugin.js"));
const events_1 = __webpack_require__(/*! events */ "events");
const path_1 = __webpack_require__(/*! path */ "path");
const url_1 = __webpack_require__(/*! url */ "url");
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const promisify_1 = __importDefault(__webpack_require__(/*! ../lib/promisify */ "./node_modules/next/dist/lib/promisify.js"));
const glob_1 = __importDefault(__webpack_require__(/*! glob */ "glob"));
const require_1 = __webpack_require__(/*! next-server/dist/server/require */ "next-server/dist/server/require");
const normalize_page_path_1 = __webpack_require__(/*! next-server/dist/server/normalize-page-path */ "next-server/dist/server/normalize-page-path");
const constants_1 = __webpack_require__(/*! next-server/constants */ "next-server/constants");
const querystring_1 = __webpack_require__(/*! querystring */ "querystring");
const ADDED = Symbol('added');
const BUILDING = Symbol('building');
const BUILT = Symbol('built');
const glob = promisify_1.default(glob_1.default);
const access = promisify_1.default(fs_1.default.access);
// Based on https://github.com/webpack/webpack/blob/master/lib/DynamicEntryPlugin.js#L29-L37
function addEntry(compilation, context, name, entry) {
    return new Promise((resolve, reject) => {
        const dep = DynamicEntryPlugin_1.default.createDependency(entry, name);
        compilation.addEntry(context, dep, name, (err) => {
            if (err)
                return reject(err);
            resolve();
        });
    });
}
function onDemandEntryHandler(devMiddleware, multiCompiler, { buildId, dir, reload, pageExtensions, maxInactiveAge, pagesBufferLength }) {
    const clients = new Set();
    const evtSourceHeaders = {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'text/event-stream;charset=utf-8',
        'Cache-Control': 'no-cache, no-transform',
        // While behind nginx, event stream should not be buffered:
        // http://nginx.org/docs/http/ngx_http_proxy_module.html#proxy_buffering
        'X-Accel-Buffering': 'no',
        'Connection': 'keep-alive'
    };
    const { compilers } = multiCompiler;
    const invalidator = new Invalidator(devMiddleware, multiCompiler);
    let entries = {};
    let lastAccessPages = [''];
    let doneCallbacks = new events_1.EventEmitter();
    let reloading = false;
    let stopped = false;
    let reloadCallbacks = new events_1.EventEmitter();
    for (const compiler of compilers) {
        compiler.hooks.make.tapPromise('NextJsOnDemandEntries', (compilation) => {
            invalidator.startBuilding();
            const allEntries = Object.keys(entries).map(async (page) => {
                const { name, absolutePagePath } = entries[page];
                try {
                    await access(absolutePagePath, (fs_1.default.constants || fs_1.default).W_OK);
                }
                catch (err) {
                    console.warn('Page was removed', page);
                    delete entries[page];
                    return;
                }
                entries[page].status = BUILDING;
                return addEntry(compilation, compiler.context, name, [compiler.name === 'client' ? `next-client-pages-loader?${querystring_1.stringify({ page, absolutePagePath })}!` : absolutePagePath]);
            });
            return Promise.all(allEntries);
        });
    }
    multiCompiler.hooks.done.tap('NextJsOnDemandEntries', (multiStats) => {
        const clientStats = multiStats.stats[0];
        const { compilation } = clientStats;
        const hardFailedPages = compilation.errors
            .filter(e => {
            // Make sure to only pick errors which marked with missing modules
            const hasNoModuleFoundError = /ENOENT/.test(e.message) || /Module not found/.test(e.message);
            if (!hasNoModuleFoundError)
                return false;
            // The page itself is missing. So this is a failed page.
            if (constants_1.IS_BUNDLED_PAGE_REGEX.test(e.module.name))
                return true;
            // No dependencies means this is a top level page.
            // So this is a failed page.
            return e.module.dependencies.length === 0;
        })
            .map(e => e.module.chunks)
            .reduce((a, b) => [...a, ...b], [])
            .map(c => {
            const pageName = constants_1.ROUTE_NAME_REGEX.exec(c.name)[1];
            return normalizePage(`/${pageName}`);
        });
        // compilation.entrypoints is a Map object, so iterating over it 0 is the key and 1 is the value
        for (const [, entrypoint] of compilation.entrypoints.entries()) {
            const result = constants_1.ROUTE_NAME_REGEX.exec(entrypoint.name);
            if (!result) {
                continue;
            }
            const pagePath = result[1];
            if (!pagePath) {
                continue;
            }
            const page = normalizePage('/' + pagePath);
            const entry = entries[page];
            if (!entry) {
                continue;
            }
            if (entry.status !== BUILDING) {
                continue;
            }
            entry.status = BUILT;
            entry.lastActiveTime = Date.now();
            doneCallbacks.emit(page);
        }
        invalidator.doneBuilding();
        if (hardFailedPages.length > 0 && !reloading) {
            console.log(`> Reloading webpack due to inconsistant state of pages(s): ${hardFailedPages.join(', ')}`);
            reloading = true;
            reload()
                .then(() => {
                console.log('> Webpack reloaded.');
                reloadCallbacks.emit('done');
                stop();
            })
                .catch(err => {
                console.error(`> Webpack reloading failed: ${err.message}`);
                console.error(err.stack);
                process.exit(1);
            });
        }
    });
    const disposeHandler = setInterval(function () {
        if (stopped)
            return;
        disposeInactiveEntries(devMiddleware, entries, lastAccessPages, maxInactiveAge);
    }, 5000);
    disposeHandler.unref();
    function stop() {
        clients.forEach(client => client.end());
        clearInterval(disposeHandler);
        stopped = true;
        doneCallbacks = null;
        reloadCallbacks = null;
    }
    function handlePing(pg) {
        const page = normalizePage(pg);
        const entryInfo = entries[page];
        let toSend;
        // If there's no entry.
        // Then it seems like an weird issue.
        if (!entryInfo) {
            const message = `Client pings, but there's no entry for page: ${page}`;
            console.error(message);
            return { invalid: true };
        }
        // 404 is an on demand entry but when a new page is added we have to refresh the page
        if (page === '/_error') {
            toSend = { invalid: true };
        }
        else {
            toSend = { success: true };
        }
        // We don't need to maintain active state of anything other than BUILT entries
        if (entryInfo.status !== BUILT)
            return;
        // If there's an entryInfo
        if (!lastAccessPages.includes(page)) {
            lastAccessPages.unshift(page);
            // Maintain the buffer max length
            if (lastAccessPages.length > pagesBufferLength) {
                lastAccessPages.pop();
            }
        }
        entryInfo.lastActiveTime = Date.now();
        return toSend;
    }
    return {
        waitUntilReloaded() {
            if (!reloading)
                return Promise.resolve(true);
            return new Promise((resolve) => {
                reloadCallbacks.once('done', function () {
                    resolve();
                });
            });
        },
        async ensurePage(page) {
            await this.waitUntilReloaded();
            page = normalizePage(page);
            let normalizedPagePath;
            try {
                normalizedPagePath = normalize_page_path_1.normalizePagePath(page);
            }
            catch (err) {
                console.error(err);
                throw require_1.pageNotFoundError(normalizedPagePath);
            }
            const extensions = pageExtensions.join('|');
            const pagesDir = path_1.join(dir, 'pages');
            let paths = await glob(`{${normalizedPagePath.slice(1)}/index,${normalizedPagePath.slice(1)}}.+(${extensions})`, { cwd: pagesDir });
            // Default the /_error route to the Next.js provided default page
            if (page === '/_error' && paths.length === 0) {
                paths = ['next/dist/pages/_error'];
            }
            if (paths.length === 0) {
                throw require_1.pageNotFoundError(normalizedPagePath);
            }
            const pagePath = paths[0];
            let pageUrl = `/${pagePath.replace(new RegExp(`\\.+(${extensions})$`), '').replace(/\\/g, '/')}`.replace(/\/index$/, '');
            pageUrl = pageUrl === '' ? '/' : pageUrl;
            const bundleFile = pageUrl === '/' ? '/index.js' : `${pageUrl}.js`;
            const name = path_1.join('static', buildId, 'pages', bundleFile);
            const absolutePagePath = pagePath.startsWith('next/dist/pages') ? /*require.resolve*/(__webpack_require__("./node_modules/next/dist/server sync recursive").resolve(pagePath)) : path_1.join(pagesDir, pagePath);
            await new Promise((resolve, reject) => {
                const entryInfo = entries[page];
                if (entryInfo) {
                    if (entryInfo.status === BUILT) {
                        resolve();
                        return;
                    }
                    if (entryInfo.status === BUILDING) {
                        doneCallbacks.once(page, handleCallback);
                        return;
                    }
                }
                console.log(`> Building page: ${page}`);
                entries[page] = { name, absolutePagePath, status: ADDED };
                doneCallbacks.once(page, handleCallback);
                invalidator.invalidate();
                function handleCallback(err) {
                    if (err)
                        return reject(err);
                    resolve();
                }
            });
        },
        middleware() {
            return (req, res, next) => {
                if (stopped) {
                    // If this handler is stopped, we need to reload the user's browser.
                    // So the user could connect to the actually running handler.
                    res.statusCode = 302;
                    res.setHeader('Location', req.url);
                    res.end('302');
                }
                else if (reloading) {
                    // Webpack config is reloading. So, we need to wait until it's done and
                    // reload user's browser.
                    // So the user could connect to the new handler and webpack setup.
                    this.waitUntilReloaded()
                        .then(() => {
                        res.statusCode = 302;
                        res.setHeader('Location', req.url);
                        res.end('302');
                    });
                }
                else {
                    if (!/^\/_next\/on-demand-entries-ping/.test(req.url))
                        return next();
                    const { query } = url_1.parse(req.url, true);
                    const page = query.page;
                    if (!page)
                        return next();
                    // Upgrade request to EventSource
                    req.socket.setKeepAlive(true);
                    res.writeHead(200, evtSourceHeaders);
                    res.write('\n');
                    clients.add(res);
                    const runPing = () => {
                        const data = handlePing(query.page);
                        if (!data)
                            return;
                        res.write('data: ' + JSON.stringify(data) + '\n\n');
                    };
                    const pingInterval = setInterval(() => runPing(), 5000);
                    req.on('close', () => {
                        clients.delete(res);
                        clearInterval(pingInterval);
                    });
                    // Do initial ping right after EventSource is finished being set up
                    runPing();
                }
            };
        }
    };
}
exports.default = onDemandEntryHandler;
function disposeInactiveEntries(devMiddleware, entries, lastAccessPages, maxInactiveAge) {
    const disposingPages = [];
    Object.keys(entries).forEach((page) => {
        const { lastActiveTime, status } = entries[page];
        // This means this entry is currently building or just added
        // We don't need to dispose those entries.
        if (status !== BUILT)
            return;
        // We should not build the last accessed page even we didn't get any pings
        // Sometimes, it's possible our XHR ping to wait before completing other requests.
        // In that case, we should not dispose the current viewing page
        if (lastAccessPages.includes(page))
            return;
        if (Date.now() - lastActiveTime > maxInactiveAge) {
            disposingPages.push(page);
        }
    });
    if (disposingPages.length > 0) {
        disposingPages.forEach((page) => {
            delete entries[page];
        });
        console.log(`> Disposing inactive page(s): ${disposingPages.join(', ')}`);
        devMiddleware.invalidate();
    }
}
// /index and / is the same. So, we need to identify both pages as the same.
// This also applies to sub pages as well.
function normalizePage(page) {
    const unixPagePath = page.replace(/\\/g, '/');
    if (unixPagePath === '/index' || unixPagePath === '/') {
        return '/';
    }
    return unixPagePath.replace(/\/index$/, '');
}
exports.normalizePage = normalizePage;
// Make sure only one invalidation happens at a time
// Otherwise, webpack hash gets changed and it'll force the client to reload.
class Invalidator {
    constructor(devMiddleware, multiCompiler) {
        this.multiCompiler = multiCompiler;
        this.devMiddleware = devMiddleware;
        // contains an array of types of compilers currently building
        this.building = false;
        this.rebuildAgain = false;
    }
    invalidate() {
        // If there's a current build is processing, we won't abort it by invalidating.
        // (If aborted, it'll cause a client side hard reload)
        // But let it to invalidate just after the completion.
        // So, it can re-build the queued pages at once.
        if (this.building) {
            this.rebuildAgain = true;
            return;
        }
        this.building = true;
        // Work around a bug in webpack, calling `invalidate` on Watching.js
        // doesn't trigger the invalid call used to keep track of the `.done` hook on multiCompiler
        for (const compiler of this.multiCompiler.compilers) {
            compiler.hooks.invalid.call();
        }
        this.devMiddleware.invalidate();
    }
    startBuilding() {
        this.building = true;
    }
    doneBuilding() {
        this.building = false;
        if (this.rebuildAgain) {
            this.rebuildAgain = false;
            this.invalidate();
        }
    }
}


/***/ }),

/***/ "./node_modules/node-libs-browser/mock sync recursive ^\\.\\/.*$":
/*!***********************************************************!*\
  !*** ./node_modules/node-libs-browser/mock sync ^\.\/.*$ ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./buffer": "./buffer",
	"./buffer.js": "./buffer.js",
	"./console": "./console",
	"./console.js": "./console.js",
	"./dns": "./dns",
	"./dns.js": "./dns.js",
	"./empty": "./empty",
	"./empty.js": "./empty.js",
	"./net": "./net",
	"./net.js": "./net.js",
	"./process": "./process",
	"./process.js": "./process.js",
	"./punycode": "./punycode",
	"./punycode.js": "./punycode.js",
	"./tls": "./tls",
	"./tls.js": "./tls.js",
	"./tty": "./tty",
	"./tty.js": "./tty.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/node-libs-browser/mock sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/terser/package.json":
/*!******************************************!*\
  !*** ./node_modules/terser/package.json ***!
  \******************************************/
/*! exports provided: name, description, homepage, author, license, version, engines, maintainers, repository, main, types, bin, files, dependencies, devDependencies, scripts, keywords, eslintConfig, pre-commit, default */
/***/ (function(module) {

module.exports = {"name":"terser","description":"JavaScript parser, mangler/compressor and beautifier toolkit for ES6+","homepage":"https://github.com/fabiosantoscode/terser","author":"Mihai Bazon <mihai.bazon@gmail.com> (http://lisperator.net/)","license":"BSD-2-Clause","version":"3.16.1","engines":{"node":">=6.0.0"},"maintainers":["Fábio Santos <fabiosantosart@gmail.com>","Alex Lam <alexlamsl@gmail.com>","Mihai Bazon <mihai.bazon@gmail.com> (http://lisperator.net/)"],"repository":"https://github.com/fabiosantoscode/terser.git","main":"dist/bundle.min.js","types":"tools/terser.d.ts","bin":{"terser":"bin/uglifyjs"},"files":["bin","dist","!dist/bundle.instrumented.js","tools","LICENSE","README.md","CHANGELOG.md","PATRONS.md"],"dependencies":{"commander":"~2.17.1","source-map":"~0.6.1","source-map-support":"~0.5.9"},"devDependencies":{"acorn":"^6.0.4","coveralls":"^3.0.2","cross-env":"^5.2.0","csv":"^5.1.0","es6-promise":"^4.2.5","escodegen":"^1.11.0","eslint":"^4.19.1","eslump":"^2.0.0","istanbul":"^0.4.5","mocha":"^3.0.0","mochallel":"^1.8.6","pre-commit":"^1.2.2","rimraf":"^2.6.2","rollup":"^1.0.1","semver":"~5.5.1"},"scripts":{"test":"rimraf dist/* && npm run prepare && istanbul instrument dist/bundle.min.js > dist/bundle.instrumented.js && node test/run-tests.js","coverage":"istanbul cover test/run-tests.js","coveralls":"coveralls < coverage/lcov.info","lint":"eslint lib","lint-fix":"eslint --fix lib","prepare":"rollup -c && cd dist && cross-env TERSER_NO_BUNDLE=1 ../bin/uglifyjs bundle.js -mc --source-map 'content=bundle.js.map,includeSources=true,url=bundle.min.js.map' -o bundle.min.js","postversion":"echo 'Remember to update the changelog!'"},"keywords":["uglify","terser","uglify-es","uglify-js","minify","minifier","javascript","ecmascript","es5","es6","es7","es8","es2015","es2016","es2017","async","await"],"eslintConfig":{"parserOptions":{"sourceType":"module"},"rules":{"brace-style":["error","1tbs",{"allowSingleLine":true}],"quotes":["error","double","avoid-escape"],"no-debugger":"error","no-undef":"error","semi":["error","always"],"no-extra-semi":"error","no-irregular-whitespace":"error","space-before-blocks":["error","always"]}},"pre-commit":["lint-fix","test"]};

/***/ }),

/***/ "./node_modules/webpack-dev-middleware/index.js":
/*!*****************************************!*\
  !*** (webpack)-dev-middleware/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const mime = __webpack_require__(/*! mime */ "./node_modules/webpack-dev-middleware/node_modules/mime/index.js");
const createContext = __webpack_require__(/*! ./lib/context */ "./node_modules/webpack-dev-middleware/lib/context.js");
const middleware = __webpack_require__(/*! ./lib/middleware */ "./node_modules/webpack-dev-middleware/lib/middleware.js");
const reporter = __webpack_require__(/*! ./lib/reporter */ "./node_modules/webpack-dev-middleware/lib/reporter.js");
const { setFs, toDisk } = __webpack_require__(/*! ./lib/fs */ "./node_modules/webpack-dev-middleware/lib/fs.js");
const { getFilenameFromUrl, noop, ready } = __webpack_require__(/*! ./lib/util */ "./node_modules/webpack-dev-middleware/lib/util.js");

const defaults = {
  logLevel: 'info',
  logTime: false,
  logger: null,
  mimeTypes: null,
  reporter,
  stats: {
    colors: true,
    context: process.cwd()
  },
  watchOptions: {
    aggregateTimeout: 200
  },
  writeToDisk: false
};

module.exports = function wdm(compiler, opts) {
  const options = Object.assign({}, defaults, opts);

  if (options.lazy) {
    if (typeof options.filename === 'string') {
      const filename = options.filename
        .replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&') // eslint-disable-line no-useless-escape
        .replace(/\\\[[a-z]+\\\]/ig, '.+');

      options.filename = new RegExp(`^[/]{0,1}${filename}$`);
    }
  }

  // defining custom MIME type
  if (options.mimeTypes) {
    mime.define(options.mimeTypes);
  }

  const context = createContext(compiler, options);

  // start watching
  if (!options.lazy) {
    const watching = compiler.watch(options.watchOptions, (err) => {
      if (err) {
        context.log.error(err.stack || err);
        if (err.details) {
          context.log.error(err.details);
        }
      }
    });

    context.watching = watching;
  } else {
    context.state = true;
  }

  if (options.writeToDisk) {
    toDisk(context);
  }

  setFs(context, compiler);

  return Object.assign(middleware(context), {
    close(callback) {
      callback = callback || noop;

      if (context.watching) {
        context.watching.close(callback);
      } else {
        callback();
      }
    },

    context,

    fileSystem: context.fs,

    getFilenameFromUrl: getFilenameFromUrl.bind(this, context.options.publicPath, context.compiler),

    invalidate(callback) {
      callback = callback || noop;
      if (context.watching) {
        ready(context, callback, {});
        context.watching.invalidate();
      } else {
        callback();
      }
    },

    waitUntilValid(callback) {
      callback = callback || noop;
      ready(context, callback, {});
    }
  });
};


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/lib/DevMiddlewareError.js":
/*!**********************************************************!*\
  !*** (webpack)-dev-middleware/lib/DevMiddlewareError.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = class DevMiddlewareError extends Error {

};


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/lib/context.js":
/*!***********************************************!*\
  !*** (webpack)-dev-middleware/lib/context.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const weblog = __webpack_require__(/*! webpack-log */ "./node_modules/webpack-log/src/index.js");

module.exports = function ctx(compiler, options) {
  const context = {
    state: false,
    webpackStats: null,
    callbacks: [],
    options,
    compiler,
    watching: null,
    forceRebuild: false
  };

  if (options.logger) {
    context.log = options.logger;
  } else {
    context.log = weblog({
      level: options.logLevel || 'info',
      name: 'wdm',
      timestamp: options.logTime
    });
  }

  const { log } = context;

  function done(stats) {
    // We are now on valid state
    context.state = true;
    context.webpackStats = stats;

    // Do the stuff in nextTick, because bundle may be invalidated
    // if a change happened while compiling
    process.nextTick(() => {
      // check if still in valid state
      if (!context.state) {
        return;
      }

      // print webpack output
      context.options.reporter(context.options, {
        log,
        state: true,
        stats
      });

      // execute callback that are delayed
      const cbs = context.callbacks;
      context.callbacks = [];
      cbs.forEach((cb) => {
        cb(stats);
      });
    });

    // In lazy mode, we may issue another rebuild
    if (context.forceRebuild) {
      context.forceRebuild = false;
      rebuild();
    }
  }

  function invalid(callback) {
    if (context.state) {
      context.options.reporter(context.options, {
        log,
        state: false
      });
    }

    // We are now in invalid state
    context.state = false;
    if (typeof callback === 'function') {
      callback();
    }
  }

  function rebuild() {
    if (context.state) {
      context.state = false;
      context.compiler.run((err) => {
        if (err) {
          log.error(err.stack || err);
          if (err.details) {
            log.error(err.details);
          }
        }
      });
    } else {
      context.forceRebuild = true;
    }
  }

  context.rebuild = rebuild;
  context.compiler.hooks.invalid.tap('WebpackDevMiddleware', invalid);
  context.compiler.hooks.run.tap('WebpackDevMiddleware', invalid);
  context.compiler.hooks.done.tap('WebpackDevMiddleware', done);
  context.compiler.hooks.watchRun.tap('WebpackDevMiddleware', (comp, callback) => {
    invalid(callback);
  });

  return context;
};


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/lib/fs.js":
/*!******************************************!*\
  !*** (webpack)-dev-middleware/lib/fs.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const MemoryFileSystem = __webpack_require__(/*! memory-fs */ "memory-fs");
const { colors } = __webpack_require__(/*! webpack-log */ "./node_modules/webpack-log/src/index.js");
const NodeOutputFileSystem = __webpack_require__(/*! webpack/lib/node/NodeOutputFileSystem */ "./node_modules/webpack/lib/node/NodeOutputFileSystem.js");
const DevMiddlewareError = __webpack_require__(/*! ./DevMiddlewareError */ "./node_modules/webpack-dev-middleware/lib/DevMiddlewareError.js");

const { mkdirp } = new NodeOutputFileSystem();

module.exports = {
  toDisk(context) {
    const compilers = context.compiler.compilers || [context.compiler];
    for (const compiler of compilers) {
      compiler.hooks.afterEmit.tap('WebpackDevMiddleware', (compilation) => {
        const { assets } = compilation;
        const { log } = context;
        const { writeToDisk: filter } = context.options;
        let { outputPath } = compiler;

        if (outputPath === '/') {
          outputPath = compiler.context;
        }

        for (const assetPath of Object.keys(assets)) {
          const asset = assets[assetPath];
          const source = asset.source();
          const isAbsolute = path.isAbsolute(assetPath);
          const writePath = isAbsolute ? assetPath : path.join(outputPath, assetPath);
          const relativePath = path.relative(process.cwd(), writePath);
          const allowWrite = filter && typeof filter === 'function' ? filter(writePath) : true;

          if (allowWrite) {
            let output = source;

            mkdirp.sync(path.dirname(writePath));

            if (Array.isArray(source)) {
              output = source.join('\n');
            }

            try {
              fs.writeFileSync(writePath, output, 'utf-8');
              log.debug(colors.cyan(`Asset written to disk: ${relativePath}`));
            } catch (e) {
              log.error(`Unable to write asset to disk:\n${e}`);
            }
          }
        }
      });
    }
  },

  setFs(context, compiler) {
    if (typeof compiler.outputPath === 'string' && !path.posix.isAbsolute(compiler.outputPath) && !path.win32.isAbsolute(compiler.outputPath)) {
      throw new DevMiddlewareError('`output.path` needs to be an absolute path or `/`.');
    }

    let fileSystem;
    // store our files in memory
    const isMemoryFs = !compiler.compilers && compiler.outputFileSystem instanceof MemoryFileSystem;

    if (isMemoryFs) {
      fileSystem = compiler.outputFileSystem;
    } else {
      fileSystem = new MemoryFileSystem();
      compiler.outputFileSystem = fileSystem;
    }

    context.fs = fileSystem;
  }
};


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/lib/middleware.js":
/*!**************************************************!*\
  !*** (webpack)-dev-middleware/lib/middleware.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const mime = __webpack_require__(/*! mime */ "./node_modules/webpack-dev-middleware/node_modules/mime/index.js");
const DevMiddlewareError = __webpack_require__(/*! ./DevMiddlewareError */ "./node_modules/webpack-dev-middleware/lib/DevMiddlewareError.js");
const { getFilenameFromUrl, handleRangeHeaders, handleRequest, ready } = __webpack_require__(/*! ./util */ "./node_modules/webpack-dev-middleware/lib/util.js");

module.exports = function wrapper(context) {
  return function middleware(req, res, next) {
    // fixes #282. credit @cexoso. in certain edge situations res.locals is
    // undefined.
    res.locals = res.locals || {};

    function goNext() {
      if (!context.options.serverSideRender) {
        return next();
      }

      return new Promise(((resolve) => {
        ready(context, () => {
          res.locals.webpackStats = context.webpackStats;
          res.locals.fs = context.fs;
          resolve(next());
        }, req);
      }));
    }

    const acceptedMethods = context.options.methods || ['GET'];
    if (acceptedMethods.indexOf(req.method) === -1) {
      return goNext();
    }

    let filename = getFilenameFromUrl(context.options.publicPath, context.compiler, req.url);

    if (filename === false) {
      return goNext();
    }

    return new Promise(((resolve) => {
      handleRequest(context, filename, processRequest, req);
      function processRequest() {
        try {
          let stat = context.fs.statSync(filename);

          if (!stat.isFile()) {
            if (stat.isDirectory()) {
              let { index } = context.options;

              if (index === undefined || index === true) {
                index = 'index.html';
              } else if (!index) {
                throw new DevMiddlewareError('next');
              }

              filename = path.posix.join(filename, index);
              stat = context.fs.statSync(filename);
              if (!stat.isFile()) {
                throw new DevMiddlewareError('next');
              }
            } else {
              throw new DevMiddlewareError('next');
            }
          }
        } catch (e) {
          return resolve(goNext());
        }

        // server content
        let content = context.fs.readFileSync(filename);
        content = handleRangeHeaders(content, req, res);

        let contentType = mime.getType(filename);

        // do not add charset to WebAssembly files, otherwise compileStreaming will fail in the client
        if (!/\.wasm$/.test(filename)) {
          contentType += '; charset=UTF-8';
        }

        res.setHeader('Content-Type', contentType);
        res.setHeader('Content-Length', content.length);

        const { headers } = context.options;
        if (headers) {
          for (const name in headers) {
            if ({}.hasOwnProperty.call(headers, name)) {
              res.setHeader(name, context.options.headers[name]);
            }
          }
        }
        // Express automatically sets the statusCode to 200, but not all servers do (Koa).
        res.statusCode = res.statusCode || 200;
        if (res.send) res.send(content);
        else res.end(content);
        resolve();
      }
    }));
  };
};


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/lib/reporter.js":
/*!************************************************!*\
  !*** (webpack)-dev-middleware/lib/reporter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function reporter(middlewareOptions, options) {
  const { log, state, stats } = options;

  if (state) {
    const displayStats = (middlewareOptions.stats !== false);

    if (displayStats) {
      if (stats.hasErrors()) {
        log.error(stats.toString(middlewareOptions.stats));
      } else if (stats.hasWarnings()) {
        log.warn(stats.toString(middlewareOptions.stats));
      } else {
        log.info(stats.toString(middlewareOptions.stats));
      }
    }

    let message = 'Compiled successfully.';

    if (stats.hasErrors()) {
      message = 'Failed to compile.';
    } else if (stats.hasWarnings()) {
      message = 'Compiled with warnings.';
    }
    log.info(message);
  } else {
    log.info('Compiling...');
  }
};


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/lib/util.js":
/*!********************************************!*\
  !*** (webpack)-dev-middleware/lib/util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const { parse } = __webpack_require__(/*! url */ "url");
const querystring = __webpack_require__(/*! querystring */ "querystring");
const parseRange = __webpack_require__(/*! range-parser */ "range-parser");

const HASH_REGEXP = /[0-9a-f]{10,}/;

// support for multi-compiler configuration
// see: https://github.com/webpack/webpack-dev-server/issues/641
function getPaths(publicPath, compiler, url) {
  const compilers = compiler && compiler.compilers;
  if (Array.isArray(compilers)) {
    let compilerPublicPath;

    // the path portion of compilerPublicPath
    let compilerPublicPathBase;

    for (let i = 0; i < compilers.length; i++) {
      compilerPublicPath = compilers[i].options
    && compilers[i].options.output
    && compilers[i].options.output.publicPath;

      if (compilerPublicPath) {
        if (compilerPublicPath.indexOf('/') === 0) {
          compilerPublicPathBase = compilerPublicPath;
        } else {
          // handle the case where compilerPublicPath is a URL with hostname
          compilerPublicPathBase = parse(compilerPublicPath).pathname;
        }

        // check the url vs the path part of the compilerPublicPath
        if (url.indexOf(compilerPublicPathBase) === 0) {
          return {
            publicPath: compilerPublicPath,
            outputPath: compilers[i].outputPath
          };
        }
      }
    }
  }
  return {
    publicPath,
    outputPath: compiler.outputPath
  };
}

function ready(context, fn, req) {
  if (context.state) {
    return fn(context.webpackStats);
  }

  context.log.info(`wait until bundle finished: ${req.url || fn.name}`);
  context.callbacks.push(fn);
}

module.exports = {
  getFilenameFromUrl(pubPath, compiler, url) {
    const { outputPath, publicPath } = getPaths(pubPath, compiler, url);
    // localPrefix is the folder our bundle should be in
    const localPrefix = parse(publicPath || '/', false, true);
    const urlObject = parse(url);
    let filename;

    // publicPath has the hostname that is not the same as request url's, should fail
    if (localPrefix.hostname !== null && urlObject.hostname !== null &&
        localPrefix.hostname !== urlObject.hostname) {
      return false;
    }

    // publicPath is not in url, so it should fail
    if (publicPath && localPrefix.hostname === urlObject.hostname &&
        url.indexOf(publicPath) !== 0) {
      return false;
    }

    // strip localPrefix from the start of url
    if (urlObject.pathname.indexOf(localPrefix.pathname) === 0) {
      filename = urlObject.pathname.substr(localPrefix.pathname.length);
    }

    if (!urlObject.hostname && localPrefix.hostname &&
        url.indexOf(localPrefix.path) !== 0) {
      return false;
    }

    let uri = outputPath;

    /* istanbul ignore if */
    if (process.platform === 'win32') {
      // Path Handling for Microsoft Windows
      if (filename) {
        uri = path.posix.join((outputPath || ''), querystring.unescape(filename));

        if (!path.win32.isAbsolute(uri)) {
          uri = `/${uri}`;
        }
      }

      return uri;
    }

    // Path Handling for all other operating systems
    if (filename) {
      uri = path.posix.join((outputPath || ''), filename);

      if (!path.posix.isAbsolute(uri)) {
        uri = `/${uri}`;
      }
    }

    // if no matches, use outputPath as filename
    return querystring.unescape(uri);
  },

  handleRangeHeaders(content, req, res) {
    // assumes express API. For other servers, need to add logic to access
    // alternative header APIs
    res.setHeader('Accept-Ranges', 'bytes');

    if (req.headers.range) {
      const ranges = parseRange(content.length, req.headers.range);

      // unsatisfiable
      if (ranges === -1) {
        res.setHeader('Content-Range', `bytes */${content.length}`);
        res.statusCode = 416;
      }

      // valid (syntactically invalid/multiple ranges are treated as a
      // regular response)
      if (ranges !== -2 && ranges.length === 1) {
        const { length } = content;

        // Content-Range
        res.statusCode = 206;
        res.setHeader(
          'Content-Range',
          `bytes ${ranges[0].start}-${ranges[0].end}/${length}`
        );

        content = content.slice(ranges[0].start, ranges[0].end + 1);
      }
    }

    return content;
  },

  handleRequest(context, filename, processRequest, req) {
    // in lazy mode, rebuild on bundle request
    if (context.options.lazy && (!context.options.filename || context.options.filename.test(filename))) {
      context.rebuild();
    }

    if (HASH_REGEXP.test(filename)) {
      try {
        if (context.fs.statSync(filename).isFile()) {
          processRequest();
          return;
        }
      } catch (e) {
        // eslint-disable-line
      }
    }

    ready(context, processRequest, req);
  },

  noop: () => {},

  ready
};


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/node_modules/mime/Mime.js":
/*!**********************************************************!*\
  !*** (webpack)-dev-middleware/node_modules/mime/Mime.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (var i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> xtension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime.prototype.define = function(typeMap, force) {
  for (var type in typeMap) {
    var extensions = typeMap[type];
    for (var i = 0; i < extensions.length; i++) {
      var ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] == '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      var ext = extensions[0];
      this._extensions[type] = (ext[0] != '*') ? ext : ext.substr(1)
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.getType = function(path) {
  path = String(path);
  var last = path.replace(/^.*[/\\]/, '').toLowerCase();
  var ext = last.replace(/^.*\./, '').toLowerCase();

  var hasPath = last.length < path.length;
  var hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

module.exports = Mime;


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/node_modules/mime/index.js":
/*!***********************************************************!*\
  !*** (webpack)-dev-middleware/node_modules/mime/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Mime = __webpack_require__(/*! ./Mime */ "./node_modules/webpack-dev-middleware/node_modules/mime/Mime.js");
module.exports = new Mime(__webpack_require__(/*! ./types/standard */ "./node_modules/webpack-dev-middleware/node_modules/mime/types/standard.json"), __webpack_require__(/*! ./types/other */ "./node_modules/webpack-dev-middleware/node_modules/mime/types/other.json"));


/***/ }),

/***/ "./node_modules/webpack-dev-middleware/node_modules/mime/types/other.json":
/*!*******************************************************************!*\
  !*** (webpack)-dev-middleware/node_modules/mime/types/other.json ***!
  \*******************************************************************/
/*! exports provided: application/prs.cww, application/vnd.3gpp.pic-bw-large, application/vnd.3gpp.pic-bw-small, application/vnd.3gpp.pic-bw-var, application/vnd.3gpp2.tcap, application/vnd.3m.post-it-notes, application/vnd.accpac.simply.aso, application/vnd.accpac.simply.imp, application/vnd.acucobol, application/vnd.acucorp, application/vnd.adobe.air-application-installer-package+zip, application/vnd.adobe.formscentral.fcdt, application/vnd.adobe.fxp, application/vnd.adobe.xdp+xml, application/vnd.adobe.xfdf, application/vnd.ahead.space, application/vnd.airzip.filesecure.azf, application/vnd.airzip.filesecure.azs, application/vnd.amazon.ebook, application/vnd.americandynamics.acc, application/vnd.amiga.ami, application/vnd.android.package-archive, application/vnd.anser-web-certificate-issue-initiation, application/vnd.anser-web-funds-transfer-initiation, application/vnd.antix.game-component, application/vnd.apple.installer+xml, application/vnd.apple.keynote, application/vnd.apple.mpegurl, application/vnd.apple.numbers, application/vnd.apple.pages, application/vnd.apple.pkpass, application/vnd.aristanetworks.swi, application/vnd.astraea-software.iota, application/vnd.audiograph, application/vnd.blueice.multipass, application/vnd.bmi, application/vnd.businessobjects, application/vnd.chemdraw+xml, application/vnd.chipnuts.karaoke-mmd, application/vnd.cinderella, application/vnd.citationstyles.style+xml, application/vnd.claymore, application/vnd.cloanto.rp9, application/vnd.clonk.c4group, application/vnd.cluetrust.cartomobile-config, application/vnd.cluetrust.cartomobile-config-pkg, application/vnd.commonspace, application/vnd.contact.cmsg, application/vnd.cosmocaller, application/vnd.crick.clicker, application/vnd.crick.clicker.keyboard, application/vnd.crick.clicker.palette, application/vnd.crick.clicker.template, application/vnd.crick.clicker.wordbank, application/vnd.criticaltools.wbs+xml, application/vnd.ctc-posml, application/vnd.cups-ppd, application/vnd.curl.car, application/vnd.curl.pcurl, application/vnd.dart, application/vnd.data-vision.rdz, application/vnd.dece.data, application/vnd.dece.ttml+xml, application/vnd.dece.unspecified, application/vnd.dece.zip, application/vnd.denovo.fcselayout-link, application/vnd.dna, application/vnd.dolby.mlp, application/vnd.dpgraph, application/vnd.dreamfactory, application/vnd.ds-keypoint, application/vnd.dvb.ait, application/vnd.dvb.service, application/vnd.dynageo, application/vnd.ecowin.chart, application/vnd.enliven, application/vnd.epson.esf, application/vnd.epson.msf, application/vnd.epson.quickanime, application/vnd.epson.salt, application/vnd.epson.ssf, application/vnd.eszigno3+xml, application/vnd.ezpix-album, application/vnd.ezpix-package, application/vnd.fdf, application/vnd.fdsn.mseed, application/vnd.fdsn.seed, application/vnd.flographit, application/vnd.fluxtime.clip, application/vnd.framemaker, application/vnd.frogans.fnc, application/vnd.frogans.ltf, application/vnd.fsc.weblaunch, application/vnd.fujitsu.oasys, application/vnd.fujitsu.oasys2, application/vnd.fujitsu.oasys3, application/vnd.fujitsu.oasysgp, application/vnd.fujitsu.oasysprs, application/vnd.fujixerox.ddd, application/vnd.fujixerox.docuworks, application/vnd.fujixerox.docuworks.binder, application/vnd.fuzzysheet, application/vnd.genomatix.tuxedo, application/vnd.geogebra.file, application/vnd.geogebra.tool, application/vnd.geometry-explorer, application/vnd.geonext, application/vnd.geoplan, application/vnd.geospace, application/vnd.gmx, application/vnd.google-apps.document, application/vnd.google-apps.presentation, application/vnd.google-apps.spreadsheet, application/vnd.google-earth.kml+xml, application/vnd.google-earth.kmz, application/vnd.grafeq, application/vnd.groove-account, application/vnd.groove-help, application/vnd.groove-identity-message, application/vnd.groove-injector, application/vnd.groove-tool-message, application/vnd.groove-tool-template, application/vnd.groove-vcard, application/vnd.hal+xml, application/vnd.handheld-entertainment+xml, application/vnd.hbci, application/vnd.hhe.lesson-player, application/vnd.hp-hpgl, application/vnd.hp-hpid, application/vnd.hp-hps, application/vnd.hp-jlyt, application/vnd.hp-pcl, application/vnd.hp-pclxl, application/vnd.hydrostatix.sof-data, application/vnd.ibm.minipay, application/vnd.ibm.modcap, application/vnd.ibm.rights-management, application/vnd.ibm.secure-container, application/vnd.iccprofile, application/vnd.igloader, application/vnd.immervision-ivp, application/vnd.immervision-ivu, application/vnd.insors.igm, application/vnd.intercon.formnet, application/vnd.intergeo, application/vnd.intu.qbo, application/vnd.intu.qfx, application/vnd.ipunplugged.rcprofile, application/vnd.irepository.package+xml, application/vnd.is-xpr, application/vnd.isac.fcs, application/vnd.jam, application/vnd.jcp.javame.midlet-rms, application/vnd.jisp, application/vnd.joost.joda-archive, application/vnd.kahootz, application/vnd.kde.karbon, application/vnd.kde.kchart, application/vnd.kde.kformula, application/vnd.kde.kivio, application/vnd.kde.kontour, application/vnd.kde.kpresenter, application/vnd.kde.kspread, application/vnd.kde.kword, application/vnd.kenameaapp, application/vnd.kidspiration, application/vnd.kinar, application/vnd.koan, application/vnd.kodak-descriptor, application/vnd.las.las+xml, application/vnd.llamagraphics.life-balance.desktop, application/vnd.llamagraphics.life-balance.exchange+xml, application/vnd.lotus-1-2-3, application/vnd.lotus-approach, application/vnd.lotus-freelance, application/vnd.lotus-notes, application/vnd.lotus-organizer, application/vnd.lotus-screencam, application/vnd.lotus-wordpro, application/vnd.macports.portpkg, application/vnd.mcd, application/vnd.medcalcdata, application/vnd.mediastation.cdkey, application/vnd.mfer, application/vnd.mfmp, application/vnd.micrografx.flo, application/vnd.micrografx.igx, application/vnd.mif, application/vnd.mobius.daf, application/vnd.mobius.dis, application/vnd.mobius.mbk, application/vnd.mobius.mqy, application/vnd.mobius.msl, application/vnd.mobius.plc, application/vnd.mobius.txf, application/vnd.mophun.application, application/vnd.mophun.certificate, application/vnd.mozilla.xul+xml, application/vnd.ms-artgalry, application/vnd.ms-cab-compressed, application/vnd.ms-excel, application/vnd.ms-excel.addin.macroenabled.12, application/vnd.ms-excel.sheet.binary.macroenabled.12, application/vnd.ms-excel.sheet.macroenabled.12, application/vnd.ms-excel.template.macroenabled.12, application/vnd.ms-fontobject, application/vnd.ms-htmlhelp, application/vnd.ms-ims, application/vnd.ms-lrm, application/vnd.ms-officetheme, application/vnd.ms-outlook, application/vnd.ms-pki.seccat, application/vnd.ms-pki.stl, application/vnd.ms-powerpoint, application/vnd.ms-powerpoint.addin.macroenabled.12, application/vnd.ms-powerpoint.presentation.macroenabled.12, application/vnd.ms-powerpoint.slide.macroenabled.12, application/vnd.ms-powerpoint.slideshow.macroenabled.12, application/vnd.ms-powerpoint.template.macroenabled.12, application/vnd.ms-project, application/vnd.ms-word.document.macroenabled.12, application/vnd.ms-word.template.macroenabled.12, application/vnd.ms-works, application/vnd.ms-wpl, application/vnd.ms-xpsdocument, application/vnd.mseq, application/vnd.musician, application/vnd.muvee.style, application/vnd.mynfc, application/vnd.neurolanguage.nlu, application/vnd.nitf, application/vnd.noblenet-directory, application/vnd.noblenet-sealer, application/vnd.noblenet-web, application/vnd.nokia.n-gage.data, application/vnd.nokia.n-gage.symbian.install, application/vnd.nokia.radio-preset, application/vnd.nokia.radio-presets, application/vnd.novadigm.edm, application/vnd.novadigm.edx, application/vnd.novadigm.ext, application/vnd.oasis.opendocument.chart, application/vnd.oasis.opendocument.chart-template, application/vnd.oasis.opendocument.database, application/vnd.oasis.opendocument.formula, application/vnd.oasis.opendocument.formula-template, application/vnd.oasis.opendocument.graphics, application/vnd.oasis.opendocument.graphics-template, application/vnd.oasis.opendocument.image, application/vnd.oasis.opendocument.image-template, application/vnd.oasis.opendocument.presentation, application/vnd.oasis.opendocument.presentation-template, application/vnd.oasis.opendocument.spreadsheet, application/vnd.oasis.opendocument.spreadsheet-template, application/vnd.oasis.opendocument.text, application/vnd.oasis.opendocument.text-master, application/vnd.oasis.opendocument.text-template, application/vnd.oasis.opendocument.text-web, application/vnd.olpc-sugar, application/vnd.oma.dd2+xml, application/vnd.openofficeorg.extension, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.presentationml.slide, application/vnd.openxmlformats-officedocument.presentationml.slideshow, application/vnd.openxmlformats-officedocument.presentationml.template, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.spreadsheetml.template, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.openxmlformats-officedocument.wordprocessingml.template, application/vnd.osgeo.mapguide.package, application/vnd.osgi.dp, application/vnd.osgi.subsystem, application/vnd.palm, application/vnd.pawaafile, application/vnd.pg.format, application/vnd.pg.osasli, application/vnd.picsel, application/vnd.pmi.widget, application/vnd.pocketlearn, application/vnd.powerbuilder6, application/vnd.previewsystems.box, application/vnd.proteus.magazine, application/vnd.publishare-delta-tree, application/vnd.pvi.ptid1, application/vnd.quark.quarkxpress, application/vnd.realvnc.bed, application/vnd.recordare.musicxml, application/vnd.recordare.musicxml+xml, application/vnd.rig.cryptonote, application/vnd.rim.cod, application/vnd.rn-realmedia, application/vnd.rn-realmedia-vbr, application/vnd.route66.link66+xml, application/vnd.sailingtracker.track, application/vnd.seemail, application/vnd.sema, application/vnd.semd, application/vnd.semf, application/vnd.shana.informed.formdata, application/vnd.shana.informed.formtemplate, application/vnd.shana.informed.interchange, application/vnd.shana.informed.package, application/vnd.simtech-mindmapper, application/vnd.smaf, application/vnd.smart.teacher, application/vnd.solent.sdkm+xml, application/vnd.spotfire.dxp, application/vnd.spotfire.sfs, application/vnd.stardivision.calc, application/vnd.stardivision.draw, application/vnd.stardivision.impress, application/vnd.stardivision.math, application/vnd.stardivision.writer, application/vnd.stardivision.writer-global, application/vnd.stepmania.package, application/vnd.stepmania.stepchart, application/vnd.sun.wadl+xml, application/vnd.sun.xml.calc, application/vnd.sun.xml.calc.template, application/vnd.sun.xml.draw, application/vnd.sun.xml.draw.template, application/vnd.sun.xml.impress, application/vnd.sun.xml.impress.template, application/vnd.sun.xml.math, application/vnd.sun.xml.writer, application/vnd.sun.xml.writer.global, application/vnd.sun.xml.writer.template, application/vnd.sus-calendar, application/vnd.svd, application/vnd.symbian.install, application/vnd.syncml+xml, application/vnd.syncml.dm+wbxml, application/vnd.syncml.dm+xml, application/vnd.tao.intent-module-archive, application/vnd.tcpdump.pcap, application/vnd.tmobile-livetv, application/vnd.trid.tpt, application/vnd.triscape.mxs, application/vnd.trueapp, application/vnd.ufdl, application/vnd.uiq.theme, application/vnd.umajin, application/vnd.unity, application/vnd.uoml+xml, application/vnd.vcx, application/vnd.visio, application/vnd.visionary, application/vnd.vsf, application/vnd.wap.wbxml, application/vnd.wap.wmlc, application/vnd.wap.wmlscriptc, application/vnd.webturbo, application/vnd.wolfram.player, application/vnd.wordperfect, application/vnd.wqd, application/vnd.wt.stf, application/vnd.xara, application/vnd.xfdl, application/vnd.yamaha.hv-dic, application/vnd.yamaha.hv-script, application/vnd.yamaha.hv-voice, application/vnd.yamaha.openscoreformat, application/vnd.yamaha.openscoreformat.osfpvg+xml, application/vnd.yamaha.smaf-audio, application/vnd.yamaha.smaf-phrase, application/vnd.yellowriver-custom-menu, application/vnd.zul, application/vnd.zzazz.deck+xml, application/x-7z-compressed, application/x-abiword, application/x-ace-compressed, application/x-apple-diskimage, application/x-arj, application/x-authorware-bin, application/x-authorware-map, application/x-authorware-seg, application/x-bcpio, application/x-bdoc, application/x-bittorrent, application/x-blorb, application/x-bzip, application/x-bzip2, application/x-cbr, application/x-cdlink, application/x-cfs-compressed, application/x-chat, application/x-chess-pgn, application/x-chrome-extension, application/x-cocoa, application/x-conference, application/x-cpio, application/x-csh, application/x-debian-package, application/x-dgc-compressed, application/x-director, application/x-doom, application/x-dtbncx+xml, application/x-dtbook+xml, application/x-dtbresource+xml, application/x-dvi, application/x-envoy, application/x-eva, application/x-font-bdf, application/x-font-ghostscript, application/x-font-linux-psf, application/x-font-pcf, application/x-font-snf, application/x-font-type1, application/x-freearc, application/x-futuresplash, application/x-gca-compressed, application/x-glulx, application/x-gnumeric, application/x-gramps-xml, application/x-gtar, application/x-hdf, application/x-httpd-php, application/x-install-instructions, application/x-iso9660-image, application/x-java-archive-diff, application/x-java-jnlp-file, application/x-latex, application/x-lua-bytecode, application/x-lzh-compressed, application/x-makeself, application/x-mie, application/x-mobipocket-ebook, application/x-ms-application, application/x-ms-shortcut, application/x-ms-wmd, application/x-ms-wmz, application/x-ms-xbap, application/x-msaccess, application/x-msbinder, application/x-mscardfile, application/x-msclip, application/x-msdos-program, application/x-msdownload, application/x-msmediaview, application/x-msmetafile, application/x-msmoney, application/x-mspublisher, application/x-msschedule, application/x-msterminal, application/x-mswrite, application/x-netcdf, application/x-ns-proxy-autoconfig, application/x-nzb, application/x-perl, application/x-pilot, application/x-pkcs12, application/x-pkcs7-certificates, application/x-pkcs7-certreqresp, application/x-rar-compressed, application/x-redhat-package-manager, application/x-research-info-systems, application/x-sea, application/x-sh, application/x-shar, application/x-shockwave-flash, application/x-silverlight-app, application/x-sql, application/x-stuffit, application/x-stuffitx, application/x-subrip, application/x-sv4cpio, application/x-sv4crc, application/x-t3vm-image, application/x-tads, application/x-tar, application/x-tcl, application/x-tex, application/x-tex-tfm, application/x-texinfo, application/x-tgif, application/x-ustar, application/x-virtualbox-hdd, application/x-virtualbox-ova, application/x-virtualbox-ovf, application/x-virtualbox-vbox, application/x-virtualbox-vbox-extpack, application/x-virtualbox-vdi, application/x-virtualbox-vhd, application/x-virtualbox-vmdk, application/x-wais-source, application/x-web-app-manifest+json, application/x-x509-ca-cert, application/x-xfig, application/x-xliff+xml, application/x-xpinstall, application/x-xz, application/x-zmachine, audio/vnd.dece.audio, audio/vnd.digital-winds, audio/vnd.dra, audio/vnd.dts, audio/vnd.dts.hd, audio/vnd.lucent.voice, audio/vnd.ms-playready.media.pya, audio/vnd.nuera.ecelp4800, audio/vnd.nuera.ecelp7470, audio/vnd.nuera.ecelp9600, audio/vnd.rip, audio/x-aac, audio/x-aiff, audio/x-caf, audio/x-flac, audio/x-m4a, audio/x-matroska, audio/x-mpegurl, audio/x-ms-wax, audio/x-ms-wma, audio/x-pn-realaudio, audio/x-pn-realaudio-plugin, audio/x-realaudio, audio/x-wav, chemical/x-cdx, chemical/x-cif, chemical/x-cmdf, chemical/x-cml, chemical/x-csml, chemical/x-xyz, image/prs.btif, image/prs.pti, image/vnd.adobe.photoshop, image/vnd.airzip.accelerator.azv, image/vnd.dece.graphic, image/vnd.djvu, image/vnd.dvb.subtitle, image/vnd.dwg, image/vnd.dxf, image/vnd.fastbidsheet, image/vnd.fpx, image/vnd.fst, image/vnd.fujixerox.edmics-mmr, image/vnd.fujixerox.edmics-rlc, image/vnd.microsoft.icon, image/vnd.ms-modi, image/vnd.ms-photo, image/vnd.net-fpx, image/vnd.tencent.tap, image/vnd.valve.source.texture, image/vnd.wap.wbmp, image/vnd.xiff, image/vnd.zbrush.pcx, image/x-3ds, image/x-cmu-raster, image/x-cmx, image/x-freehand, image/x-icon, image/x-jng, image/x-mrsid-image, image/x-ms-bmp, image/x-pcx, image/x-pict, image/x-portable-anymap, image/x-portable-bitmap, image/x-portable-graymap, image/x-portable-pixmap, image/x-rgb, image/x-tga, image/x-xbitmap, image/x-xpixmap, image/x-xwindowdump, message/vnd.wfa.wsc, model/vnd.collada+xml, model/vnd.dwf, model/vnd.gdl, model/vnd.gtw, model/vnd.mts, model/vnd.vtu, text/prs.lines.tag, text/vnd.curl, text/vnd.curl.dcurl, text/vnd.curl.mcurl, text/vnd.curl.scurl, text/vnd.dvb.subtitle, text/vnd.fly, text/vnd.fmi.flexstor, text/vnd.graphviz, text/vnd.in3d.3dml, text/vnd.in3d.spot, text/vnd.sun.j2me.app-descriptor, text/vnd.wap.wml, text/vnd.wap.wmlscript, text/x-asm, text/x-c, text/x-component, text/x-fortran, text/x-handlebars-template, text/x-java-source, text/x-lua, text/x-markdown, text/x-nfo, text/x-opml, text/x-org, text/x-pascal, text/x-processing, text/x-sass, text/x-scss, text/x-setext, text/x-sfv, text/x-suse-ymp, text/x-uuencode, text/x-vcalendar, text/x-vcard, video/vnd.dece.hd, video/vnd.dece.mobile, video/vnd.dece.pd, video/vnd.dece.sd, video/vnd.dece.video, video/vnd.dvb.file, video/vnd.fvt, video/vnd.mpegurl, video/vnd.ms-playready.media.pyv, video/vnd.uvvu.mp4, video/vnd.vivo, video/x-f4v, video/x-fli, video/x-flv, video/x-m4v, video/x-matroska, video/x-mng, video/x-ms-asf, video/x-ms-vob, video/x-ms-wm, video/x-ms-wmv, video/x-ms-wmx, video/x-ms-wvx, video/x-msvideo, video/x-sgi-movie, video/x-smv, x-conference/x-cooltalk, default */
/***/ (function(module) {

module.exports = {"application/prs.cww":["cww"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.keynote":["keynote"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.numbers":["numbers"],"application/vnd.apple.pages":["pages"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.citationstyles.style+xml":["csl"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["*wmf","*wmz","*emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/prs.pti":["pti"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.airzip.accelerator.azv":["azv"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.microsoft.icon":["ico"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.tencent.tap":["tap"],"image/vnd.valve.source.texture":["vtf"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/vnd.zbrush.pcx":["pcx"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["*ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["*pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]};

/***/ }),

/***/ "./node_modules/webpack-dev-middleware/node_modules/mime/types/standard.json":
/*!**********************************************************************!*\
  !*** (webpack)-dev-middleware/node_modules/mime/types/standard.json ***!
  \**********************************************************************/
/*! exports provided: application/andrew-inset, application/applixware, application/atom+xml, application/atomcat+xml, application/atomsvc+xml, application/bdoc, application/ccxml+xml, application/cdmi-capability, application/cdmi-container, application/cdmi-domain, application/cdmi-object, application/cdmi-queue, application/cu-seeme, application/dash+xml, application/davmount+xml, application/docbook+xml, application/dssc+der, application/dssc+xml, application/ecmascript, application/emma+xml, application/epub+zip, application/exi, application/font-tdpfr, application/geo+json, application/gml+xml, application/gpx+xml, application/gxf, application/gzip, application/hjson, application/hyperstudio, application/inkml+xml, application/ipfix, application/java-archive, application/java-serialized-object, application/java-vm, application/javascript, application/json, application/json5, application/jsonml+json, application/ld+json, application/lost+xml, application/mac-binhex40, application/mac-compactpro, application/mads+xml, application/manifest+json, application/marc, application/marcxml+xml, application/mathematica, application/mathml+xml, application/mbox, application/mediaservercontrol+xml, application/metalink+xml, application/metalink4+xml, application/mets+xml, application/mods+xml, application/mp21, application/mp4, application/msword, application/mxf, application/octet-stream, application/oda, application/oebps-package+xml, application/ogg, application/omdoc+xml, application/onenote, application/oxps, application/patch-ops-error+xml, application/pdf, application/pgp-encrypted, application/pgp-signature, application/pics-rules, application/pkcs10, application/pkcs7-mime, application/pkcs7-signature, application/pkcs8, application/pkix-attr-cert, application/pkix-cert, application/pkix-crl, application/pkix-pkipath, application/pkixcmp, application/pls+xml, application/postscript, application/pskc+xml, application/raml+yaml, application/rdf+xml, application/reginfo+xml, application/relax-ng-compact-syntax, application/resource-lists+xml, application/resource-lists-diff+xml, application/rls-services+xml, application/rpki-ghostbusters, application/rpki-manifest, application/rpki-roa, application/rsd+xml, application/rss+xml, application/rtf, application/sbml+xml, application/scvp-cv-request, application/scvp-cv-response, application/scvp-vp-request, application/scvp-vp-response, application/sdp, application/set-payment-initiation, application/set-registration-initiation, application/shf+xml, application/smil+xml, application/sparql-query, application/sparql-results+xml, application/srgs, application/srgs+xml, application/sru+xml, application/ssdl+xml, application/ssml+xml, application/tei+xml, application/thraud+xml, application/timestamped-data, application/voicexml+xml, application/wasm, application/widget, application/winhlp, application/wsdl+xml, application/wspolicy+xml, application/xaml+xml, application/xcap-diff+xml, application/xenc+xml, application/xhtml+xml, application/xml, application/xml-dtd, application/xop+xml, application/xproc+xml, application/xslt+xml, application/xspf+xml, application/xv+xml, application/yang, application/yin+xml, application/zip, audio/3gpp, audio/adpcm, audio/basic, audio/midi, audio/mp3, audio/mp4, audio/mpeg, audio/ogg, audio/s3m, audio/silk, audio/wav, audio/wave, audio/webm, audio/xm, font/collection, font/otf, font/ttf, font/woff, font/woff2, image/aces, image/apng, image/bmp, image/cgm, image/dicom-rle, image/emf, image/fits, image/g3fax, image/gif, image/heic, image/heic-sequence, image/heif, image/heif-sequence, image/ief, image/jls, image/jp2, image/jpeg, image/jpm, image/jpx, image/ktx, image/png, image/sgi, image/svg+xml, image/t38, image/tiff, image/tiff-fx, image/webp, image/wmf, message/disposition-notification, message/global, message/global-delivery-status, message/global-disposition-notification, message/global-headers, message/rfc822, model/gltf+json, model/gltf-binary, model/iges, model/mesh, model/vrml, model/x3d+binary, model/x3d+vrml, model/x3d+xml, text/cache-manifest, text/calendar, text/coffeescript, text/css, text/csv, text/html, text/jade, text/jsx, text/less, text/markdown, text/mathml, text/n3, text/plain, text/richtext, text/rtf, text/sgml, text/shex, text/slim, text/stylus, text/tab-separated-values, text/troff, text/turtle, text/uri-list, text/vcard, text/vtt, text/xml, text/yaml, video/3gpp, video/3gpp2, video/h261, video/h263, video/h264, video/jpeg, video/jpm, video/mj2, video/mp2t, video/mp4, video/mpeg, video/ogg, video/quicktime, video/webm, default */
/***/ (function(module) {

module.exports = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomsvc+xml":["atomsvc"],"application/bdoc":["bdoc"],"application/ccxml+xml":["ccxml"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma","es"],"application/emma+xml":["emma"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-diff+xml":["xdf"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/ktx":["ktx"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["x3db","x3dbz"],"model/x3d+vrml":["x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

/***/ }),

/***/ "./node_modules/webpack-hot-middleware/helpers.js":
/*!*******************************************!*\
  !*** (webpack)-hot-middleware/helpers.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(/*! url */ "url").parse;

exports.pathMatch = function(url, path) {
  try {
    return parse(url).pathname === path;
  } catch (e) {
    return false;
  }
}


/***/ }),

/***/ "./node_modules/webpack-hot-middleware/middleware.js":
/*!**********************************************!*\
  !*** (webpack)-hot-middleware/middleware.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = webpackHotMiddleware;

var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/webpack-hot-middleware/helpers.js");
var pathMatch = helpers.pathMatch;

function webpackHotMiddleware(compiler, opts) {
  opts = opts || {};
  opts.log = typeof opts.log == 'undefined' ? console.log.bind(console) : opts.log;
  opts.path = opts.path || '/__webpack_hmr';
  opts.heartbeat = opts.heartbeat || 10 * 1000;

  var eventStream = createEventStream(opts.heartbeat);
  var latestStats = null;
  var closed = false;

  if (compiler.hooks) {
    compiler.hooks.invalid.tap("webpack-hot-middleware", onInvalid);
    compiler.hooks.done.tap("webpack-hot-middleware", onDone);
  } else {
    compiler.plugin("invalid", onInvalid);
    compiler.plugin("done", onDone);
  }
  function onInvalid() {
    if (closed) return;
    latestStats = null;
    if (opts.log) opts.log("webpack building...");
    eventStream.publish({action: "building"});
  }
  function onDone(statsResult) {
    if (closed) return;
    // Keep hold of latest stats so they can be propagated to new clients
    latestStats = statsResult;
    publishStats("built", latestStats, eventStream, opts.log);
  }
  var middleware = function(req, res, next) {
    if (closed) return next();
    if (!pathMatch(req.url, opts.path)) return next();
    eventStream.handler(req, res);
    if (latestStats) {
      // Explicitly not passing in `log` fn as we don't want to log again on
      // the server
      publishStats("sync", latestStats, eventStream);
    }
  };
  middleware.publish = function(payload) {
    if (closed) return;
    eventStream.publish(payload);
  };
  middleware.close = function() {
    if (closed) return;
    // Can't remove compiler plugins, so we just set a flag and noop if closed
    // https://github.com/webpack/tapable/issues/32#issuecomment-350644466
    closed = true;
    eventStream.close();
    eventStream = null;
  };
  return middleware;
}

function createEventStream(heartbeat) {
  var clientId = 0;
  var clients = {};
  function everyClient(fn) {
    Object.keys(clients).forEach(function(id) {
      fn(clients[id]);
    });
  }
  var interval = setInterval(function heartbeatTick() {
    everyClient(function(client) {
      client.write("data: \uD83D\uDC93\n\n");
    });
  }, heartbeat).unref();
  return {
    close: function() {
      clearInterval(interval);
      everyClient(function(client) {
        if (!client.finished) client.end();
      });
      clients = {};
    },
    handler: function(req, res) {
      var headers = {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'text/event-stream;charset=utf-8',
        'Cache-Control': 'no-cache, no-transform',
        // While behind nginx, event stream should not be buffered:
        // http://nginx.org/docs/http/ngx_http_proxy_module.html#proxy_buffering
        'X-Accel-Buffering': 'no'
      };

      var isHttp1 = !(parseInt(req.httpVersion) >= 2);
      if (isHttp1) {
        req.socket.setKeepAlive(true);
        Object.assign(headers, {
          'Connection': 'keep-alive',
        });
      }

      res.writeHead(200, headers);
      res.write('\n');
      var id = clientId++;
      clients[id] = res;
      req.on("close", function(){
        if (!res.finished) res.end();
        delete clients[id];
      });
    },
    publish: function(payload) {
      everyClient(function(client) {
        client.write("data: " + JSON.stringify(payload) + "\n\n");
      });
    }
  };
}

function publishStats(action, statsResult, eventStream, log) {
  var stats = statsResult.toJson({
    all: false,
    cached: true,
    children: true,
    modules: true,
    timings: true,
    hash: true
  });
  // For multi-compiler, stats will be an object with a 'children' array of stats
  var bundles = extractBundles(stats);
  bundles.forEach(function(stats) {
    var name = stats.name || "";

    // Fallback to compilation name in case of 1 bundle (if it exists)
    if (bundles.length === 1 && !name && statsResult.compilation) {
      name = statsResult.compilation.name || "";
    }

    if (log) {
      log("webpack built " + (name ? name + " " : "") +
        stats.hash + " in " + stats.time + "ms");
    }
    eventStream.publish({
      name: name,
      action: action,
      time: stats.time,
      hash: stats.hash,
      warnings: stats.warnings || [],
      errors: stats.errors || [],
      modules: buildModuleMap(stats.modules)
    });
  });
}

function extractBundles(stats) {
  // Stats has modules, single bundle
  if (stats.modules) return [stats];

  // Stats has children, multiple bundles
  if (stats.children && stats.children.length) return stats.children;

  // Not sure, assume single
  return [stats];
}

function buildModuleMap(modules) {
  var map = {};
  modules.forEach(function(module) {
    map[module.id] = module.name;
  });
  return map;
}


/***/ }),

/***/ "./node_modules/webpack-log/src/index.js":
/*!**********************************!*\
  !*** (webpack)-log/src/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global window: true */
/* eslint-disable
  no-shadow,
  no-param-reassign,
  space-before-function-paren
*/
const uuid = __webpack_require__(/*! uuid/v4 */ "uuid/v4");
const colors = __webpack_require__(/*! ansi-colors */ "ansi-colors");
const loglevel = __webpack_require__(/*! ./loglevel */ "./node_modules/webpack-log/src/loglevel/index.js");

const symbols = {
  trace: colors.grey('₸'),
  debug: colors.cyan('➤'),
  info: colors.blue(colors.symbols.info),
  warn: colors.yellow(colors.symbols.warning),
  error: colors.red(colors.symbols.cross)
};

const defaults = {
  name: '<unknown>',
  level: 'info',
  unique: true
};

const prefix = {
  level (options) {
    return symbols[options.level];
  },
  template: `{{level}} ${colors.gray('｢{{name}}｣')}: `
};

function log (options) {
  const opts = Object.assign({}, defaults, options);
  const { id } = options;

  opts.prefix = Object.assign({}, prefix, options.prefix);
  delete opts.id;

  Object.defineProperty(opts, 'id', {
    get() {
      if (!id) {
        return this.name + (opts.unique ? `-${uuid()}` : '');
      }

      return id;
    }
  });

  if (opts.timestamp) {
    opts.prefix.template = `[{{time}}] ${opts.prefix.template}`;
  }

  const log = loglevel.getLogger(opts);

  if (!Object.prototype.hasOwnProperty.call(log, 'id')) {
    Object.defineProperty(log, 'id', {
      get() {
        return opts.id;
      }
    });
  }

  return log;
}

module.exports = log;
// NOTE: this is exported so that consumers of webpack-log can use the same
// version of ansi-colors to decorate log messages without incurring additional
// dependency overhead
module.exports.colors = colors;
// NOTE: This is an undocumented function solely for the purpose of tests.
// Do not use this method in production code. Using in production code
// may result in strange behavior.
module.exports.delLogger = function delLogger(name) {
  delete loglevel.loggers[name];
};

module.exports.factories = loglevel.factories;


/***/ }),

/***/ "./node_modules/webpack-log/src/loglevel/LogLevel.js":
/*!**********************************************!*\
  !*** (webpack)-log/src/loglevel/LogLevel.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global window: true */
/* eslint-disable
  multiline-ternary,
  no-param-reassign
*/
const PrefixFactory = __webpack_require__(/*! ./PrefixFactory */ "./node_modules/webpack-log/src/loglevel/PrefixFactory.js");
const MethodFactory = __webpack_require__(/*! ./MethodFactory */ "./node_modules/webpack-log/src/loglevel/MethodFactory.js");

const defaults = {
  name: +new Date(),
  level: 'warn',
  prefix: null,
  factory: null
};

class LogLevel {
  constructor(options) {
    // implement for some _very_ loose type checking. avoids getting into a
    // circular require between MethodFactory and LogLevel
    this.type = 'LogLevel';
    this.options = Object.assign({}, defaults, options);
    this.methodFactory = options.factory;

    if (!this.methodFactory) {
      const factory = options.prefix
        ? new PrefixFactory(this, options.prefix)
        : new MethodFactory(this);

      this.methodFactory = factory;
    }

    if (!this.methodFactory.logger) {
      this.methodFactory.logger = this;
    }

    this.name = options.name || '<unknown>';
    // this.level is a setter, do this after setting up the factory
    this.level = this.options.level;
  }

  get factory() {
    return this.methodFactory;
  }

  set factory(factory) {
    factory.logger = this;

    this.methodFactory = factory;
    this.methodFactory.replaceMethods(this.level);
  }

  enable() {
    this.level = this.levels.TRACE;
  }

  disable() {
    this.level = this.levels.SILENT;
  }

  get level() {
    return this.currentLevel;
  }

  set level(logLevel) {
    const level = this.methodFactory.distillLevel(logLevel);

    if (level == null) {
      throw new Error(
        `loglevel: setLevel() called with invalid level: ${logLevel}`
      );
    }

    this.currentLevel = level;
    this.methodFactory.replaceMethods(level);

    if (typeof console === 'undefined' && level < this.levels.SILENT) {
      // eslint-disable-next-line no-console
      console.warn(
        'loglevel: console is undefined. The log will produce no output'
      );
    }
  }

  get levels() { // eslint-disable-line class-methods-use-this
    return this.methodFactory.levels;
  }
}

module.exports = LogLevel;


/***/ }),

/***/ "./node_modules/webpack-log/src/loglevel/MethodFactory.js":
/*!***************************************************!*\
  !*** (webpack)-log/src/loglevel/MethodFactory.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable
  arrow-parens,
  multiline-ternary,
  consistent-return,
  no-param-reassign,
  prefer-destructuring
*/
const noop = () => {};

const levels = Symbol('levels');
const instance = Symbol('instance');

class MethodFactory {
  constructor(logger) {
    this[levels] = {
      TRACE: 0,
      DEBUG: 1,
      INFO: 2,
      WARN: 3,
      ERROR: 4,
      SILENT: 5
    };

    this[instance] = logger;
  }

  set logger(logger) {
    this[instance] = logger;
  }

  get logger() {
    return this[instance];
  }

  get levels() {
    return this[levels];
  }

  get methods() {
    return Object.keys(this.levels)
      .map((key) => key.toLowerCase())
      .filter((key) => key !== 'silent');
  }

  distillLevel(level) {
    let result = level;

    if (
      typeof result === 'string' &&
      typeof this.levels[result.toUpperCase()] !== 'undefined'
    ) {
      result = this.levels[result.toUpperCase()];
    }

    if (this.levelValid(result)) {
      return result;
    }
  }

  levelValid(level) {
    if (
      typeof level === 'number' && level >= 0 &&
      level <= this.levels.SILENT
    ) {
      return true;
    }

    return false;
  }
  /**
   * Build the best logging method possible for this env
   * Wherever possible we want to bind, not wrap, to preserve stack traces.
   * Since we're targeting modern browsers, there's no need to wait for the
   * console to become available.
   */
  // eslint-disable-next-line class-methods-use-this
  make(method) {
    if (method === 'debug') {
      method = 'log';
    }

    /* eslint-disable no-console */
    if (typeof console[method] !== 'undefined') {
      return this.bindMethod(console, method);
    } else if (typeof console.log !== 'undefined') {
      return this.bindMethod(console, 'log');
    }

    /* eslint-enable no-console */
    return noop;
  }

  // eslint-disable-next-line class-methods-use-this
  bindMethod(obj, name) {
    const method = obj[name];

    if (typeof method.bind === 'function') {
      return method.bind(obj);
    }

    try {
      return Function.prototype.bind.call(method, obj);
    } catch (err) {
      // Missing bind shim or IE8 + Modernizr, fallback to wrapping
      return function result() {
        // eslint-disable-next-line prefer-rest-params
        return Function.prototype.apply.apply(method, [obj, arguments]);
      };
    }
  }

  replaceMethods(logLevel) {
    const level = this.distillLevel(logLevel);

    if (level == null) {
      throw new Error(
        `loglevel: replaceMethods() called with invalid level: ${logLevel}`
      );
    }

    if (!this.logger || this.logger.type !== 'LogLevel') {
      throw new TypeError(
        'loglevel: Logger is undefined or invalid. Please specify a valid Logger instance.'
      );
    }

    this.methods.forEach((method) => {
      this.logger[method] = (this.levels[method.toUpperCase()] < level)
        ? noop
        : this.make(method);
    });

    // Define log.log as an alias for log.debug
    this.logger.log = this.logger.debug;
  }
}

module.exports = MethodFactory;


/***/ }),

/***/ "./node_modules/webpack-log/src/loglevel/PrefixFactory.js":
/*!***************************************************!*\
  !*** (webpack)-log/src/loglevel/PrefixFactory.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable
  no-param-reassign,
  space-before-function-paren
*/
const MethodFactory = __webpack_require__(/*! ./MethodFactory */ "./node_modules/webpack-log/src/loglevel/MethodFactory.js");

const defaults = {
  name (options) {
    return options.logger.name;
  },
  time () {
    return new Date().toTimeString().split(' ')[0];
  },
  level (options) {
    return `[${options.level}]`;
  },
  template: '{{time}} {{level}} '
};

class PrefixFactory extends MethodFactory {
  constructor(logger, options) {
    super(logger);

    this.options = Object.assign({}, defaults, options);
  }

  interpolate(level) {
    return this.options.template.replace(/{{([^{}]*)}}/g, (stache, prop) => {
      const fn = this.options[prop];

      if (fn) {
        return fn({ level, logger: this.logger });
      }

      return stache;
    });
  }

  make(method) {
    const og = super.make(method);

    return (...args) => {
      const [first] = args;

      const output = this.interpolate(method);

      if (typeof first === 'string') {
        args[0] = output + first;
      } else {
        args.unshift(output);
      }

      og(...args);
    };
  }
}

module.exports = PrefixFactory;


/***/ }),

/***/ "./node_modules/webpack-log/src/loglevel/index.js":
/*!*******************************************!*\
  !*** (webpack)-log/src/loglevel/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global window: true */
/* eslint-disable
  no-shadow,
  no-param-reassign,
  space-before-function-paren
*/
const LogLevel = __webpack_require__(/*! ./LogLevel */ "./node_modules/webpack-log/src/loglevel/LogLevel.js");
const MethodFactory = __webpack_require__(/*! ./MethodFactory */ "./node_modules/webpack-log/src/loglevel/MethodFactory.js");
const PrefixFactory = __webpack_require__(/*! ./PrefixFactory */ "./node_modules/webpack-log/src/loglevel/PrefixFactory.js");

const defaultLogger = new LogLevel({ name: 'default' });
const cache = { default: defaultLogger };

// Grab the current global log variable in case of overwrite
const existing = (typeof window !== 'undefined') ? window.log : null;

const loglevel = Object.assign(defaultLogger, {
  get factories() {
    return {
      MethodFactory,
      PrefixFactory
    };
  },
  get loggers() {
    return cache;
  },
  getLogger(options) {
    if (typeof options === 'string') {
      options = { name: options };
    }

    if (!options.id) {
      options.id = options.name;
    }

    const { name, id } = options;
    const defaults = { level: defaultLogger.level };

    if (typeof name !== 'string' || !name || !name.length) {
      throw new TypeError('You must supply a name when creating a logger');
    }

    let logger = cache[id];

    if (!logger) {
      logger = new LogLevel(Object.assign({}, defaults, options));

      cache[id] = logger;
    }

    return logger;
  },
  noConflict() {
    if (typeof window !== 'undefined' && window.log === defaultLogger) {
      window.log = existing;
    }

    return defaultLogger;
  }
});

module.exports = loglevel;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/CachedSource.js":
/*!*********************************************!*\
  !*** (webpack)-sources/lib/CachedSource.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");

class CachedSource extends Source {
	constructor(source) {
		super();
		this._source = source;
		this._cachedSource = undefined;
		this._cachedSize = undefined;
		this._cachedMaps = {};

		if(source.node) this.node = function(options) {
			return this._source.node(options);
		};

		if(source.listMap) this.listMap = function(options) {
			return this._source.listMap(options);
		};
	}

	source() {
		if(typeof this._cachedSource !== "undefined") return this._cachedSource;
		return this._cachedSource = this._source.source();
	}

	size() {
		if(typeof this._cachedSize !== "undefined") return this._cachedSize;
		if(typeof this._cachedSource !== "undefined")
			return this._cachedSize = this._cachedSource.length;
		return this._cachedSize = this._source.size();
	}

	sourceAndMap(options) {
		const key = JSON.stringify(options);
		if(typeof this._cachedSource !== "undefined" && key in this._cachedMaps)
			return {
				source: this._cachedSource,
				map: this._cachedMaps[key]
			};
		else if(typeof this._cachedSource !== "undefined") {
			return {
				source: this._cachedSource,
				map: this._cachedMaps[key] = this._source.map(options)
			};
		} else if(key in this._cachedMaps) {
			return {
				source: this._cachedSource = this._source.source(),
				map: this._cachedMaps[key]
			};
		}
		const result = this._source.sourceAndMap(options);
		this._cachedSource = result.source;
		this._cachedMaps[key] = result.map;
		return {
			source: this._cachedSource,
			map: this._cachedMaps[key]
		};
	}

	map(options) {
		if(!options) options = {};
		const key = JSON.stringify(options);
		if(key in this._cachedMaps)
			return this._cachedMaps[key];
		return this._cachedMaps[key] = this._source.map();
	}

	updateHash(hash) {
		this._source.updateHash(hash);
	}
}

module.exports = CachedSource;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/ConcatSource.js":
/*!*********************************************!*\
  !*** (webpack)-sources/lib/ConcatSource.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const SourceNode = __webpack_require__(/*! source-map */ "source-map").SourceNode;
const SourceListMap = __webpack_require__(/*! source-list-map */ "source-list-map").SourceListMap;
const Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");

class ConcatSource extends Source {
	constructor() {
		super();
		this.children = [];
		for(var i = 0; i < arguments.length; i++) {
			var item = arguments[i];
			if(item instanceof ConcatSource) {
				var children = item.children;
				for(var j = 0; j < children.length; j++)
					this.children.push(children[j]);
			} else {
				this.children.push(item);
			}
		}
	}

	add(item) {
		if(item instanceof ConcatSource) {
			var children = item.children;
			for(var j = 0; j < children.length; j++)
				this.children.push(children[j]);
		} else {
			this.children.push(item);
		}
	}

	source() {
		let source = "";
		const children = this.children;
		for(let i = 0; i < children.length; i++) {
			const child = children[i];
			source += typeof child === "string" ? child : child.source();
		}
		return source;
	}

	size() {
		let size = 0;
		const children = this.children;
		for(let i = 0; i < children.length; i++) {
			const child = children[i];
			size += typeof child === "string" ? child.length : child.size();
		}
		return size;
	}

	node(options) {
		const node = new SourceNode(null, null, null, this.children.map(function(item) {
			return typeof item === "string" ? item : item.node(options);
		}));
		return node;
	}

	listMap(options) {
		const map = new SourceListMap();
		var children = this.children;
		for(var i = 0; i < children.length; i++) {
			var item = children[i];
			if(typeof item === "string")
				map.add(item);
			else
				map.add(item.listMap(options));
		}
		return map;
	}

	updateHash(hash) {
		var children = this.children;
		for(var i = 0; i < children.length; i++) {
			var item = children[i];
			if(typeof item === "string")
				hash.update(item);
			else
				item.updateHash(hash);
		}
	}
}

__webpack_require__(/*! ./SourceAndMapMixin */ "./node_modules/webpack-sources/lib/SourceAndMapMixin.js")(ConcatSource.prototype);

module.exports = ConcatSource;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/LineToLineMappedSource.js":
/*!*******************************************************!*\
  !*** (webpack)-sources/lib/LineToLineMappedSource.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


var SourceNode = __webpack_require__(/*! source-map */ "source-map").SourceNode;
var SourceMapConsumer = __webpack_require__(/*! source-map */ "source-map").SourceMapConsumer;
var SourceListMap = __webpack_require__(/*! source-list-map */ "source-list-map").SourceListMap;
var Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");

class LineToLineMappedSource extends Source {
	constructor(value, name, originalSource) {
		super();
		this._value = value;
		this._name = name;
		this._originalSource = originalSource;
	}

	source() {
		return this._value;
	}

	node(options) {
		var value = this._value;
		var name = this._name;
		var lines = value.split("\n");
		var node = new SourceNode(null, null, null,
			lines.map(function(line, idx) {
				return new SourceNode(idx + 1, 0, name, (line + (idx != lines.length - 1 ? "\n" : "")));
			})
		);
		node.setSourceContent(name, this._originalSource);
		return node;
	}

	listMap(options) {
		return new SourceListMap(this._value, this._name, this._originalSource)
	}

	updateHash(hash) {
		hash.update(this._value);
		hash.update(this._originalSource);
	}
}

__webpack_require__(/*! ./SourceAndMapMixin */ "./node_modules/webpack-sources/lib/SourceAndMapMixin.js")(LineToLineMappedSource.prototype);

module.exports = LineToLineMappedSource;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/OriginalSource.js":
/*!***********************************************!*\
  !*** (webpack)-sources/lib/OriginalSource.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


var SourceNode = __webpack_require__(/*! source-map */ "source-map").SourceNode;
var SourceMapConsumer = __webpack_require__(/*! source-map */ "source-map").SourceMapConsumer;
var SourceListMap = __webpack_require__(/*! source-list-map */ "source-list-map").SourceListMap;
var Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");

var SPLIT_REGEX = /(?!$)[^\n\r;{}]*[\n\r;{}]*/g;

function _splitCode(code) {
	return code.match(SPLIT_REGEX) || [];
}

class OriginalSource extends Source {
	constructor(value, name) {
		super();
		this._value = value;
		this._name = name;
	}

	source() {
		return this._value;
	}

	node(options) {
		options = options || {};
		var sourceMap = this._sourceMap;
		var value = this._value;
		var name = this._name;
		var lines = value.split("\n");
		var node = new SourceNode(null, null, null,
			lines.map(function(line, idx) {
				var pos = 0;
				if(options.columns === false) {
					var content = line + (idx != lines.length - 1 ? "\n" : "");
					return new SourceNode(idx + 1, 0, name, content);
				}
				return new SourceNode(null, null, null,
					_splitCode(line + (idx != lines.length - 1 ? "\n" : "")).map(function(item) {
						if(/^\s*$/.test(item)) {
							pos += item.length;
							return item;
						}
						var res = new SourceNode(idx + 1, pos, name, item);
						pos += item.length;
						return res;
					})
				);
			})
		);
		node.setSourceContent(name, value);
		return node;
	}

	listMap(options) {
		return new SourceListMap(this._value, this._name, this._value)
	}

	updateHash(hash) {
		hash.update(this._value);
	}
}

__webpack_require__(/*! ./SourceAndMapMixin */ "./node_modules/webpack-sources/lib/SourceAndMapMixin.js")(OriginalSource.prototype);

module.exports = OriginalSource;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/PrefixSource.js":
/*!*********************************************!*\
  !*** (webpack)-sources/lib/PrefixSource.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


var Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");
var SourceNode = __webpack_require__(/*! source-map */ "source-map").SourceNode;

var REPLACE_REGEX = /\n(?=.|\s)/g;

function cloneAndPrefix(node, prefix, append) {
	if(typeof node === "string") {
		var result = node.replace(REPLACE_REGEX, "\n" + prefix);
		if(append.length > 0) result = append.pop() + result;
		if(/\n$/.test(node)) append.push(prefix);
		return result;
	} else {
		var newNode = new SourceNode(
			node.line,
			node.column,
			node.source,
			node.children.map(function(node) {
				return cloneAndPrefix(node, prefix, append);
			}),
			node.name
		);
		newNode.sourceContents = node.sourceContents;
		return newNode;
	}
};

class PrefixSource extends Source {
	constructor(prefix, source) {
		super();
		this._source = source;
		this._prefix = prefix;
	}

	source() {
		var node = typeof this._source === "string" ? this._source : this._source.source();
		var prefix = this._prefix;
		return prefix + node.replace(REPLACE_REGEX, "\n" + prefix);
	}

	node(options) {
		var node = this._source.node(options);
		var append = [this._prefix];
		return new SourceNode(null, null, null, [
			cloneAndPrefix(node, this._prefix, append)
		]);
	}

	listMap(options) {
		var prefix = this._prefix;
		var map = this._source.listMap(options);
		return map.mapGeneratedCode(function(code) {
			return prefix + code.replace(REPLACE_REGEX, "\n" + prefix);
		});
	}

	updateHash(hash) {
		if(typeof this._source === "string")
			hash.update(this._source);
		else
			this._source.updateHash(hash);
		if(typeof this._prefix === "string")
			hash.update(this._prefix);
		else
			this._prefix.updateHash(hash);
	}
}

__webpack_require__(/*! ./SourceAndMapMixin */ "./node_modules/webpack-sources/lib/SourceAndMapMixin.js")(PrefixSource.prototype);

module.exports = PrefixSource;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/RawSource.js":
/*!******************************************!*\
  !*** (webpack)-sources/lib/RawSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


var Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");
var SourceNode = __webpack_require__(/*! source-map */ "source-map").SourceNode;
var SourceListMap = __webpack_require__(/*! source-list-map */ "source-list-map").SourceListMap;

class RawSource extends Source {
	constructor(value) {
		super();
		this._value = value;
	}

	source() {
		return this._value;
	}

	map(options) {
		return null;
	}

	node(options) {
		return new SourceNode(null, null, null, this._value);
	}

	listMap(options) {
		return new SourceListMap(this._value);
	}

	updateHash(hash) {
		hash.update(this._value);
	}
}

module.exports = RawSource;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/ReplaceSource.js":
/*!**********************************************!*\
  !*** (webpack)-sources/lib/ReplaceSource.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


var Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");
var SourceNode = __webpack_require__(/*! source-map */ "source-map").SourceNode;
var SourceListMap = __webpack_require__(/*! source-list-map */ "source-list-map").SourceListMap;
var fromStringWithSourceMap = __webpack_require__(/*! source-list-map */ "source-list-map").fromStringWithSourceMap;
var SourceMapConsumer = __webpack_require__(/*! source-map */ "source-map").SourceMapConsumer;

class Replacement {
	constructor(start, end, content, insertIndex, name) {
		this.start = start;
		this.end = end;
		this.content = content;
		this.insertIndex = insertIndex;
		this.name = name;
	}
}

class ReplaceSource extends Source {
	constructor(source, name) {
		super();
		this._source = source;
		this._name = name;
		/** @type {Replacement[]} */
		this.replacements = [];
	}

	replace(start, end, newValue, name) {
		if(typeof newValue !== "string")
			throw new Error("insertion must be a string, but is a " + typeof newValue);
		this.replacements.push(new Replacement(start, end, newValue, this.replacements.length, name));
	}

	insert(pos, newValue, name) {
		if(typeof newValue !== "string")
			throw new Error("insertion must be a string, but is a " + typeof newValue + ": " + newValue);
		this.replacements.push(new Replacement(pos, pos - 1, newValue, this.replacements.length, name));
	}

	source(options) {
		return this._replaceString(this._source.source());
	}

	original() {
		return this._source;
	}

	_sortReplacements() {
		this.replacements.sort(function(a, b) {
			var diff = b.end - a.end;
			if(diff !== 0)
				return diff;
			diff = b.start - a.start;
			if(diff !== 0)
				return diff;
			return b.insertIndex - a.insertIndex;
		});
	}

	_replaceString(str) {
		if(typeof str !== "string")
			throw new Error("str must be a string, but is a " + typeof str + ": " + str);
		this._sortReplacements();
		var result = [str];
		this.replacements.forEach(function(repl) {
			var remSource = result.pop();
			var splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));
			var splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));
			result.push(splitted1[1], repl.content, splitted2[0]);
		}, this);

		// write out result array in reverse order
		let resultStr = "";
		for(let i = result.length - 1; i >= 0; --i) {
			resultStr += result[i];
		}
		return resultStr;
	}

	node(options) {
		var node = this._source.node(options);
		if(this.replacements.length === 0) {
			return node;
		}
		this._sortReplacements();
		var replace = new ReplacementEnumerator(this.replacements);
		var output = [];
		var position = 0;
		var sources = Object.create(null);
		var sourcesInLines = Object.create(null);

		// We build a new list of SourceNodes in "output"
		// from the original mapping data

		var result = new SourceNode();

		// We need to add source contents manually
		// because "walk" will not handle it
		node.walkSourceContents(function(sourceFile, sourceContent) {
			result.setSourceContent(sourceFile, sourceContent);
			sources["$" + sourceFile] = sourceContent;
		});

		var replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {
			var key = "$" + mapping.source;
			var lines = sourcesInLines[key];
			if(!lines) {
				var source = sources[key];
				if(!source) return null;
				lines = source.split("\n").map(function(line) {
					return line + "\n";
				});
				sourcesInLines[key] = lines;
			}
			// line is 1-based
			if(mapping.line > lines.length) return null;
			var line = lines[mapping.line - 1];
			return line.substr(mapping.column);
		});

		node.walk(function(chunk, mapping) {
			position = replaceInStringNode(chunk, position, mapping);
		});

		// If any replacements occur after the end of the original file, then we append them
		// directly to the end of the output
		var remaining = replace.footer();
		if(remaining) {
			output.push(remaining);
		}

		result.add(output);

		return result;
	}

	listMap(options) {
		this._sortReplacements();
		var map = this._source.listMap(options);
		var currentIndex = 0;
		var replacements = this.replacements;
		var idxReplacement = replacements.length - 1;
		var removeChars = 0;
		map = map.mapGeneratedCode(function(str) {
			var newCurrentIndex = currentIndex + str.length;
			if(removeChars > str.length) {
				removeChars -= str.length;
				str = "";
			} else {
				if(removeChars > 0) {
					str = str.substr(removeChars);
					currentIndex += removeChars;
					removeChars = 0;
				}
				var finalStr = "";
				while(idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {
					var repl = replacements[idxReplacement];
					var start = Math.floor(repl.start);
					var end = Math.floor(repl.end + 1);
					var before = str.substr(0, Math.max(0, start - currentIndex));
					if(end <= newCurrentIndex) {
						var after = str.substr(Math.max(0, end - currentIndex));
						finalStr += before + repl.content;
						str = after;
						currentIndex = Math.max(currentIndex, end);
					} else {
						finalStr += before + repl.content;
						str = "";
						removeChars = end - newCurrentIndex;
					}
					idxReplacement--;
				}
				str = finalStr + str;
			}
			currentIndex = newCurrentIndex;
			return str;
		});
		var extraCode = "";
		while(idxReplacement >= 0) {
			extraCode += replacements[idxReplacement].content;
			idxReplacement--;
		}
		if(extraCode) {
			map.add(extraCode);
		}
		return map;
	}

	_splitString(str, position) {
		return position <= 0 ? ["", str] : [str.substr(0, position), str.substr(position)];
	}

	_replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {
		var original = undefined;

		do {
			var splitPosition = replace.position - position;
			// If multiple replaces occur in the same location then the splitPosition may be
			// before the current position for the subsequent splits. Ensure it is >= 0
			if(splitPosition < 0) {
				splitPosition = 0;
			}
			if(splitPosition >= node.length || replace.done) {
				if(replace.emit) {
					var nodeEnd = new SourceNode(
						mapping.line,
						mapping.column,
						mapping.source,
						node,
						mapping.name
					);
					output.push(nodeEnd);
				}
				return position + node.length;
			}

			var originalColumn = mapping.column;

			// Try to figure out if generated code matches original code of this segement
			// If this is the case we assume that it's allowed to move mapping.column
			// Because getOriginalSource can be expensive we only do it when neccessary

			var nodePart;
			if(splitPosition > 0) {
				nodePart = node.slice(0, splitPosition);
				if(original === undefined) {
					original = getOriginalSource(mapping);
				}
				if(original && original.length >= splitPosition && original.startsWith(nodePart)) {
					mapping.column += splitPosition;
					original = original.substr(splitPosition);
				}
			}

			var emit = replace.next();
			if(!emit) {
				// Stop emitting when we have found the beginning of the string to replace.
				// Emit the part of the string before splitPosition
				if(splitPosition > 0) {
					var nodeStart = new SourceNode(
						mapping.line,
						originalColumn,
						mapping.source,
						nodePart,
						mapping.name
					);
					output.push(nodeStart);
				}

				// Emit the replacement value
				if(replace.value) {
					output.push(new SourceNode(
						mapping.line,
						mapping.column,
						mapping.source,
						replace.value,
						mapping.name || replace.name
					));
				}
			}

			// Recurse with remainder of the string as there may be multiple replaces within a single node
			node = node.substr(splitPosition);
			position += splitPosition;
		} while (true);
	}
}

class ReplacementEnumerator {
	/**
	 * @param {Replacement[]} replacements list of replacements
	 */
	constructor(replacements) {
		this.replacements = replacements || [];
		this.index = this.replacements.length;
		this.done = false;
		this.emit = false;
		// Set initial start position
		this.next();
	}

	next() {
		if(this.done)
			return true;
		if(this.emit) {
			// Start point found. stop emitting. set position to find end
			var repl = this.replacements[this.index];
			var end = Math.floor(repl.end + 1);
			this.position = end;
			this.value = repl.content;
			this.name = repl.name;
		} else {
			// End point found. start emitting. set position to find next start
			this.index--;
			if(this.index < 0) {
				this.done = true;
			} else {
				var nextRepl = this.replacements[this.index];
				var start = Math.floor(nextRepl.start);
				this.position = start;
			}
		}
		if(this.position < 0)
			this.position = 0;
		this.emit = !this.emit;
		return this.emit;
	}

	footer() {
		if(!this.done && !this.emit)
			this.next(); // If we finished _replaceInNode mid emit we advance to next entry
		if(this.done) {
			return [];
		} else {
			var resultStr = "";
			for(var i = this.index; i >= 0; i--) {
				var repl = this.replacements[i];
				// this doesn't need to handle repl.name, because in SourceMaps generated code
				// without pointer to original source can't have a name
				resultStr += repl.content;
			}
			return resultStr;
		}
	}
}

__webpack_require__(/*! ./SourceAndMapMixin */ "./node_modules/webpack-sources/lib/SourceAndMapMixin.js")(ReplaceSource.prototype);

module.exports = ReplaceSource;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/Source.js":
/*!***************************************!*\
  !*** (webpack)-sources/lib/Source.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


var SourceNode = __webpack_require__(/*! source-map */ "source-map").SourceNode;
var SourceMapConsumer = __webpack_require__(/*! source-map */ "source-map").SourceMapConsumer;

class Source {

	source() {
		throw new Error("Abstract");
	}

	size() {
		return this.source().length;
	}

	map(options) {
		return null;
	}

	sourceAndMap(options) {
		return {
			source: this.source(),
			map: this.map()
		};
	}

	node() {
		throw new Error("Abstract");
	}

	listNode() {
		throw new Error("Abstract");
	}

	updateHash(hash) {
		var source = this.source();
		hash.update(source || "");
	}
}

module.exports = Source;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/SourceAndMapMixin.js":
/*!**************************************************!*\
  !*** (webpack)-sources/lib/SourceAndMapMixin.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


module.exports = function mixinSourceAndMap(proto) {
	proto.map = function(options) {
		options = options || {};
		if(options.columns === false) {
			return this.listMap(options).toStringWithSourceMap({
				file: "x"
			}).map;
		}

		return this.node(options).toStringWithSourceMap({
			file: "x"
		}).map.toJSON();
	};

	proto.sourceAndMap = function(options) {
		options = options || {};
		if(options.columns === false) {
			//console.log(this.listMap(options).debugInfo());
			return this.listMap(options).toStringWithSourceMap({
				file: "x"
			});
		}

		var res = this.node(options).toStringWithSourceMap({
			file: "x"
		});
		return {
			source: res.code,
			map: res.map.toJSON()
		};
	};
}


/***/ }),

/***/ "./node_modules/webpack-sources/lib/SourceMapSource.js":
/*!************************************************!*\
  !*** (webpack)-sources/lib/SourceMapSource.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


var SourceNode = __webpack_require__(/*! source-map */ "source-map").SourceNode;
var SourceMapConsumer = __webpack_require__(/*! source-map */ "source-map").SourceMapConsumer;
var SourceMapGenerator = __webpack_require__(/*! source-map */ "source-map").SourceMapGenerator;
var SourceListMap = __webpack_require__(/*! source-list-map */ "source-list-map").SourceListMap;
var fromStringWithSourceMap = __webpack_require__(/*! source-list-map */ "source-list-map").fromStringWithSourceMap;
var Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");

class SourceMapSource extends Source {
	constructor(value, name, sourceMap, originalSource, innerSourceMap) {
		super();
		this._value = value;
		this._name = name;
		this._sourceMap = sourceMap;
		this._originalSource = originalSource;
		this._innerSourceMap = innerSourceMap;
	}

	source() {
		return this._value;
	}

	node(options) {
		var innerSourceMap = this._innerSourceMap;
		var sourceMap = this._sourceMap;
		if(innerSourceMap) {
			sourceMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(sourceMap));
			if(this._originalSource)
				sourceMap.setSourceContent(this._name, this._originalSource);
			innerSourceMap = new SourceMapConsumer(innerSourceMap);
			sourceMap.applySourceMap(innerSourceMap, this._name);
			sourceMap = sourceMap.toJSON();
		}
		return SourceNode.fromStringWithSourceMap(this._value, new SourceMapConsumer(sourceMap));
	}

	listMap(options) {
		options = options || {};
		if(options.module === false)
			return new SourceListMap(this._value, this._name, this._value);
		return fromStringWithSourceMap(this._value, typeof this._sourceMap === "string" ? JSON.parse(this._sourceMap) : this._sourceMap);
	}

	updateHash(hash) {
		hash.update(this._value);
		if(this._originalSource)
			hash.update(this._originalSource);
	}
}

__webpack_require__(/*! ./SourceAndMapMixin */ "./node_modules/webpack-sources/lib/SourceAndMapMixin.js")(SourceMapSource.prototype);

module.exports = SourceMapSource;


/***/ }),

/***/ "./node_modules/webpack-sources/lib/index.js":
/*!**************************************!*\
  !*** (webpack)-sources/lib/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
exports.Source = __webpack_require__(/*! ./Source */ "./node_modules/webpack-sources/lib/Source.js");

exports.RawSource = __webpack_require__(/*! ./RawSource */ "./node_modules/webpack-sources/lib/RawSource.js");
exports.OriginalSource = __webpack_require__(/*! ./OriginalSource */ "./node_modules/webpack-sources/lib/OriginalSource.js");
exports.SourceMapSource = __webpack_require__(/*! ./SourceMapSource */ "./node_modules/webpack-sources/lib/SourceMapSource.js");
exports.LineToLineMappedSource = __webpack_require__(/*! ./LineToLineMappedSource */ "./node_modules/webpack-sources/lib/LineToLineMappedSource.js");

exports.CachedSource = __webpack_require__(/*! ./CachedSource */ "./node_modules/webpack-sources/lib/CachedSource.js");
exports.ConcatSource = __webpack_require__(/*! ./ConcatSource */ "./node_modules/webpack-sources/lib/ConcatSource.js");
exports.ReplaceSource = __webpack_require__(/*! ./ReplaceSource */ "./node_modules/webpack-sources/lib/ReplaceSource.js");
exports.PrefixSource = __webpack_require__(/*! ./PrefixSource */ "./node_modules/webpack-sources/lib/PrefixSource.js");


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/system.js":
/*!***********************************!*\
  !*** (webpack)/buildin/system.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Provide a "System" global.
module.exports = {
	// Make sure import is only used as "System.import"
	import: function() {
		throw new Error("System.import cannot be used indirectly");
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/APIPlugin.js":
/*!**********************************!*\
  !*** (webpack)/lib/APIPlugin.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const ParserHelpers = __webpack_require__(/*! ./ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");

const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

/* eslint-disable camelcase */
const REPLACEMENTS = {
	__webpack_require__: "__webpack_require__",
	__webpack_public_path__: "__webpack_require__.p",
	__webpack_modules__: "__webpack_require__.m",
	__webpack_chunk_load__: "__webpack_require__.e",
	__non_webpack_require__: "require",
	__webpack_nonce__: "__webpack_require__.nc",
	"require.onError": "__webpack_require__.oe"
};
const NO_WEBPACK_REQUIRE = {
	__non_webpack_require__: true
};
const REPLACEMENT_TYPES = {
	__webpack_public_path__: "string",
	__webpack_require__: "function",
	__webpack_modules__: "object",
	__webpack_chunk_load__: "function",
	__webpack_nonce__: "string"
};
/* eslint-enable camelcase */

class APIPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"APIPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const handler = parser => {
					Object.keys(REPLACEMENTS).forEach(key => {
						parser.hooks.expression
							.for(key)
							.tap(
								"APIPlugin",
								NO_WEBPACK_REQUIRE[key]
									? ParserHelpers.toConstantDependency(
											parser,
											REPLACEMENTS[key]
									  )
									: ParserHelpers.toConstantDependencyWithWebpackRequire(
											parser,
											REPLACEMENTS[key]
									  )
							);
						parser.hooks.evaluateTypeof
							.for(key)
							.tap(
								"APIPlugin",
								ParserHelpers.evaluateToString(REPLACEMENT_TYPES[key])
							);
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("APIPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("APIPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("APIPlugin", handler);
			}
		);
	}
}

module.exports = APIPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/AmdMainTemplatePlugin.js":
/*!**********************************************!*\
  !*** (webpack)/lib/AmdMainTemplatePlugin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */



const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

/** @typedef {import("./Compilation")} Compilation */

/**
 * @typedef {Object} AmdMainTemplatePluginOptions
 * @param {string=} name the library name
 * @property {boolean=} requireAsWrapper
 */

class AmdMainTemplatePlugin {
	/**
	 * @param {AmdMainTemplatePluginOptions} options the plugin options
	 */
	constructor(options) {
		if (!options || typeof options === "string") {
			this.name = options;
			this.requireAsWrapper = false;
		} else {
			this.name = options.name;
			this.requireAsWrapper = options.requireAsWrapper;
		}
	}

	/**
	 * @param {Compilation} compilation the compilation instance
	 * @returns {void}
	 */
	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const externals = chunk.getModules().filter(m => m.external);
			const externalsDepsArray = JSON.stringify(
				externals.map(
					m => (typeof m.request === "object" ? m.request.amd : m.request)
				)
			);
			const externalsArguments = externals
				.map(
					m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${m.id}`)}__`
				)
				.join(", ");

			if (this.requireAsWrapper) {
				return new ConcatSource(
					`require(${externalsDepsArray}, function(${externalsArguments}) { return `,
					source,
					"});"
				);
			} else if (this.name) {
				const name = mainTemplate.getAssetPath(this.name, {
					hash,
					chunk
				});

				return new ConcatSource(
					`define(${JSON.stringify(
						name
					)}, ${externalsDepsArray}, function(${externalsArguments}) { return `,
					source,
					"});"
				);
			} else if (externalsArguments) {
				return new ConcatSource(
					`define(${externalsDepsArray}, function(${externalsArguments}) { return `,
					source,
					"});"
				);
			} else {
				return new ConcatSource("define(function() { return ", source, "});");
			}
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"AmdMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap("AmdMainTemplatePlugin", paths => {
			if (this.name) {
				paths.push(this.name);
			}
			return paths;
		});

		mainTemplate.hooks.hash.tap("AmdMainTemplatePlugin", hash => {
			hash.update("exports amd");
			if (this.name) {
				hash.update(this.name);
			}
		});
	}
}

module.exports = AmdMainTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/AsyncDependenciesBlock.js":
/*!***********************************************!*\
  !*** (webpack)/lib/AsyncDependenciesBlock.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DependenciesBlock = __webpack_require__(/*! ./DependenciesBlock */ "./node_modules/webpack/lib/DependenciesBlock.js");

/** @typedef {import("./ChunkGroup")} ChunkGroup */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./util/createHash").Hash} Hash */
/** @typedef {TODO} GroupOptions */

module.exports = class AsyncDependenciesBlock extends DependenciesBlock {
	/**
	 * @param {GroupOptions} groupOptions options for the group
	 * @param {Module} module the Module object
	 * @param {DependencyLocation=} loc the line of code
	 * @param {TODO=} request the request
	 */
	constructor(groupOptions, module, loc, request) {
		super();
		if (typeof groupOptions === "string") {
			groupOptions = { name: groupOptions };
		} else if (!groupOptions) {
			groupOptions = { name: undefined };
		}
		this.groupOptions = groupOptions;
		/** @type {ChunkGroup=} */
		this.chunkGroup = undefined;
		this.module = module;
		this.loc = loc;
		this.request = request;
		/** @type {DependenciesBlock} */
		this.parent = undefined;
	}

	/**
	 * @returns {string} The name of the chunk
	 */
	get chunkName() {
		return this.groupOptions.name;
	}

	/**
	 * @param {string} value The new chunk name
	 * @returns {void}
	 */
	set chunkName(value) {
		this.groupOptions.name = value;
	}

	/**
	 * @returns {never} this throws and should never be called
	 */
	get chunks() {
		throw new Error("Moved to AsyncDependenciesBlock.chunkGroup");
	}

	/**
	 * @param {never} value setter value
	 * @returns {never} this is going to throw therefore we should throw type
	 * assertions by returning never
	 */
	set chunks(value) {
		throw new Error("Moved to AsyncDependenciesBlock.chunkGroup");
	}

	/**
	 * @param {Hash} hash the hash used to track block changes, from "crypto" module
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update(JSON.stringify(this.groupOptions));
		hash.update(
			(this.chunkGroup &&
				this.chunkGroup.chunks
					.map(chunk => {
						return chunk.id !== null ? chunk.id : "";
					})
					.join(",")) ||
				""
		);
		super.updateHash(hash);
	}

	/**
	 * @returns {void}
	 */
	disconnect() {
		this.chunkGroup = undefined;
		super.disconnect();
	}

	/**
	 * @returns {void}
	 */
	unseal() {
		this.chunkGroup = undefined;
		super.unseal();
	}

	/**
	 * @returns {void}
	 */
	sortItems() {
		super.sortItems();
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/AsyncDependencyToInitialChunkError.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/AsyncDependencyToInitialChunkError.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

/** @typedef {import("./Module")} Module */

class AsyncDependencyToInitialChunkError extends WebpackError {
	/**
	 * Creates an instance of AsyncDependencyToInitialChunkError.
	 * @param {string} chunkName Name of Chunk
	 * @param {Module} module module tied to dependency
	 * @param {TODO} loc location of dependency
	 */
	constructor(chunkName, module, loc) {
		super(
			`It's not allowed to load an initial chunk on demand. The chunk name "${chunkName}" is already used by an entrypoint.`
		);

		this.name = "AsyncDependencyToInitialChunkError";
		this.module = module;
		this.loc = loc;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = AsyncDependencyToInitialChunkError;


/***/ }),

/***/ "./node_modules/webpack/lib/AutomaticPrefetchPlugin.js":
/*!************************************************!*\
  !*** (webpack)/lib/AutomaticPrefetchPlugin.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");
const PrefetchDependency = __webpack_require__(/*! ./dependencies/PrefetchDependency */ "./node_modules/webpack/lib/dependencies/PrefetchDependency.js");
const NormalModule = __webpack_require__(/*! ./NormalModule */ "./node_modules/webpack/lib/NormalModule.js");

/** @typedef {import("./Compiler")} Compiler */

class AutomaticPrefetchPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler Webpack Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"AutomaticPrefetchPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					PrefetchDependency,
					normalModuleFactory
				);
			}
		);
		let lastModules = null;
		compiler.hooks.afterCompile.tap("AutomaticPrefetchPlugin", compilation => {
			lastModules = compilation.modules
				.filter(m => m instanceof NormalModule)
				.map((/** @type {NormalModule} */ m) => ({
					context: m.context,
					request: m.request
				}));
		});
		compiler.hooks.make.tapAsync(
			"AutomaticPrefetchPlugin",
			(compilation, callback) => {
				if (!lastModules) return callback();
				asyncLib.forEach(
					lastModules,
					(m, callback) => {
						compilation.prefetch(
							m.context || compiler.context,
							new PrefetchDependency(m.request),
							callback
						);
					},
					callback
				);
			}
		);
	}
}
module.exports = AutomaticPrefetchPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/BannerPlugin.js":
/*!*************************************!*\
  !*** (webpack)/lib/BannerPlugin.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */



const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const ModuleFilenameHelpers = __webpack_require__(/*! ./ModuleFilenameHelpers */ "./node_modules/webpack/lib/ModuleFilenameHelpers.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/BannerPlugin.json */ "./node_modules/webpack/schemas/plugins/BannerPlugin.json");

/** @typedef {import("../declarations/plugins/BannerPlugin").BannerPluginArgument} BannerPluginArgument */
/** @typedef {import("../declarations/plugins/BannerPlugin").BannerPluginOptions} BannerPluginOptions */

const wrapComment = str => {
	if (!str.includes("\n")) {
		return Template.toComment(str);
	}
	return `/*!\n * ${str
		.replace(/\*\//g, "* /")
		.split("\n")
		.join("\n * ")}\n */`;
};

class BannerPlugin {
	/**
	 * @param {BannerPluginArgument} options options object
	 */
	constructor(options) {
		if (arguments.length > 1) {
			throw new Error(
				"BannerPlugin only takes one argument (pass an options object)"
			);
		}

		validateOptions(schema, options, "Banner Plugin");

		if (typeof options === "string" || typeof options === "function") {
			options = {
				banner: options
			};
		}

		/** @type {BannerPluginOptions} */
		this.options = options;

		const bannerOption = options.banner;
		if (typeof bannerOption === "function") {
			const getBanner = bannerOption;
			this.banner = this.options.raw
				? getBanner
				: data => wrapComment(getBanner(data));
		} else {
			const banner = this.options.raw
				? bannerOption
				: wrapComment(bannerOption);
			this.banner = () => banner;
		}
	}

	apply(compiler) {
		const options = this.options;
		const banner = this.banner;
		const matchObject = ModuleFilenameHelpers.matchObject.bind(
			undefined,
			options
		);

		compiler.hooks.compilation.tap("BannerPlugin", compilation => {
			compilation.hooks.optimizeChunkAssets.tap("BannerPlugin", chunks => {
				for (const chunk of chunks) {
					if (options.entryOnly && !chunk.canBeInitial()) {
						continue;
					}

					for (const file of chunk.files) {
						if (!matchObject(file)) {
							continue;
						}

						let basename;
						let query = "";
						let filename = file;
						const hash = compilation.hash;
						const querySplit = filename.indexOf("?");

						if (querySplit >= 0) {
							query = filename.substr(querySplit);
							filename = filename.substr(0, querySplit);
						}

						const lastSlashIndex = filename.lastIndexOf("/");

						if (lastSlashIndex === -1) {
							basename = filename;
						} else {
							basename = filename.substr(lastSlashIndex + 1);
						}

						const data = {
							hash,
							chunk,
							filename,
							basename,
							query
						};

						const comment = compilation.getPath(banner(data), data);

						compilation.assets[file] = new ConcatSource(
							comment,
							"\n",
							compilation.assets[file]
						);
					}
				}
			});
		});
	}
}

module.exports = BannerPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/BasicEvaluatedExpression.js":
/*!*************************************************!*\
  !*** (webpack)/lib/BasicEvaluatedExpression.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



const TypeUnknown = 0;
const TypeNull = 1;
const TypeString = 2;
const TypeNumber = 3;
const TypeBoolean = 4;
const TypeRegExp = 5;
const TypeConditional = 6;
const TypeArray = 7;
const TypeConstArray = 8;
const TypeIdentifier = 9;
const TypeWrapped = 10;
const TypeTemplateString = 11;

class BasicEvaluatedExpression {
	constructor() {
		this.type = TypeUnknown;
		this.range = null;
		this.falsy = false;
		this.truthy = false;
		this.bool = null;
		this.number = null;
		this.regExp = null;
		this.string = null;
		this.quasis = null;
		this.parts = null;
		this.array = null;
		this.items = null;
		this.options = null;
		this.prefix = null;
		this.postfix = null;
		this.wrappedInnerExpressions = null;
		this.expression = null;
	}

	isNull() {
		return this.type === TypeNull;
	}

	isString() {
		return this.type === TypeString;
	}

	isNumber() {
		return this.type === TypeNumber;
	}

	isBoolean() {
		return this.type === TypeBoolean;
	}

	isRegExp() {
		return this.type === TypeRegExp;
	}

	isConditional() {
		return this.type === TypeConditional;
	}

	isArray() {
		return this.type === TypeArray;
	}

	isConstArray() {
		return this.type === TypeConstArray;
	}

	isIdentifier() {
		return this.type === TypeIdentifier;
	}

	isWrapped() {
		return this.type === TypeWrapped;
	}

	isTemplateString() {
		return this.type === TypeTemplateString;
	}

	isTruthy() {
		return this.truthy;
	}

	isFalsy() {
		return this.falsy;
	}

	asBool() {
		if (this.truthy) return true;
		if (this.falsy) return false;
		if (this.isBoolean()) return this.bool;
		if (this.isNull()) return false;
		if (this.isString()) return this.string !== "";
		if (this.isNumber()) return this.number !== 0;
		if (this.isRegExp()) return true;
		if (this.isArray()) return true;
		if (this.isConstArray()) return true;
		if (this.isWrapped()) {
			return (this.prefix && this.prefix.asBool()) ||
				(this.postfix && this.postfix.asBool())
				? true
				: undefined;
		}
		if (this.isTemplateString()) {
			const str = this.asString();
			if (typeof str === "string") return str !== "";
		}
		return undefined;
	}

	asString() {
		if (this.isBoolean()) return `${this.bool}`;
		if (this.isNull()) return "null";
		if (this.isString()) return this.string;
		if (this.isNumber()) return `${this.number}`;
		if (this.isRegExp()) return `${this.regExp}`;
		if (this.isArray()) {
			let array = [];
			for (const item of this.items) {
				const itemStr = item.asString();
				if (itemStr === undefined) return undefined;
				array.push(itemStr);
			}
			return `${array}`;
		}
		if (this.isConstArray()) return `${this.array}`;
		if (this.isTemplateString()) {
			let str = "";
			for (const part of this.parts) {
				const partStr = part.asString();
				if (partStr === undefined) return undefined;
				str += partStr;
			}
			return str;
		}
		return undefined;
	}

	setString(string) {
		this.type = TypeString;
		this.string = string;
		return this;
	}

	setNull() {
		this.type = TypeNull;
		return this;
	}

	setNumber(number) {
		this.type = TypeNumber;
		this.number = number;
		return this;
	}

	setBoolean(bool) {
		this.type = TypeBoolean;
		this.bool = bool;
		return this;
	}

	setRegExp(regExp) {
		this.type = TypeRegExp;
		this.regExp = regExp;
		return this;
	}

	setIdentifier(identifier) {
		this.type = TypeIdentifier;
		this.identifier = identifier;
		return this;
	}

	setWrapped(prefix, postfix, innerExpressions) {
		this.type = TypeWrapped;
		this.prefix = prefix;
		this.postfix = postfix;
		this.wrappedInnerExpressions = innerExpressions;
		return this;
	}

	setOptions(options) {
		this.type = TypeConditional;
		this.options = options;
		return this;
	}

	addOptions(options) {
		if (!this.options) {
			this.type = TypeConditional;
			this.options = [];
		}
		for (const item of options) {
			this.options.push(item);
		}
		return this;
	}

	setItems(items) {
		this.type = TypeArray;
		this.items = items;
		return this;
	}

	setArray(array) {
		this.type = TypeConstArray;
		this.array = array;
		return this;
	}

	setTemplateString(quasis, parts, kind) {
		this.type = TypeTemplateString;
		this.quasis = quasis;
		this.parts = parts;
		this.templateStringKind = kind;
		return this;
	}

	setTruthy() {
		this.falsy = false;
		this.truthy = true;
		return this;
	}

	setFalsy() {
		this.falsy = true;
		this.truthy = false;
		return this;
	}

	setRange(range) {
		this.range = range;
		return this;
	}

	setExpression(expression) {
		this.expression = expression;
		return this;
	}
}

module.exports = BasicEvaluatedExpression;


/***/ }),

/***/ "./node_modules/webpack/lib/CachePlugin.js":
/*!************************************!*\
  !*** (webpack)/lib/CachePlugin.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");

class CachePlugin {
	constructor(cache) {
		this.cache = cache || {};
		this.FS_ACCURACY = 2000;
	}

	apply(compiler) {
		if (Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) => {
				new CachePlugin((this.cache[idx] = this.cache[idx] || {})).apply(c);
			});
		} else {
			const registerCacheToCompiler = (compiler, cache) => {
				compiler.hooks.thisCompilation.tap("CachePlugin", compilation => {
					compilation.cache = cache;
					compilation.hooks.childCompiler.tap(
						"CachePlugin",
						(childCompiler, compilerName, compilerIndex) => {
							if (cache) {
								let childCache;
								if (!cache.children) {
									cache.children = {};
								}
								if (!cache.children[compilerName]) {
									cache.children[compilerName] = [];
								}
								if (cache.children[compilerName][compilerIndex]) {
									childCache = cache.children[compilerName][compilerIndex];
								} else {
									cache.children[compilerName].push((childCache = {}));
								}
								registerCacheToCompiler(childCompiler, childCache);
							}
						}
					);
				});
			};
			registerCacheToCompiler(compiler, this.cache);
			compiler.hooks.watchRun.tap("CachePlugin", () => {
				this.watching = true;
			});
			compiler.hooks.run.tapAsync("CachePlugin", (compiler, callback) => {
				if (!compiler._lastCompilationFileDependencies) {
					return callback();
				}
				const fs = compiler.inputFileSystem;
				const fileTs = (compiler.fileTimestamps = new Map());
				asyncLib.forEach(
					compiler._lastCompilationFileDependencies,
					(file, callback) => {
						fs.stat(file, (err, stat) => {
							if (err) {
								if (err.code === "ENOENT") return callback();
								return callback(err);
							}

							if (stat.mtime) this.applyMtime(+stat.mtime);

							fileTs.set(file, +stat.mtime || Infinity);

							callback();
						});
					},
					err => {
						if (err) return callback(err);

						for (const [file, ts] of fileTs) {
							fileTs.set(file, ts + this.FS_ACCURACY);
						}

						callback();
					}
				);
			});
			compiler.hooks.afterCompile.tap("CachePlugin", compilation => {
				compilation.compiler._lastCompilationFileDependencies =
					compilation.fileDependencies;
				compilation.compiler._lastCompilationContextDependencies =
					compilation.contextDependencies;
			});
		}
	}

	/* istanbul ignore next */
	applyMtime(mtime) {
		if (this.FS_ACCURACY > 1 && mtime % 2 !== 0) this.FS_ACCURACY = 1;
		else if (this.FS_ACCURACY > 10 && mtime % 20 !== 0) this.FS_ACCURACY = 10;
		else if (this.FS_ACCURACY > 100 && mtime % 200 !== 0)
			this.FS_ACCURACY = 100;
		else if (this.FS_ACCURACY > 1000 && mtime % 2000 !== 0)
			this.FS_ACCURACY = 1000;
	}
}
module.exports = CachePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/CaseSensitiveModulesWarning.js":
/*!****************************************************!*\
  !*** (webpack)/lib/CaseSensitiveModulesWarning.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

/** @typedef {import("./Module")} Module */

/**
 * @param {Module[]} modules the modules to be sorted
 * @returns {Module[]} sorted version of original modules
 */
const sortModules = modules => {
	return modules.slice().sort((a, b) => {
		const aIdent = a.identifier();
		const bIdent = b.identifier();
		/* istanbul ignore next */
		if (aIdent < bIdent) return -1;
		/* istanbul ignore next */
		if (aIdent > bIdent) return 1;
		/* istanbul ignore next */
		return 0;
	});
};

/**
 * @param {Module[]} modules each module from throw
 * @returns {string} each message from provided moduels
 */
const createModulesListMessage = modules => {
	return modules
		.map(m => {
			let message = `* ${m.identifier()}`;
			const validReasons = m.reasons.filter(reason => reason.module);

			if (validReasons.length > 0) {
				message += `\n    Used by ${validReasons.length} module(s), i. e.`;
				message += `\n    ${validReasons[0].module.identifier()}`;
			}
			return message;
		})
		.join("\n");
};

class CaseSensitiveModulesWarning extends WebpackError {
	/**
	 * Creates an instance of CaseSensitiveModulesWarning.
	 * @param {Module[]} modules modules that were detected
	 */
	constructor(modules) {
		const sortedModules = sortModules(modules);
		const modulesList = createModulesListMessage(sortedModules);
		super(`There are multiple modules with names that only differ in casing.
This can lead to unexpected behavior when compiling on a filesystem with other case-semantic.
Use equal casing. Compare these module identifiers:
${modulesList}`);

		this.name = "CaseSensitiveModulesWarning";
		this.origin = this.module = sortedModules[0];

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = CaseSensitiveModulesWarning;


/***/ }),

/***/ "./node_modules/webpack/lib/Chunk.js":
/*!******************************!*\
  !*** (webpack)/lib/Chunk.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License http://www.opensource.org/licenses/mit-license.php
Author Tobias Koppers @sokra
*/


const util = __webpack_require__(/*! util */ "util");
const SortableSet = __webpack_require__(/*! ./util/SortableSet */ "./node_modules/webpack/lib/util/SortableSet.js");
const intersect = __webpack_require__(/*! ./util/SetHelpers */ "./node_modules/webpack/lib/util/SetHelpers.js").intersect;
const GraphHelpers = __webpack_require__(/*! ./GraphHelpers */ "./node_modules/webpack/lib/GraphHelpers.js");
const Entrypoint = __webpack_require__(/*! ./Entrypoint */ "./node_modules/webpack/lib/Entrypoint.js");
let debugId = 1000;
const ERR_CHUNK_ENTRY = "Chunk.entry was removed. Use hasRuntime()";
const ERR_CHUNK_INITIAL =
	"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()";

/** @typedef {import("./Module")} Module */
/** @typedef {import("./ChunkGroup")} ChunkGroup */
/** @typedef {import("./ModuleReason")} ModuleReason */
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./util/createHash").Hash} Hash */

/**
 *  @typedef {Object} WithId an object who has an id property *
 *  @property {string | number} id the id of the object
 */

/**
 * Compare two Modules based on their ids for sorting
 * @param {Module} a module
 * @param {Module} b module
 * @returns {-1|0|1} sort value
 */

// TODO use @callback
/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */
/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */
/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */

const sortModuleById = (a, b) => {
	if (a.id < b.id) return -1;
	if (b.id < a.id) return 1;
	return 0;
};

/**
 * Compare two ChunkGroups based on their ids for sorting
 * @param {ChunkGroup} a chunk group
 * @param {ChunkGroup} b chunk group
 * @returns {-1|0|1} sort value
 */
const sortChunkGroupById = (a, b) => {
	if (a.id < b.id) return -1;
	if (b.id < a.id) return 1;
	return 0;
};

/**
 * Compare two Identifiables , based on their ids for sorting
 * @param {Module} a first object with ident fn
 * @param {Module} b second object with ident fn
 * @returns {-1|0|1} The order number of the sort
 */
const sortByIdentifier = (a, b) => {
	if (a.identifier() > b.identifier()) return 1;
	if (a.identifier() < b.identifier()) return -1;
	return 0;
};

/**
 * @returns {string} a concatenation of module identifiers sorted
 * @param {SortableSet} set to pull module identifiers from
 */
const getModulesIdent = set => {
	set.sort();
	let str = "";
	for (const m of set) {
		str += m.identifier() + "#";
	}
	return str;
};

/**
 * @template T
 * @param {SortableSet<T>} set the sortable set to convert to array
 * @returns {Array<T>} the array returned from Array.from(set)
 */
const getArray = set => Array.from(set);

/**
 * @param {SortableSet<Module>} set the sortable Set to get the count/size of
 * @returns {number} the size of the modules
 */
const getModulesSize = set => {
	let size = 0;
	for (const module of set) {
		size += module.size();
	}
	return size;
};

/**
 * A Chunk is a unit of encapsulation for Modules.
 * Chunks are "rendered" into bundles that get emitted when the build completes.
 */
class Chunk {
	/**
	 * @param {string=} name of chunk being created, is optional (for subclasses)
	 */
	constructor(name) {
		/** @type {number | null} */
		this.id = null;
		/** @type {number[] | null} */
		this.ids = null;
		/** @type {number} */
		this.debugId = debugId++;
		/** @type {string} */
		this.name = name;
		/** @type {boolean} */
		this.preventIntegration = false;
		/** @type {Module=} */
		this.entryModule = undefined;
		/** @private @type {SortableSet<Module>} */
		this._modules = new SortableSet(undefined, sortByIdentifier);
		/** @type {string?} */
		this.filenameTemplate = undefined;
		/** @private @type {SortableSet<ChunkGroup>} */
		this._groups = new SortableSet(undefined, sortChunkGroupById);
		/** @type {string[]} */
		this.files = [];
		/** @type {boolean} */
		this.rendered = false;
		/** @type {string=} */
		this.hash = undefined;
		/** @type {Object} */
		this.contentHash = Object.create(null);
		/** @type {string=} */
		this.renderedHash = undefined;
		/** @type {string=} */
		this.chunkReason = undefined;
		/** @type {boolean} */
		this.extraAsync = false;
		this.removedModules = undefined;
	}

	/**
	 * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead
	 * @returns {never} Throws an error trying to access this property
	 */
	get entry() {
		throw new Error(ERR_CHUNK_ENTRY);
	}

	/**
	 * @deprecated .entry has been deprecated. Please use .hasRuntime() instead
	 * @param {never} data The data that was attempting to be set
	 * @returns {never} Throws an error trying to access this property
	 */
	set entry(data) {
		throw new Error(ERR_CHUNK_ENTRY);
	}

	/**
	 * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()
	 * @returns {never} Throws an error trying to access this property
	 */
	get initial() {
		throw new Error(ERR_CHUNK_INITIAL);
	}

	/**
	 * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()
	 * @param {never} data The data attempting to be set
	 * @returns {never} Throws an error trying to access this property
	 */
	set initial(data) {
		throw new Error(ERR_CHUNK_INITIAL);
	}

	/**
	 * @returns {boolean} whether or not the Chunk will have a runtime
	 */
	hasRuntime() {
		for (const chunkGroup of this._groups) {
			if (
				chunkGroup.isInitial() &&
				chunkGroup instanceof Entrypoint &&
				chunkGroup.getRuntimeChunk() === this
			) {
				return true;
			}
		}
		return false;
	}

	/**
	 * @returns {boolean} whether or not this chunk can be an initial chunk
	 */
	canBeInitial() {
		for (const chunkGroup of this._groups) {
			if (chunkGroup.isInitial()) return true;
		}
		return false;
	}

	/**
	 * @returns {boolean} whether this chunk can only be an initial chunk
	 */
	isOnlyInitial() {
		if (this._groups.size <= 0) return false;
		for (const chunkGroup of this._groups) {
			if (!chunkGroup.isInitial()) return false;
		}
		return true;
	}

	/**
	 * @returns {boolean} if this chunk contains the entry module
	 */
	hasEntryModule() {
		return !!this.entryModule;
	}

	/**
	 * @param {Module} module the module that will be added to this chunk.
	 * @returns {boolean} returns true if the chunk doesn't have the module and it was added
	 */
	addModule(module) {
		if (!this._modules.has(module)) {
			this._modules.add(module);
			return true;
		}
		return false;
	}

	/**
	 * @param {Module} module the module that will be removed from this chunk
	 * @returns {boolean} returns true if chunk exists and is successfully deleted
	 */
	removeModule(module) {
		if (this._modules.delete(module)) {
			module.removeChunk(this);
			return true;
		}
		return false;
	}

	/**
	 * @param {Module[]} modules the new modules to be set
	 * @returns {void} set new modules to this chunk and return nothing
	 */
	setModules(modules) {
		this._modules = new SortableSet(modules, sortByIdentifier);
	}

	/**
	 * @returns {number} the amount of modules in chunk
	 */
	getNumberOfModules() {
		return this._modules.size;
	}

	/**
	 * @returns {SortableSet} return the modules SortableSet for this chunk
	 */
	get modulesIterable() {
		return this._modules;
	}

	/**
	 * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added
	 * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully
	 */
	addGroup(chunkGroup) {
		if (this._groups.has(chunkGroup)) return false;
		this._groups.add(chunkGroup);
		return true;
	}

	/**
	 * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from
	 * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed
	 */
	removeGroup(chunkGroup) {
		if (!this._groups.has(chunkGroup)) return false;
		this._groups.delete(chunkGroup);
		return true;
	}

	/**
	 * @param {ChunkGroup} chunkGroup the chunkGroup to check
	 * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup
	 */
	isInGroup(chunkGroup) {
		return this._groups.has(chunkGroup);
	}

	/**
	 * @returns {number} the amount of groups said chunk is in
	 */
	getNumberOfGroups() {
		return this._groups.size;
	}

	/**
	 * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in
	 */
	get groupsIterable() {
		return this._groups;
	}

	/**
	 * @param {Chunk} otherChunk the chunk to compare itself with
	 * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order
	 */
	compareTo(otherChunk) {
		if (this.name && !otherChunk.name) return -1;
		if (!this.name && otherChunk.name) return 1;
		if (this.name < otherChunk.name) return -1;
		if (this.name > otherChunk.name) return 1;
		if (this._modules.size > otherChunk._modules.size) return -1;
		if (this._modules.size < otherChunk._modules.size) return 1;
		this._modules.sort();
		otherChunk._modules.sort();
		const a = this._modules[Symbol.iterator]();
		const b = otherChunk._modules[Symbol.iterator]();
		// eslint-disable-next-line no-constant-condition
		while (true) {
			const aItem = a.next();
			if (aItem.done) return 0;
			const bItem = b.next();
			const aModuleIdentifier = aItem.value.identifier();
			const bModuleIdentifier = bItem.value.identifier();
			if (aModuleIdentifier < bModuleIdentifier) return -1;
			if (aModuleIdentifier > bModuleIdentifier) return 1;
		}
	}

	/**
	 * @param {Module} module Module to check
	 * @returns {boolean} returns true if module does exist in this chunk
	 */
	containsModule(module) {
		return this._modules.has(module);
	}

	/**
	 * @returns {Module[]} an array of modules (do not modify)
	 */
	getModules() {
		return this._modules.getFromCache(getArray);
	}

	getModulesIdent() {
		return this._modules.getFromUnorderedCache(getModulesIdent);
	}

	remove() {
		// cleanup modules
		// Array.from is used here to create a clone, because removeChunk modifies this._modules
		for (const module of Array.from(this._modules)) {
			module.removeChunk(this);
		}
		for (const chunkGroup of this._groups) {
			chunkGroup.removeChunk(this);
		}
	}

	/**
	 *
	 * @param {Module} module module to move
	 * @param {Chunk} otherChunk other chunk to move it to
	 * @returns {void}
	 */
	moveModule(module, otherChunk) {
		GraphHelpers.disconnectChunkAndModule(this, module);
		GraphHelpers.connectChunkAndModule(otherChunk, module);
		module.rewriteChunkInReasons(this, [otherChunk]);
	}

	/**
	 *
	 * @param {Chunk} otherChunk the chunk to integrate with
	 * @param {ModuleReason} reason reason why the module is being integrated
	 * @returns {boolean} returns true or false if integration succeeds or fails
	 */
	integrate(otherChunk, reason) {
		if (!this.canBeIntegrated(otherChunk)) {
			return false;
		}

		// Pick a new name for the integrated chunk
		if (this.name && otherChunk.name) {
			if (this.hasEntryModule() === otherChunk.hasEntryModule()) {
				// When both chunks have entry modules or none have one, use
				// shortest name
				if (this.name.length !== otherChunk.name.length) {
					this.name =
						this.name.length < otherChunk.name.length
							? this.name
							: otherChunk.name;
				} else {
					this.name = this.name < otherChunk.name ? this.name : otherChunk.name;
				}
			} else if (otherChunk.hasEntryModule()) {
				// Pick the name of the chunk with the entry module
				this.name = otherChunk.name;
			}
		} else if (otherChunk.name) {
			this.name = otherChunk.name;
		}

		// Array.from is used here to create a clone, because moveModule modifies otherChunk._modules
		for (const module of Array.from(otherChunk._modules)) {
			otherChunk.moveModule(module, this);
		}
		otherChunk._modules.clear();

		if (otherChunk.entryModule) {
			this.entryModule = otherChunk.entryModule;
		}

		for (const chunkGroup of otherChunk._groups) {
			chunkGroup.replaceChunk(otherChunk, this);
			this.addGroup(chunkGroup);
		}
		otherChunk._groups.clear();

		return true;
	}

	/**
	 * @param {Chunk} newChunk the new chunk that will be split out of the current chunk
	 * @returns {void}
	 */
	split(newChunk) {
		for (const chunkGroup of this._groups) {
			chunkGroup.insertChunk(newChunk, this);
			newChunk.addGroup(chunkGroup);
		}
	}

	isEmpty() {
		return this._modules.size === 0;
	}

	updateHash(hash) {
		hash.update(`${this.id} `);
		hash.update(this.ids ? this.ids.join(",") : "");
		hash.update(`${this.name || ""} `);
		for (const m of this._modules) {
			hash.update(m.hash);
		}
	}

	canBeIntegrated(otherChunk) {
		if (this.preventIntegration || otherChunk.preventIntegration) {
			return false;
		}

		const isAvailable = (a, b) => {
			const queue = new Set(b.groupsIterable);
			for (const chunkGroup of queue) {
				if (a.isInGroup(chunkGroup)) continue;
				if (chunkGroup.isInitial()) return false;
				for (const parent of chunkGroup.parentsIterable) {
					queue.add(parent);
				}
			}
			return true;
		};

		const selfHasRuntime = this.hasRuntime();
		const otherChunkHasRuntime = otherChunk.hasRuntime();

		if (selfHasRuntime !== otherChunkHasRuntime) {
			if (selfHasRuntime) {
				return isAvailable(this, otherChunk);
			} else if (otherChunkHasRuntime) {
				return isAvailable(otherChunk, this);
			} else {
				return false;
			}
		}

		if (this.hasEntryModule() || otherChunk.hasEntryModule()) {
			return false;
		}

		return true;
	}

	/**
	 *
	 * @param {number} size the size
	 * @param {Object} options the options passed in
	 * @returns {number} the multiplier returned
	 */
	addMultiplierAndOverhead(size, options) {
		const overhead =
			typeof options.chunkOverhead === "number" ? options.chunkOverhead : 10000;
		const multiplicator = this.canBeInitial()
			? options.entryChunkMultiplicator || 10
			: 1;

		return size * multiplicator + overhead;
	}

	/**
	 * @returns {number} the size of all modules
	 */
	modulesSize() {
		return this._modules.getFromUnorderedCache(getModulesSize);
	}

	/**
	 * @param {Object} options the size display options
	 * @returns {number} the chunk size
	 */
	size(options) {
		return this.addMultiplierAndOverhead(this.modulesSize(), options);
	}

	/**
	 * @param {Chunk} otherChunk the other chunk
	 * @param {TODO} options the options for this function
	 * @returns {number | false} the size, or false if it can't be integrated
	 */
	integratedSize(otherChunk, options) {
		// Chunk if it's possible to integrate this chunk
		if (!this.canBeIntegrated(otherChunk)) {
			return false;
		}

		let integratedModulesSize = this.modulesSize();
		// only count modules that do not exist in this chunk!
		for (const otherModule of otherChunk._modules) {
			if (!this._modules.has(otherModule)) {
				integratedModulesSize += otherModule.size();
			}
		}

		return this.addMultiplierAndOverhead(integratedModulesSize, options);
	}

	/**
	 * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules
	 * @returns {void}
	 */
	sortModules(sortByFn) {
		this._modules.sortWith(sortByFn || sortModuleById);
	}

	sortItems() {
		this.sortModules();
	}

	/**
	 * @returns {Set<Chunk>} a set of all the async chunks
	 */
	getAllAsyncChunks() {
		const queue = new Set();
		const chunks = new Set();

		const initialChunks = intersect(
			Array.from(this.groupsIterable, g => new Set(g.chunks))
		);

		for (const chunkGroup of this.groupsIterable) {
			for (const child of chunkGroup.childrenIterable) {
				queue.add(child);
			}
		}

		for (const chunkGroup of queue) {
			for (const chunk of chunkGroup.chunks) {
				if (!initialChunks.has(chunk)) {
					chunks.add(chunk);
				}
			}
			for (const child of chunkGroup.childrenIterable) {
				queue.add(child);
			}
		}

		return chunks;
	}

	/**
	 * @typedef {Object} ChunkMaps
	 * @property {Record<string|number, string>} hash
	 * @property {Record<string|number, Record<string, string>>} contentHash
	 * @property {Record<string|number, string>} name
	 */

	/**
	 * @param {boolean} realHash should the full hash or the rendered hash be used
	 * @returns {ChunkMaps} the chunk map information
	 */
	getChunkMaps(realHash) {
		/** @type {Record<string|number, string>} */
		const chunkHashMap = Object.create(null);
		/** @type {Record<string|number, Record<string, string>>} */
		const chunkContentHashMap = Object.create(null);
		/** @type {Record<string|number, string>} */
		const chunkNameMap = Object.create(null);

		for (const chunk of this.getAllAsyncChunks()) {
			chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;
			for (const key of Object.keys(chunk.contentHash)) {
				if (!chunkContentHashMap[key]) {
					chunkContentHashMap[key] = Object.create(null);
				}
				chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];
			}
			if (chunk.name) {
				chunkNameMap[chunk.id] = chunk.name;
			}
		}

		return {
			hash: chunkHashMap,
			contentHash: chunkContentHashMap,
			name: chunkNameMap
		};
	}

	/**
	 * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)
	 */
	getChildIdsByOrders() {
		const lists = new Map();
		for (const group of this.groupsIterable) {
			if (group.chunks[group.chunks.length - 1] === this) {
				for (const childGroup of group.childrenIterable) {
					// TODO webpack 5 remove this check for options
					if (typeof childGroup.options === "object") {
						for (const key of Object.keys(childGroup.options)) {
							if (key.endsWith("Order")) {
								const name = key.substr(0, key.length - "Order".length);
								let list = lists.get(name);
								if (list === undefined) lists.set(name, (list = []));
								list.push({
									order: childGroup.options[key],
									group: childGroup
								});
							}
						}
					}
				}
			}
		}
		const result = Object.create(null);
		for (const [name, list] of lists) {
			list.sort((a, b) => {
				const cmp = b.order - a.order;
				if (cmp !== 0) return cmp;
				// TODO webpack 5 remove this check of compareTo
				if (a.group.compareTo) {
					return a.group.compareTo(b.group);
				}
				return 0;
			});
			result[name] = Array.from(
				list.reduce((set, item) => {
					for (const chunk of item.group.chunks) {
						set.add(chunk.id);
					}
					return set;
				}, new Set())
			);
		}
		return result;
	}

	getChildIdsByOrdersMap(includeDirectChildren) {
		const chunkMaps = Object.create(null);

		const addChildIdsByOrdersToMap = chunk => {
			const data = chunk.getChildIdsByOrders();
			for (const key of Object.keys(data)) {
				let chunkMap = chunkMaps[key];
				if (chunkMap === undefined) {
					chunkMaps[key] = chunkMap = Object.create(null);
				}
				chunkMap[chunk.id] = data[key];
			}
		};

		if (includeDirectChildren) {
			addChildIdsByOrdersToMap(this);
		}

		for (const chunk of this.getAllAsyncChunks()) {
			addChildIdsByOrdersToMap(chunk);
		}

		return chunkMaps;
	}

	/**
	 * @typedef {Object} ChunkModuleMaps
	 * @property {Record<string|number, (string|number)[]>} id
	 * @property {Record<string|number, string>} hash
	 */

	/**
	 * @param {ModuleFilterPredicate} filterFn function used to filter modules
	 * @returns {ChunkModuleMaps} module map information
	 */
	getChunkModuleMaps(filterFn) {
		/** @type {Record<string|number, (string|number)[]>} */
		const chunkModuleIdMap = Object.create(null);
		/** @type {Record<string|number, string>} */
		const chunkModuleHashMap = Object.create(null);

		for (const chunk of this.getAllAsyncChunks()) {
			/** @type {(string|number)[]} */
			let array;
			for (const module of chunk.modulesIterable) {
				if (filterFn(module)) {
					if (array === undefined) {
						array = [];
						chunkModuleIdMap[chunk.id] = array;
					}
					array.push(module.id);
					chunkModuleHashMap[module.id] = module.renderedHash;
				}
			}
			if (array !== undefined) {
				array.sort();
			}
		}

		return {
			id: chunkModuleIdMap,
			hash: chunkModuleHashMap
		};
	}

	/**
	 *
	 * @param {function(Module): boolean} filterFn predicate function used to filter modules
	 * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks
	 * @returns {boolean} return true if module exists in graph
	 */
	hasModuleInGraph(filterFn, filterChunkFn) {
		const queue = new Set(this.groupsIterable);
		const chunksProcessed = new Set();

		for (const chunkGroup of queue) {
			for (const chunk of chunkGroup.chunks) {
				if (!chunksProcessed.has(chunk)) {
					chunksProcessed.add(chunk);
					if (!filterChunkFn || filterChunkFn(chunk)) {
						for (const module of chunk.modulesIterable) {
							if (filterFn(module)) {
								return true;
							}
						}
					}
				}
			}
			for (const child of chunkGroup.childrenIterable) {
				queue.add(child);
			}
		}
		return false;
	}

	toString() {
		return `Chunk[${Array.from(this._modules).join()}]`;
	}
}

// TODO remove in webpack 5
Object.defineProperty(Chunk.prototype, "forEachModule", {
	configurable: false,
	value: util.deprecate(
		/**
		 * @deprecated
		 * @this {Chunk}
		 * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback
		 * @param {ForEachModuleCallback} fn Callback function
		 * @returns {void}
		 */
		function(fn) {
			this._modules.forEach(fn);
		},
		"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead"
	)
});

// TODO remove in webpack 5
Object.defineProperty(Chunk.prototype, "mapModules", {
	configurable: false,
	value: util.deprecate(
		/**
		 * @deprecated
		 * @this {Chunk}
		 * @typedef {function(any, number): any} MapModulesCallback
		 * @param {MapModulesCallback} fn Callback function
		 * @returns {TODO[]} result of mapped modules
		 */
		function(fn) {
			return Array.from(this._modules, fn);
		},
		"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead"
	)
});

// TODO remove in webpack 5
Object.defineProperty(Chunk.prototype, "chunks", {
	configurable: false,
	get() {
		throw new Error("Chunk.chunks: Use ChunkGroup.getChildren() instead");
	},
	set() {
		throw new Error("Chunk.chunks: Use ChunkGroup.add/removeChild() instead");
	}
});

// TODO remove in webpack 5
Object.defineProperty(Chunk.prototype, "parents", {
	configurable: false,
	get() {
		throw new Error("Chunk.parents: Use ChunkGroup.getParents() instead");
	},
	set() {
		throw new Error("Chunk.parents: Use ChunkGroup.add/removeParent() instead");
	}
});

// TODO remove in webpack 5
Object.defineProperty(Chunk.prototype, "blocks", {
	configurable: false,
	get() {
		throw new Error("Chunk.blocks: Use ChunkGroup.getBlocks() instead");
	},
	set() {
		throw new Error("Chunk.blocks: Use ChunkGroup.add/removeBlock() instead");
	}
});

// TODO remove in webpack 5
Object.defineProperty(Chunk.prototype, "entrypoints", {
	configurable: false,
	get() {
		throw new Error(
			"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead"
		);
	},
	set() {
		throw new Error("Chunk.entrypoints: Use Chunks.addGroup instead");
	}
});

module.exports = Chunk;


/***/ }),

/***/ "./node_modules/webpack/lib/ChunkGroup.js":
/*!***********************************!*\
  !*** (webpack)/lib/ChunkGroup.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const SortableSet = __webpack_require__(/*! ./util/SortableSet */ "./node_modules/webpack/lib/util/SortableSet.js");
const compareLocations = __webpack_require__(/*! ./compareLocations */ "./node_modules/webpack/lib/compareLocations.js");

/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./ModuleReason")} ModuleReason */

/** @typedef {{module: Module, loc: TODO, request: string}} OriginRecord */
/** @typedef {string|{name: string}} ChunkGroupOptions */

let debugId = 5000;

/**
 * @template T
 * @param {SortableSet<T>} set set to convert to array.
 * @returns {T[]} the array format of existing set
 */
const getArray = set => Array.from(set);

/**
 * A convenience method used to sort chunks based on their id's
 * @param {ChunkGroup} a first sorting comparator
 * @param {ChunkGroup} b second sorting comparator
 * @returns {1|0|-1} a sorting index to determine order
 */
const sortById = (a, b) => {
	if (a.id < b.id) return -1;
	if (b.id < a.id) return 1;
	return 0;
};

/**
 * @param {OriginRecord} a the first comparator in sort
 * @param {OriginRecord} b the second comparator in sort
 * @returns {1|-1|0} returns sorting order as index
 */
const sortOrigin = (a, b) => {
	const aIdent = a.module ? a.module.identifier() : "";
	const bIdent = b.module ? b.module.identifier() : "";
	if (aIdent < bIdent) return -1;
	if (aIdent > bIdent) return 1;
	return compareLocations(a.loc, b.loc);
};

class ChunkGroup {
	/**
	 * Creates an instance of ChunkGroup.
	 * @param {ChunkGroupOptions=} options chunk group options passed to chunkGroup
	 */
	constructor(options) {
		if (typeof options === "string") {
			options = { name: options };
		} else if (!options) {
			options = { name: undefined };
		}
		/** @type {number} */
		this.groupDebugId = debugId++;
		this.options = options;
		/** @type {SortableSet<ChunkGroup>} */
		this._children = new SortableSet(undefined, sortById);
		this._parents = new SortableSet(undefined, sortById);
		this._blocks = new SortableSet();
		/** @type {Chunk[]} */
		this.chunks = [];
		/** @type {OriginRecord[]} */
		this.origins = [];
		/** Indicies in top-down order */
		/** @private @type {Map<Module, number>} */
		this._moduleIndicies = new Map();
		/** Indicies in bottom-up order */
		/** @private @type {Map<Module, number>} */
		this._moduleIndicies2 = new Map();
	}

	/**
	 * when a new chunk is added to a chunkGroup, addingOptions will occur.
	 * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions
	 * @returns {void}
	 */
	addOptions(options) {
		for (const key of Object.keys(options)) {
			if (this.options[key] === undefined) {
				this.options[key] = options[key];
			} else if (this.options[key] !== options[key]) {
				if (key.endsWith("Order")) {
					this.options[key] = Math.max(this.options[key], options[key]);
				} else {
					throw new Error(
						`ChunkGroup.addOptions: No option merge strategy for ${key}`
					);
				}
			}
		}
	}

	/**
	 * returns the name of current ChunkGroup
	 * @returns {string|undefined} returns the ChunkGroup name
	 */
	get name() {
		return this.options.name;
	}

	/**
	 * sets a new name for current ChunkGroup
	 * @param {string} value the new name for ChunkGroup
	 * @returns {void}
	 */
	set name(value) {
		this.options.name = value;
	}

	/**
	 * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's
	 * @returns {string} a unique concatenation of chunk debugId's
	 */
	get debugId() {
		return Array.from(this.chunks, x => x.debugId).join("+");
	}

	/**
	 * get a unique id for ChunkGroup, made up of its member Chunk id's
	 * @returns {string} a unique concatenation of chunk ids
	 */
	get id() {
		return Array.from(this.chunks, x => x.id).join("+");
	}

	/**
	 * Performs an unshift of a specific chunk
	 * @param {Chunk} chunk chunk being unshifted
	 * @returns {boolean} returns true if attempted chunk shift is accepted
	 */
	unshiftChunk(chunk) {
		const oldIdx = this.chunks.indexOf(chunk);
		if (oldIdx > 0) {
			this.chunks.splice(oldIdx, 1);
			this.chunks.unshift(chunk);
		} else if (oldIdx < 0) {
			this.chunks.unshift(chunk);
			return true;
		}
		return false;
	}

	/**
	 * inserts a chunk before another existing chunk in group
	 * @param {Chunk} chunk Chunk being inserted
	 * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point
	 * @returns {boolean} return true if insertion was successful
	 */
	insertChunk(chunk, before) {
		const oldIdx = this.chunks.indexOf(chunk);
		const idx = this.chunks.indexOf(before);
		if (idx < 0) {
			throw new Error("before chunk not found");
		}
		if (oldIdx >= 0 && oldIdx > idx) {
			this.chunks.splice(oldIdx, 1);
			this.chunks.splice(idx, 0, chunk);
		} else if (oldIdx < 0) {
			this.chunks.splice(idx, 0, chunk);
			return true;
		}
		return false;
	}

	/**
	 * add a chunk into ChunkGroup. Is pushed on or prepended
	 * @param {Chunk} chunk chunk being pushed into ChunkGroupS
	 * @returns {boolean} returns true if chunk addition was ssuccesful.
	 */
	pushChunk(chunk) {
		const oldIdx = this.chunks.indexOf(chunk);
		if (oldIdx >= 0) {
			return false;
		}
		this.chunks.push(chunk);
		return true;
	}

	/**
	 * @param {Chunk} oldChunk chunk to be replaced
	 * @param {Chunk} newChunk New chunkt that will be replaced
	 * @returns {boolean} rerturns true for
	 */
	replaceChunk(oldChunk, newChunk) {
		const oldIdx = this.chunks.indexOf(oldChunk);
		if (oldIdx < 0) return false;
		const newIdx = this.chunks.indexOf(newChunk);
		if (newIdx < 0) {
			this.chunks[oldIdx] = newChunk;
			return true;
		}
		if (newIdx < oldIdx) {
			this.chunks.splice(oldIdx, 1);
			return true;
		} else if (newIdx !== oldIdx) {
			this.chunks[oldIdx] = newChunk;
			this.chunks.splice(newIdx, 1);
			return true;
		}
	}

	removeChunk(chunk) {
		const idx = this.chunks.indexOf(chunk);
		if (idx >= 0) {
			this.chunks.splice(idx, 1);
			return true;
		}
		return false;
	}

	isInitial() {
		return false;
	}

	addChild(chunk) {
		if (this._children.has(chunk)) {
			return false;
		}
		this._children.add(chunk);
		return true;
	}

	getChildren() {
		return this._children.getFromCache(getArray);
	}

	getNumberOfChildren() {
		return this._children.size;
	}

	get childrenIterable() {
		return this._children;
	}

	removeChild(chunk) {
		if (!this._children.has(chunk)) {
			return false;
		}

		this._children.delete(chunk);
		chunk.removeParent(this);
		return true;
	}

	addParent(parentChunk) {
		if (!this._parents.has(parentChunk)) {
			this._parents.add(parentChunk);
			return true;
		}
		return false;
	}

	getParents() {
		return this._parents.getFromCache(getArray);
	}

	setParents(newParents) {
		this._parents.clear();
		for (const p of newParents) {
			this._parents.add(p);
		}
	}

	getNumberOfParents() {
		return this._parents.size;
	}

	hasParent(parent) {
		return this._parents.has(parent);
	}

	get parentsIterable() {
		return this._parents;
	}

	removeParent(chunk) {
		if (this._parents.delete(chunk)) {
			chunk.removeChunk(this);
			return true;
		}
		return false;
	}

	/**
	 * @returns {Array} - an array containing the blocks
	 */
	getBlocks() {
		return this._blocks.getFromCache(getArray);
	}

	getNumberOfBlocks() {
		return this._blocks.size;
	}

	hasBlock(block) {
		return this._blocks.has(block);
	}

	get blocksIterable() {
		return this._blocks;
	}

	addBlock(block) {
		if (!this._blocks.has(block)) {
			this._blocks.add(block);
			return true;
		}
		return false;
	}

	addOrigin(module, loc, request) {
		this.origins.push({
			module,
			loc,
			request
		});
	}

	containsModule(module) {
		for (const chunk of this.chunks) {
			if (chunk.containsModule(module)) return true;
		}
		return false;
	}

	getFiles() {
		const files = new Set();

		for (const chunk of this.chunks) {
			for (const file of chunk.files) {
				files.add(file);
			}
		}

		return Array.from(files);
	}

	/**
	 * @param {ModuleReason} reason reason for removing ChunkGroup
	 * @returns {void}
	 */
	remove(reason) {
		// cleanup parents
		for (const parentChunkGroup of this._parents) {
			// remove this chunk from its parents
			parentChunkGroup._children.delete(this);

			// cleanup "sub chunks"
			for (const chunkGroup of this._children) {
				/**
				 * remove this chunk as "intermediary" and connect
				 * it "sub chunks" and parents directly
				 */
				// add parent to each "sub chunk"
				chunkGroup.addParent(parentChunkGroup);
				// add "sub chunk" to parent
				parentChunkGroup.addChild(chunkGroup);
			}
		}

		/**
		 * we need to iterate again over the children
		 * to remove this from the childs parents.
		 * This can not be done in the above loop
		 * as it is not guaranteed that `this._parents` contains anything.
		 */
		for (const chunkGroup of this._children) {
			// remove this as parent of every "sub chunk"
			chunkGroup._parents.delete(this);
		}

		// cleanup blocks
		for (const block of this._blocks) {
			block.chunkGroup = null;
		}

		// remove chunks
		for (const chunk of this.chunks) {
			chunk.removeGroup(this);
		}
	}

	sortItems() {
		this.origins.sort(sortOrigin);
		this._parents.sort();
		this._children.sort();
	}

	/**
	 * Sorting predicate which allows current ChunkGroup to be compared against another.
	 * Sorting values are based off of number of chunks in ChunkGroup.
	 *
	 * @param {ChunkGroup} otherGroup the chunkGroup to compare this against
	 * @returns {-1|0|1} sort position for comparison
	 */
	compareTo(otherGroup) {
		if (this.chunks.length > otherGroup.chunks.length) return -1;
		if (this.chunks.length < otherGroup.chunks.length) return 1;
		const a = this.chunks[Symbol.iterator]();
		const b = otherGroup.chunks[Symbol.iterator]();
		// eslint-disable-next-line no-constant-condition
		while (true) {
			const aItem = a.next();
			const bItem = b.next();
			if (aItem.done) return 0;
			const cmp = aItem.value.compareTo(bItem.value);
			if (cmp !== 0) return cmp;
		}
	}

	getChildrenByOrders() {
		const lists = new Map();
		for (const childGroup of this._children) {
			// TODO webpack 5 remove this check for options
			if (typeof childGroup.options === "object") {
				for (const key of Object.keys(childGroup.options)) {
					if (key.endsWith("Order")) {
						const name = key.substr(0, key.length - "Order".length);
						let list = lists.get(name);
						if (list === undefined) {
							lists.set(name, (list = []));
						}
						list.push({
							order: childGroup.options[key],
							group: childGroup
						});
					}
				}
			}
		}
		const result = Object.create(null);
		for (const [name, list] of lists) {
			list.sort((a, b) => {
				const cmp = b.order - a.order;
				if (cmp !== 0) return cmp;
				// TODO webpack 5 remove this check of compareTo
				if (a.group.compareTo) {
					return a.group.compareTo(b.group);
				}
				return 0;
			});
			result[name] = list.map(i => i.group);
		}
		return result;
	}

	/**
	 * Sets the top-down index of a module in this ChunkGroup
	 * @param {Module} module module for which the index should be set
	 * @param {number} index the index of the module
	 * @returns {void}
	 */
	setModuleIndex(module, index) {
		this._moduleIndicies.set(module, index);
	}

	/**
	 * Gets the top-down index of a module in this ChunkGroup
	 * @param {Module} module the module
	 * @returns {number} index
	 */
	getModuleIndex(module) {
		return this._moduleIndicies.get(module);
	}

	/**
	 * Sets the bottom-up index of a module in this ChunkGroup
	 * @param {Module} module module for which the index should be set
	 * @param {number} index the index of the module
	 * @returns {void}
	 */
	setModuleIndex2(module, index) {
		this._moduleIndicies2.set(module, index);
	}

	/**
	 * Gets the bottom-up index of a module in this ChunkGroup
	 * @param {Module} module the module
	 * @returns {number} index
	 */
	getModuleIndex2(module) {
		return this._moduleIndicies2.get(module);
	}

	checkConstraints() {
		const chunk = this;
		for (const child of chunk._children) {
			if (!child._parents.has(chunk)) {
				throw new Error(
					`checkConstraints: child missing parent ${chunk.debugId} -> ${
						child.debugId
					}`
				);
			}
		}
		for (const parentChunk of chunk._parents) {
			if (!parentChunk._children.has(chunk)) {
				throw new Error(
					`checkConstraints: parent missing child ${parentChunk.debugId} <- ${
						chunk.debugId
					}`
				);
			}
		}
	}
}

module.exports = ChunkGroup;


/***/ }),

/***/ "./node_modules/webpack/lib/ChunkRenderError.js":
/*!*****************************************!*\
  !*** (webpack)/lib/ChunkRenderError.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

/** @typedef {import("./Chunk")} Chunk */

class ChunkRenderError extends WebpackError {
	/**
	 * Create a new ChunkRenderError
	 * @param {Chunk} chunk A chunk
	 * @param {string} file Related file
	 * @param {Error} error Original error
	 */
	constructor(chunk, file, error) {
		super();

		this.name = "ChunkRenderError";
		this.error = error;
		this.message = error.message;
		this.details = error.stack;
		this.file = file;
		this.chunk = chunk;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ChunkRenderError;


/***/ }),

/***/ "./node_modules/webpack/lib/ChunkTemplate.js":
/*!**************************************!*\
  !*** (webpack)/lib/ChunkTemplate.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { Tapable, SyncWaterfallHook, SyncHook } = __webpack_require__(/*! tapable */ "tapable");

/** @typedef {import("./ModuleTemplate")} ModuleTemplate */
/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./Module")} Module} */
/** @typedef {import("./Dependency").DependencyTemplate} DependencyTemplate} */
/** @typedef {import("./util/createHash").Hash} Hash} */

/**
 * @typedef {Object} RenderManifestOptions
 * @property {Chunk} chunk the chunk used to render
 * @property {string} hash
 * @property {string} fullHash
 * @property {TODO} outputOptions
 * @property {{javascript: ModuleTemplate, webassembly: ModuleTemplate}} moduleTemplates
 * @property {Map<TODO, TODO>} dependencyTemplates
 */

module.exports = class ChunkTemplate extends Tapable {
	constructor(outputOptions) {
		super();
		this.outputOptions = outputOptions || {};
		this.hooks = {
			/** @type {SyncWaterfallHook<TODO[], RenderManifestOptions>} */
			renderManifest: new SyncWaterfallHook(["result", "options"]),
			modules: new SyncWaterfallHook([
				"source",
				"chunk",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			render: new SyncWaterfallHook([
				"source",
				"chunk",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			renderWithEntry: new SyncWaterfallHook(["source", "chunk"]),
			hash: new SyncHook(["hash"]),
			hashForChunk: new SyncHook(["hash", "chunk"])
		};
	}

	/**
	 *
	 * @param {RenderManifestOptions} options render manifest options
	 * @returns {TODO[]} returns render manifest
	 */
	getRenderManifest(options) {
		const result = [];

		this.hooks.renderManifest.call(result, options);

		return result;
	}

	/**
	 * Updates hash with information from this template
	 * @param {Hash} hash the hash to update
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update("ChunkTemplate");
		hash.update("2");
		this.hooks.hash.call(hash);
	}

	/**
	 * TODO webpack 5: remove moduleTemplate and dependencyTemplates
	 * Updates hash with chunk-specific information from this template
	 * @param {Hash} hash the hash to update
	 * @param {Chunk} chunk the chunk
	 * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render
	 * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates
	 * @returns {void}
	 */
	updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {
		this.updateHash(hash);
		this.hooks.hashForChunk.call(hash, chunk);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/CommentCompilationWarning.js":
/*!**************************************************!*\
  !*** (webpack)/lib/CommentCompilationWarning.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

/** @typedef {import("./Module")} Module */

/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */

class CommentCompilationWarning extends WebpackError {
	/**
	 *
	 * @param {string} message warning message
	 * @param {Module} module affected module
	 * @param {DependencyLocation} loc affected lines of code
	 */
	constructor(message, module, loc) {
		super(message);

		this.name = "CommentCompilationWarning";

		this.module = module;
		this.loc = loc;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = CommentCompilationWarning;


/***/ }),

/***/ "./node_modules/webpack/lib/CompatibilityPlugin.js":
/*!********************************************!*\
  !*** (webpack)/lib/CompatibilityPlugin.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");

const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

/** @typedef {import("./Compiler")} Compiler */

class CompatibilityPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler Webpack Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"CompatibilityPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("CompatibilityPlugin", (parser, parserOptions) => {
						if (
							parserOptions.browserify !== undefined &&
							!parserOptions.browserify
						)
							return;

						parser.hooks.call
							.for("require")
							.tap("CompatibilityPlugin", expr => {
								// support for browserify style require delegator: "require(o, !0)"
								if (expr.arguments.length !== 2) return;
								const second = parser.evaluateExpression(expr.arguments[1]);
								if (!second.isBoolean()) return;
								if (second.asBool() !== true) return;
								const dep = new ConstDependency("require", expr.callee.range);
								dep.loc = expr.loc;
								if (parser.state.current.dependencies.length > 1) {
									const last =
										parser.state.current.dependencies[
											parser.state.current.dependencies.length - 1
										];
									if (
										last.critical &&
										last.options &&
										last.options.request === "." &&
										last.userRequest === "." &&
										last.options.recursive
									)
										parser.state.current.dependencies.pop();
								}
								parser.state.current.addDependency(dep);
								return true;
							});
					});
			}
		);
	}
}
module.exports = CompatibilityPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/Compilation.js":
/*!************************************!*\
  !*** (webpack)/lib/Compilation.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
	*/


const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");
const util = __webpack_require__(/*! util */ "util");
const { CachedSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const {
	Tapable,
	SyncHook,
	SyncBailHook,
	SyncWaterfallHook,
	AsyncSeriesHook
} = __webpack_require__(/*! tapable */ "tapable");
const EntryModuleNotFoundError = __webpack_require__(/*! ./EntryModuleNotFoundError */ "./node_modules/webpack/lib/EntryModuleNotFoundError.js");
const ModuleNotFoundError = __webpack_require__(/*! ./ModuleNotFoundError */ "./node_modules/webpack/lib/ModuleNotFoundError.js");
const ModuleDependencyWarning = __webpack_require__(/*! ./ModuleDependencyWarning */ "./node_modules/webpack/lib/ModuleDependencyWarning.js");
const ModuleDependencyError = __webpack_require__(/*! ./ModuleDependencyError */ "./node_modules/webpack/lib/ModuleDependencyError.js");
const ChunkGroup = __webpack_require__(/*! ./ChunkGroup */ "./node_modules/webpack/lib/ChunkGroup.js");
const Chunk = __webpack_require__(/*! ./Chunk */ "./node_modules/webpack/lib/Chunk.js");
const Entrypoint = __webpack_require__(/*! ./Entrypoint */ "./node_modules/webpack/lib/Entrypoint.js");
const MainTemplate = __webpack_require__(/*! ./MainTemplate */ "./node_modules/webpack/lib/MainTemplate.js");
const ChunkTemplate = __webpack_require__(/*! ./ChunkTemplate */ "./node_modules/webpack/lib/ChunkTemplate.js");
const HotUpdateChunkTemplate = __webpack_require__(/*! ./HotUpdateChunkTemplate */ "./node_modules/webpack/lib/HotUpdateChunkTemplate.js");
const ModuleTemplate = __webpack_require__(/*! ./ModuleTemplate */ "./node_modules/webpack/lib/ModuleTemplate.js");
const RuntimeTemplate = __webpack_require__(/*! ./RuntimeTemplate */ "./node_modules/webpack/lib/RuntimeTemplate.js");
const ChunkRenderError = __webpack_require__(/*! ./ChunkRenderError */ "./node_modules/webpack/lib/ChunkRenderError.js");
const AsyncDependencyToInitialChunkError = __webpack_require__(/*! ./AsyncDependencyToInitialChunkError */ "./node_modules/webpack/lib/AsyncDependencyToInitialChunkError.js");
const Stats = __webpack_require__(/*! ./Stats */ "./node_modules/webpack/lib/Stats.js");
const Semaphore = __webpack_require__(/*! ./util/Semaphore */ "./node_modules/webpack/lib/util/Semaphore.js");
const createHash = __webpack_require__(/*! ./util/createHash */ "./node_modules/webpack/lib/util/createHash.js");
const Queue = __webpack_require__(/*! ./util/Queue */ "./node_modules/webpack/lib/util/Queue.js");
const SortableSet = __webpack_require__(/*! ./util/SortableSet */ "./node_modules/webpack/lib/util/SortableSet.js");
const GraphHelpers = __webpack_require__(/*! ./GraphHelpers */ "./node_modules/webpack/lib/GraphHelpers.js");
const ModuleDependency = __webpack_require__(/*! ./dependencies/ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const compareLocations = __webpack_require__(/*! ./compareLocations */ "./node_modules/webpack/lib/compareLocations.js");

/** @typedef {import("./Module")} Module */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./WebpackError")} WebpackError */
/** @typedef {import("./DependenciesBlockVariable")} DependenciesBlockVariable */
/** @typedef {import("./dependencies/SingleEntryDependency")} SingleEntryDependency */
/** @typedef {import("./dependencies/MultiEntryDependency")} MultiEntryDependency */
/** @typedef {import("./dependencies/DllEntryDependency")} DllEntryDependency */
/** @typedef {import("./dependencies/DependencyReference")} DependencyReference */
/** @typedef {import("./DependenciesBlock")} DependenciesBlock */
/** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("./Dependency")} Dependency */
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Dependency").DependencyTemplate} DependencyTemplate */
/** @typedef {import("./util/createHash").Hash} Hash */

// TODO use @callback
/** @typedef {{[assetName: string]: Source}} CompilationAssets */
/** @typedef {(err: Error|null, result?: Module) => void } ModuleCallback */
/** @typedef {(err?: Error|null, result?: Module) => void } ModuleChainCallback */
/** @typedef {(module: Module) => void} OnModuleCallback */
/** @typedef {(err?: Error|null) => void} Callback */
/** @typedef {(d: Dependency) => any} DepBlockVarDependenciesCallback */
/** @typedef {new (...args: any[]) => Dependency} DepConstructor */
/** @typedef {{apply: () => void}} Plugin */

/**
 * @typedef {Object} ModuleFactoryCreateDataContextInfo
 * @property {string} issuer
 * @property {string} compiler
 */

/**
 * @typedef {Object} ModuleFactoryCreateData
 * @property {ModuleFactoryCreateDataContextInfo} contextInfo
 * @property {any=} resolveOptions
 * @property {string} context
 * @property {Dependency[]} dependencies
 */

/**
 * @typedef {Object} ModuleFactory
 * @property {(data: ModuleFactoryCreateData, callback: ModuleCallback) => any} create
 */

/**
 * @typedef {Object} SortedDependency
 * @property {ModuleFactory} factory
 * @property {Dependency[]} dependencies
 */

/**
 * @typedef {Object} DependenciesBlockLike
 * @property {Dependency[]} dependencies
 * @property {AsyncDependenciesBlock[]} blocks
 * @property {DependenciesBlockVariable[]} variables
 */

/**
 * @param {Chunk} a first chunk to sort by id
 * @param {Chunk} b second chunk to sort by id
 * @returns {-1|0|1} sort value
 */
const byId = (a, b) => {
	if (typeof a.id !== typeof b.id) {
		return typeof a.id < typeof b.id ? -1 : 1;
	}
	if (a.id < b.id) return -1;
	if (a.id > b.id) return 1;
	return 0;
};

/**
 * @param {Module} a first module to sort by
 * @param {Module} b second module to sort by
 * @returns {-1|0|1} sort value
 */
const byIdOrIdentifier = (a, b) => {
	if (typeof a.id !== typeof b.id) {
		return typeof a.id < typeof b.id ? -1 : 1;
	}
	if (a.id < b.id) return -1;
	if (a.id > b.id) return 1;
	const identA = a.identifier();
	const identB = b.identifier();
	if (identA < identB) return -1;
	if (identA > identB) return 1;
	return 0;
};

/**
 * @param {Module} a first module to sort by
 * @param {Module} b second module to sort by
 * @returns {-1|0|1} sort value
 */
const byIndexOrIdentifier = (a, b) => {
	if (a.index < b.index) return -1;
	if (a.index > b.index) return 1;
	const identA = a.identifier();
	const identB = b.identifier();
	if (identA < identB) return -1;
	if (identA > identB) return 1;
	return 0;
};

/**
 * @param {Compilation} a first compilation to sort by
 * @param {Compilation} b second compilation to sort by
 * @returns {-1|0|1} sort value
 */
const byNameOrHash = (a, b) => {
	if (a.name < b.name) return -1;
	if (a.name > b.name) return 1;
	if (a.fullHash < b.fullHash) return -1;
	if (a.fullHash > b.fullHash) return 1;
	return 0;
};

/**
 * @template T
 * @param {Set<T>} a first set
 * @param {Set<T>} b second set
 * @returns {number} cmp
 */
const bySetSize = (a, b) => {
	return a.size - b.size;
};

/**
 * @param {DependenciesBlockVariable[]} variables DepBlock Variables to iterate over
 * @param {DepBlockVarDependenciesCallback} fn callback to apply on iterated elements
 * @returns {void}
 */
const iterationBlockVariable = (variables, fn) => {
	for (
		let indexVariable = 0;
		indexVariable < variables.length;
		indexVariable++
	) {
		const varDep = variables[indexVariable].dependencies;
		for (let indexVDep = 0; indexVDep < varDep.length; indexVDep++) {
			fn(varDep[indexVDep]);
		}
	}
};

/**
 * @template T
 * @param {T[]} arr array of elements to iterate over
 * @param {function(T): void} fn callback applied to each element
 * @returns {void}
 */
const iterationOfArrayCallback = (arr, fn) => {
	for (let index = 0; index < arr.length; index++) {
		fn(arr[index]);
	}
};

/**
 * @template T
 * @param {Set<T>} set set to add items to
 * @param {Set<T>} otherSet set to add items from
 * @returns {void}
 */
const addAllToSet = (set, otherSet) => {
	for (const item of otherSet) {
		set.add(item);
	}
};

class Compilation extends Tapable {
	/**
	 * Creates an instance of Compilation.
	 * @param {Compiler} compiler the compiler which created the compilation
	 */
	constructor(compiler) {
		super();
		this.hooks = {
			/** @type {SyncHook<Module>} */
			buildModule: new SyncHook(["module"]),
			/** @type {SyncHook<Module>} */
			rebuildModule: new SyncHook(["module"]),
			/** @type {SyncHook<Module, Error>} */
			failedModule: new SyncHook(["module", "error"]),
			/** @type {SyncHook<Module>} */
			succeedModule: new SyncHook(["module"]),

			/** @type {SyncHook<Dependency, string>} */
			addEntry: new SyncHook(["entry", "name"]),
			/** @type {SyncHook<Dependency, string, Error>} */
			failedEntry: new SyncHook(["entry", "name", "error"]),
			/** @type {SyncHook<Dependency, string, Module>} */
			succeedEntry: new SyncHook(["entry", "name", "module"]),

			/** @type {SyncWaterfallHook<DependencyReference, Dependency, Module>} */
			dependencyReference: new SyncWaterfallHook([
				"dependencyReference",
				"dependency",
				"module"
			]),

			/** @type {SyncHook<Module[]>} */
			finishModules: new SyncHook(["modules"]),
			/** @type {SyncHook<Module>} */
			finishRebuildingModule: new SyncHook(["module"]),
			/** @type {SyncHook} */
			unseal: new SyncHook([]),
			/** @type {SyncHook} */
			seal: new SyncHook([]),

			/** @type {SyncHook} */
			beforeChunks: new SyncHook([]),
			/** @type {SyncHook<Chunk[]>} */
			afterChunks: new SyncHook(["chunks"]),

			/** @type {SyncBailHook<Module[]>} */
			optimizeDependenciesBasic: new SyncBailHook(["modules"]),
			/** @type {SyncBailHook<Module[]>} */
			optimizeDependencies: new SyncBailHook(["modules"]),
			/** @type {SyncBailHook<Module[]>} */
			optimizeDependenciesAdvanced: new SyncBailHook(["modules"]),
			/** @type {SyncBailHook<Module[]>} */
			afterOptimizeDependencies: new SyncHook(["modules"]),

			/** @type {SyncHook} */
			optimize: new SyncHook([]),
			/** @type {SyncBailHook<Module[]>} */
			optimizeModulesBasic: new SyncBailHook(["modules"]),
			/** @type {SyncBailHook<Module[]>} */
			optimizeModules: new SyncBailHook(["modules"]),
			/** @type {SyncBailHook<Module[]>} */
			optimizeModulesAdvanced: new SyncBailHook(["modules"]),
			/** @type {SyncHook<Module[]>} */
			afterOptimizeModules: new SyncHook(["modules"]),

			/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */
			optimizeChunksBasic: new SyncBailHook(["chunks", "chunkGroups"]),
			/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */
			optimizeChunks: new SyncBailHook(["chunks", "chunkGroups"]),
			/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */
			optimizeChunksAdvanced: new SyncBailHook(["chunks", "chunkGroups"]),
			/** @type {SyncHook<Chunk[], ChunkGroup[]>} */
			afterOptimizeChunks: new SyncHook(["chunks", "chunkGroups"]),

			/** @type {AsyncSeriesHook<Chunk[], Module[]>} */
			optimizeTree: new AsyncSeriesHook(["chunks", "modules"]),
			/** @type {SyncHook<Chunk[], Module[]>} */
			afterOptimizeTree: new SyncHook(["chunks", "modules"]),

			/** @type {SyncBailHook<Chunk[], Module[]>} */
			optimizeChunkModulesBasic: new SyncBailHook(["chunks", "modules"]),
			/** @type {SyncBailHook<Chunk[], Module[]>} */
			optimizeChunkModules: new SyncBailHook(["chunks", "modules"]),
			/** @type {SyncBailHook<Chunk[], Module[]>} */
			optimizeChunkModulesAdvanced: new SyncBailHook(["chunks", "modules"]),
			/** @type {SyncHook<Chunk[], Module[]>} */
			afterOptimizeChunkModules: new SyncHook(["chunks", "modules"]),
			/** @type {SyncBailHook} */
			shouldRecord: new SyncBailHook([]),

			/** @type {SyncHook<Module[], any>} */
			reviveModules: new SyncHook(["modules", "records"]),
			/** @type {SyncHook<Module[]>} */
			optimizeModuleOrder: new SyncHook(["modules"]),
			/** @type {SyncHook<Module[]>} */
			advancedOptimizeModuleOrder: new SyncHook(["modules"]),
			/** @type {SyncHook<Module[]>} */
			beforeModuleIds: new SyncHook(["modules"]),
			/** @type {SyncHook<Module[]>} */
			moduleIds: new SyncHook(["modules"]),
			/** @type {SyncHook<Module[]>} */
			optimizeModuleIds: new SyncHook(["modules"]),
			/** @type {SyncHook<Module[]>} */
			afterOptimizeModuleIds: new SyncHook(["modules"]),

			/** @type {SyncHook<Chunk[], any>} */
			reviveChunks: new SyncHook(["chunks", "records"]),
			/** @type {SyncHook<Chunk[]>} */
			optimizeChunkOrder: new SyncHook(["chunks"]),
			/** @type {SyncHook<Chunk[]>} */
			beforeChunkIds: new SyncHook(["chunks"]),
			/** @type {SyncHook<Chunk[]>} */
			optimizeChunkIds: new SyncHook(["chunks"]),
			/** @type {SyncHook<Chunk[]>} */
			afterOptimizeChunkIds: new SyncHook(["chunks"]),

			/** @type {SyncHook<Module[], any>} */
			recordModules: new SyncHook(["modules", "records"]),
			/** @type {SyncHook<Chunk[], any>} */
			recordChunks: new SyncHook(["chunks", "records"]),

			/** @type {SyncHook} */
			beforeHash: new SyncHook([]),
			/** @type {SyncHook<Chunk>} */
			contentHash: new SyncHook(["chunk"]),
			/** @type {SyncHook} */
			afterHash: new SyncHook([]),
			/** @type {SyncHook<any>} */
			recordHash: new SyncHook(["records"]),
			/** @type {SyncHook<Compilation, any>} */
			record: new SyncHook(["compilation", "records"]),

			/** @type {SyncHook} */
			beforeModuleAssets: new SyncHook([]),
			/** @type {SyncBailHook} */
			shouldGenerateChunkAssets: new SyncBailHook([]),
			/** @type {SyncHook} */
			beforeChunkAssets: new SyncHook([]),
			/** @type {SyncHook<Chunk[]>} */
			additionalChunkAssets: new SyncHook(["chunks"]),

			/** @type {AsyncSeriesHook} */
			additionalAssets: new AsyncSeriesHook([]),
			/** @type {AsyncSeriesHook<Chunk[]>} */
			optimizeChunkAssets: new AsyncSeriesHook(["chunks"]),
			/** @type {SyncHook<Chunk[]>} */
			afterOptimizeChunkAssets: new SyncHook(["chunks"]),
			/** @type {AsyncSeriesHook<CompilationAssets>} */
			optimizeAssets: new AsyncSeriesHook(["assets"]),
			/** @type {SyncHook<CompilationAssets>} */
			afterOptimizeAssets: new SyncHook(["assets"]),

			/** @type {SyncBailHook} */
			needAdditionalSeal: new SyncBailHook([]),
			/** @type {AsyncSeriesHook} */
			afterSeal: new AsyncSeriesHook([]),

			/** @type {SyncHook<Chunk, Hash>} */
			chunkHash: new SyncHook(["chunk", "chunkHash"]),
			/** @type {SyncHook<Module, string>} */
			moduleAsset: new SyncHook(["module", "filename"]),
			/** @type {SyncHook<Chunk, string>} */
			chunkAsset: new SyncHook(["chunk", "filename"]),

			/** @type {SyncWaterfallHook<string, TODO>} */
			assetPath: new SyncWaterfallHook(["filename", "data"]), // TODO MainTemplate

			/** @type {SyncBailHook} */
			needAdditionalPass: new SyncBailHook([]),

			/** @type {SyncHook<Compiler, string, number>} */
			childCompiler: new SyncHook([
				"childCompiler",
				"compilerName",
				"compilerIndex"
			]),

			// TODO the following hooks are weirdly located here
			// TODO move them for webpack 5
			/** @type {SyncHook<object, Module>} */
			normalModuleLoader: new SyncHook(["loaderContext", "module"]),

			/** @type {SyncBailHook<Chunk[]>} */
			optimizeExtractedChunksBasic: new SyncBailHook(["chunks"]),
			/** @type {SyncBailHook<Chunk[]>} */
			optimizeExtractedChunks: new SyncBailHook(["chunks"]),
			/** @type {SyncBailHook<Chunk[]>} */
			optimizeExtractedChunksAdvanced: new SyncBailHook(["chunks"]),
			/** @type {SyncHook<Chunk[]>} */
			afterOptimizeExtractedChunks: new SyncHook(["chunks"])
		};
		this._pluginCompat.tap("Compilation", options => {
			switch (options.name) {
				case "optimize-tree":
				case "additional-assets":
				case "optimize-chunk-assets":
				case "optimize-assets":
				case "after-seal":
					options.async = true;
					break;
			}
		});
		/** @type {string=} */
		this.name = undefined;
		/** @type {Compiler} */
		this.compiler = compiler;
		this.resolverFactory = compiler.resolverFactory;
		this.inputFileSystem = compiler.inputFileSystem;
		this.requestShortener = compiler.requestShortener;

		const options = compiler.options;
		this.options = options;
		this.outputOptions = options && options.output;
		/** @type {boolean=} */
		this.bail = options && options.bail;
		this.profile = options && options.profile;
		this.performance = options && options.performance;

		this.mainTemplate = new MainTemplate(this.outputOptions);
		this.chunkTemplate = new ChunkTemplate(this.outputOptions);
		this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(
			this.outputOptions
		);
		this.runtimeTemplate = new RuntimeTemplate(
			this.outputOptions,
			this.requestShortener
		);
		this.moduleTemplates = {
			javascript: new ModuleTemplate(this.runtimeTemplate, "javascript"),
			webassembly: new ModuleTemplate(this.runtimeTemplate, "webassembly")
		};

		this.semaphore = new Semaphore(options.parallelism || 100);

		this.entries = [];
		/** @private @type {{name: string, request: string, module: Module}[]} */
		this._preparedEntrypoints = [];
		this.entrypoints = new Map();
		/** @type {Chunk[]} */
		this.chunks = [];
		/** @type {ChunkGroup[]} */
		this.chunkGroups = [];
		/** @type {Map<string, ChunkGroup>} */
		this.namedChunkGroups = new Map();
		/** @type {Map<string, Chunk>} */
		this.namedChunks = new Map();
		/** @type {Module[]} */
		this.modules = [];
		/** @private @type {Map<string, Module>} */
		this._modules = new Map();
		this.cache = null;
		this.records = null;
		/** @type {string[]} */
		this.additionalChunkAssets = [];
		/** @type {CompilationAssets} */
		this.assets = {};
		/** @type {WebpackError[]} */
		this.errors = [];
		/** @type {WebpackError[]} */
		this.warnings = [];
		/** @type {Compilation[]} */
		this.children = [];
		/** @type {Map<DepConstructor, ModuleFactory>} */
		this.dependencyFactories = new Map();
		/** @type {Map<DepConstructor, DependencyTemplate>} */
		this.dependencyTemplates = new Map();
		// TODO refactor this in webpack 5 to a custom DependencyTemplates class with a hash property
		// @ts-ignore
		this.dependencyTemplates.set("hash", "");
		this.childrenCounters = {};
		/** @type {Set<number|string>} */
		this.usedChunkIds = null;
		/** @type {Set<number>} */
		this.usedModuleIds = null;
		/** @type {Map<string, number>=} */
		this.fileTimestamps = undefined;
		/** @type {Map<string, number>=} */
		this.contextTimestamps = undefined;
		/** @type {Set<string>=} */
		this.compilationDependencies = undefined;
		/** @private @type {Map<Module, Callback[]>} */
		this._buildingModules = new Map();
		/** @private @type {Map<Module, Callback[]>} */
		this._rebuildingModules = new Map();
		/** @type {Set<string>} */
		this.emittedAssets = new Set();
	}

	getStats() {
		return new Stats(this);
	}

	/**
	 * @typedef {Object} AddModuleResult
	 * @property {Module} module the added or existing module
	 * @property {boolean} issuer was this the first request for this module
	 * @property {boolean} build should the module be build
	 * @property {boolean} dependencies should dependencies be walked
	 */

	/**
	 * @param {Module} module module to be added that was created
	 * @param {any=} cacheGroup cacheGroup it is apart of
	 * @returns {AddModuleResult} returns meta about whether or not the module had built
	 * had an issuer, or any dependnecies
	 */
	addModule(module, cacheGroup) {
		const identifier = module.identifier();
		const alreadyAddedModule = this._modules.get(identifier);
		if (alreadyAddedModule) {
			return {
				module: alreadyAddedModule,
				issuer: false,
				build: false,
				dependencies: false
			};
		}
		const cacheName = (cacheGroup || "m") + identifier;
		if (this.cache && this.cache[cacheName]) {
			const cacheModule = this.cache[cacheName];

			if (typeof cacheModule.updateCacheModule === "function") {
				cacheModule.updateCacheModule(module);
			}

			let rebuild = true;
			if (this.fileTimestamps && this.contextTimestamps) {
				rebuild = cacheModule.needRebuild(
					this.fileTimestamps,
					this.contextTimestamps
				);
			}

			if (!rebuild) {
				cacheModule.disconnect();
				this._modules.set(identifier, cacheModule);
				this.modules.push(cacheModule);
				for (const err of cacheModule.errors) {
					this.errors.push(err);
				}
				for (const err of cacheModule.warnings) {
					this.warnings.push(err);
				}
				return {
					module: cacheModule,
					issuer: true,
					build: false,
					dependencies: true
				};
			}
			cacheModule.unbuild();
			module = cacheModule;
		}
		this._modules.set(identifier, module);
		if (this.cache) {
			this.cache[cacheName] = module;
		}
		this.modules.push(module);
		return {
			module: module,
			issuer: true,
			build: true,
			dependencies: true
		};
	}

	/**
	 * Fetches a module from a compilation by its identifier
	 * @param {Module} module the module provided
	 * @returns {Module} the module requested
	 */
	getModule(module) {
		const identifier = module.identifier();
		return this._modules.get(identifier);
	}

	/**
	 * Attempts to search for a module by its identifier
	 * @param {string} identifier identifier (usually path) for module
	 * @returns {Module|undefined} attempt to search for module and return it, else undefined
	 */
	findModule(identifier) {
		return this._modules.get(identifier);
	}

	/**
	 * @param {Module} module module with its callback list
	 * @param {Callback} callback the callback function
	 * @returns {void}
	 */
	waitForBuildingFinished(module, callback) {
		let callbackList = this._buildingModules.get(module);
		if (callbackList) {
			callbackList.push(() => callback());
		} else {
			process.nextTick(callback);
		}
	}

	/**
	 * Builds the module object
	 *
	 * @param {Module} module module to be built
	 * @param {boolean} optional optional flag
	 * @param {Module=} origin origin module this module build was requested from
	 * @param {Dependency[]=} dependencies optional dependencies from the module to be built
	 * @param {TODO} thisCallback the callback
	 * @returns {TODO} returns the callback function with results
	 */
	buildModule(module, optional, origin, dependencies, thisCallback) {
		let callbackList = this._buildingModules.get(module);
		if (callbackList) {
			callbackList.push(thisCallback);
			return;
		}
		this._buildingModules.set(module, (callbackList = [thisCallback]));

		const callback = err => {
			this._buildingModules.delete(module);
			for (const cb of callbackList) {
				cb(err);
			}
		};

		this.hooks.buildModule.call(module);
		module.build(
			this.options,
			this,
			this.resolverFactory.get("normal", module.resolveOptions),
			this.inputFileSystem,
			error => {
				const errors = module.errors;
				for (let indexError = 0; indexError < errors.length; indexError++) {
					const err = errors[indexError];
					err.origin = origin;
					err.dependencies = dependencies;
					if (optional) {
						this.warnings.push(err);
					} else {
						this.errors.push(err);
					}
				}

				const warnings = module.warnings;
				for (
					let indexWarning = 0;
					indexWarning < warnings.length;
					indexWarning++
				) {
					const war = warnings[indexWarning];
					war.origin = origin;
					war.dependencies = dependencies;
					this.warnings.push(war);
				}
				const originalMap = module.dependencies.reduce((map, v, i) => {
					map.set(v, i);
					return map;
				}, new Map());
				module.dependencies.sort((a, b) => {
					const cmp = compareLocations(a.loc, b.loc);
					if (cmp) return cmp;
					return originalMap.get(a) - originalMap.get(b);
				});
				if (error) {
					this.hooks.failedModule.call(module, error);
					return callback(error);
				}
				this.hooks.succeedModule.call(module);
				return callback();
			}
		);
	}

	/**
	 * @param {Module} module to be processed for deps
	 * @param {ModuleCallback} callback callback to be triggered
	 * @returns {void}
	 */
	processModuleDependencies(module, callback) {
		const dependencies = new Map();

		const addDependency = dep => {
			const resourceIdent = dep.getResourceIdentifier();
			if (resourceIdent) {
				const factory = this.dependencyFactories.get(dep.constructor);
				if (factory === undefined) {
					throw new Error(
						`No module factory available for dependency type: ${
							dep.constructor.name
						}`
					);
				}
				let innerMap = dependencies.get(factory);
				if (innerMap === undefined) {
					dependencies.set(factory, (innerMap = new Map()));
				}
				let list = innerMap.get(resourceIdent);
				if (list === undefined) innerMap.set(resourceIdent, (list = []));
				list.push(dep);
			}
		};

		const addDependenciesBlock = block => {
			if (block.dependencies) {
				iterationOfArrayCallback(block.dependencies, addDependency);
			}
			if (block.blocks) {
				iterationOfArrayCallback(block.blocks, addDependenciesBlock);
			}
			if (block.variables) {
				iterationBlockVariable(block.variables, addDependency);
			}
		};

		try {
			addDependenciesBlock(module);
		} catch (e) {
			callback(e);
		}

		const sortedDependencies = [];

		for (const pair1 of dependencies) {
			for (const pair2 of pair1[1]) {
				sortedDependencies.push({
					factory: pair1[0],
					dependencies: pair2[1]
				});
			}
		}

		this.addModuleDependencies(
			module,
			sortedDependencies,
			this.bail,
			null,
			true,
			callback
		);
	}

	/**
	 * @param {Module} module module to add deps to
	 * @param {SortedDependency[]} dependencies set of sorted dependencies to iterate through
	 * @param {(boolean|null)=} bail whether to bail or not
	 * @param {TODO} cacheGroup optional cacheGroup
	 * @param {boolean} recursive whether it is recursive traversal
	 * @param {function} callback callback for when dependencies are finished being added
	 * @returns {void}
	 */
	addModuleDependencies(
		module,
		dependencies,
		bail,
		cacheGroup,
		recursive,
		callback
	) {
		const start = this.profile && Date.now();
		const currentProfile = this.profile && {};

		asyncLib.forEach(
			dependencies,
			(item, callback) => {
				const dependencies = item.dependencies;

				const errorAndCallback = err => {
					err.origin = module;
					err.dependencies = dependencies;
					this.errors.push(err);
					if (bail) {
						callback(err);
					} else {
						callback();
					}
				};
				const warningAndCallback = err => {
					err.origin = module;
					this.warnings.push(err);
					callback();
				};

				const semaphore = this.semaphore;
				semaphore.acquire(() => {
					const factory = item.factory;
					factory.create(
						{
							contextInfo: {
								issuer: module.nameForCondition && module.nameForCondition(),
								compiler: this.compiler.name
							},
							resolveOptions: module.resolveOptions,
							context: module.context,
							dependencies: dependencies
						},
						(err, dependentModule) => {
							let afterFactory;

							const isOptional = () => {
								return dependencies.every(d => d.optional);
							};

							const errorOrWarningAndCallback = err => {
								if (isOptional()) {
									return warningAndCallback(err);
								} else {
									return errorAndCallback(err);
								}
							};

							if (err) {
								semaphore.release();
								return errorOrWarningAndCallback(
									new ModuleNotFoundError(module, err)
								);
							}
							if (!dependentModule) {
								semaphore.release();
								return process.nextTick(callback);
							}
							if (currentProfile) {
								afterFactory = Date.now();
								currentProfile.factory = afterFactory - start;
							}

							const iterationDependencies = depend => {
								for (let index = 0; index < depend.length; index++) {
									const dep = depend[index];
									dep.module = dependentModule;
									dependentModule.addReason(module, dep);
								}
							};

							const addModuleResult = this.addModule(
								dependentModule,
								cacheGroup
							);
							dependentModule = addModuleResult.module;
							iterationDependencies(dependencies);

							const afterBuild = () => {
								if (currentProfile) {
									const afterBuilding = Date.now();
									currentProfile.building = afterBuilding - afterFactory;
								}

								if (recursive && addModuleResult.dependencies) {
									this.processModuleDependencies(dependentModule, callback);
								} else {
									return callback();
								}
							};

							if (addModuleResult.issuer) {
								if (currentProfile) {
									dependentModule.profile = currentProfile;
								}

								dependentModule.issuer = module;
							} else {
								if (this.profile) {
									if (module.profile) {
										const time = Date.now() - start;
										if (
											!module.profile.dependencies ||
											time > module.profile.dependencies
										) {
											module.profile.dependencies = time;
										}
									}
								}
							}

							if (addModuleResult.build) {
								this.buildModule(
									dependentModule,
									isOptional(),
									module,
									dependencies,
									err => {
										if (err) {
											semaphore.release();
											return errorOrWarningAndCallback(err);
										}

										if (currentProfile) {
											const afterBuilding = Date.now();
											currentProfile.building = afterBuilding - afterFactory;
										}

										semaphore.release();
										afterBuild();
									}
								);
							} else {
								semaphore.release();
								this.waitForBuildingFinished(dependentModule, afterBuild);
							}
						}
					);
				});
			},
			err => {
				// In V8, the Error objects keep a reference to the functions on the stack. These warnings &
				// errors are created inside closures that keep a reference to the Compilation, so errors are
				// leaking the Compilation object.

				if (err) {
					// eslint-disable-next-line no-self-assign
					err.stack = err.stack;
					return callback(err);
				}

				return process.nextTick(callback);
			}
		);
	}

	/**
	 *
	 * @param {string} context context string path
	 * @param {Dependency} dependency dependency used to create Module chain
	 * @param {OnModuleCallback} onModule function invoked on modules creation
	 * @param {ModuleChainCallback} callback callback for when module chain is complete
	 * @returns {void} will throw if dependency instance is not a valid Dependency
	 */
	_addModuleChain(context, dependency, onModule, callback) {
		const start = this.profile && Date.now();
		const currentProfile = this.profile && {};

		const errorAndCallback = this.bail
			? err => {
					callback(err);
			  }
			: err => {
					err.dependencies = [dependency];
					this.errors.push(err);
					callback();
			  };

		if (
			typeof dependency !== "object" ||
			dependency === null ||
			!dependency.constructor
		) {
			throw new Error("Parameter 'dependency' must be a Dependency");
		}
		const Dep = /** @type {DepConstructor} */ (dependency.constructor);
		const moduleFactory = this.dependencyFactories.get(Dep);
		if (!moduleFactory) {
			throw new Error(
				`No dependency factory available for this dependency type: ${
					dependency.constructor.name
				}`
			);
		}

		this.semaphore.acquire(() => {
			moduleFactory.create(
				{
					contextInfo: {
						issuer: "",
						compiler: this.compiler.name
					},
					context: context,
					dependencies: [dependency]
				},
				(err, module) => {
					if (err) {
						this.semaphore.release();
						return errorAndCallback(new EntryModuleNotFoundError(err));
					}

					let afterFactory;

					if (currentProfile) {
						afterFactory = Date.now();
						currentProfile.factory = afterFactory - start;
					}

					const addModuleResult = this.addModule(module);
					module = addModuleResult.module;

					onModule(module);

					dependency.module = module;
					module.addReason(null, dependency);

					const afterBuild = () => {
						if (currentProfile) {
							const afterBuilding = Date.now();
							currentProfile.building = afterBuilding - afterFactory;
						}

						if (addModuleResult.dependencies) {
							this.processModuleDependencies(module, err => {
								if (err) return callback(err);
								callback(null, module);
							});
						} else {
							return callback(null, module);
						}
					};

					if (addModuleResult.issuer) {
						if (currentProfile) {
							module.profile = currentProfile;
						}
					}

					if (addModuleResult.build) {
						this.buildModule(module, false, null, null, err => {
							if (err) {
								this.semaphore.release();
								return errorAndCallback(err);
							}

							if (currentProfile) {
								const afterBuilding = Date.now();
								currentProfile.building = afterBuilding - afterFactory;
							}

							this.semaphore.release();
							afterBuild();
						});
					} else {
						this.semaphore.release();
						this.waitForBuildingFinished(module, afterBuild);
					}
				}
			);
		});
	}

	/**
	 *
	 * @param {string} context context path for entry
	 * @param {Dependency} entry entry dependency being created
	 * @param {string} name name of entry
	 * @param {ModuleCallback} callback callback function
	 * @returns {void} returns
	 */
	addEntry(context, entry, name, callback) {
		this.hooks.addEntry.call(entry, name);

		const slot = {
			name: name,
			// TODO webpack 5 remove `request`
			request: null,
			module: null
		};

		if (entry instanceof ModuleDependency) {
			slot.request = entry.request;
		}

		// TODO webpack 5: merge modules instead when multiple entry modules are supported
		const idx = this._preparedEntrypoints.findIndex(slot => slot.name === name);
		if (idx >= 0) {
			// Overwrite existing entrypoint
			this._preparedEntrypoints[idx] = slot;
		} else {
			this._preparedEntrypoints.push(slot);
		}
		this._addModuleChain(
			context,
			entry,
			module => {
				this.entries.push(module);
			},
			(err, module) => {
				if (err) {
					this.hooks.failedEntry.call(entry, name, err);
					return callback(err);
				}

				if (module) {
					slot.module = module;
				} else {
					const idx = this._preparedEntrypoints.indexOf(slot);
					if (idx >= 0) {
						this._preparedEntrypoints.splice(idx, 1);
					}
				}
				this.hooks.succeedEntry.call(entry, name, module);
				return callback(null, module);
			}
		);
	}

	/**
	 * @param {string} context context path string
	 * @param {Dependency} dependency dep used to create module
	 * @param {ModuleCallback} callback module callback sending module up a level
	 * @returns {void}
	 */
	prefetch(context, dependency, callback) {
		this._addModuleChain(
			context,
			dependency,
			module => {
				module.prefetched = true;
			},
			callback
		);
	}

	/**
	 * @param {Module} module module to be rebuilt
	 * @param {Callback} thisCallback callback when module finishes rebuilding
	 * @returns {void}
	 */
	rebuildModule(module, thisCallback) {
		let callbackList = this._rebuildingModules.get(module);
		if (callbackList) {
			callbackList.push(thisCallback);
			return;
		}
		this._rebuildingModules.set(module, (callbackList = [thisCallback]));

		const callback = err => {
			this._rebuildingModules.delete(module);
			for (const cb of callbackList) {
				cb(err);
			}
		};

		this.hooks.rebuildModule.call(module);
		const oldDependencies = module.dependencies.slice();
		const oldVariables = module.variables.slice();
		const oldBlocks = module.blocks.slice();
		module.unbuild();
		this.buildModule(module, false, module, null, err => {
			if (err) {
				this.hooks.finishRebuildingModule.call(module);
				return callback(err);
			}

			this.processModuleDependencies(module, err => {
				if (err) return callback(err);
				this.removeReasonsOfDependencyBlock(module, {
					dependencies: oldDependencies,
					variables: oldVariables,
					blocks: oldBlocks
				});
				this.hooks.finishRebuildingModule.call(module);
				callback();
			});
		});
	}

	finish() {
		const modules = this.modules;
		this.hooks.finishModules.call(modules);

		for (let index = 0; index < modules.length; index++) {
			const module = modules[index];
			this.reportDependencyErrorsAndWarnings(module, [module]);
		}
	}

	unseal() {
		this.hooks.unseal.call();
		this.chunks.length = 0;
		this.chunkGroups.length = 0;
		this.namedChunks.clear();
		this.namedChunkGroups.clear();
		this.additionalChunkAssets.length = 0;
		this.assets = {};
		for (const module of this.modules) {
			module.unseal();
		}
	}

	/**
	 * @param {Callback} callback signals when the seal method is finishes
	 * @returns {void}
	 */
	seal(callback) {
		this.hooks.seal.call();

		while (
			this.hooks.optimizeDependenciesBasic.call(this.modules) ||
			this.hooks.optimizeDependencies.call(this.modules) ||
			this.hooks.optimizeDependenciesAdvanced.call(this.modules)
		) {
			/* empty */
		}
		this.hooks.afterOptimizeDependencies.call(this.modules);

		this.hooks.beforeChunks.call();
		for (const preparedEntrypoint of this._preparedEntrypoints) {
			const module = preparedEntrypoint.module;
			const name = preparedEntrypoint.name;
			const chunk = this.addChunk(name);
			const entrypoint = new Entrypoint(name);
			entrypoint.setRuntimeChunk(chunk);
			entrypoint.addOrigin(null, name, preparedEntrypoint.request);
			this.namedChunkGroups.set(name, entrypoint);
			this.entrypoints.set(name, entrypoint);
			this.chunkGroups.push(entrypoint);

			GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);
			GraphHelpers.connectChunkAndModule(chunk, module);

			chunk.entryModule = module;
			chunk.name = name;

			this.assignDepth(module);
		}
		this.processDependenciesBlocksForChunkGroups(this.chunkGroups.slice());
		this.sortModules(this.modules);
		this.hooks.afterChunks.call(this.chunks);

		this.hooks.optimize.call();

		while (
			this.hooks.optimizeModulesBasic.call(this.modules) ||
			this.hooks.optimizeModules.call(this.modules) ||
			this.hooks.optimizeModulesAdvanced.call(this.modules)
		) {
			/* empty */
		}
		this.hooks.afterOptimizeModules.call(this.modules);

		while (
			this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) ||
			this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) ||
			this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)
		) {
			/* empty */
		}
		this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);

		this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err => {
			if (err) {
				return callback(err);
			}

			this.hooks.afterOptimizeTree.call(this.chunks, this.modules);

			while (
				this.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) ||
				this.hooks.optimizeChunkModules.call(this.chunks, this.modules) ||
				this.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)
			) {
				/* empty */
			}
			this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);

			const shouldRecord = this.hooks.shouldRecord.call() !== false;

			this.hooks.reviveModules.call(this.modules, this.records);
			this.hooks.optimizeModuleOrder.call(this.modules);
			this.hooks.advancedOptimizeModuleOrder.call(this.modules);
			this.hooks.beforeModuleIds.call(this.modules);
			this.hooks.moduleIds.call(this.modules);
			this.applyModuleIds();
			this.hooks.optimizeModuleIds.call(this.modules);
			this.hooks.afterOptimizeModuleIds.call(this.modules);

			this.sortItemsWithModuleIds();

			this.hooks.reviveChunks.call(this.chunks, this.records);
			this.hooks.optimizeChunkOrder.call(this.chunks);
			this.hooks.beforeChunkIds.call(this.chunks);
			this.applyChunkIds();
			this.hooks.optimizeChunkIds.call(this.chunks);
			this.hooks.afterOptimizeChunkIds.call(this.chunks);

			this.sortItemsWithChunkIds();

			if (shouldRecord) {
				this.hooks.recordModules.call(this.modules, this.records);
				this.hooks.recordChunks.call(this.chunks, this.records);
			}

			this.hooks.beforeHash.call();
			this.createHash();
			this.hooks.afterHash.call();

			if (shouldRecord) {
				this.hooks.recordHash.call(this.records);
			}

			this.hooks.beforeModuleAssets.call();
			this.createModuleAssets();
			if (this.hooks.shouldGenerateChunkAssets.call() !== false) {
				this.hooks.beforeChunkAssets.call();
				this.createChunkAssets();
			}
			this.hooks.additionalChunkAssets.call(this.chunks);
			this.summarizeDependencies();
			if (shouldRecord) {
				this.hooks.record.call(this, this.records);
			}

			this.hooks.additionalAssets.callAsync(err => {
				if (err) {
					return callback(err);
				}
				this.hooks.optimizeChunkAssets.callAsync(this.chunks, err => {
					if (err) {
						return callback(err);
					}
					this.hooks.afterOptimizeChunkAssets.call(this.chunks);
					this.hooks.optimizeAssets.callAsync(this.assets, err => {
						if (err) {
							return callback(err);
						}
						this.hooks.afterOptimizeAssets.call(this.assets);
						if (this.hooks.needAdditionalSeal.call()) {
							this.unseal();
							return this.seal(callback);
						}
						return this.hooks.afterSeal.callAsync(callback);
					});
				});
			});
		});
	}

	/**
	 * @param {Module[]} modules the modules array on compilation to perform the sort for
	 * @returns {void}
	 */
	sortModules(modules) {
		// TODO webpack 5: this should only be enabled when `moduleIds: "natural"`
		// TODO move it into a plugin (NaturalModuleIdsPlugin) and use this in WebpackOptionsApply
		// TODO remove this method
		modules.sort(byIndexOrIdentifier);
	}

	/**
	 * @param {Module} module moulde to report from
	 * @param {DependenciesBlock[]} blocks blocks to report from
	 * @returns {void}
	 */
	reportDependencyErrorsAndWarnings(module, blocks) {
		for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
			const block = blocks[indexBlock];
			const dependencies = block.dependencies;

			for (let indexDep = 0; indexDep < dependencies.length; indexDep++) {
				const d = dependencies[indexDep];

				const warnings = d.getWarnings();
				if (warnings) {
					for (let indexWar = 0; indexWar < warnings.length; indexWar++) {
						const w = warnings[indexWar];

						const warning = new ModuleDependencyWarning(module, w, d.loc);
						this.warnings.push(warning);
					}
				}
				const errors = d.getErrors();
				if (errors) {
					for (let indexErr = 0; indexErr < errors.length; indexErr++) {
						const e = errors[indexErr];

						const error = new ModuleDependencyError(module, e, d.loc);
						this.errors.push(error);
					}
				}
			}

			this.reportDependencyErrorsAndWarnings(module, block.blocks);
		}
	}

	/**
	 * @param {TODO} groupOptions options for the chunk group
	 * @param {Module} module the module the references the chunk group
	 * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)
	 * @param {string} request the request from which the the chunk group is referenced
	 * @returns {ChunkGroup} the new or existing chunk group
	 */
	addChunkInGroup(groupOptions, module, loc, request) {
		if (typeof groupOptions === "string") {
			groupOptions = { name: groupOptions };
		}
		const name = groupOptions.name;
		if (name) {
			const chunkGroup = this.namedChunkGroups.get(name);
			if (chunkGroup !== undefined) {
				chunkGroup.addOptions(groupOptions);
				if (module) {
					chunkGroup.addOrigin(module, loc, request);
				}
				return chunkGroup;
			}
		}
		const chunkGroup = new ChunkGroup(groupOptions);
		if (module) chunkGroup.addOrigin(module, loc, request);
		const chunk = this.addChunk(name);

		GraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);

		this.chunkGroups.push(chunkGroup);
		if (name) {
			this.namedChunkGroups.set(name, chunkGroup);
		}
		return chunkGroup;
	}

	/**
	 * This method first looks to see if a name is provided for a new chunk,
	 * and first looks to see if any named chunks already exist and reuse that chunk instead.
	 *
	 * @param {string=} name optional chunk name to be provided
	 * @returns {Chunk} create a chunk (invoked during seal event)
	 */
	addChunk(name) {
		if (name) {
			const chunk = this.namedChunks.get(name);
			if (chunk !== undefined) {
				return chunk;
			}
		}
		const chunk = new Chunk(name);
		this.chunks.push(chunk);
		if (name) {
			this.namedChunks.set(name, chunk);
		}
		return chunk;
	}

	/**
	 * @param {Module} module module to assign depth
	 * @returns {void}
	 */
	assignDepth(module) {
		const queue = new Set([module]);
		let depth;

		module.depth = 0;

		/**
		 * @param {Module} module module for processeing
		 * @returns {void}
		 */
		const enqueueJob = module => {
			const d = module.depth;
			if (typeof d === "number" && d <= depth) return;
			queue.add(module);
			module.depth = depth;
		};

		/**
		 * @param {Dependency} dependency dependency to assign depth to
		 * @returns {void}
		 */
		const assignDepthToDependency = dependency => {
			if (dependency.module) {
				enqueueJob(dependency.module);
			}
		};

		/**
		 * @param {DependenciesBlock} block block to assign depth to
		 * @returns {void}
		 */
		const assignDepthToDependencyBlock = block => {
			if (block.variables) {
				iterationBlockVariable(block.variables, assignDepthToDependency);
			}

			if (block.dependencies) {
				iterationOfArrayCallback(block.dependencies, assignDepthToDependency);
			}

			if (block.blocks) {
				iterationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);
			}
		};

		for (module of queue) {
			queue.delete(module);
			depth = module.depth;

			depth++;
			assignDepthToDependencyBlock(module);
		}
	}

	/**
	 * @param {Module} module the module containing the dependency
	 * @param {Dependency} dependency the dependency
	 * @returns {DependencyReference} a reference for the dependency
	 */
	getDependencyReference(module, dependency) {
		// TODO remove dep.getReference existence check in webpack 5
		if (typeof dependency.getReference !== "function") return null;
		const ref = dependency.getReference();
		if (!ref) return null;
		return this.hooks.dependencyReference.call(ref, dependency, module);
	}

	/**
	 * This method creates the Chunk graph from the Module graph
	 * @private
	 * @param {TODO[]} inputChunkGroups chunk groups which are processed
	 * @returns {void}
	 */
	processDependenciesBlocksForChunkGroups(inputChunkGroups) {
		// Process is splitting into two parts:
		// Part one traverse the module graph and builds a very basic chunks graph
		//   in chunkDependencies.
		// Part two traverse every possible way through the basic chunk graph and
		//   tracks the available modules. While traversing it connects chunks with
		//   eachother and Blocks with Chunks. It stops traversing when all modules
		//   for a chunk are already available. So it doesn't connect unneeded chunks.

		/** @type {Map<ChunkGroup, {block: AsyncDependenciesBlock, chunkGroup: ChunkGroup, couldBeFiltered: boolean}[]>} */
		const chunkDependencies = new Map();
		const allCreatedChunkGroups = new Set();

		// PREPARE
		/** @type {Map<DependenciesBlock, { modules: Module[], blocks: AsyncDependenciesBlock[]}>} */
		const blockInfoMap = new Map();

		/**
		 * @param {Dependency} d dependency to iterate over
		 * @returns {void}
		 */
		const iteratorDependency = d => {
			// We skip Dependencies without Reference
			const ref = this.getDependencyReference(currentModule, d);
			if (!ref) {
				return;
			}
			// We skip Dependencies without Module pointer
			const refModule = ref.module;
			if (!refModule) {
				return;
			}
			// We skip weak Dependencies
			if (ref.weak) {
				return;
			}

			blockInfoModules.add(refModule);
		};

		/**
		 * @param {AsyncDependenciesBlock} b blocks to prepare
		 * @returns {void}
		 */
		const iteratorBlockPrepare = b => {
			blockInfoBlocks.push(b);
			blockQueue.push(b);
		};

		/** @type {Module} */
		let currentModule;
		/** @type {DependenciesBlock} */
		let block;
		/** @type {DependenciesBlock[]} */
		let blockQueue;
		/** @type {Set<Module>} */
		let blockInfoModules;
		/** @type {AsyncDependenciesBlock[]} */
		let blockInfoBlocks;

		for (const module of this.modules) {
			blockQueue = [module];
			currentModule = module;
			while (blockQueue.length > 0) {
				block = blockQueue.pop();
				blockInfoModules = new Set();
				blockInfoBlocks = [];

				if (block.variables) {
					iterationBlockVariable(block.variables, iteratorDependency);
				}

				if (block.dependencies) {
					iterationOfArrayCallback(block.dependencies, iteratorDependency);
				}

				if (block.blocks) {
					iterationOfArrayCallback(block.blocks, iteratorBlockPrepare);
				}

				const blockInfo = {
					modules: Array.from(blockInfoModules),
					blocks: blockInfoBlocks
				};
				blockInfoMap.set(block, blockInfo);
			}
		}

		// PART ONE

		/** @type {Map<ChunkGroup, { index: number, index2: number }>} */
		const chunkGroupCounters = new Map();
		for (const chunkGroup of inputChunkGroups) {
			chunkGroupCounters.set(chunkGroup, { index: 0, index2: 0 });
		}

		let nextFreeModuleIndex = 0;
		let nextFreeModuleIndex2 = 0;

		/** @type {Map<DependenciesBlock, ChunkGroup>} */
		const blockChunkGroups = new Map();

		/** @type {Set<DependenciesBlock>} */
		const blocksWithNestedBlocks = new Set();

		const ADD_AND_ENTER_MODULE = 0;
		const ENTER_MODULE = 1;
		const PROCESS_BLOCK = 2;
		const LEAVE_MODULE = 3;

		/**
		 * @typedef {Object} QueueItem
		 * @property {number} action
		 * @property {DependenciesBlock} block
		 * @property {Module} module
		 * @property {Chunk} chunk
		 * @property {ChunkGroup} chunkGroup
		 */

		/**
		 * @param {ChunkGroup} chunkGroup chunk group
		 * @returns {QueueItem} queue item
		 */
		const chunkGroupToQueueItem = chunkGroup => ({
			action: ENTER_MODULE,
			block: chunkGroup.chunks[0].entryModule,
			module: chunkGroup.chunks[0].entryModule,
			chunk: chunkGroup.chunks[0],
			chunkGroup
		});

		// Start with the provided modules/chunks
		/** @type {QueueItem[]} */
		let queue = inputChunkGroups.map(chunkGroupToQueueItem).reverse();
		/** @type {QueueItem[]} */
		let queueDelayed = [];

		/** @type {Module} */
		let module;
		/** @type {Chunk} */
		let chunk;
		/** @type {ChunkGroup} */
		let chunkGroup;

		// For each async Block in graph
		/**
		 * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock
		 * @returns {void}
		 */
		const iteratorBlock = b => {
			// 1. We create a chunk for this Block
			// but only once (blockChunkGroups map)
			let c = blockChunkGroups.get(b);
			if (c === undefined) {
				c = this.namedChunkGroups.get(b.chunkName);
				if (c && c.isInitial()) {
					this.errors.push(
						new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc)
					);
					c = chunkGroup;
				} else {
					c = this.addChunkInGroup(
						b.groupOptions || b.chunkName,
						module,
						b.loc,
						b.request
					);
					chunkGroupCounters.set(c, { index: 0, index2: 0 });
					blockChunkGroups.set(b, c);
					allCreatedChunkGroups.add(c);
				}
			} else {
				// TODO webpack 5 remove addOptions check
				if (c.addOptions) c.addOptions(b.groupOptions);
				c.addOrigin(module, b.loc, b.request);
			}

			// 2. We store the Block+Chunk mapping as dependency for the chunk
			let deps = chunkDependencies.get(chunkGroup);
			if (!deps) chunkDependencies.set(chunkGroup, (deps = []));
			deps.push({
				block: b,
				chunkGroup: c,
				couldBeFiltered: true
			});

			// 3. We enqueue the DependenciesBlock for traversal
			queueDelayed.push({
				action: PROCESS_BLOCK,
				block: b,
				module: module,
				chunk: c.chunks[0],
				chunkGroup: c
			});
		};

		// Iterative traversal of the Module graph
		// Recursive would be simpler to write but could result in Stack Overflows
		while (queue.length) {
			while (queue.length) {
				const queueItem = queue.pop();
				module = queueItem.module;
				block = queueItem.block;
				chunk = queueItem.chunk;
				chunkGroup = queueItem.chunkGroup;

				switch (queueItem.action) {
					case ADD_AND_ENTER_MODULE: {
						// We connect Module and Chunk when not already done
						if (chunk.addModule(module)) {
							module.addChunk(chunk);
						} else {
							// already connected, skip it
							break;
						}
					}
					// fallthrough
					case ENTER_MODULE: {
						if (chunkGroup !== undefined) {
							const index = chunkGroup.getModuleIndex(module);
							if (index === undefined) {
								chunkGroup.setModuleIndex(
									module,
									chunkGroupCounters.get(chunkGroup).index++
								);
							}
						}

						if (module.index === null) {
							module.index = nextFreeModuleIndex++;
						}

						queue.push({
							action: LEAVE_MODULE,
							block,
							module,
							chunk,
							chunkGroup
						});
					}
					// fallthrough
					case PROCESS_BLOCK: {
						// get prepared block info
						const blockInfo = blockInfoMap.get(block);

						// Traverse all referenced modules
						for (let i = blockInfo.modules.length - 1; i >= 0; i--) {
							const refModule = blockInfo.modules[i];
							if (chunk.containsModule(refModule)) {
								// skip early if already connected
								continue;
							}
							// enqueue the add and enter to enter in the correct order
							// this is relevant with circular dependencies
							queue.push({
								action: ADD_AND_ENTER_MODULE,
								block: refModule,
								module: refModule,
								chunk,
								chunkGroup
							});
						}

						// Traverse all Blocks
						iterationOfArrayCallback(blockInfo.blocks, iteratorBlock);

						if (blockInfo.blocks.length > 0 && module !== block) {
							blocksWithNestedBlocks.add(block);
						}
						break;
					}
					case LEAVE_MODULE: {
						if (chunkGroup !== undefined) {
							const index = chunkGroup.getModuleIndex2(module);
							if (index === undefined) {
								chunkGroup.setModuleIndex2(
									module,
									chunkGroupCounters.get(chunkGroup).index2++
								);
							}
						}

						if (module.index2 === null) {
							module.index2 = nextFreeModuleIndex2++;
						}
						break;
					}
				}
			}
			const tempQueue = queue;
			queue = queueDelayed.reverse();
			queueDelayed = tempQueue;
		}

		// PART TWO
		/** @type {Set<Module>} */
		let newAvailableModules;

		/**
		 * @typedef {Object} ChunkGroupInfo
		 * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point
		 * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules
		 */

		/** @type {Map<ChunkGroup, ChunkGroupInfo>} */
		const chunkGroupInfoMap = new Map();

		/** @type {Queue<ChunkGroup>} */
		const queue2 = new Queue(inputChunkGroups);

		for (const chunkGroup of inputChunkGroups) {
			chunkGroupInfoMap.set(chunkGroup, {
				minAvailableModules: undefined,
				availableModulesToBeMerged: [new Set()]
			});
		}

		/**
		 * Helper function to check if all modules of a chunk are available
		 *
		 * @param {ChunkGroup} chunkGroup the chunkGroup to scan
		 * @param {Set<Module>} availableModules the comparitor set
		 * @returns {boolean} return true if all modules of a chunk are available
		 */
		const areModulesAvailable = (chunkGroup, availableModules) => {
			for (const chunk of chunkGroup.chunks) {
				for (const module of chunk.modulesIterable) {
					if (!availableModules.has(module)) return false;
				}
			}
			return true;
		};

		// For each edge in the basic chunk graph
		/**
		 * @param {TODO} dep the dependency used for filtering
		 * @returns {boolean} used to filter "edges" (aka Dependencies) that were pointing
		 * to modules that are already available. Also filters circular dependencies in the chunks graph
		 */
		const filterFn = dep => {
			const depChunkGroup = dep.chunkGroup;
			if (!dep.couldBeFiltered) return true;
			if (blocksWithNestedBlocks.has(dep.block)) return true;
			if (areModulesAvailable(depChunkGroup, newAvailableModules)) {
				return false; // break all modules are already available
			}
			dep.couldBeFiltered = false;
			return true;
		};

		// Iterative traversing of the basic chunk graph
		while (queue2.length) {
			chunkGroup = queue2.dequeue();
			const info = chunkGroupInfoMap.get(chunkGroup);
			const availableModulesToBeMerged = info.availableModulesToBeMerged;
			let minAvailableModules = info.minAvailableModules;

			// 1. Get minimal available modules
			// It doesn't make sense to traverse a chunk again with more available modules.
			// This step calculates the minimal available modules and skips traversal when
			// the list didn't shrink.
			availableModulesToBeMerged.sort(bySetSize);
			let changed = false;
			for (const availableModules of availableModulesToBeMerged) {
				if (minAvailableModules === undefined) {
					minAvailableModules = new Set(availableModules);
					info.minAvailableModules = minAvailableModules;
					changed = true;
				} else {
					for (const m of minAvailableModules) {
						if (!availableModules.has(m)) {
							minAvailableModules.delete(m);
							changed = true;
						}
					}
				}
			}
			availableModulesToBeMerged.length = 0;
			if (!changed) continue;

			// 2. Get the edges at this point of the graph
			const deps = chunkDependencies.get(chunkGroup);
			if (!deps) continue;
			if (deps.length === 0) continue;

			// 3. Create a new Set of available modules at this points
			newAvailableModules = new Set(minAvailableModules);
			for (const chunk of chunkGroup.chunks) {
				for (const m of chunk.modulesIterable) {
					newAvailableModules.add(m);
				}
			}

			// 4. Foreach remaining edge
			const nextChunkGroups = new Set();
			for (let i = 0; i < deps.length; i++) {
				const dep = deps[i];

				// Filter inline, rather than creating a new array from `.filter()`
				if (!filterFn(dep)) {
					continue;
				}
				const depChunkGroup = dep.chunkGroup;
				const depBlock = dep.block;

				// 5. Connect block with chunk
				GraphHelpers.connectDependenciesBlockAndChunkGroup(
					depBlock,
					depChunkGroup
				);

				// 6. Connect chunk with parent
				GraphHelpers.connectChunkGroupParentAndChild(chunkGroup, depChunkGroup);

				nextChunkGroups.add(depChunkGroup);
			}

			// 7. Enqueue further traversal
			for (const nextChunkGroup of nextChunkGroups) {
				let nextInfo = chunkGroupInfoMap.get(nextChunkGroup);
				if (nextInfo === undefined) {
					nextInfo = {
						minAvailableModules: undefined,
						availableModulesToBeMerged: []
					};
					chunkGroupInfoMap.set(nextChunkGroup, nextInfo);
				}
				nextInfo.availableModulesToBeMerged.push(newAvailableModules);

				// As queue deduplicates enqueued items this makes sure that a ChunkGroup
				// is not enqueued twice
				queue2.enqueue(nextChunkGroup);
			}
		}

		// Remove all unconnected chunk groups
		for (const chunkGroup of allCreatedChunkGroups) {
			if (chunkGroup.getNumberOfParents() === 0) {
				for (const chunk of chunkGroup.chunks) {
					const idx = this.chunks.indexOf(chunk);
					if (idx >= 0) this.chunks.splice(idx, 1);
					chunk.remove("unconnected");
				}
				chunkGroup.remove("unconnected");
			}
		}
	}

	/**
	 *
	 * @param {Module} module module relationship for removal
	 * @param {DependenciesBlockLike} block //TODO: good description
	 * @returns {void}
	 */
	removeReasonsOfDependencyBlock(module, block) {
		const iteratorDependency = d => {
			if (!d.module) {
				return;
			}
			if (d.module.removeReason(module, d)) {
				for (const chunk of d.module.chunksIterable) {
					this.patchChunksAfterReasonRemoval(d.module, chunk);
				}
			}
		};

		if (block.blocks) {
			iterationOfArrayCallback(block.blocks, block =>
				this.removeReasonsOfDependencyBlock(module, block)
			);
		}

		if (block.dependencies) {
			iterationOfArrayCallback(block.dependencies, iteratorDependency);
		}

		if (block.variables) {
			iterationBlockVariable(block.variables, iteratorDependency);
		}
	}

	/**
	 * @param {Module} module module to patch tie
	 * @param {Chunk} chunk chunk to patch tie
	 * @returns {void}
	 */
	patchChunksAfterReasonRemoval(module, chunk) {
		if (!module.hasReasons()) {
			this.removeReasonsOfDependencyBlock(module, module);
		}
		if (!module.hasReasonForChunk(chunk)) {
			if (module.removeChunk(chunk)) {
				this.removeChunkFromDependencies(module, chunk);
			}
		}
	}

	/**
	 *
	 * @param {DependenciesBlock} block block tie for Chunk
	 * @param {Chunk} chunk chunk to remove from dep
	 * @returns {void}
	 */
	removeChunkFromDependencies(block, chunk) {
		const iteratorDependency = d => {
			if (!d.module) {
				return;
			}
			this.patchChunksAfterReasonRemoval(d.module, chunk);
		};

		const blocks = block.blocks;
		for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
			const asyncBlock = blocks[indexBlock];
			// Grab all chunks from the first Block's AsyncDepBlock
			const chunks = asyncBlock.chunkGroup.chunks;
			// For each chunk in chunkGroup
			for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
				const iteratedChunk = chunks[indexChunk];
				asyncBlock.chunkGroup.removeChunk(iteratedChunk);
				asyncBlock.chunkGroup.removeParent(iteratedChunk);
				// Recurse
				this.removeChunkFromDependencies(block, iteratedChunk);
			}
		}

		if (block.dependencies) {
			iterationOfArrayCallback(block.dependencies, iteratorDependency);
		}

		if (block.variables) {
			iterationBlockVariable(block.variables, iteratorDependency);
		}
	}

	applyModuleIds() {
		const unusedIds = [];
		let nextFreeModuleId = 0;
		const usedIds = new Set();
		if (this.usedModuleIds) {
			for (const id of this.usedModuleIds) {
				usedIds.add(id);
			}
		}

		const modules1 = this.modules;
		for (let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {
			const module1 = modules1[indexModule1];
			if (module1.id !== null) {
				usedIds.add(module1.id);
			}
		}

		if (usedIds.size > 0) {
			let usedIdMax = -1;
			for (const usedIdKey of usedIds) {
				if (typeof usedIdKey !== "number") {
					continue;
				}

				usedIdMax = Math.max(usedIdMax, usedIdKey);
			}

			let lengthFreeModules = (nextFreeModuleId = usedIdMax + 1);

			while (lengthFreeModules--) {
				if (!usedIds.has(lengthFreeModules)) {
					unusedIds.push(lengthFreeModules);
				}
			}
		}

		const modules2 = this.modules;
		for (let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {
			const module2 = modules2[indexModule2];
			if (module2.id === null) {
				if (unusedIds.length > 0) {
					module2.id = unusedIds.pop();
				} else {
					module2.id = nextFreeModuleId++;
				}
			}
		}
	}

	applyChunkIds() {
		/** @type {Set<number>} */
		const usedIds = new Set();

		// Get used ids from usedChunkIds property (i. e. from records)
		if (this.usedChunkIds) {
			for (const id of this.usedChunkIds) {
				if (typeof id !== "number") {
					continue;
				}

				usedIds.add(id);
			}
		}

		// Get used ids from existing chunks
		const chunks = this.chunks;
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			const chunk = chunks[indexChunk];
			const usedIdValue = chunk.id;

			if (typeof usedIdValue !== "number") {
				continue;
			}

			usedIds.add(usedIdValue);
		}

		// Calculate maximum assigned chunk id
		let nextFreeChunkId = -1;
		for (const id of usedIds) {
			nextFreeChunkId = Math.max(nextFreeChunkId, id);
		}
		nextFreeChunkId++;

		// Determine free chunk ids from 0 to maximum
		/** @type {number[]} */
		const unusedIds = [];
		if (nextFreeChunkId > 0) {
			let index = nextFreeChunkId;
			while (index--) {
				if (!usedIds.has(index)) {
					unusedIds.push(index);
				}
			}
		}

		// Assign ids to chunk which has no id
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			const chunk = chunks[indexChunk];
			if (chunk.id === null) {
				if (unusedIds.length > 0) {
					chunk.id = unusedIds.pop();
				} else {
					chunk.id = nextFreeChunkId++;
				}
			}
			if (!chunk.ids) {
				chunk.ids = [chunk.id];
			}
		}
	}

	sortItemsWithModuleIds() {
		this.modules.sort(byIdOrIdentifier);

		const modules = this.modules;
		for (let indexModule = 0; indexModule < modules.length; indexModule++) {
			modules[indexModule].sortItems(false);
		}

		const chunks = this.chunks;
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			chunks[indexChunk].sortItems();
		}

		chunks.sort((a, b) => a.compareTo(b));
	}

	sortItemsWithChunkIds() {
		for (const chunkGroup of this.chunkGroups) {
			chunkGroup.sortItems();
		}

		this.chunks.sort(byId);

		for (
			let indexModule = 0;
			indexModule < this.modules.length;
			indexModule++
		) {
			this.modules[indexModule].sortItems(true);
		}

		const chunks = this.chunks;
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			chunks[indexChunk].sortItems();
		}

		/**
		 * Used to sort errors and warnings in compilation. this.warnings, and
		 * this.errors contribute to the compilation hash and therefore should be
		 * updated whenever other references (having a chunk id) are sorted. This preserves the hash
		 * integrity
		 *
		 * @param {WebpackError} a first WebpackError instance (including subclasses)
		 * @param {WebpackError} b second WebpackError instance (including subclasses)
		 * @returns {-1|0|1} sort order index
		 */
		const byMessage = (a, b) => {
			const ma = `${a.message}`;
			const mb = `${b.message}`;
			if (ma < mb) return -1;
			if (mb < ma) return 1;
			return 0;
		};

		this.errors.sort(byMessage);
		this.warnings.sort(byMessage);
		this.children.sort(byNameOrHash);
	}

	summarizeDependencies() {
		this.fileDependencies = new SortableSet(this.compilationDependencies);
		this.contextDependencies = new SortableSet();
		this.missingDependencies = new SortableSet();

		for (
			let indexChildren = 0;
			indexChildren < this.children.length;
			indexChildren++
		) {
			const child = this.children[indexChildren];

			addAllToSet(this.fileDependencies, child.fileDependencies);
			addAllToSet(this.contextDependencies, child.contextDependencies);
			addAllToSet(this.missingDependencies, child.missingDependencies);
		}

		for (
			let indexModule = 0;
			indexModule < this.modules.length;
			indexModule++
		) {
			const module = this.modules[indexModule];

			if (module.buildInfo.fileDependencies) {
				addAllToSet(this.fileDependencies, module.buildInfo.fileDependencies);
			}
			if (module.buildInfo.contextDependencies) {
				addAllToSet(
					this.contextDependencies,
					module.buildInfo.contextDependencies
				);
			}
		}
		for (const error of this.errors) {
			if (
				typeof error.missing === "object" &&
				error.missing &&
				error.missing[Symbol.iterator]
			) {
				addAllToSet(this.missingDependencies, error.missing);
			}
		}
		this.fileDependencies.sort();
		this.contextDependencies.sort();
		this.missingDependencies.sort();
	}

	createHash() {
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.mainTemplate.updateHash(hash);
		this.chunkTemplate.updateHash(hash);
		for (const key of Object.keys(this.moduleTemplates).sort()) {
			this.moduleTemplates[key].updateHash(hash);
		}
		for (const child of this.children) {
			hash.update(child.hash);
		}
		for (const warning of this.warnings) {
			hash.update(`${warning.message}`);
		}
		for (const error of this.errors) {
			hash.update(`${error.message}`);
		}
		const modules = this.modules;
		for (let i = 0; i < modules.length; i++) {
			const module = modules[i];
			const moduleHash = createHash(hashFunction);
			module.updateHash(moduleHash);
			module.hash = moduleHash.digest(hashDigest);
			module.renderedHash = module.hash.substr(0, hashDigestLength);
		}
		// clone needed as sort below is inplace mutation
		const chunks = this.chunks.slice();
		/**
		 * sort here will bring all "falsy" values to the beginning
		 * this is needed as the "hasRuntime()" chunks are dependent on the
		 * hashes of the non-runtime chunks.
		 */
		chunks.sort((a, b) => {
			const aEntry = a.hasRuntime();
			const bEntry = b.hasRuntime();
			if (aEntry && !bEntry) return 1;
			if (!aEntry && bEntry) return -1;
			return byId(a, b);
		});
		for (let i = 0; i < chunks.length; i++) {
			const chunk = chunks[i];
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash);
				const template = chunk.hasRuntime()
					? this.mainTemplate
					: this.chunkTemplate;
				template.updateHashForChunk(
					chunkHash,
					chunk,
					this.moduleTemplates.javascript,
					this.dependencyTemplates
				);
				this.hooks.chunkHash.call(chunk, chunkHash);
				chunk.hash = chunkHash.digest(hashDigest);
				hash.update(chunk.hash);
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				this.hooks.contentHash.call(chunk);
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
		}
		this.fullHash = hash.digest(hashDigest);
		this.hash = this.fullHash.substr(0, hashDigestLength);
	}

	/**
	 * @param {string} update extra information
	 * @returns {void}
	 */
	modifyHash(update) {
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		hash.update(this.fullHash);
		hash.update(update);
		this.fullHash = hash.digest(hashDigest);
		this.hash = this.fullHash.substr(0, hashDigestLength);
	}

	createModuleAssets() {
		for (let i = 0; i < this.modules.length; i++) {
			const module = this.modules[i];
			if (module.buildInfo.assets) {
				for (const assetName of Object.keys(module.buildInfo.assets)) {
					const fileName = this.getPath(assetName);
					this.assets[fileName] = module.buildInfo.assets[assetName];
					this.hooks.moduleAsset.call(module, fileName);
				}
			}
		}
	}

	createChunkAssets() {
		const outputOptions = this.outputOptions;
		const cachedSourceMap = new Map();
		/** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */
		const alreadyWrittenFiles = new Map();
		for (let i = 0; i < this.chunks.length; i++) {
			const chunk = this.chunks[i];
			chunk.files = [];
			let source;
			let file;
			let filenameTemplate;
			try {
				const template = chunk.hasRuntime()
					? this.mainTemplate
					: this.chunkTemplate;
				const manifest = template.getRenderManifest({
					chunk,
					hash: this.hash,
					fullHash: this.fullHash,
					outputOptions,
					moduleTemplates: this.moduleTemplates,
					dependencyTemplates: this.dependencyTemplates
				}); // [{ render(), filenameTemplate, pathOptions, identifier, hash }]
				for (const fileManifest of manifest) {
					const cacheName = fileManifest.identifier;
					const usedHash = fileManifest.hash;
					filenameTemplate = fileManifest.filenameTemplate;
					file = this.getPath(filenameTemplate, fileManifest.pathOptions);

					// check if the same filename was already written by another chunk
					const alreadyWritten = alreadyWrittenFiles.get(file);
					if (alreadyWritten !== undefined) {
						if (alreadyWritten.hash === usedHash) {
							if (this.cache) {
								this.cache[cacheName] = {
									hash: usedHash,
									source: alreadyWritten.source
								};
							}
							chunk.files.push(file);
							this.hooks.chunkAsset.call(chunk, file);
							continue;
						} else {
							throw new Error(
								`Conflict: Multiple chunks emit assets to the same filename ${file}` +
									` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`
							);
						}
					}
					if (
						this.cache &&
						this.cache[cacheName] &&
						this.cache[cacheName].hash === usedHash
					) {
						source = this.cache[cacheName].source;
					} else {
						source = fileManifest.render();
						// Ensure that source is a cached source to avoid additional cost because of repeated access
						if (!(source instanceof CachedSource)) {
							const cacheEntry = cachedSourceMap.get(source);
							if (cacheEntry) {
								source = cacheEntry;
							} else {
								const cachedSource = new CachedSource(source);
								cachedSourceMap.set(source, cachedSource);
								source = cachedSource;
							}
						}
						if (this.cache) {
							this.cache[cacheName] = {
								hash: usedHash,
								source
							};
						}
					}
					if (this.assets[file] && this.assets[file] !== source) {
						throw new Error(
							`Conflict: Multiple assets emit to the same filename ${file}`
						);
					}
					this.assets[file] = source;
					chunk.files.push(file);
					this.hooks.chunkAsset.call(chunk, file);
					alreadyWrittenFiles.set(file, {
						hash: usedHash,
						source,
						chunk
					});
				}
			} catch (err) {
				this.errors.push(
					new ChunkRenderError(chunk, file || filenameTemplate, err)
				);
			}
		}
	}

	/**
	 * @param {string} filename used to get asset path with hash
	 * @param {TODO=} data // TODO: figure out this param type
	 * @returns {string} interpolated path
	 */
	getPath(filename, data) {
		data = data || {};
		data.hash = data.hash || this.hash;
		return this.mainTemplate.getAssetPath(filename, data);
	}

	/**
	 * This function allows you to run another instance of webpack inside of webpack however as
	 * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins
	 * from parent (or top level compiler) and creates a child Compilation
	 *
	 * @param {string} name name of the child compiler
	 * @param {TODO} outputOptions // Need to convert config schema to types for this
	 * @param {Plugin[]} plugins webpack plugins that will be applied
	 * @returns {Compiler} creates a child Compiler instance
	 */
	createChildCompiler(name, outputOptions, plugins) {
		const idx = this.childrenCounters[name] || 0;
		this.childrenCounters[name] = idx + 1;
		return this.compiler.createChildCompiler(
			this,
			name,
			idx,
			outputOptions,
			plugins
		);
	}

	checkConstraints() {
		/** @type {Set<number|string>} */
		const usedIds = new Set();

		const modules = this.modules;
		for (let indexModule = 0; indexModule < modules.length; indexModule++) {
			const moduleId = modules[indexModule].id;
			if (moduleId === null) continue;
			if (usedIds.has(moduleId)) {
				throw new Error(`checkConstraints: duplicate module id ${moduleId}`);
			}
			usedIds.add(moduleId);
		}

		const chunks = this.chunks;
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			const chunk = chunks[indexChunk];
			if (chunks.indexOf(chunk) !== indexChunk) {
				throw new Error(
					`checkConstraints: duplicate chunk in compilation ${chunk.debugId}`
				);
			}
		}

		for (const chunkGroup of this.chunkGroups) {
			chunkGroup.checkConstraints();
		}
	}
}

// TODO remove in webpack 5
Compilation.prototype.applyPlugins = util.deprecate(
	/**
	 * @deprecated
	 * @param {string} name Name
	 * @param {any[]} args Other arguments
	 * @returns {void}
	 * @this {Compilation}
	 */
	function(name, ...args) {
		this.hooks[
			name.replace(/[- ]([a-z])/g, match => match[1].toUpperCase())
		].call(...args);
	},
	"Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead"
);

// TODO remove in webpack 5
Object.defineProperty(Compilation.prototype, "moduleTemplate", {
	configurable: false,
	get: util.deprecate(
		/**
		 * @deprecated
		 * @this {Compilation}
		 * @returns {TODO} module template
		 */
		function() {
			return this.moduleTemplates.javascript;
		},
		"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead"
	),
	set: util.deprecate(
		/**
		 * @deprecated
		 * @param {ModuleTemplate} value Template value
		 * @this {Compilation}
		 * @returns {void}
		 */
		function(value) {
			this.moduleTemplates.javascript = value;
		},
		"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead."
	)
});

module.exports = Compilation;


/***/ }),

/***/ "./node_modules/webpack/lib/Compiler.js":
/*!*********************************!*\
  !*** (webpack)/lib/Compiler.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const parseJson = __webpack_require__(/*! json-parse-better-errors */ "json-parse-better-errors");
const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");
const path = __webpack_require__(/*! path */ "path");
const { Source } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const util = __webpack_require__(/*! util */ "util");
const {
	Tapable,
	SyncHook,
	SyncBailHook,
	AsyncParallelHook,
	AsyncSeriesHook
} = __webpack_require__(/*! tapable */ "tapable");

const Compilation = __webpack_require__(/*! ./Compilation */ "./node_modules/webpack/lib/Compilation.js");
const Stats = __webpack_require__(/*! ./Stats */ "./node_modules/webpack/lib/Stats.js");
const Watching = __webpack_require__(/*! ./Watching */ "./node_modules/webpack/lib/Watching.js");
const NormalModuleFactory = __webpack_require__(/*! ./NormalModuleFactory */ "./node_modules/webpack/lib/NormalModuleFactory.js");
const ContextModuleFactory = __webpack_require__(/*! ./ContextModuleFactory */ "./node_modules/webpack/lib/ContextModuleFactory.js");
const ResolverFactory = __webpack_require__(/*! ./ResolverFactory */ "./node_modules/webpack/lib/ResolverFactory.js");

const RequestShortener = __webpack_require__(/*! ./RequestShortener */ "./node_modules/webpack/lib/RequestShortener.js");
const { makePathsRelative } = __webpack_require__(/*! ./util/identifier */ "./node_modules/webpack/lib/util/identifier.js");
const ConcurrentCompilationError = __webpack_require__(/*! ./ConcurrentCompilationError */ "./node_modules/webpack/lib/ConcurrentCompilationError.js");

/** @typedef {import("../declarations/WebpackOptions").Entry} Entry */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptions} WebpackOptions */

/**
 * @typedef {Object} CompilationParams
 * @property {NormalModuleFactory} normalModuleFactory
 * @property {ContextModuleFactory} contextModuleFactory
 * @property {Set<string>} compilationDependencies
 */

class Compiler extends Tapable {
	constructor(context) {
		super();
		this.hooks = {
			/** @type {SyncBailHook<Compilation>} */
			shouldEmit: new SyncBailHook(["compilation"]),
			/** @type {AsyncSeriesHook<Stats>} */
			done: new AsyncSeriesHook(["stats"]),
			/** @type {AsyncSeriesHook<>} */
			additionalPass: new AsyncSeriesHook([]),
			/** @type {AsyncSeriesHook<Compiler>} */
			beforeRun: new AsyncSeriesHook(["compiler"]),
			/** @type {AsyncSeriesHook<Compiler>} */
			run: new AsyncSeriesHook(["compiler"]),
			/** @type {AsyncSeriesHook<Compilation>} */
			emit: new AsyncSeriesHook(["compilation"]),
			/** @type {AsyncSeriesHook<Compilation>} */
			afterEmit: new AsyncSeriesHook(["compilation"]),

			/** @type {SyncHook<Compilation, CompilationParams>} */
			thisCompilation: new SyncHook(["compilation", "params"]),
			/** @type {SyncHook<Compilation, CompilationParams>} */
			compilation: new SyncHook(["compilation", "params"]),
			/** @type {SyncHook<NormalModuleFactory>} */
			normalModuleFactory: new SyncHook(["normalModuleFactory"]),
			/** @type {SyncHook<ContextModuleFactory>}  */
			contextModuleFactory: new SyncHook(["contextModulefactory"]),

			/** @type {AsyncSeriesHook<CompilationParams>} */
			beforeCompile: new AsyncSeriesHook(["params"]),
			/** @type {SyncHook<CompilationParams>} */
			compile: new SyncHook(["params"]),
			/** @type {AsyncParallelHook<Compilation>} */
			make: new AsyncParallelHook(["compilation"]),
			/** @type {AsyncSeriesHook<Compilation>} */
			afterCompile: new AsyncSeriesHook(["compilation"]),

			/** @type {AsyncSeriesHook<Compiler>} */
			watchRun: new AsyncSeriesHook(["compiler"]),
			/** @type {SyncHook<Error>} */
			failed: new SyncHook(["error"]),
			/** @type {SyncHook<string, string>} */
			invalid: new SyncHook(["filename", "changeTime"]),
			/** @type {SyncHook} */
			watchClose: new SyncHook([]),

			// TODO the following hooks are weirdly located here
			// TODO move them for webpack 5
			/** @type {SyncHook} */
			environment: new SyncHook([]),
			/** @type {SyncHook} */
			afterEnvironment: new SyncHook([]),
			/** @type {SyncHook<Compiler>} */
			afterPlugins: new SyncHook(["compiler"]),
			/** @type {SyncHook<Compiler>} */
			afterResolvers: new SyncHook(["compiler"]),
			/** @type {SyncBailHook<string, Entry>} */
			entryOption: new SyncBailHook(["context", "entry"])
		};

		this._pluginCompat.tap("Compiler", options => {
			switch (options.name) {
				case "additional-pass":
				case "before-run":
				case "run":
				case "emit":
				case "after-emit":
				case "before-compile":
				case "make":
				case "after-compile":
				case "watch-run":
					options.async = true;
					break;
			}
		});

		/** @type {string=} */
		this.name = undefined;
		/** @type {Compilation=} */
		this.parentCompilation = undefined;
		/** @type {string} */
		this.outputPath = "";

		this.outputFileSystem = null;
		this.inputFileSystem = null;

		/** @type {string|null} */
		this.recordsInputPath = null;
		/** @type {string|null} */
		this.recordsOutputPath = null;
		this.records = {};
		this.removedFiles = new Set();
		/** @type {Map<string, number>} */
		this.fileTimestamps = new Map();
		/** @type {Map<string, number>} */
		this.contextTimestamps = new Map();
		/** @type {ResolverFactory} */
		this.resolverFactory = new ResolverFactory();

		// TODO remove in webpack 5
		this.resolvers = {
			normal: {
				plugins: util.deprecate((hook, fn) => {
					this.resolverFactory.plugin("resolver normal", resolver => {
						resolver.plugin(hook, fn);
					});
				}, "webpack: Using compiler.resolvers.normal is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
				apply: util.deprecate((...args) => {
					this.resolverFactory.plugin("resolver normal", resolver => {
						resolver.apply(...args);
					});
				}, "webpack: Using compiler.resolvers.normal is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
			},
			loader: {
				plugins: util.deprecate((hook, fn) => {
					this.resolverFactory.plugin("resolver loader", resolver => {
						resolver.plugin(hook, fn);
					});
				}, "webpack: Using compiler.resolvers.loader is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
				apply: util.deprecate((...args) => {
					this.resolverFactory.plugin("resolver loader", resolver => {
						resolver.apply(...args);
					});
				}, "webpack: Using compiler.resolvers.loader is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
			},
			context: {
				plugins: util.deprecate((hook, fn) => {
					this.resolverFactory.plugin("resolver context", resolver => {
						resolver.plugin(hook, fn);
					});
				}, "webpack: Using compiler.resolvers.context is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
				apply: util.deprecate((...args) => {
					this.resolverFactory.plugin("resolver context", resolver => {
						resolver.apply(...args);
					});
				}, "webpack: Using compiler.resolvers.context is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
			}
		};

		/** @type {WebpackOptions} */
		this.options = /** @type {WebpackOptions} */ ({});

		this.context = context;

		this.requestShortener = new RequestShortener(context);

		/** @type {boolean} */
		this.running = false;

		/** @type {boolean} */
		this.watchMode = false;

		/** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */
		this._assetEmittingSourceCache = new WeakMap();
		/** @private @type {Map<string, number>} */
		this._assetEmittingWrittenFiles = new Map();
	}

	watch(watchOptions, handler) {
		if (this.running) return handler(new ConcurrentCompilationError());

		this.running = true;
		this.watchMode = true;
		this.fileTimestamps = new Map();
		this.contextTimestamps = new Map();
		this.removedFiles = new Set();
		return new Watching(this, watchOptions, handler);
	}

	run(callback) {
		if (this.running) return callback(new ConcurrentCompilationError());

		const finalCallback = (err, stats) => {
			this.running = false;

			if (err) {
				this.hooks.failed.call(err);
			}

			if (callback !== undefined) return callback(err, stats);
		};

		const startTime = Date.now();

		this.running = true;

		const onCompiled = (err, compilation) => {
			if (err) return finalCallback(err);

			if (this.hooks.shouldEmit.call(compilation) === false) {
				const stats = new Stats(compilation);
				stats.startTime = startTime;
				stats.endTime = Date.now();
				this.hooks.done.callAsync(stats, err => {
					if (err) return finalCallback(err);
					return finalCallback(null, stats);
				});
				return;
			}

			this.emitAssets(compilation, err => {
				if (err) return finalCallback(err);

				if (compilation.hooks.needAdditionalPass.call()) {
					compilation.needAdditionalPass = true;

					const stats = new Stats(compilation);
					stats.startTime = startTime;
					stats.endTime = Date.now();
					this.hooks.done.callAsync(stats, err => {
						if (err) return finalCallback(err);

						this.hooks.additionalPass.callAsync(err => {
							if (err) return finalCallback(err);
							this.compile(onCompiled);
						});
					});
					return;
				}

				this.emitRecords(err => {
					if (err) return finalCallback(err);

					const stats = new Stats(compilation);
					stats.startTime = startTime;
					stats.endTime = Date.now();
					this.hooks.done.callAsync(stats, err => {
						if (err) return finalCallback(err);
						return finalCallback(null, stats);
					});
				});
			});
		};

		this.hooks.beforeRun.callAsync(this, err => {
			if (err) return finalCallback(err);

			this.hooks.run.callAsync(this, err => {
				if (err) return finalCallback(err);

				this.readRecords(err => {
					if (err) return finalCallback(err);

					this.compile(onCompiled);
				});
			});
		});
	}

	runAsChild(callback) {
		this.compile((err, compilation) => {
			if (err) return callback(err);

			this.parentCompilation.children.push(compilation);
			for (const name of Object.keys(compilation.assets)) {
				this.parentCompilation.assets[name] = compilation.assets[name];
			}

			const entries = Array.from(
				compilation.entrypoints.values(),
				ep => ep.chunks
			).reduce((array, chunks) => {
				return array.concat(chunks);
			}, []);

			return callback(null, entries, compilation);
		});
	}

	purgeInputFileSystem() {
		if (this.inputFileSystem && this.inputFileSystem.purge) {
			this.inputFileSystem.purge();
		}
	}

	emitAssets(compilation, callback) {
		let outputPath;
		const emitFiles = err => {
			if (err) return callback(err);

			asyncLib.forEachLimit(
				compilation.assets,
				15,
				(source, file, callback) => {
					let targetFile = file;
					const queryStringIdx = targetFile.indexOf("?");
					if (queryStringIdx >= 0) {
						targetFile = targetFile.substr(0, queryStringIdx);
					}

					const writeOut = err => {
						if (err) return callback(err);
						const targetPath = this.outputFileSystem.join(
							outputPath,
							targetFile
						);
						// TODO webpack 5 remove futureEmitAssets option and make it on by default
						if (this.options.output.futureEmitAssets) {
							// check if the target file has already been written by this Compiler
							const targetFileGeneration = this._assetEmittingWrittenFiles.get(
								targetPath
							);

							// create an cache entry for this Source if not already existing
							let cacheEntry = this._assetEmittingSourceCache.get(source);
							if (cacheEntry === undefined) {
								cacheEntry = {
									sizeOnlySource: undefined,
									writtenTo: new Map()
								};
								this._assetEmittingSourceCache.set(source, cacheEntry);
							}

							// if the target file has already been written
							if (targetFileGeneration !== undefined) {
								// check if the Source has been written to this target file
								const writtenGeneration = cacheEntry.writtenTo.get(targetPath);
								if (writtenGeneration === targetFileGeneration) {
									// if yes, we skip writing the file
									// as it's already there
									// (we assume one doesn't remove files while the Compiler is running)
									return callback();
								}
							}

							// get the binary (Buffer) content from the Source
							/** @type {Buffer} */
							let content;
							if (typeof source.buffer === "function") {
								content = source.buffer();
							} else {
								const bufferOrString = source.source();
								if (Buffer.isBuffer(bufferOrString)) {
									content = bufferOrString;
								} else {
									content = Buffer.from(bufferOrString, "utf8");
								}
							}

							// Create a replacement resource which only allows to ask for size
							// This allows to GC all memory allocated by the Source
							// (expect when the Source is stored in any other cache)
							cacheEntry.sizeOnlySource = new SizeOnlySource(content.length);
							compilation.assets[file] = cacheEntry.sizeOnlySource;

							// Write the file to output file system
							this.outputFileSystem.writeFile(targetPath, content, err => {
								if (err) return callback(err);

								// information marker that the asset has been emitted
								compilation.emittedAssets.add(file);

								// cache the information that the Source has been written to that location
								const newGeneration =
									targetFileGeneration === undefined
										? 1
										: targetFileGeneration + 1;
								cacheEntry.writtenTo.set(targetPath, newGeneration);
								this._assetEmittingWrittenFiles.set(targetPath, newGeneration);
								callback();
							});
						} else {
							if (source.existsAt === targetPath) {
								source.emitted = false;
								return callback();
							}
							let content = source.source();

							if (!Buffer.isBuffer(content)) {
								content = Buffer.from(content, "utf8");
							}

							source.existsAt = targetPath;
							source.emitted = true;
							this.outputFileSystem.writeFile(targetPath, content, callback);
						}
					};

					if (targetFile.match(/\/|\\/)) {
						const dir = path.dirname(targetFile);
						this.outputFileSystem.mkdirp(
							this.outputFileSystem.join(outputPath, dir),
							writeOut
						);
					} else {
						writeOut();
					}
				},
				err => {
					if (err) return callback(err);

					this.hooks.afterEmit.callAsync(compilation, err => {
						if (err) return callback(err);

						return callback();
					});
				}
			);
		};

		this.hooks.emit.callAsync(compilation, err => {
			if (err) return callback(err);
			outputPath = compilation.getPath(this.outputPath);
			this.outputFileSystem.mkdirp(outputPath, emitFiles);
		});
	}

	emitRecords(callback) {
		if (!this.recordsOutputPath) return callback();
		const idx1 = this.recordsOutputPath.lastIndexOf("/");
		const idx2 = this.recordsOutputPath.lastIndexOf("\\");
		let recordsOutputPathDirectory = null;
		if (idx1 > idx2) {
			recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);
		} else if (idx1 < idx2) {
			recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);
		}

		const writeFile = () => {
			this.outputFileSystem.writeFile(
				this.recordsOutputPath,
				JSON.stringify(this.records, undefined, 2),
				callback
			);
		};

		if (!recordsOutputPathDirectory) {
			return writeFile();
		}
		this.outputFileSystem.mkdirp(recordsOutputPathDirectory, err => {
			if (err) return callback(err);
			writeFile();
		});
	}

	readRecords(callback) {
		if (!this.recordsInputPath) {
			this.records = {};
			return callback();
		}
		this.inputFileSystem.stat(this.recordsInputPath, err => {
			// It doesn't exist
			// We can ignore this.
			if (err) return callback();

			this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {
				if (err) return callback(err);

				try {
					this.records = parseJson(content.toString("utf-8"));
				} catch (e) {
					e.message = "Cannot parse records: " + e.message;
					return callback(e);
				}

				return callback();
			});
		});
	}

	createChildCompiler(
		compilation,
		compilerName,
		compilerIndex,
		outputOptions,
		plugins
	) {
		const childCompiler = new Compiler(this.context);
		if (Array.isArray(plugins)) {
			for (const plugin of plugins) {
				plugin.apply(childCompiler);
			}
		}
		for (const name in this.hooks) {
			if (
				![
					"make",
					"compile",
					"emit",
					"afterEmit",
					"invalid",
					"done",
					"thisCompilation"
				].includes(name)
			) {
				if (childCompiler.hooks[name]) {
					childCompiler.hooks[name].taps = this.hooks[name].taps.slice();
				}
			}
		}
		childCompiler.name = compilerName;
		childCompiler.outputPath = this.outputPath;
		childCompiler.inputFileSystem = this.inputFileSystem;
		childCompiler.outputFileSystem = null;
		childCompiler.resolverFactory = this.resolverFactory;
		childCompiler.fileTimestamps = this.fileTimestamps;
		childCompiler.contextTimestamps = this.contextTimestamps;

		const relativeCompilerName = makePathsRelative(this.context, compilerName);
		if (!this.records[relativeCompilerName]) {
			this.records[relativeCompilerName] = [];
		}
		if (this.records[relativeCompilerName][compilerIndex]) {
			childCompiler.records = this.records[relativeCompilerName][compilerIndex];
		} else {
			this.records[relativeCompilerName].push((childCompiler.records = {}));
		}

		childCompiler.options = Object.create(this.options);
		childCompiler.options.output = Object.create(childCompiler.options.output);
		for (const name in outputOptions) {
			childCompiler.options.output[name] = outputOptions[name];
		}
		childCompiler.parentCompilation = compilation;

		compilation.hooks.childCompiler.call(
			childCompiler,
			compilerName,
			compilerIndex
		);

		return childCompiler;
	}

	isChild() {
		return !!this.parentCompilation;
	}

	createCompilation() {
		return new Compilation(this);
	}

	newCompilation(params) {
		const compilation = this.createCompilation();
		compilation.fileTimestamps = this.fileTimestamps;
		compilation.contextTimestamps = this.contextTimestamps;
		compilation.name = this.name;
		compilation.records = this.records;
		compilation.compilationDependencies = params.compilationDependencies;
		this.hooks.thisCompilation.call(compilation, params);
		this.hooks.compilation.call(compilation, params);
		return compilation;
	}

	createNormalModuleFactory() {
		const normalModuleFactory = new NormalModuleFactory(
			this.options.context,
			this.resolverFactory,
			this.options.module || {}
		);
		this.hooks.normalModuleFactory.call(normalModuleFactory);
		return normalModuleFactory;
	}

	createContextModuleFactory() {
		const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);
		this.hooks.contextModuleFactory.call(contextModuleFactory);
		return contextModuleFactory;
	}

	newCompilationParams() {
		const params = {
			normalModuleFactory: this.createNormalModuleFactory(),
			contextModuleFactory: this.createContextModuleFactory(),
			compilationDependencies: new Set()
		};
		return params;
	}

	compile(callback) {
		const params = this.newCompilationParams();
		this.hooks.beforeCompile.callAsync(params, err => {
			if (err) return callback(err);

			this.hooks.compile.call(params);

			const compilation = this.newCompilation(params);

			this.hooks.make.callAsync(compilation, err => {
				if (err) return callback(err);

				compilation.finish();

				compilation.seal(err => {
					if (err) return callback(err);

					this.hooks.afterCompile.callAsync(compilation, err => {
						if (err) return callback(err);

						return callback(null, compilation);
					});
				});
			});
		});
	}
}

module.exports = Compiler;

class SizeOnlySource extends Source {
	constructor(size) {
		super();
		this._size = size;
	}

	_error() {
		return new Error(
			"Content and Map of this Source is no longer available (only size() is supported)"
		);
	}

	size() {
		return this._size;
	}

	/**
	 * @param {any} options options
	 * @returns {string} the source
	 */
	source(options) {
		throw this._error();
	}

	node() {
		throw this._error();
	}

	listMap() {
		throw this._error();
	}

	map() {
		throw this._error();
	}

	listNode() {
		throw this._error();
	}

	updateHash() {
		throw this._error();
	}
}


/***/ }),

/***/ "./node_modules/webpack/lib/ConcurrentCompilationError.js":
/*!***************************************************!*\
  !*** (webpack)/lib/ConcurrentCompilationError.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Maksim Nazarjev @acupofspirt
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

module.exports = class ConcurrentCompilationError extends WebpackError {
	constructor() {
		super();

		this.name = "ConcurrentCompilationError";
		this.message =
			"You ran Webpack twice. Each instance only supports a single concurrent compilation at a time.";

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/ConstPlugin.js":
/*!************************************!*\
  !*** (webpack)/lib/ConstPlugin.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");
const ParserHelpers = __webpack_require__(/*! ./ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");

const getQuery = request => {
	const i = request.indexOf("?");
	return i !== -1 ? request.substr(i) : "";
};

const collectDeclaration = (declarations, pattern) => {
	const stack = [pattern];
	while (stack.length > 0) {
		const node = stack.pop();
		switch (node.type) {
			case "Identifier":
				declarations.add(node.name);
				break;
			case "ArrayPattern":
				for (const element of node.elements) {
					if (element) {
						stack.push(element);
					}
				}
				break;
			case "AssignmentPattern":
				stack.push(node.left);
				break;
			case "ObjectPattern":
				for (const property of node.properties) {
					stack.push(property.value);
				}
				break;
			case "RestElement":
				stack.push(node.argument);
				break;
		}
	}
};

const getHoistedDeclarations = (branch, includeFunctionDeclarations) => {
	const declarations = new Set();
	const stack = [branch];
	while (stack.length > 0) {
		const node = stack.pop();
		// Some node could be `null` or `undefined`.
		if (!node) continue;
		switch (node.type) {
			// Walk through control statements to look for hoisted declarations.
			// Some branches are skipped since they do not allow declarations.
			case "BlockStatement":
				for (const stmt of node.body) {
					stack.push(stmt);
				}
				break;
			case "IfStatement":
				stack.push(node.consequent);
				stack.push(node.alternate);
				break;
			case "ForStatement":
				stack.push(node.init);
				stack.push(node.body);
				break;
			case "ForInStatement":
			case "ForOfStatement":
				stack.push(node.left);
				stack.push(node.body);
				break;
			case "DoWhileStatement":
			case "WhileStatement":
			case "LabeledStatement":
				stack.push(node.body);
				break;
			case "SwitchStatement":
				for (const cs of node.cases) {
					for (const consequent of cs.consequent) {
						stack.push(consequent);
					}
				}
				break;
			case "TryStatement":
				stack.push(node.block);
				if (node.handler) {
					stack.push(node.handler.body);
				}
				stack.push(node.finalizer);
				break;
			case "FunctionDeclaration":
				if (includeFunctionDeclarations) {
					collectDeclaration(declarations, node.id);
				}
				break;
			case "VariableDeclaration":
				if (node.kind === "var") {
					for (const decl of node.declarations) {
						collectDeclaration(declarations, decl.id);
					}
				}
				break;
		}
	}
	return Array.from(declarations);
};

class ConstPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"ConstPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const handler = parser => {
					parser.hooks.statementIf.tap("ConstPlugin", statement => {
						const param = parser.evaluateExpression(statement.test);
						const bool = param.asBool();
						if (typeof bool === "boolean") {
							if (statement.test.type !== "Literal") {
								const dep = new ConstDependency(`${bool}`, param.range);
								dep.loc = statement.loc;
								parser.state.current.addDependency(dep);
							}
							const branchToRemove = bool
								? statement.alternate
								: statement.consequent;
							if (branchToRemove) {
								// Before removing the dead branch, the hoisted declarations
								// must be collected.
								//
								// Given the following code:
								//
								//     if (true) f() else g()
								//     if (false) {
								//       function f() {}
								//       const g = function g() {}
								//       if (someTest) {
								//         let a = 1
								//         var x, {y, z} = obj
								//       }
								//     } else {
								//       …
								//     }
								//
								// the generated code is:
								//
								//     if (true) f() else {}
								//     if (false) {
								//       var f, x, y, z;   (in loose mode)
								//       var x, y, z;      (in strict mode)
								//     } else {
								//       …
								//     }
								//
								// NOTE: When code runs in strict mode, `var` declarations
								// are hoisted but `function` declarations don't.
								//
								let declarations;
								if (parser.scope.isStrict) {
									// If the code runs in strict mode, variable declarations
									// using `var` must be hoisted.
									declarations = getHoistedDeclarations(branchToRemove, false);
								} else {
									// Otherwise, collect all hoisted declaration.
									declarations = getHoistedDeclarations(branchToRemove, true);
								}
								let replacement;
								if (declarations.length > 0) {
									replacement = `{ var ${declarations.join(", ")}; }`;
								} else {
									replacement = "{}";
								}
								const dep = new ConstDependency(
									replacement,
									branchToRemove.range
								);
								dep.loc = branchToRemove.loc;
								parser.state.current.addDependency(dep);
							}
							return bool;
						}
					});
					parser.hooks.expressionConditionalOperator.tap(
						"ConstPlugin",
						expression => {
							const param = parser.evaluateExpression(expression.test);
							const bool = param.asBool();
							if (typeof bool === "boolean") {
								if (expression.test.type !== "Literal") {
									const dep = new ConstDependency(` ${bool}`, param.range);
									dep.loc = expression.loc;
									parser.state.current.addDependency(dep);
								}
								// Expressions do not hoist.
								// It is safe to remove the dead branch.
								//
								// Given the following code:
								//
								//   false ? someExpression() : otherExpression();
								//
								// the generated code is:
								//
								//   false ? undefined : otherExpression();
								//
								const branchToRemove = bool
									? expression.alternate
									: expression.consequent;
								const dep = new ConstDependency(
									"undefined",
									branchToRemove.range
								);
								dep.loc = branchToRemove.loc;
								parser.state.current.addDependency(dep);
								return bool;
							}
						}
					);
					parser.hooks.expressionLogicalOperator.tap(
						"ConstPlugin",
						expression => {
							if (
								expression.operator === "&&" ||
								expression.operator === "||"
							) {
								const param = parser.evaluateExpression(expression.left);
								const bool = param.asBool();
								if (typeof bool === "boolean") {
									// Expressions do not hoist.
									// It is safe to remove the dead branch.
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() && someExpression();
									//
									// the generated code is:
									//
									//   falsyExpression() && false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() && someExpression();
									//
									// the generated code is:
									//
									//   true && someExpression();
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   truthyExpression() || false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   false && someExpression();
									//
									const keepRight =
										(expression.operator === "&&" && bool) ||
										(expression.operator === "||" && !bool);

									if (param.isBoolean() || keepRight) {
										// for case like
										//
										//   return'development'===process.env.NODE_ENV&&'foo'
										//
										// we need a space before the bool to prevent result like
										//
										//   returnfalse&&'foo'
										//
										const dep = new ConstDependency(` ${bool}`, param.range);
										dep.loc = expression.loc;
										parser.state.current.addDependency(dep);
									} else {
										parser.walkExpression(expression.left);
									}
									if (!keepRight) {
										const dep = new ConstDependency(
											"false",
											expression.right.range
										);
										dep.loc = expression.loc;
										parser.state.current.addDependency(dep);
									}
									return keepRight;
								}
							}
						}
					);
					parser.hooks.evaluateIdentifier
						.for("__resourceQuery")
						.tap("ConstPlugin", expr => {
							if (!parser.state.module) return;
							return ParserHelpers.evaluateToString(
								getQuery(parser.state.module.resource)
							)(expr);
						});
					parser.hooks.expression
						.for("__resourceQuery")
						.tap("ConstPlugin", () => {
							if (!parser.state.module) return;
							parser.state.current.addVariable(
								"__resourceQuery",
								JSON.stringify(getQuery(parser.state.module.resource))
							);
							return true;
						});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ConstPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ConstPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("ConstPlugin", handler);
			}
		);
	}
}

module.exports = ConstPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ContextExclusionPlugin.js":
/*!***********************************************!*\
  !*** (webpack)/lib/ContextExclusionPlugin.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./ContextModuleFactory")} ContextModuleFactory */

class ContextExclusionPlugin {
	/**
	 * @param {RegExp} negativeMatcher Matcher regular expression
	 */
	constructor(negativeMatcher) {
		this.negativeMatcher = negativeMatcher;
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler Webpack Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.contextModuleFactory.tap("ContextExclusionPlugin", cmf => {
			cmf.hooks.contextModuleFiles.tap("ContextExclusionPlugin", files => {
				return files.filter(filePath => !this.negativeMatcher.test(filePath));
			});
		});
	}
}

module.exports = ContextExclusionPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ContextModule.js":
/*!**************************************!*\
  !*** (webpack)/lib/ContextModule.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const util = __webpack_require__(/*! util */ "util");
const { OriginalSource, RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const Module = __webpack_require__(/*! ./Module */ "./node_modules/webpack/lib/Module.js");
const AsyncDependenciesBlock = __webpack_require__(/*! ./AsyncDependenciesBlock */ "./node_modules/webpack/lib/AsyncDependenciesBlock.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");
const contextify = __webpack_require__(/*! ./util/identifier */ "./node_modules/webpack/lib/util/identifier.js").contextify;

/** @typedef {"sync" | "eager" | "weak" | "async-weak" | "lazy" | "lazy-once"} ContextMode Context mode */
/** @typedef {import("./dependencies/ContextElementDependency")} ContextElementDependency */

/**
 * @callback ResolveDependenciesCallback
 * @param {Error=} err
 * @param {ContextElementDependency[]} dependencies
 */

/**
 * @callback ResolveDependencies
 * @param {TODO} fs
 * @param {TODO} options
 * @param {ResolveDependenciesCallback} callback
 */

class ContextModule extends Module {
	// type ContextMode = "sync" | "eager" | "weak" | "async-weak" | "lazy" | "lazy-once"
	// type ContextOptions = { resource: string, recursive: boolean, regExp: RegExp, addon?: string, mode?: ContextMode, chunkName?: string, include?: RegExp, exclude?: RegExp, groupOptions?: Object }
	// resolveDependencies: (fs: FS, options: ContextOptions, (err: Error?, dependencies: Dependency[]) => void) => void
	// options: ContextOptions
	/**
	 * @param {ResolveDependencies} resolveDependencies function to get dependencies in this context
	 * @param {TODO} options options object
	 */
	constructor(resolveDependencies, options) {
		let resource;
		let resourceQuery;
		const queryIdx = options.resource.indexOf("?");
		if (queryIdx >= 0) {
			resource = options.resource.substr(0, queryIdx);
			resourceQuery = options.resource.substr(queryIdx);
		} else {
			resource = options.resource;
			resourceQuery = "";
		}

		super("javascript/dynamic", resource);

		// Info from Factory
		this.resolveDependencies = resolveDependencies;
		this.options = Object.assign({}, options, {
			resource: resource,
			resourceQuery: resourceQuery
		});
		if (options.resolveOptions !== undefined) {
			this.resolveOptions = options.resolveOptions;
		}

		// Info from Build
		this._contextDependencies = new Set([this.context]);

		if (typeof options.mode !== "string") {
			throw new Error("options.mode is a required option");
		}

		this._identifier = this._createIdentifier();
	}

	updateCacheModule(module) {
		this.resolveDependencies = module.resolveDependencies;
		this.options = module.options;
		this.resolveOptions = module.resolveOptions;
	}

	prettyRegExp(regexString) {
		// remove the "/" at the front and the beginning
		// "/foo/" -> "foo"
		return regexString.substring(1, regexString.length - 1);
	}

	_createIdentifier() {
		let identifier = this.context;
		if (this.options.resourceQuery) {
			identifier += ` ${this.options.resourceQuery}`;
		}
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (!this.options.recursive) {
			identifier += " nonrecursive";
		}
		if (this.options.addon) {
			identifier += ` ${this.options.addon}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this.options.regExp}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this.options.include}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this.options.exclude}`;
		}
		if (this.options.groupOptions) {
			identifier += ` groupOptions: ${JSON.stringify(
				this.options.groupOptions
			)}`;
		}
		if (this.options.namespaceObject === "strict") {
			identifier += " strict namespace object";
		} else if (this.options.namespaceObject) {
			identifier += " namespace object";
		}

		return identifier;
	}

	identifier() {
		return this._identifier;
	}

	readableIdentifier(requestShortener) {
		let identifier = requestShortener.shorten(this.context);
		if (this.options.resourceQuery) {
			identifier += ` ${this.options.resourceQuery}`;
		}
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (!this.options.recursive) {
			identifier += " nonrecursive";
		}
		if (this.options.addon) {
			identifier += ` ${requestShortener.shorten(this.options.addon)}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this.prettyRegExp(this.options.regExp + "")}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this.prettyRegExp(this.options.include + "")}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this.prettyRegExp(this.options.exclude + "")}`;
		}
		if (this.options.groupOptions) {
			const groupOptions = this.options.groupOptions;
			for (const key of Object.keys(groupOptions)) {
				identifier += ` ${key}: ${groupOptions[key]}`;
			}
		}
		if (this.options.namespaceObject === "strict") {
			identifier += " strict namespace object";
		} else if (this.options.namespaceObject) {
			identifier += " namespace object";
		}

		return identifier;
	}

	libIdent(options) {
		let identifier = contextify(options.context, this.context);
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (this.options.recursive) {
			identifier += " recursive";
		}
		if (this.options.addon) {
			identifier += ` ${contextify(options.context, this.options.addon)}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this.prettyRegExp(this.options.regExp + "")}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this.prettyRegExp(this.options.include + "")}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this.prettyRegExp(this.options.exclude + "")}`;
		}

		return identifier;
	}

	needRebuild(fileTimestamps, contextTimestamps) {
		const ts = contextTimestamps.get(this.context);
		if (!ts) {
			return true;
		}

		return ts >= this.buildInfo.builtTime;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {
			builtTime: Date.now(),
			contextDependencies: this._contextDependencies
		};
		this.resolveDependencies(fs, this.options, (err, dependencies) => {
			if (err) return callback(err);

			// abort if something failed
			// this will create an empty context
			if (!dependencies) {
				callback();
				return;
			}

			// enhance dependencies with meta info
			for (const dep of dependencies) {
				dep.loc = {
					name: dep.userRequest
				};
				dep.request = this.options.addon + dep.request;
			}

			if (this.options.mode === "sync" || this.options.mode === "eager") {
				// if we have an sync or eager context
				// just add all dependencies and continue
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy-once") {
				// for the lazy-once mode create a new async dependency block
				// and add that block to this context
				if (dependencies.length > 0) {
					const block = new AsyncDependenciesBlock(
						Object.assign({}, this.options.groupOptions, {
							name: this.options.chunkName
						}),
						this
					);
					for (const dep of dependencies) {
						block.addDependency(dep);
					}
					this.addBlock(block);
				}
			} else if (
				this.options.mode === "weak" ||
				this.options.mode === "async-weak"
			) {
				// we mark all dependencies as weak
				for (const dep of dependencies) {
					dep.weak = true;
				}
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy") {
				// if we are lazy create a new async dependency block per dependency
				// and add all blocks to this context
				let index = 0;
				for (const dep of dependencies) {
					let chunkName = this.options.chunkName;
					if (chunkName) {
						if (!/\[(index|request)\]/.test(chunkName)) {
							chunkName += "[index]";
						}
						chunkName = chunkName.replace(/\[index\]/g, index++);
						chunkName = chunkName.replace(
							/\[request\]/g,
							Template.toPath(dep.userRequest)
						);
					}
					const block = new AsyncDependenciesBlock(
						Object.assign({}, this.options.groupOptions, {
							name: chunkName
						}),
						dep.module,
						dep.loc,
						dep.userRequest
					);
					block.addDependency(dep);
					this.addBlock(block);
				}
			} else {
				callback(
					new Error(`Unsupported mode "${this.options.mode}" in context`)
				);
				return;
			}
			callback();
		});
	}

	getUserRequestMap(dependencies) {
		// if we filter first we get a new array
		// therefor we dont need to create a clone of dependencies explicitly
		// therefore the order of this is !important!
		return dependencies
			.filter(dependency => dependency.module)
			.sort((a, b) => {
				if (a.userRequest === b.userRequest) {
					return 0;
				}
				return a.userRequest < b.userRequest ? -1 : 1;
			})
			.reduce((map, dep) => {
				map[dep.userRequest] = dep.module.id;
				return map;
			}, Object.create(null));
	}

	getFakeMap(dependencies) {
		if (!this.options.namespaceObject) {
			return 9;
		}
		// if we filter first we get a new array
		// therefor we dont need to create a clone of dependencies explicitly
		// therefore the order of this is !important!
		let hasNonHarmony = false;
		let hasNamespace = false;
		let hasNamed = false;
		const fakeMap = dependencies
			.filter(dependency => dependency.module)
			.sort((a, b) => {
				return b.module.id - a.module.id;
			})
			.reduce((map, dep) => {
				const exportsType =
					dep.module.buildMeta && dep.module.buildMeta.exportsType;
				const id = dep.module.id;
				if (!exportsType) {
					map[id] = this.options.namespaceObject === "strict" ? 1 : 7;
					hasNonHarmony = true;
				} else if (exportsType === "namespace") {
					map[id] = 9;
					hasNamespace = true;
				} else if (exportsType === "named") {
					map[id] = 3;
					hasNamed = true;
				}
				return map;
			}, Object.create(null));
		if (!hasNamespace && hasNonHarmony && !hasNamed) {
			return this.options.namespaceObject === "strict" ? 1 : 7;
		}
		if (hasNamespace && !hasNonHarmony && !hasNamed) {
			return 9;
		}
		if (!hasNamespace && !hasNonHarmony && hasNamed) {
			return 3;
		}
		if (!hasNamespace && !hasNonHarmony && !hasNamed) {
			return 9;
		}
		return fakeMap;
	}

	getFakeMapInitStatement(fakeMap) {
		return typeof fakeMap === "object"
			? `var fakeMap = ${JSON.stringify(fakeMap, null, "\t")};`
			: "";
	}

	getReturn(type) {
		if (type === 9) {
			return "__webpack_require__(id)";
		}
		return `__webpack_require__.t(id, ${type})`;
	}

	getReturnModuleObjectSource(fakeMap, fakeMapDataExpression = "fakeMap[id]") {
		if (typeof fakeMap === "number") {
			return `return ${this.getReturn(fakeMap)};`;
		}
		return `return __webpack_require__.t(id, ${fakeMapDataExpression})`;
	}

	getSyncSource(dependencies, id) {
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackContext(req) {
	var id = webpackContextResolve(req);
	${returnModuleObject}
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = ${JSON.stringify(id)};`;
	}

	getWeakSyncSource(dependencies, id) {
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackContext(req) {
	var id = webpackContextResolve(req);
	if(!__webpack_require__.m[id]) {
		var e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	${returnModuleObject}
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
webpackContext.id = ${JSON.stringify(id)};
module.exports = webpackContext;`;
	}

	getAsyncWeakSource(dependencies, id) {
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(function(id) {
		if(!__webpack_require__.m[id]) {
			var e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		${returnModuleObject}
	});
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		var id = map[req];
		if(!(id + 1)) { // check for number or string
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return id;
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	getEagerSource(dependencies, id) {
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const thenFunction =
			fakeMap !== 9
				? `function(id) {
		${this.getReturnModuleObjectSource(fakeMap)}
	}`
				: "__webpack_require__";
		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${thenFunction});
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		var id = map[req];
		if(!(id + 1)) { // check for number or string
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return id;
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	getLazyOnceSource(block, dependencies, id, runtimeTemplate) {
		const promise = runtimeTemplate.blockPromise({
			block,
			message: "lazy-once context"
		});
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const thenFunction =
			fakeMap !== 9
				? `function(id) {
		${this.getReturnModuleObjectSource(fakeMap)};
	}`
				: "__webpack_require__";

		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${thenFunction});
}
function webpackAsyncContextResolve(req) {
	return ${promise}.then(function() {
		var id = map[req];
		if(!(id + 1)) { // check for number or string
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return id;
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	getLazySource(blocks, id) {
		let hasMultipleOrNoChunks = false;
		const fakeMap = this.getFakeMap(blocks.map(b => b.dependencies[0]));
		const map = blocks
			.filter(block => block.dependencies[0].module)
			.map(block => ({
				dependency: block.dependencies[0],
				block: block,
				userRequest: block.dependencies[0].userRequest
			}))
			.sort((a, b) => {
				if (a.userRequest === b.userRequest) return 0;
				return a.userRequest < b.userRequest ? -1 : 1;
			})
			.reduce((map, item) => {
				const chunks =
					(item.block.chunkGroup && item.block.chunkGroup.chunks) || [];
				if (chunks.length !== 1) {
					hasMultipleOrNoChunks = true;
				}
				const arrayStart = [item.dependency.module.id];
				if (typeof fakeMap === "object") {
					arrayStart.push(fakeMap[item.dependency.module.id]);
				}
				map[item.userRequest] = arrayStart.concat(
					chunks.map(chunk => chunk.id)
				);

				return map;
			}, Object.create(null));

		const chunksStartPosition = typeof fakeMap === "object" ? 2 : 1;
		const requestPrefix = hasMultipleOrNoChunks
			? `Promise.all(ids.slice(${chunksStartPosition}).map(__webpack_require__.e))`
			: `__webpack_require__.e(ids[${chunksStartPosition}])`;
		const returnModuleObject = this.getReturnModuleObjectSource(
			fakeMap,
			"ids[1]"
		);

		return `var map = ${JSON.stringify(map, null, "\t")};
function webpackAsyncContext(req) {
	var ids = map[req];
	if(!ids) {
		return Promise.resolve().then(function() {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}
	return ${requestPrefix}.then(function() {
		var id = ids[0];
		${returnModuleObject}
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	getSourceForEmptyContext(id) {
		return `function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = ${JSON.stringify(id)};`;
	}

	getSourceForEmptyAsyncContext(id) {
		return `function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = ${JSON.stringify(id)};`;
	}

	getSourceString(asyncMode, runtimeTemplate) {
		if (asyncMode === "lazy") {
			if (this.blocks && this.blocks.length > 0) {
				return this.getLazySource(this.blocks, this.id);
			}
			return this.getSourceForEmptyAsyncContext(this.id);
		}
		if (asyncMode === "eager") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getEagerSource(this.dependencies, this.id);
			}
			return this.getSourceForEmptyAsyncContext(this.id);
		}
		if (asyncMode === "lazy-once") {
			const block = this.blocks[0];
			if (block) {
				return this.getLazyOnceSource(
					block,
					block.dependencies,
					this.id,
					runtimeTemplate
				);
			}
			return this.getSourceForEmptyAsyncContext(this.id);
		}
		if (asyncMode === "async-weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getAsyncWeakSource(this.dependencies, this.id);
			}
			return this.getSourceForEmptyAsyncContext(this.id);
		}
		if (asyncMode === "weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getWeakSyncSource(this.dependencies, this.id);
			}
		}
		if (this.dependencies && this.dependencies.length > 0) {
			return this.getSyncSource(this.dependencies, this.id);
		}
		return this.getSourceForEmptyContext(this.id);
	}

	getSource(sourceString) {
		if (this.useSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

	source(dependencyTemplates, runtimeTemplate) {
		return this.getSource(
			this.getSourceString(this.options.mode, runtimeTemplate)
		);
	}

	size() {
		// base penalty
		const initialSize = 160;

		// if we dont have dependencies we stop here.
		return this.dependencies.reduce((size, dependency) => {
			const element = /** @type {ContextElementDependency} */ (dependency);
			return size + 5 + element.userRequest.length;
		}, initialSize);
	}
}

// TODO remove in webpack 5
Object.defineProperty(ContextModule.prototype, "recursive", {
	configurable: false,
	get: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @returns {boolean} is recursive
		 */
		function() {
			return this.options.recursive;
		},
		"ContextModule.recursive has been moved to ContextModule.options.recursive"
	),
	set: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @param {boolean} value is recursive
		 * @returns {void}
		 */
		function(value) {
			this.options.recursive = value;
		},
		"ContextModule.recursive has been moved to ContextModule.options.recursive"
	)
});

// TODO remove in webpack 5
Object.defineProperty(ContextModule.prototype, "regExp", {
	configurable: false,
	get: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @returns {RegExp} regular expression
		 */
		function() {
			return this.options.regExp;
		},
		"ContextModule.regExp has been moved to ContextModule.options.regExp"
	),
	set: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @param {RegExp} value Regular expression
		 * @returns {void}
		 */
		function(value) {
			this.options.regExp = value;
		},
		"ContextModule.regExp has been moved to ContextModule.options.regExp"
	)
});

// TODO remove in webpack 5
Object.defineProperty(ContextModule.prototype, "addon", {
	configurable: false,
	get: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @returns {string} addon
		 */
		function() {
			return this.options.addon;
		},
		"ContextModule.addon has been moved to ContextModule.options.addon"
	),
	set: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @param {string} value addon
		 * @returns {void}
		 */
		function(value) {
			this.options.addon = value;
		},
		"ContextModule.addon has been moved to ContextModule.options.addon"
	)
});

// TODO remove in webpack 5
Object.defineProperty(ContextModule.prototype, "async", {
	configurable: false,
	get: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @returns {boolean} is async
		 */
		function() {
			return this.options.mode;
		},
		"ContextModule.async has been moved to ContextModule.options.mode"
	),
	set: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @param {ContextMode} value Context mode
		 * @returns {void}
		 */
		function(value) {
			this.options.mode = value;
		},
		"ContextModule.async has been moved to ContextModule.options.mode"
	)
});

// TODO remove in webpack 5
Object.defineProperty(ContextModule.prototype, "chunkName", {
	configurable: false,
	get: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @returns {string} chunk name
		 */
		function() {
			return this.options.chunkName;
		},
		"ContextModule.chunkName has been moved to ContextModule.options.chunkName"
	),
	set: util.deprecate(
		/**
		 * @deprecated
		 * @this {ContextModule}
		 * @param {string} value chunk name
		 * @returns {void}
		 */
		function(value) {
			this.options.chunkName = value;
		},
		"ContextModule.chunkName has been moved to ContextModule.options.chunkName"
	)
});

module.exports = ContextModule;


/***/ }),

/***/ "./node_modules/webpack/lib/ContextModuleFactory.js":
/*!*********************************************!*\
  !*** (webpack)/lib/ContextModuleFactory.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");
const path = __webpack_require__(/*! path */ "path");

const {
	Tapable,
	AsyncSeriesWaterfallHook,
	SyncWaterfallHook
} = __webpack_require__(/*! tapable */ "tapable");
const ContextModule = __webpack_require__(/*! ./ContextModule */ "./node_modules/webpack/lib/ContextModule.js");
const ContextElementDependency = __webpack_require__(/*! ./dependencies/ContextElementDependency */ "./node_modules/webpack/lib/dependencies/ContextElementDependency.js");

/** @typedef {import("./Module")} Module */

const EMPTY_RESOLVE_OPTIONS = {};

module.exports = class ContextModuleFactory extends Tapable {
	constructor(resolverFactory) {
		super();
		this.hooks = {
			/** @type {AsyncSeriesWaterfallHook<TODO>} */
			beforeResolve: new AsyncSeriesWaterfallHook(["data"]),
			/** @type {AsyncSeriesWaterfallHook<TODO>} */
			afterResolve: new AsyncSeriesWaterfallHook(["data"]),
			/** @type {SyncWaterfallHook<string[]>} */
			contextModuleFiles: new SyncWaterfallHook(["files"]),
			/** @type {SyncWaterfallHook<TODO[]>} */
			alternatives: new AsyncSeriesWaterfallHook(["modules"])
		};
		this._pluginCompat.tap("ContextModuleFactory", options => {
			switch (options.name) {
				case "before-resolve":
				case "after-resolve":
				case "alternatives":
					options.async = true;
					break;
			}
		});
		this.resolverFactory = resolverFactory;
	}

	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = dependencies[0];
		this.hooks.beforeResolve.callAsync(
			Object.assign(
				{
					context: context,
					dependencies: dependencies,
					resolveOptions
				},
				dependency.options
			),
			(err, beforeResolveResult) => {
				if (err) return callback(err);

				// Ignored
				if (!beforeResolveResult) return callback();

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}

				const contextResolver = this.resolverFactory.get(
					"context",
					resolveOptions || EMPTY_RESOLVE_OPTIONS
				);
				const loaderResolver = this.resolverFactory.get(
					"loader",
					EMPTY_RESOLVE_OPTIONS
				);

				asyncLib.parallel(
					[
						callback => {
							contextResolver.resolve(
								{},
								context,
								resource,
								{},
								(err, result) => {
									if (err) return callback(err);
									callback(null, result);
								}
							);
						},
						callback => {
							asyncLib.map(
								loaders,
								(loader, callback) => {
									loaderResolver.resolve(
										{},
										context,
										loader,
										{},
										(err, result) => {
											if (err) return callback(err);
											callback(null, result);
										}
									);
								},
								callback
							);
						}
					],
					(err, result) => {
						if (err) return callback(err);

						this.hooks.afterResolve.callAsync(
							Object.assign(
								{
									addon:
										loadersPrefix +
										result[1].join("!") +
										(result[1].length > 0 ? "!" : ""),
									resource: result[0],
									resolveDependencies: this.resolveDependencies.bind(this)
								},
								beforeResolveResult
							),
							(err, result) => {
								if (err) return callback(err);

								// Ignored
								if (!result) return callback();

								return callback(
									null,
									new ContextModule(result.resolveDependencies, result)
								);
							}
						);
					}
				);
			}
		);
	}

	resolveDependencies(fs, options, callback) {
		const cmf = this;
		let resource = options.resource;
		let resourceQuery = options.resourceQuery;
		let recursive = options.recursive;
		let regExp = options.regExp;
		let include = options.include;
		let exclude = options.exclude;
		if (!regExp || !resource) return callback(null, []);

		const addDirectory = (directory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				files = cmf.hooks.contextModuleFiles.call(files);
				if (!files || files.length === 0) return callback(null, []);
				asyncLib.map(
					files.filter(p => p.indexOf(".") !== 0),
					(segment, callback) => {
						const subResource = path.join(directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, stat) => {
								if (err) {
									if (err.code === "ENOENT") {
										// ENOENT is ok here because the file may have been deleted between
										// the readdir and stat calls.
										return callback();
									} else {
										return callback(err);
									}
								}

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addDirectory.call(this, subResource, callback);
								} else if (
									stat.isFile() &&
									(!include || subResource.match(include))
								) {
									const obj = {
										context: resource,
										request:
											"." +
											subResource.substr(resource.length).replace(/\\/g, "/")
									};

									this.hooks.alternatives.callAsync(
										[obj],
										(err, alternatives) => {
											if (err) return callback(err);
											alternatives = alternatives
												.filter(obj => regExp.test(obj.request))
												.map(obj => {
													const dep = new ContextElementDependency(
														obj.request + resourceQuery,
														obj.request
													);
													dep.optional = true;
													return dep;
												});
											callback(null, alternatives);
										}
									);
								} else {
									callback();
								}
							});
						} else {
							callback();
						}
					},
					(err, result) => {
						if (err) return callback(err);

						if (!result) return callback(null, []);

						callback(
							null,
							result.filter(Boolean).reduce((a, i) => a.concat(i), [])
						);
					}
				);
			});
		};

		addDirectory(resource, callback);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/ContextReplacementPlugin.js":
/*!*************************************************!*\
  !*** (webpack)/lib/ContextReplacementPlugin.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const path = __webpack_require__(/*! path */ "path");
const ContextElementDependency = __webpack_require__(/*! ./dependencies/ContextElementDependency */ "./node_modules/webpack/lib/dependencies/ContextElementDependency.js");

class ContextReplacementPlugin {
	constructor(
		resourceRegExp,
		newContentResource,
		newContentRecursive,
		newContentRegExp
	) {
		this.resourceRegExp = resourceRegExp;

		if (typeof newContentResource === "function") {
			this.newContentCallback = newContentResource;
		} else if (
			typeof newContentResource === "string" &&
			typeof newContentRecursive === "object"
		) {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = (fs, callback) => {
				callback(null, newContentRecursive);
			};
		} else if (
			typeof newContentResource === "string" &&
			typeof newContentRecursive === "function"
		) {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = newContentRecursive;
		} else {
			if (typeof newContentResource !== "string") {
				newContentRegExp = newContentRecursive;
				newContentRecursive = newContentResource;
				newContentResource = undefined;
			}
			if (typeof newContentRecursive !== "boolean") {
				newContentRegExp = newContentRecursive;
				newContentRecursive = undefined;
			}
			this.newContentResource = newContentResource;
			this.newContentRecursive = newContentRecursive;
			this.newContentRegExp = newContentRegExp;
		}
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const newContentCallback = this.newContentCallback;
		const newContentResource = this.newContentResource;
		const newContentRecursive = this.newContentRecursive;
		const newContentRegExp = this.newContentRegExp;
		const newContentCreateContextMap = this.newContentCreateContextMap;

		compiler.hooks.contextModuleFactory.tap("ContextReplacementPlugin", cmf => {
			cmf.hooks.beforeResolve.tap("ContextReplacementPlugin", result => {
				if (!result) return;
				if (resourceRegExp.test(result.request)) {
					if (newContentResource !== undefined) {
						result.request = newContentResource;
					}
					if (newContentRecursive !== undefined) {
						result.recursive = newContentRecursive;
					}
					if (newContentRegExp !== undefined) {
						result.regExp = newContentRegExp;
					}
					if (typeof newContentCallback === "function") {
						newContentCallback(result);
					} else {
						for (const d of result.dependencies) {
							if (d.critical) d.critical = false;
						}
					}
				}
				return result;
			});
			cmf.hooks.afterResolve.tap("ContextReplacementPlugin", result => {
				if (!result) return;
				if (resourceRegExp.test(result.resource)) {
					if (newContentResource !== undefined) {
						result.resource = path.resolve(result.resource, newContentResource);
					}
					if (newContentRecursive !== undefined) {
						result.recursive = newContentRecursive;
					}
					if (newContentRegExp !== undefined) {
						result.regExp = newContentRegExp;
					}
					if (typeof newContentCreateContextMap === "function") {
						result.resolveDependencies = createResolveDependenciesFromContextMap(
							newContentCreateContextMap
						);
					}
					if (typeof newContentCallback === "function") {
						const origResource = result.resource;
						newContentCallback(result);
						if (result.resource !== origResource) {
							result.resource = path.resolve(origResource, result.resource);
						}
					} else {
						for (const d of result.dependencies) {
							if (d.critical) d.critical = false;
						}
					}
				}
				return result;
			});
		});
	}
}

const createResolveDependenciesFromContextMap = createContextMap => {
	const resolveDependenciesFromContextMap = (fs, options, callback) => {
		createContextMap(fs, (err, map) => {
			if (err) return callback(err);
			const dependencies = Object.keys(map).map(key => {
				return new ContextElementDependency(
					map[key] + options.resourceQuery,
					key
				);
			});
			callback(null, dependencies);
		});
	};
	return resolveDependenciesFromContextMap;
};

module.exports = ContextReplacementPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/DefinePlugin.js":
/*!*************************************!*\
  !*** (webpack)/lib/DefinePlugin.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const BasicEvaluatedExpression = __webpack_require__(/*! ./BasicEvaluatedExpression */ "./node_modules/webpack/lib/BasicEvaluatedExpression.js");
const ParserHelpers = __webpack_require__(/*! ./ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");
const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Parser")} Parser */
/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */
/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */

class RuntimeValue {
	constructor(fn, fileDependencies) {
		this.fn = fn;
		this.fileDependencies = fileDependencies || [];
	}

	exec(parser) {
		if (this.fileDependencies === true) {
			parser.state.module.buildInfo.cacheable = false;
		} else {
			for (const fileDependency of this.fileDependencies) {
				parser.state.module.buildInfo.fileDependencies.add(fileDependency);
			}
		}

		return this.fn({ module: parser.state.module });
	}
}

const stringifyObj = (obj, parser) => {
	return (
		"Object({" +
		Object.keys(obj)
			.map(key => {
				const code = obj[key];
				return JSON.stringify(key) + ":" + toCode(code, parser);
			})
			.join(",") +
		"})"
	);
};

/**
 * Convert code to a string that evaluates
 * @param {CodeValue} code Code to evaluate
 * @param {Parser} parser Parser
 * @returns {string} code converted to string that evaluates
 */
const toCode = (code, parser) => {
	if (code === null) {
		return "null";
	}
	if (code === undefined) {
		return "undefined";
	}
	if (code instanceof RuntimeValue) {
		return toCode(code.exec(parser), parser);
	}
	if (code instanceof RegExp && code.toString) {
		return code.toString();
	}
	if (typeof code === "function" && code.toString) {
		return "(" + code.toString() + ")";
	}
	if (typeof code === "object") {
		return stringifyObj(code, parser);
	}
	return code + "";
};

class DefinePlugin {
	/**
	 * Create a new define plugin
	 * @param {Record<string, CodeValue>} definitions A map of global object definitions
	 */
	constructor(definitions) {
		this.definitions = definitions;
	}

	static runtimeValue(fn, fileDependencies) {
		return new RuntimeValue(fn, fileDependencies);
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler Webpack compiler
	 * @returns {void}
	 */
	apply(compiler) {
		const definitions = this.definitions;
		compiler.hooks.compilation.tap(
			"DefinePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				/**
				 * Handler
				 * @param {Parser} parser Parser
				 * @returns {void}
				 */
				const handler = parser => {
					/**
					 * Walk definitions
					 * @param {Object} definitions Definitions map
					 * @param {string} prefix Prefix string
					 * @returns {void}
					 */
					const walkDefinitions = (definitions, prefix) => {
						Object.keys(definitions).forEach(key => {
							const code = definitions[key];
							if (
								code &&
								typeof code === "object" &&
								!(code instanceof RuntimeValue) &&
								!(code instanceof RegExp)
							) {
								walkDefinitions(code, prefix + key + ".");
								applyObjectDefine(prefix + key, code);
								return;
							}
							applyDefineKey(prefix, key);
							applyDefine(prefix + key, code);
						});
					};

					/**
					 * Apply define key
					 * @param {string} prefix Prefix
					 * @param {string} key Key
					 * @returns {void}
					 */
					const applyDefineKey = (prefix, key) => {
						const splittedKey = key.split(".");
						splittedKey.slice(1).forEach((_, i) => {
							const fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
							parser.hooks.canRename
								.for(fullKey)
								.tap("DefinePlugin", ParserHelpers.approve);
						});
					};

					/**
					 * Apply Code
					 * @param {string} key Key
					 * @param {CodeValue} code Code
					 * @returns {void}
					 */
					const applyDefine = (key, code) => {
						const isTypeof = /^typeof\s+/.test(key);
						if (isTypeof) key = key.replace(/^typeof\s+/, "");
						let recurse = false;
						let recurseTypeof = false;
						if (!isTypeof) {
							parser.hooks.canRename
								.for(key)
								.tap("DefinePlugin", ParserHelpers.approve);
							parser.hooks.evaluateIdentifier
								.for(key)
								.tap("DefinePlugin", expr => {
									/**
									 * this is needed in case there is a recursion in the DefinePlugin
									 * to prevent an endless recursion
									 * e.g.: new DefinePlugin({
									 * "a": "b",
									 * "b": "a"
									 * });
									 */
									if (recurse) return;
									recurse = true;
									const res = parser.evaluate(toCode(code, parser));
									recurse = false;
									res.setRange(expr.range);
									return res;
								});
							parser.hooks.expression.for(key).tap("DefinePlugin", expr => {
								const strCode = toCode(code, parser);
								if (/__webpack_require__/.test(strCode)) {
									return ParserHelpers.toConstantDependencyWithWebpackRequire(
										parser,
										strCode
									)(expr);
								} else {
									return ParserHelpers.toConstantDependency(parser, strCode)(
										expr
									);
								}
							});
						}
						parser.hooks.evaluateTypeof.for(key).tap("DefinePlugin", expr => {
							/**
							 * this is needed in case there is a recursion in the DefinePlugin
							 * to prevent an endless recursion
							 * e.g.: new DefinePlugin({
							 * "typeof a": "typeof b",
							 * "typeof b": "typeof a"
							 * });
							 */
							if (recurseTypeof) return;
							recurseTypeof = true;
							const typeofCode = isTypeof
								? toCode(code, parser)
								: "typeof (" + toCode(code, parser) + ")";
							const res = parser.evaluate(typeofCode);
							recurseTypeof = false;
							res.setRange(expr.range);
							return res;
						});
						parser.hooks.typeof.for(key).tap("DefinePlugin", expr => {
							const typeofCode = isTypeof
								? toCode(code, parser)
								: "typeof (" + toCode(code, parser) + ")";
							const res = parser.evaluate(typeofCode);
							if (!res.isString()) return;
							return ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify(res.string)
							).bind(parser)(expr);
						});
					};

					/**
					 * Apply Object
					 * @param {string} key Key
					 * @param {Object} obj Object
					 * @returns {void}
					 */
					const applyObjectDefine = (key, obj) => {
						parser.hooks.canRename
							.for(key)
							.tap("DefinePlugin", ParserHelpers.approve);
						parser.hooks.evaluateIdentifier
							.for(key)
							.tap("DefinePlugin", expr =>
								new BasicEvaluatedExpression().setTruthy().setRange(expr.range)
							);
						parser.hooks.evaluateTypeof.for(key).tap("DefinePlugin", expr => {
							return ParserHelpers.evaluateToString("object")(expr);
						});
						parser.hooks.expression.for(key).tap("DefinePlugin", expr => {
							const strCode = stringifyObj(obj, parser);

							if (/__webpack_require__/.test(strCode)) {
								return ParserHelpers.toConstantDependencyWithWebpackRequire(
									parser,
									strCode
								)(expr);
							} else {
								return ParserHelpers.toConstantDependency(parser, strCode)(
									expr
								);
							}
						});
						parser.hooks.typeof.for(key).tap("DefinePlugin", expr => {
							return ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("object")
							)(expr);
						});
					};

					walkDefinitions(definitions, "");
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("DefinePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("DefinePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("DefinePlugin", handler);
			}
		);
	}
}
module.exports = DefinePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/DelegatedModule.js":
/*!****************************************!*\
  !*** (webpack)/lib/DelegatedModule.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { OriginalSource, RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

const Module = __webpack_require__(/*! ./Module */ "./node_modules/webpack/lib/Module.js");
const WebpackMissingModule = __webpack_require__(/*! ./dependencies/WebpackMissingModule */ "./node_modules/webpack/lib/dependencies/WebpackMissingModule.js");
const DelegatedSourceDependency = __webpack_require__(/*! ./dependencies/DelegatedSourceDependency */ "./node_modules/webpack/lib/dependencies/DelegatedSourceDependency.js");
const DelegatedExportsDependency = __webpack_require__(/*! ./dependencies/DelegatedExportsDependency */ "./node_modules/webpack/lib/dependencies/DelegatedExportsDependency.js");

/** @typedef {import("./dependencies/ModuleDependency")} ModuleDependency */
/** @typedef {import("./util/createHash").Hash} Hash */

class DelegatedModule extends Module {
	constructor(sourceRequest, data, type, userRequest, originalRequest) {
		super("javascript/dynamic", null);

		// Info from Factory
		this.sourceRequest = sourceRequest;
		this.request = data.id;
		this.type = type;
		this.userRequest = userRequest;
		this.originalRequest = originalRequest;
		this.delegateData = data;

		// Build info
		this.delegatedSourceDependency = undefined;
	}

	libIdent(options) {
		return typeof this.originalRequest === "string"
			? this.originalRequest
			: this.originalRequest.libIdent(options);
	}

	identifier() {
		return `delegated ${JSON.stringify(this.request)} from ${
			this.sourceRequest
		}`;
	}

	readableIdentifier() {
		return `delegated ${this.userRequest} from ${this.sourceRequest}`;
	}

	needRebuild() {
		return false;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = Object.assign({}, this.delegateData.buildMeta);
		this.buildInfo = {};
		this.delegatedSourceDependency = new DelegatedSourceDependency(
			this.sourceRequest
		);
		this.addDependency(this.delegatedSourceDependency);
		this.addDependency(
			new DelegatedExportsDependency(this, this.delegateData.exports || true)
		);
		callback();
	}

	source(depTemplates, runtime) {
		const dep = /** @type {DelegatedSourceDependency} */ (this.dependencies[0]);
		const sourceModule = dep.module;
		let str;

		if (!sourceModule) {
			str = WebpackMissingModule.moduleCode(this.sourceRequest);
		} else {
			str = `module.exports = (${runtime.moduleExports({
				module: sourceModule,
				request: dep.request
			})})`;

			switch (this.type) {
				case "require":
					str += `(${JSON.stringify(this.request)})`;
					break;
				case "object":
					str += `[${JSON.stringify(this.request)}]`;
					break;
			}

			str += ";";
		}

		if (this.useSourceMap) {
			return new OriginalSource(str, this.identifier());
		} else {
			return new RawSource(str);
		}
	}

	size() {
		return 42;
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update(this.type);
		hash.update(JSON.stringify(this.request));
		super.updateHash(hash);
	}
}

module.exports = DelegatedModule;


/***/ }),

/***/ "./node_modules/webpack/lib/DelegatedModuleFactoryPlugin.js":
/*!*****************************************************!*\
  !*** (webpack)/lib/DelegatedModuleFactoryPlugin.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DelegatedModule = __webpack_require__(/*! ./DelegatedModule */ "./node_modules/webpack/lib/DelegatedModule.js");

// options.source
// options.type
// options.context
// options.scope
// options.content
class DelegatedModuleFactoryPlugin {
	constructor(options) {
		this.options = options;
		options.type = options.type || "require";
		options.extensions = options.extensions || [
			"",
			".wasm",
			".mjs",
			".js",
			".json"
		];
	}

	apply(normalModuleFactory) {
		const scope = this.options.scope;
		if (scope) {
			normalModuleFactory.hooks.factory.tap(
				"DelegatedModuleFactoryPlugin",
				factory => (data, callback) => {
					const dependency = data.dependencies[0];
					const request = dependency.request;
					if (request && request.indexOf(scope + "/") === 0) {
						const innerRequest = "." + request.substr(scope.length);
						let resolved;
						if (innerRequest in this.options.content) {
							resolved = this.options.content[innerRequest];
							return callback(
								null,
								new DelegatedModule(
									this.options.source,
									resolved,
									this.options.type,
									innerRequest,
									request
								)
							);
						}
						for (let i = 0; i < this.options.extensions.length; i++) {
							const extension = this.options.extensions[i];
							const requestPlusExt = innerRequest + extension;
							if (requestPlusExt in this.options.content) {
								resolved = this.options.content[requestPlusExt];
								return callback(
									null,
									new DelegatedModule(
										this.options.source,
										resolved,
										this.options.type,
										requestPlusExt,
										request + extension
									)
								);
							}
						}
					}
					return factory(data, callback);
				}
			);
		} else {
			normalModuleFactory.hooks.module.tap(
				"DelegatedModuleFactoryPlugin",
				module => {
					if (module.libIdent) {
						const request = module.libIdent(this.options);
						if (request && request in this.options.content) {
							const resolved = this.options.content[request];
							return new DelegatedModule(
								this.options.source,
								resolved,
								this.options.type,
								request,
								module
							);
						}
					}
					return module;
				}
			);
		}
	}
}
module.exports = DelegatedModuleFactoryPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/DependenciesBlock.js":
/*!******************************************!*\
  !*** (webpack)/lib/DependenciesBlock.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */


const DependenciesBlockVariable = __webpack_require__(/*! ./DependenciesBlockVariable */ "./node_modules/webpack/lib/DependenciesBlockVariable.js");

/** @typedef {import("./ChunkGroup")} ChunkGroup */
/** @typedef {import("./Dependency")} Dependency */
/** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("./DependenciesBlockVariable")} DependenciesBlockVariable */
/** @typedef {(d: Dependency) => boolean} DependencyFilterFunction */
/** @typedef {import("./util/createHash").Hash} Hash */

class DependenciesBlock {
	constructor() {
		/** @type {Dependency[]} */
		this.dependencies = [];
		/** @type {AsyncDependenciesBlock[]} */
		this.blocks = [];
		/** @type {DependenciesBlockVariable[]} */
		this.variables = [];
	}

	/**
	 * Adds a DependencyBlock to DependencyBlock relationship.
	 * This is used for when a Module has a AsyncDependencyBlock tie (for code-splitting)
	 *
	 * @param {AsyncDependenciesBlock} block block being added
	 * @returns {void}
	 */
	addBlock(block) {
		this.blocks.push(block);
		block.parent = this;
	}

	/**
	 * @param {string} name name of dependency
	 * @param {string} expression expression string for variable
	 * @param {Dependency[]} dependencies dependency instances tied to variable
	 * @returns {void}
	 */
	addVariable(name, expression, dependencies) {
		for (let v of this.variables) {
			if (v.name === name && v.expression === expression) {
				return;
			}
		}
		this.variables.push(
			new DependenciesBlockVariable(name, expression, dependencies)
		);
	}

	/**
	 * @param {Dependency} dependency dependency being tied to block.
	 * This is an "edge" pointing to another "node" on module graph.
	 * @returns {void}
	 */
	addDependency(dependency) {
		this.dependencies.push(dependency);
	}

	/**
	 * @param {Dependency} dependency dependency being removed
	 * @returns {void}
	 */
	removeDependency(dependency) {
		const idx = this.dependencies.indexOf(dependency);
		if (idx >= 0) {
			this.dependencies.splice(idx, 1);
		}
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @returns {void}
	 */
	updateHash(hash) {
		for (const dep of this.dependencies) dep.updateHash(hash);
		for (const block of this.blocks) block.updateHash(hash);
		for (const variable of this.variables) variable.updateHash(hash);
	}

	disconnect() {
		for (const dep of this.dependencies) dep.disconnect();
		for (const block of this.blocks) block.disconnect();
		for (const variable of this.variables) variable.disconnect();
	}

	unseal() {
		for (const block of this.blocks) block.unseal();
	}

	/**
	 * @param {DependencyFilterFunction} filter filter function for dependencies, gets passed all dependency ties from current instance
	 * @returns {boolean} returns boolean for filter
	 */
	hasDependencies(filter) {
		if (filter) {
			for (const dep of this.dependencies) {
				if (filter(dep)) return true;
			}
		} else {
			if (this.dependencies.length > 0) {
				return true;
			}
		}

		for (const block of this.blocks) {
			if (block.hasDependencies(filter)) return true;
		}
		for (const variable of this.variables) {
			if (variable.hasDependencies(filter)) return true;
		}
		return false;
	}

	sortItems() {
		for (const block of this.blocks) block.sortItems();
	}
}

module.exports = DependenciesBlock;


/***/ }),

/***/ "./node_modules/webpack/lib/DependenciesBlockVariable.js":
/*!**************************************************!*\
  !*** (webpack)/lib/DependenciesBlockVariable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { RawSource, ReplaceSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

/** @typedef {import("./Dependency")} Dependency */
/** @typedef {import("./Dependency").DependencyTemplate} DependencyTemplate */
/** @typedef {import("./RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("./util/createHash").Hash} Hash */
/** @typedef {(d: Dependency) => boolean} DependencyFilterFunction */
/** @typedef {Map<Function, DependencyTemplate>} DependencyTemplates */

class DependenciesBlockVariable {
	/**
	 * Creates an instance of DependenciesBlockVariable.
	 * @param {string} name name of DependenciesBlockVariable
	 * @param {string} expression expression string
	 * @param {Dependency[]=} dependencies dependencies tied to this varaiable
	 */
	constructor(name, expression, dependencies) {
		this.name = name;
		this.expression = expression;
		this.dependencies = dependencies || [];
	}

	/**
	 * @param {Hash} hash hash for instance to update
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update(this.name);
		hash.update(this.expression);
		for (const d of this.dependencies) {
			d.updateHash(hash);
		}
	}

	/**
	 * @param {DependencyTemplates} dependencyTemplates Dependency constructors and templates Map.
	 * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate to generate expression souce
	 * @returns {ReplaceSource} returns constructed source for expression via templates
	 */
	expressionSource(dependencyTemplates, runtimeTemplate) {
		const source = new ReplaceSource(new RawSource(this.expression));
		for (const dep of this.dependencies) {
			const template = dependencyTemplates.get(dep.constructor);
			if (!template) {
				throw new Error(`No template for dependency: ${dep.constructor.name}`);
			}
			template.apply(dep, source, runtimeTemplate, dependencyTemplates);
		}
		return source;
	}

	disconnect() {
		for (const d of this.dependencies) {
			d.disconnect();
		}
	}

	hasDependencies(filter) {
		if (filter) {
			return this.dependencies.some(filter);
		}
		return this.dependencies.length > 0;
	}
}

module.exports = DependenciesBlockVariable;


/***/ }),

/***/ "./node_modules/webpack/lib/Dependency.js":
/*!***********************************!*\
  !*** (webpack)/lib/Dependency.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const util = __webpack_require__(/*! util */ "util");
const compareLocations = __webpack_require__(/*! ./compareLocations */ "./node_modules/webpack/lib/compareLocations.js");
const DependencyReference = __webpack_require__(/*! ./dependencies/DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");

/** @typedef {import("./Module")} Module */
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./RuntimeTemplate")} RuntimeTemplate */

/**
 * @typedef {Object} DependencyTemplate
 * @property {function(Dependency, Source, RuntimeTemplate, Map<Function, DependencyTemplate>): void} apply
 */

/** @typedef {Object} SourcePosition
 *  @property {number} line
 *  @property {number=} column
 */

/** @typedef {Object} RealDependencyLocation
 *  @property {SourcePosition} start
 *  @property {SourcePosition=} end
 *  @property {number=} index
 */

/** @typedef {Object} SynteticDependencyLocation
 *  @property {string} name
 *  @property {number=} index
 */

/** @typedef {SynteticDependencyLocation|RealDependencyLocation} DependencyLocation */

class Dependency {
	constructor() {
		/** @type {Module|null} */
		this.module = null;
		// TODO remove in webpack 5
		/** @type {boolean} */
		this.weak = false;
		/** @type {boolean} */
		this.optional = false;
		/** @type {DependencyLocation} */
		this.loc = undefined;
	}

	getResourceIdentifier() {
		return null;
	}

	// Returns the referenced module and export
	getReference() {
		if (!this.module) return null;
		return new DependencyReference(this.module, true, this.weak);
	}

	// Returns the exported names
	getExports() {
		return null;
	}

	getWarnings() {
		return null;
	}

	getErrors() {
		return null;
	}

	updateHash(hash) {
		hash.update((this.module && this.module.id) + "");
	}

	disconnect() {
		this.module = null;
	}
}

// TODO remove in webpack 5
Dependency.compare = util.deprecate(
	(a, b) => compareLocations(a.loc, b.loc),
	"Dependency.compare is deprecated and will be removed in the next major version"
);

module.exports = Dependency;


/***/ }),

/***/ "./node_modules/webpack/lib/DllEntryPlugin.js":
/*!***************************************!*\
  !*** (webpack)/lib/DllEntryPlugin.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DllEntryDependency = __webpack_require__(/*! ./dependencies/DllEntryDependency */ "./node_modules/webpack/lib/dependencies/DllEntryDependency.js");
const SingleEntryDependency = __webpack_require__(/*! ./dependencies/SingleEntryDependency */ "./node_modules/webpack/lib/dependencies/SingleEntryDependency.js");
const DllModuleFactory = __webpack_require__(/*! ./DllModuleFactory */ "./node_modules/webpack/lib/DllModuleFactory.js");

class DllEntryPlugin {
	constructor(context, entries, name) {
		this.context = context;
		this.entries = entries;
		this.name = name;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"DllEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				const dllModuleFactory = new DllModuleFactory();
				compilation.dependencyFactories.set(
					DllEntryDependency,
					dllModuleFactory
				);
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);
		compiler.hooks.make.tapAsync("DllEntryPlugin", (compilation, callback) => {
			compilation.addEntry(
				this.context,
				new DllEntryDependency(
					this.entries.map((e, idx) => {
						const dep = new SingleEntryDependency(e);
						dep.loc = {
							name: this.name,
							index: idx
						};
						return dep;
					}),
					this.name
				),
				this.name,
				callback
			);
		});
	}
}

module.exports = DllEntryPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/DllModule.js":
/*!**********************************!*\
  !*** (webpack)/lib/DllModule.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
	*/


const { RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const Module = __webpack_require__(/*! ./Module */ "./node_modules/webpack/lib/Module.js");

/** @typedef {import("./util/createHash").Hash} Hash */

class DllModule extends Module {
	constructor(context, dependencies, name, type) {
		super("javascript/dynamic", context);

		// Info from Factory
		this.dependencies = dependencies;
		this.name = name;
		this.type = type;
	}

	identifier() {
		return `dll ${this.name}`;
	}

	readableIdentifier() {
		return `dll ${this.name}`;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {};
		return callback();
	}

	source() {
		return new RawSource("module.exports = __webpack_require__;");
	}

	needRebuild() {
		return false;
	}

	size() {
		return 12;
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update("dll module");
		hash.update(this.name || "");
		super.updateHash(hash);
	}
}

module.exports = DllModule;


/***/ }),

/***/ "./node_modules/webpack/lib/DllModuleFactory.js":
/*!*****************************************!*\
  !*** (webpack)/lib/DllModuleFactory.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { Tapable } = __webpack_require__(/*! tapable */ "tapable");
const DllModule = __webpack_require__(/*! ./DllModule */ "./node_modules/webpack/lib/DllModule.js");

class DllModuleFactory extends Tapable {
	constructor() {
		super();
		this.hooks = {};
	}
	create(data, callback) {
		const dependency = data.dependencies[0];
		callback(
			null,
			new DllModule(
				data.context,
				dependency.dependencies,
				dependency.name,
				dependency.type
			)
		);
	}
}

module.exports = DllModuleFactory;


/***/ }),

/***/ "./node_modules/webpack/lib/DllPlugin.js":
/*!**********************************!*\
  !*** (webpack)/lib/DllPlugin.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
	*/


const DllEntryPlugin = __webpack_require__(/*! ./DllEntryPlugin */ "./node_modules/webpack/lib/DllEntryPlugin.js");
const LibManifestPlugin = __webpack_require__(/*! ./LibManifestPlugin */ "./node_modules/webpack/lib/LibManifestPlugin.js");
const FlagInitialModulesAsUsedPlugin = __webpack_require__(/*! ./FlagInitialModulesAsUsedPlugin */ "./node_modules/webpack/lib/FlagInitialModulesAsUsedPlugin.js");

const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/DllPlugin.json */ "./node_modules/webpack/schemas/plugins/DllPlugin.json");

/** @typedef {import("../declarations/plugins/DllPlugin").DllPluginOptions} DllPluginOptions */

class DllPlugin {
	/**
	 * @param {DllPluginOptions} options options object
	 */
	constructor(options) {
		validateOptions(schema, options, "Dll Plugin");
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.entryOption.tap("DllPlugin", (context, entry) => {
			const itemToPlugin = (item, name) => {
				if (Array.isArray(item)) {
					return new DllEntryPlugin(context, item, name);
				}
				throw new Error("DllPlugin: supply an Array as entry");
			};
			if (typeof entry === "object" && !Array.isArray(entry)) {
				Object.keys(entry).forEach(name => {
					itemToPlugin(entry[name], name).apply(compiler);
				});
			} else {
				itemToPlugin(entry, "main").apply(compiler);
			}
			return true;
		});
		new LibManifestPlugin(this.options).apply(compiler);
		if (!this.options.entryOnly) {
			new FlagInitialModulesAsUsedPlugin("DllPlugin").apply(compiler);
		}
	}
}

module.exports = DllPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/DllReferencePlugin.js":
/*!*******************************************!*\
  !*** (webpack)/lib/DllReferencePlugin.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const parseJson = __webpack_require__(/*! json-parse-better-errors */ "json-parse-better-errors");
const DelegatedSourceDependency = __webpack_require__(/*! ./dependencies/DelegatedSourceDependency */ "./node_modules/webpack/lib/dependencies/DelegatedSourceDependency.js");
const DelegatedModuleFactoryPlugin = __webpack_require__(/*! ./DelegatedModuleFactoryPlugin */ "./node_modules/webpack/lib/DelegatedModuleFactoryPlugin.js");
const ExternalModuleFactoryPlugin = __webpack_require__(/*! ./ExternalModuleFactoryPlugin */ "./node_modules/webpack/lib/ExternalModuleFactoryPlugin.js");
const DelegatedExportsDependency = __webpack_require__(/*! ./dependencies/DelegatedExportsDependency */ "./node_modules/webpack/lib/dependencies/DelegatedExportsDependency.js");
const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");
const makePathsRelative = __webpack_require__(/*! ./util/identifier */ "./node_modules/webpack/lib/util/identifier.js").makePathsRelative;
const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/DllReferencePlugin.json */ "./node_modules/webpack/schemas/plugins/DllReferencePlugin.json");

/** @typedef {import("../declarations/plugins/DllReferencePlugin").DllReferencePluginOptions} DllReferencePluginOptions */
/** @typedef {import("../declarations/plugins/DllReferencePlugin").DllReferencePluginOptionsManifest} DllReferencePluginOptionsManifest */

class DllReferencePlugin {
	/**
	 * @param {DllReferencePluginOptions} options options object
	 */
	constructor(options) {
		validateOptions(schema, options, "Dll Reference Plugin");
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"DllReferencePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					DelegatedSourceDependency,
					normalModuleFactory
				);
				compilation.dependencyFactories.set(
					DelegatedExportsDependency,
					new NullFactory()
				);
			}
		);

		compiler.hooks.beforeCompile.tapAsync(
			"DllReferencePlugin",
			(params, callback) => {
				if ("manifest" in this.options) {
					const manifest = this.options.manifest;
					if (typeof manifest === "string") {
						params.compilationDependencies.add(manifest);
						compiler.inputFileSystem.readFile(manifest, (err, result) => {
							if (err) return callback(err);
							// Catch errors parsing the manifest so that blank
							// or malformed manifest files don't kill the process.
							try {
								params["dll reference " + manifest] = parseJson(
									result.toString("utf-8")
								);
							} catch (e) {
								// Store the error in the params so that it can
								// be added as a compilation error later on.
								const manifestPath = makePathsRelative(
									compiler.options.context,
									manifest
								);
								params[
									"dll reference parse error " + manifest
								] = new DllManifestError(manifestPath, e.message);
							}
							return callback();
						});
						return;
					}
				}
				return callback();
			}
		);

		compiler.hooks.compile.tap("DllReferencePlugin", params => {
			let name = this.options.name;
			let sourceType = this.options.sourceType;
			let content =
				"content" in this.options ? this.options.content : undefined;
			if ("manifest" in this.options) {
				let manifestParameter = this.options.manifest;
				let manifest;
				if (typeof manifestParameter === "string") {
					// If there was an error parsing the manifest
					// file, exit now because the error will be added
					// as a compilation error in the "compilation" hook.
					if (params["dll reference parse error " + manifestParameter]) {
						return;
					}
					manifest =
						/** @type {DllReferencePluginOptionsManifest} */ (params[
							"dll reference " + manifestParameter
						]);
				} else {
					manifest = manifestParameter;
				}
				if (manifest) {
					if (!name) name = manifest.name;
					if (!sourceType) sourceType = manifest.type;
					if (!content) content = manifest.content;
				}
			}
			const externals = {};
			const source = "dll-reference " + name;
			externals[source] = name;
			const normalModuleFactory = params.normalModuleFactory;
			new ExternalModuleFactoryPlugin(sourceType || "var", externals).apply(
				normalModuleFactory
			);
			new DelegatedModuleFactoryPlugin({
				source: source,
				type: this.options.type,
				scope: this.options.scope,
				context: this.options.context || compiler.options.context,
				content,
				extensions: this.options.extensions
			}).apply(normalModuleFactory);
		});

		compiler.hooks.compilation.tap(
			"DllReferencePlugin",
			(compilation, params) => {
				if ("manifest" in this.options) {
					let manifest = this.options.manifest;
					if (typeof manifest === "string") {
						// If there was an error parsing the manifest file, add the
						// error as a compilation error to make the compilation fail.
						let e = params["dll reference parse error " + manifest];
						if (e) {
							compilation.errors.push(e);
						}
					}
				}
			}
		);
	}
}

class DllManifestError extends WebpackError {
	constructor(filename, message) {
		super();

		this.name = "DllManifestError";
		this.message = `Dll manifest ${filename}\n${message}`;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = DllReferencePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/DynamicEntryPlugin.js":
/*!*******************************************!*\
  !*** (webpack)/lib/DynamicEntryPlugin.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Naoyuki Kanezawa @nkzawa
*/


const MultiEntryDependency = __webpack_require__(/*! ./dependencies/MultiEntryDependency */ "./node_modules/webpack/lib/dependencies/MultiEntryDependency.js");
const SingleEntryDependency = __webpack_require__(/*! ./dependencies/SingleEntryDependency */ "./node_modules/webpack/lib/dependencies/SingleEntryDependency.js");
const MultiModuleFactory = __webpack_require__(/*! ./MultiModuleFactory */ "./node_modules/webpack/lib/MultiModuleFactory.js");
const MultiEntryPlugin = __webpack_require__(/*! ./MultiEntryPlugin */ "./node_modules/webpack/lib/MultiEntryPlugin.js");
const SingleEntryPlugin = __webpack_require__(/*! ./SingleEntryPlugin */ "./node_modules/webpack/lib/SingleEntryPlugin.js");

/** @typedef {import("../declarations/WebpackOptions").EntryDynamic} EntryDynamic */
/** @typedef {import("../declarations/WebpackOptions").EntryStatic} EntryStatic */
/** @typedef {import("./Compiler")} Compiler */

class DynamicEntryPlugin {
	/**
	 * @param {string} context the context path
	 * @param {EntryDynamic} entry the entry value
	 */
	constructor(context, entry) {
		this.context = context;
		this.entry = entry;
	}

	/**
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"DynamicEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				const multiModuleFactory = new MultiModuleFactory();

				compilation.dependencyFactories.set(
					MultiEntryDependency,
					multiModuleFactory
				);
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.make.tapAsync(
			"DynamicEntryPlugin",
			(compilation, callback) => {
				/**
				 * @param {string|string[]} entry entry value or array of entry values
				 * @param {string} name name of entry
				 * @returns {Promise<EntryStatic>} returns the promise resolving the Compilation#addEntry function
				 */
				const addEntry = (entry, name) => {
					const dep = DynamicEntryPlugin.createDependency(entry, name);
					return new Promise((resolve, reject) => {
						compilation.addEntry(this.context, dep, name, err => {
							if (err) return reject(err);
							resolve();
						});
					});
				};

				Promise.resolve(this.entry()).then(entry => {
					if (typeof entry === "string" || Array.isArray(entry)) {
						addEntry(entry, "main").then(() => callback(), callback);
					} else if (typeof entry === "object") {
						Promise.all(
							Object.keys(entry).map(name => {
								return addEntry(entry[name], name);
							})
						).then(() => callback(), callback);
					}
				});
			}
		);
	}
}

module.exports = DynamicEntryPlugin;
/**
 * @param {string|string[]} entry entry value or array of entry paths
 * @param {string} name name of entry
 * @returns {SingleEntryDependency|MultiEntryDependency} returns dep
 */
DynamicEntryPlugin.createDependency = (entry, name) => {
	if (Array.isArray(entry)) {
		return MultiEntryPlugin.createDependency(entry, name);
	} else {
		return SingleEntryPlugin.createDependency(entry, name);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/EntryModuleNotFoundError.js":
/*!*************************************************!*\
  !*** (webpack)/lib/EntryModuleNotFoundError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

class EntryModuleNotFoundError extends WebpackError {
	constructor(err) {
		super("Entry module not found: " + err);

		this.name = "EntryModuleNotFoundError";
		this.details = err.details;
		this.error = err;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = EntryModuleNotFoundError;


/***/ }),

/***/ "./node_modules/webpack/lib/EntryOptionPlugin.js":
/*!******************************************!*\
  !*** (webpack)/lib/EntryOptionPlugin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const SingleEntryPlugin = __webpack_require__(/*! ./SingleEntryPlugin */ "./node_modules/webpack/lib/SingleEntryPlugin.js");
const MultiEntryPlugin = __webpack_require__(/*! ./MultiEntryPlugin */ "./node_modules/webpack/lib/MultiEntryPlugin.js");
const DynamicEntryPlugin = __webpack_require__(/*! ./DynamicEntryPlugin */ "./node_modules/webpack/lib/DynamicEntryPlugin.js");

/** @typedef {import("../declarations/WebpackOptions").EntryItem} EntryItem */
/** @typedef {import("./Compiler")} Compiler */

/**
 * @param {string} context context path
 * @param {EntryItem} item entry array or single path
 * @param {string} name entry key name
 * @returns {SingleEntryPlugin | MultiEntryPlugin} returns either a single or multi entry plugin
 */
const itemToPlugin = (context, item, name) => {
	if (Array.isArray(item)) {
		return new MultiEntryPlugin(context, item, name);
	}
	return new SingleEntryPlugin(context, item, name);
};

module.exports = class EntryOptionPlugin {
	/**
	 * @param {Compiler} compiler the compiler instance one is tapping into
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.entryOption.tap("EntryOptionPlugin", (context, entry) => {
			if (typeof entry === "string" || Array.isArray(entry)) {
				itemToPlugin(context, entry, "main").apply(compiler);
			} else if (typeof entry === "object") {
				for (const name of Object.keys(entry)) {
					itemToPlugin(context, entry[name], name).apply(compiler);
				}
			} else if (typeof entry === "function") {
				new DynamicEntryPlugin(context, entry).apply(compiler);
			}
			return true;
		});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/Entrypoint.js":
/*!***********************************!*\
  !*** (webpack)/lib/Entrypoint.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ChunkGroup = __webpack_require__(/*! ./ChunkGroup */ "./node_modules/webpack/lib/ChunkGroup.js");

/** @typedef {import("./Chunk")} Chunk */

/**
 * Entrypoint serves as an encapsulation primitive for chunks that are
 * a part of a single ChunkGroup. They represent all bundles that need to be loaded for a
 * single instance of a page. Multi-page application architectures will typically yield multiple Entrypoint objects
 * inside of the compilation, whereas a Single Page App may only contain one with many lazy-loaded chunks.
 */
class Entrypoint extends ChunkGroup {
	/**
	 * Creates an instance of Entrypoint.
	 * @param {string} name the name of the entrypoint
	 */
	constructor(name) {
		super(name);
		/** @type {Chunk=} */
		this.runtimeChunk = undefined;
	}

	/**
	 * isInitial will always return true for Entrypoint ChunkGroup.
	 * @returns {true} returns true as all entrypoints are initial ChunkGroups
	 */
	isInitial() {
		return true;
	}

	/**
	 * Sets the runtimeChunk for an entrypoint.
	 * @param {Chunk} chunk the chunk being set as the runtime chunk.
	 * @returns {void}
	 */
	setRuntimeChunk(chunk) {
		this.runtimeChunk = chunk;
	}

	/**
	 * Fetches the chunk reference containing the webpack bootstrap code
	 * @returns {Chunk} returns the runtime chunk or first chunk in `this.chunks`
	 */
	getRuntimeChunk() {
		return this.runtimeChunk || this.chunks[0];
	}

	/**
	 * @param {Chunk} oldChunk chunk to be replaced
	 * @param {Chunk} newChunk New chunkt that will be replaced
	 * @returns {boolean} rerturns true for
	 */
	replaceChunk(oldChunk, newChunk) {
		if (this.runtimeChunk === oldChunk) this.runtimeChunk = newChunk;
		return super.replaceChunk(oldChunk, newChunk);
	}
}

module.exports = Entrypoint;


/***/ }),

/***/ "./node_modules/webpack/lib/EnvironmentPlugin.js":
/*!******************************************!*\
  !*** (webpack)/lib/EnvironmentPlugin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Authors Simen Brekken @simenbrekken, Einar Löve @einarlove
*/



/** @typedef {import("./Compiler")} Compiler */

const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const DefinePlugin = __webpack_require__(/*! ./DefinePlugin */ "./node_modules/webpack/lib/DefinePlugin.js");

const needsEnvVarFix =
	["8", "9"].indexOf(process.versions.node.split(".")[0]) >= 0 &&
	process.platform === "win32";

class EnvironmentPlugin {
	constructor(...keys) {
		if (keys.length === 1 && Array.isArray(keys[0])) {
			this.keys = keys[0];
			this.defaultValues = {};
		} else if (keys.length === 1 && keys[0] && typeof keys[0] === "object") {
			this.keys = Object.keys(keys[0]);
			this.defaultValues = keys[0];
		} else {
			this.keys = keys;
			this.defaultValues = {};
		}
	}

	/**
	 * @param {Compiler} compiler webpack compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const definitions = this.keys.reduce((defs, key) => {
			// TODO remove once the fix has made its way into Node 8.
			// Work around https://github.com/nodejs/node/pull/18463,
			// affecting Node 8 & 9 by performing an OS-level
			// operation that always succeeds before reading
			// environment variables:
			if (needsEnvVarFix) __webpack_require__(/*! os */ "os").cpus();

			const value =
				process.env[key] !== undefined
					? process.env[key]
					: this.defaultValues[key];

			if (value === undefined) {
				compiler.hooks.thisCompilation.tap("EnvironmentPlugin", compilation => {
					const error = new WebpackError(
						`EnvironmentPlugin - ${key} environment variable is undefined.\n\n` +
							"You can pass an object with default values to suppress this warning.\n" +
							"See https://webpack.js.org/plugins/environment-plugin for example."
					);

					error.name = "EnvVariableNotDefinedError";
					compilation.warnings.push(error);
				});
			}

			defs[`process.env.${key}`] =
				value === undefined ? "undefined" : JSON.stringify(value);

			return defs;
		}, {});

		new DefinePlugin(definitions).apply(compiler);
	}
}

module.exports = EnvironmentPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ErrorHelpers.js":
/*!*************************************!*\
  !*** (webpack)/lib/ErrorHelpers.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const loaderFlag = "LOADER_EXECUTION";

const webpackOptionsFlag = "WEBPACK_OPTIONS";

exports.cutOffByFlag = (stack, flag) => {
	stack = stack.split("\n");
	for (let i = 0; i < stack.length; i++) {
		if (stack[i].includes(flag)) {
			stack.length = i;
		}
	}
	return stack.join("\n");
};

exports.cutOffLoaderExecution = stack =>
	exports.cutOffByFlag(stack, loaderFlag);

exports.cutOffWebpackOptions = stack =>
	exports.cutOffByFlag(stack, webpackOptionsFlag);

exports.cutOffMultilineMessage = (stack, message) => {
	stack = stack.split("\n");
	message = message.split("\n");

	return stack
		.reduce(
			(acc, line, idx) =>
				line.includes(message[idx]) ? acc : acc.concat(line),
			[]
		)
		.join("\n");
};

exports.cutOffMessage = (stack, message) => {
	const nextLine = stack.indexOf("\n");
	if (nextLine === -1) {
		return stack === message ? "" : stack;
	} else {
		const firstLine = stack.substr(0, nextLine);
		return firstLine === message ? stack.substr(nextLine + 1) : stack;
	}
};

exports.cleanUp = (stack, message) => {
	stack = exports.cutOffLoaderExecution(stack);
	stack = exports.cutOffMessage(stack, message);
	return stack;
};

exports.cleanUpWebpackOptions = (stack, message) => {
	stack = exports.cutOffWebpackOptions(stack);
	stack = exports.cutOffMultilineMessage(stack, message);
	return stack;
};


/***/ }),

/***/ "./node_modules/webpack/lib/EvalDevToolModulePlugin.js":
/*!************************************************!*\
  !*** (webpack)/lib/EvalDevToolModulePlugin.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const EvalDevToolModuleTemplatePlugin = __webpack_require__(/*! ./EvalDevToolModuleTemplatePlugin */ "./node_modules/webpack/lib/EvalDevToolModuleTemplatePlugin.js");

class EvalDevToolModulePlugin {
	constructor(options) {
		this.sourceUrlComment = options.sourceUrlComment;
		this.moduleFilenameTemplate = options.moduleFilenameTemplate;
		this.namespace = options.namespace;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap("EvalDevToolModulePlugin", compilation => {
			new EvalDevToolModuleTemplatePlugin({
				sourceUrlComment: this.sourceUrlComment,
				moduleFilenameTemplate: this.moduleFilenameTemplate,
				namespace: this.namespace
			}).apply(compilation.moduleTemplates.javascript);
		});
	}
}

module.exports = EvalDevToolModulePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/EvalDevToolModuleTemplatePlugin.js":
/*!********************************************************!*\
  !*** (webpack)/lib/EvalDevToolModuleTemplatePlugin.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const ModuleFilenameHelpers = __webpack_require__(/*! ./ModuleFilenameHelpers */ "./node_modules/webpack/lib/ModuleFilenameHelpers.js");

const cache = new WeakMap();

class EvalDevToolModuleTemplatePlugin {
	constructor(options) {
		this.sourceUrlComment = options.sourceUrlComment || "\n//# sourceURL=[url]";
		this.moduleFilenameTemplate =
			options.moduleFilenameTemplate ||
			"webpack://[namespace]/[resourcePath]?[loaders]";
		this.namespace = options.namespace || "";
	}

	apply(moduleTemplate) {
		moduleTemplate.hooks.module.tap(
			"EvalDevToolModuleTemplatePlugin",
			(source, module) => {
				const cacheEntry = cache.get(source);
				if (cacheEntry !== undefined) return cacheEntry;
				const content = source.source();
				const str = ModuleFilenameHelpers.createFilename(
					module,
					{
						moduleFilenameTemplate: this.moduleFilenameTemplate,
						namespace: this.namespace
					},
					moduleTemplate.runtimeTemplate.requestShortener
				);
				const footer =
					"\n" +
					this.sourceUrlComment.replace(
						/\[url\]/g,
						encodeURI(str)
							.replace(/%2F/g, "/")
							.replace(/%20/g, "_")
							.replace(/%5E/g, "^")
							.replace(/%5C/g, "\\")
							.replace(/^\//, "")
					);
				const result = new RawSource(
					`eval(${JSON.stringify(content + footer)});`
				);
				cache.set(source, result);
				return result;
			}
		);
		moduleTemplate.hooks.hash.tap("EvalDevToolModuleTemplatePlugin", hash => {
			hash.update("EvalDevToolModuleTemplatePlugin");
			hash.update("2");
		});
	}
}

module.exports = EvalDevToolModuleTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/EvalSourceMapDevToolModuleTemplatePlugin.js":
/*!*****************************************************************!*\
  !*** (webpack)/lib/EvalSourceMapDevToolModuleTemplatePlugin.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const ModuleFilenameHelpers = __webpack_require__(/*! ./ModuleFilenameHelpers */ "./node_modules/webpack/lib/ModuleFilenameHelpers.js");

const cache = new WeakMap();

class EvalSourceMapDevToolModuleTemplatePlugin {
	constructor(compilation, options) {
		this.compilation = compilation;
		this.sourceMapComment =
			options.append || "//# sourceURL=[module]\n//# sourceMappingURL=[url]";
		this.moduleFilenameTemplate =
			options.moduleFilenameTemplate ||
			"webpack://[namespace]/[resource-path]?[hash]";
		this.namespace = options.namespace || "";
		this.options = options;
	}

	apply(moduleTemplate) {
		const self = this;
		const options = this.options;
		const matchModule = ModuleFilenameHelpers.matchObject.bind(
			ModuleFilenameHelpers,
			options
		);
		moduleTemplate.hooks.module.tap(
			"EvalSourceMapDevToolModuleTemplatePlugin",
			(source, module) => {
				const cachedSource = cache.get(source);
				if (cachedSource !== undefined) {
					return cachedSource;
				}

				if (!matchModule(module.resource)) {
					return source;
				}

				/** @type {{ [key: string]: TODO; }} */
				let sourceMap;
				let content;
				if (source.sourceAndMap) {
					const sourceAndMap = source.sourceAndMap(options);
					sourceMap = sourceAndMap.map;
					content = sourceAndMap.source;
				} else {
					sourceMap = source.map(options);
					content = source.source();
				}
				if (!sourceMap) {
					return source;
				}

				// Clone (flat) the sourcemap to ensure that the mutations below do not persist.
				sourceMap = Object.keys(sourceMap).reduce((obj, key) => {
					obj[key] = sourceMap[key];
					return obj;
				}, {});
				const modules = sourceMap.sources.map(source => {
					const module = self.compilation.findModule(source);
					return module || source;
				});
				let moduleFilenames = modules.map(module => {
					return ModuleFilenameHelpers.createFilename(
						module,
						{
							moduleFilenameTemplate: self.moduleFilenameTemplate,
							namespace: self.namespace
						},
						moduleTemplate.runtimeTemplate.requestShortener
					);
				});
				moduleFilenames = ModuleFilenameHelpers.replaceDuplicates(
					moduleFilenames,
					(filename, i, n) => {
						for (let j = 0; j < n; j++) filename += "*";
						return filename;
					}
				);
				sourceMap.sources = moduleFilenames;
				sourceMap.sourceRoot = options.sourceRoot || "";
				sourceMap.file = `${module.id}.js`;

				const footer =
					self.sourceMapComment.replace(
						/\[url\]/g,
						`data:application/json;charset=utf-8;base64,${Buffer.from(
							JSON.stringify(sourceMap),
							"utf8"
						).toString("base64")}`
					) + `\n//# sourceURL=webpack-internal:///${module.id}\n`; // workaround for chrome bug

				const evalSource = new RawSource(
					`eval(${JSON.stringify(content + footer)});`
				);

				cache.set(source, evalSource);

				return evalSource;
			}
		);
		moduleTemplate.hooks.hash.tap(
			"EvalSourceMapDevToolModuleTemplatePlugin",
			hash => {
				hash.update("eval-source-map");
				hash.update("2");
			}
		);
	}
}
module.exports = EvalSourceMapDevToolModuleTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/EvalSourceMapDevToolPlugin.js":
/*!***************************************************!*\
  !*** (webpack)/lib/EvalSourceMapDevToolPlugin.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const EvalSourceMapDevToolModuleTemplatePlugin = __webpack_require__(/*! ./EvalSourceMapDevToolModuleTemplatePlugin */ "./node_modules/webpack/lib/EvalSourceMapDevToolModuleTemplatePlugin.js");
const SourceMapDevToolModuleOptionsPlugin = __webpack_require__(/*! ./SourceMapDevToolModuleOptionsPlugin */ "./node_modules/webpack/lib/SourceMapDevToolModuleOptionsPlugin.js");

class EvalSourceMapDevToolPlugin {
	constructor(options) {
		if (arguments.length > 1) {
			throw new Error(
				"EvalSourceMapDevToolPlugin only takes one argument (pass an options object)"
			);
		}
		if (typeof options === "string") {
			options = {
				append: options
			};
		}
		if (!options) options = {};
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"EvalSourceMapDevToolPlugin",
			compilation => {
				new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
				new EvalSourceMapDevToolModuleTemplatePlugin(
					compilation,
					options
				).apply(compilation.moduleTemplates.javascript);
			}
		);
	}
}

module.exports = EvalSourceMapDevToolPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ExportPropertyMainTemplatePlugin.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/ExportPropertyMainTemplatePlugin.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

/** @typedef {import("./Compilation")} Compilation */

/**
 * @param {string[]} accessor the accessor to convert to path
 * @returns {string} the path
 */
const accessorToObjectAccess = accessor => {
	return accessor.map(a => `[${JSON.stringify(a)}]`).join("");
};

class ExportPropertyMainTemplatePlugin {
	/**
	 * @param {string|string[]} property the name of the property to export
	 */
	constructor(property) {
		this.property = property;
	}

	/**
	 * @param {Compilation} compilation the compilation instance
	 * @returns {void}
	 */
	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const postfix = `${accessorToObjectAccess([].concat(this.property))}`;
			return new ConcatSource(source, postfix);
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"ExportPropertyMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.hash.tap("ExportPropertyMainTemplatePlugin", hash => {
			hash.update("export property");
			hash.update(`${this.property}`);
		});
	}
}

module.exports = ExportPropertyMainTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ExtendedAPIPlugin.js":
/*!******************************************!*\
  !*** (webpack)/lib/ExtendedAPIPlugin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");
const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const ParserHelpers = __webpack_require__(/*! ./ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");
const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

const REPLACEMENTS = {
	// eslint-disable-next-line camelcase
	__webpack_hash__: "__webpack_require__.h",
	// eslint-disable-next-line camelcase
	__webpack_chunkname__: "__webpack_require__.cn"
};
const REPLACEMENT_TYPES = {
	// eslint-disable-next-line camelcase
	__webpack_hash__: "string",
	// eslint-disable-next-line camelcase
	__webpack_chunkname__: "string"
};

class ExtendedAPIPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"ExtendedAPIPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const mainTemplate = compilation.mainTemplate;
				mainTemplate.hooks.requireExtensions.tap(
					"ExtendedAPIPlugin",
					(source, chunk, hash) => {
						const buf = [source];
						buf.push("");
						buf.push("// __webpack_hash__");
						buf.push(`${mainTemplate.requireFn}.h = ${JSON.stringify(hash)};`);
						buf.push("");
						buf.push("// __webpack_chunkname__");
						buf.push(
							`${mainTemplate.requireFn}.cn = ${JSON.stringify(chunk.name)};`
						);
						return Template.asString(buf);
					}
				);
				mainTemplate.hooks.globalHash.tap("ExtendedAPIPlugin", () => true);

				const handler = (parser, parserOptions) => {
					Object.keys(REPLACEMENTS).forEach(key => {
						parser.hooks.expression
							.for(key)
							.tap(
								"ExtendedAPIPlugin",
								ParserHelpers.toConstantDependencyWithWebpackRequire(
									parser,
									REPLACEMENTS[key]
								)
							);
						parser.hooks.evaluateTypeof
							.for(key)
							.tap(
								"ExtendedAPIPlugin",
								ParserHelpers.evaluateToString(REPLACEMENT_TYPES[key])
							);
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ExtendedAPIPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ExtendedAPIPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("ExtendedAPIPlugin", handler);
			}
		);
	}
}

module.exports = ExtendedAPIPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ExternalModule.js":
/*!***************************************!*\
  !*** (webpack)/lib/ExternalModule.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { OriginalSource, RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const Module = __webpack_require__(/*! ./Module */ "./node_modules/webpack/lib/Module.js");
const WebpackMissingModule = __webpack_require__(/*! ./dependencies/WebpackMissingModule */ "./node_modules/webpack/lib/dependencies/WebpackMissingModule.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

/** @typedef {import("./util/createHash").Hash} Hash */

class ExternalModule extends Module {
	constructor(request, type, userRequest) {
		super("javascript/dynamic", null);

		// Info from Factory
		this.request = request;
		this.externalType = type;
		this.userRequest = userRequest;
		this.external = true;
	}

	libIdent() {
		return this.userRequest;
	}

	chunkCondition(chunk) {
		return chunk.hasEntryModule();
	}

	identifier() {
		return "external " + JSON.stringify(this.request);
	}

	readableIdentifier() {
		return "external " + JSON.stringify(this.request);
	}

	needRebuild() {
		return false;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {};
		callback();
	}

	getSourceForGlobalVariableExternal(variableName, type) {
		if (!Array.isArray(variableName)) {
			// make it an array as the look up works the same basically
			variableName = [variableName];
		}

		// needed for e.g. window["some"]["thing"]
		const objectLookup = variableName
			.map(r => `[${JSON.stringify(r)}]`)
			.join("");
		return `(function() { module.exports = ${type}${objectLookup}; }());`;
	}

	getSourceForCommonJsExternal(moduleAndSpecifiers) {
		if (!Array.isArray(moduleAndSpecifiers)) {
			return `module.exports = require(${JSON.stringify(
				moduleAndSpecifiers
			)});`;
		}

		const moduleName = moduleAndSpecifiers[0];
		const objectLookup = moduleAndSpecifiers
			.slice(1)
			.map(r => `[${JSON.stringify(r)}]`)
			.join("");
		return `module.exports = require(${JSON.stringify(
			moduleName
		)})${objectLookup};`;
	}

	checkExternalVariable(variableToCheck, request) {
		return `if(typeof ${variableToCheck} === 'undefined') {${WebpackMissingModule.moduleCode(
			request
		)}}\n`;
	}

	getSourceForAmdOrUmdExternal(id, optional, request) {
		const externalVariable = `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(
			`${id}`
		)}__`;
		const missingModuleError = optional
			? this.checkExternalVariable(externalVariable, request)
			: "";
		return `${missingModuleError}module.exports = ${externalVariable};`;
	}

	getSourceForDefaultCase(optional, request) {
		if (!Array.isArray(request)) {
			// make it an array as the look up works the same basically
			request = [request];
		}

		const variableName = request[0];
		const missingModuleError = optional
			? this.checkExternalVariable(variableName, request.join("."))
			: "";
		const objectLookup = request
			.slice(1)
			.map(r => `[${JSON.stringify(r)}]`)
			.join("");
		return `${missingModuleError}module.exports = ${variableName}${objectLookup};`;
	}

	getSourceString(runtime) {
		const request =
			typeof this.request === "object" && !Array.isArray(this.request)
				? this.request[this.externalType]
				: this.request;
		switch (this.externalType) {
			case "this":
			case "window":
			case "self":
				return this.getSourceForGlobalVariableExternal(
					request,
					this.externalType
				);
			case "global":
				return this.getSourceForGlobalVariableExternal(
					request,
					runtime.outputOptions.globalObject
				);
			case "commonjs":
			case "commonjs2":
				return this.getSourceForCommonJsExternal(request);
			case "amd":
			case "amd-require":
			case "umd":
			case "umd2":
				return this.getSourceForAmdOrUmdExternal(
					this.id,
					this.optional,
					request
				);
			default:
				return this.getSourceForDefaultCase(this.optional, request);
		}
	}

	getSource(sourceString) {
		if (this.useSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}

		return new RawSource(sourceString);
	}

	source(dependencyTemplates, runtime) {
		return this.getSource(this.getSourceString(runtime));
	}

	size() {
		return 42;
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update(this.externalType);
		hash.update(JSON.stringify(this.request));
		hash.update(JSON.stringify(Boolean(this.optional)));
		super.updateHash(hash);
	}
}

module.exports = ExternalModule;


/***/ }),

/***/ "./node_modules/webpack/lib/ExternalModuleFactoryPlugin.js":
/*!****************************************************!*\
  !*** (webpack)/lib/ExternalModuleFactoryPlugin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ExternalModule = __webpack_require__(/*! ./ExternalModule */ "./node_modules/webpack/lib/ExternalModule.js");

class ExternalModuleFactoryPlugin {
	constructor(type, externals) {
		this.type = type;
		this.externals = externals;
	}

	apply(normalModuleFactory) {
		const globalType = this.type;
		normalModuleFactory.hooks.factory.tap(
			"ExternalModuleFactoryPlugin",
			factory => (data, callback) => {
				const context = data.context;
				const dependency = data.dependencies[0];

				const handleExternal = (value, type, callback) => {
					if (typeof type === "function") {
						callback = type;
						type = undefined;
					}
					if (value === false) return factory(data, callback);
					if (value === true) value = dependency.request;
					if (type === undefined && /^[a-z0-9]+ /.test(value)) {
						const idx = value.indexOf(" ");
						type = value.substr(0, idx);
						value = value.substr(idx + 1);
					}
					callback(
						null,
						new ExternalModule(value, type || globalType, dependency.request)
					);
					return true;
				};

				const handleExternals = (externals, callback) => {
					if (typeof externals === "string") {
						if (externals === dependency.request) {
							return handleExternal(dependency.request, callback);
						}
					} else if (Array.isArray(externals)) {
						let i = 0;
						const next = () => {
							let asyncFlag;
							const handleExternalsAndCallback = (err, module) => {
								if (err) return callback(err);
								if (!module) {
									if (asyncFlag) {
										asyncFlag = false;
										return;
									}
									return next();
								}
								callback(null, module);
							};

							do {
								asyncFlag = true;
								if (i >= externals.length) return callback();
								handleExternals(externals[i++], handleExternalsAndCallback);
							} while (!asyncFlag);
							asyncFlag = false;
						};

						next();
						return;
					} else if (externals instanceof RegExp) {
						if (externals.test(dependency.request)) {
							return handleExternal(dependency.request, callback);
						}
					} else if (typeof externals === "function") {
						externals.call(
							null,
							context,
							dependency.request,
							(err, value, type) => {
								if (err) return callback(err);
								if (value !== undefined) {
									handleExternal(value, type, callback);
								} else {
									callback();
								}
							}
						);
						return;
					} else if (
						typeof externals === "object" &&
						Object.prototype.hasOwnProperty.call(externals, dependency.request)
					) {
						return handleExternal(externals[dependency.request], callback);
					}
					callback();
				};

				handleExternals(this.externals, (err, module) => {
					if (err) return callback(err);
					if (!module) return handleExternal(false, callback);
					return callback(null, module);
				});
			}
		);
	}
}
module.exports = ExternalModuleFactoryPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ExternalsPlugin.js":
/*!****************************************!*\
  !*** (webpack)/lib/ExternalsPlugin.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ExternalModuleFactoryPlugin = __webpack_require__(/*! ./ExternalModuleFactoryPlugin */ "./node_modules/webpack/lib/ExternalModuleFactoryPlugin.js");

class ExternalsPlugin {
	constructor(type, externals) {
		this.type = type;
		this.externals = externals;
	}
	apply(compiler) {
		compiler.hooks.compile.tap("ExternalsPlugin", ({ normalModuleFactory }) => {
			new ExternalModuleFactoryPlugin(this.type, this.externals).apply(
				normalModuleFactory
			);
		});
	}
}

module.exports = ExternalsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/FlagDependencyExportsPlugin.js":
/*!****************************************************!*\
  !*** (webpack)/lib/FlagDependencyExportsPlugin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Queue = __webpack_require__(/*! ./util/Queue */ "./node_modules/webpack/lib/util/Queue.js");

const addToSet = (a, b) => {
	let changed = false;
	for (const item of b) {
		if (!a.has(item)) {
			a.add(item);
			changed = true;
		}
	}
	return changed;
};

class FlagDependencyExportsPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"FlagDependencyExportsPlugin",
			compilation => {
				compilation.hooks.finishModules.tap(
					"FlagDependencyExportsPlugin",
					modules => {
						const dependencies = new Map();

						const queue = new Queue();

						let module;
						let moduleWithExports;
						let moduleProvidedExports;
						let providedExportsAreTemporary;

						const processDependenciesBlock = depBlock => {
							for (const dep of depBlock.dependencies) {
								if (processDependency(dep)) return true;
							}
							for (const variable of depBlock.variables) {
								for (const dep of variable.dependencies) {
									if (processDependency(dep)) return true;
								}
							}
							for (const block of depBlock.blocks) {
								if (processDependenciesBlock(block)) return true;
							}
							return false;
						};

						const processDependency = dep => {
							const exportDesc = dep.getExports && dep.getExports();
							if (!exportDesc) return;
							moduleWithExports = true;
							const exports = exportDesc.exports;
							// break early if it's only in the worst state
							if (module.buildMeta.providedExports === true) {
								return true;
							}
							// break if it should move to the worst state
							if (exports === true) {
								module.buildMeta.providedExports = true;
								notifyDependencies();
								return true;
							}
							// merge in new exports
							if (Array.isArray(exports)) {
								if (addToSet(moduleProvidedExports, exports)) {
									notifyDependencies();
								}
							}
							// store dependencies
							const exportDeps = exportDesc.dependencies;
							if (exportDeps) {
								providedExportsAreTemporary = true;
								for (const exportDependency of exportDeps) {
									// add dependency for this module
									const set = dependencies.get(exportDependency);
									if (set === undefined) {
										dependencies.set(exportDependency, new Set([module]));
									} else {
										set.add(module);
									}
								}
							}
							return false;
						};

						const notifyDependencies = () => {
							const deps = dependencies.get(module);
							if (deps !== undefined) {
								for (const dep of deps) {
									queue.enqueue(dep);
								}
							}
						};

						// Start with all modules without provided exports
						for (const module of modules) {
							if (module.buildInfo.temporaryProvidedExports) {
								// Clear exports when they are temporary
								// and recreate them
								module.buildMeta.providedExports = null;
								queue.enqueue(module);
							} else if (!module.buildMeta.providedExports) {
								queue.enqueue(module);
							}
						}

						while (queue.length > 0) {
							module = queue.dequeue();

							if (module.buildMeta.providedExports !== true) {
								moduleWithExports =
									module.buildMeta && module.buildMeta.exportsType;
								moduleProvidedExports = Array.isArray(
									module.buildMeta.providedExports
								)
									? new Set(module.buildMeta.providedExports)
									: new Set();
								providedExportsAreTemporary = false;
								processDependenciesBlock(module);
								module.buildInfo.temporaryProvidedExports = providedExportsAreTemporary;
								if (!moduleWithExports) {
									module.buildMeta.providedExports = true;
									notifyDependencies();
								} else if (module.buildMeta.providedExports !== true) {
									module.buildMeta.providedExports = Array.from(
										moduleProvidedExports
									);
								}
							}
						}
					}
				);
				const providedExportsCache = new WeakMap();
				compilation.hooks.rebuildModule.tap(
					"FlagDependencyExportsPlugin",
					module => {
						providedExportsCache.set(module, module.buildMeta.providedExports);
					}
				);
				compilation.hooks.finishRebuildingModule.tap(
					"FlagDependencyExportsPlugin",
					module => {
						module.buildMeta.providedExports = providedExportsCache.get(module);
					}
				);
			}
		);
	}
}

module.exports = FlagDependencyExportsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/FlagDependencyUsagePlugin.js":
/*!**************************************************!*\
  !*** (webpack)/lib/FlagDependencyUsagePlugin.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


/** @typedef {import("./Module")} Module */
/** @typedef {import("./DependenciesBlock")} DependenciesBlock */

/** @typedef {false | true | string[]} UsedExports */

const addToSet = (a, b) => {
	for (const item of b) {
		if (!a.includes(item)) a.push(item);
	}
	return a;
};

const isSubset = (biggerSet, subset) => {
	if (biggerSet === true) return true;
	if (subset === true) return false;
	return subset.every(item => biggerSet.indexOf(item) >= 0);
};

class FlagDependencyUsagePlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("FlagDependencyUsagePlugin", compilation => {
			compilation.hooks.optimizeDependencies.tap(
				"FlagDependencyUsagePlugin",
				modules => {
					const processModule = (module, usedExports) => {
						module.used = true;
						if (module.usedExports === true) return;
						if (usedExports === true) {
							module.usedExports = true;
						} else if (Array.isArray(usedExports)) {
							const old = module.usedExports ? module.usedExports.length : -1;
							module.usedExports = addToSet(
								module.usedExports || [],
								usedExports
							);
							if (module.usedExports.length === old) {
								return;
							}
						} else if (Array.isArray(module.usedExports)) {
							return;
						} else {
							module.usedExports = false;
						}

						// for a module without side effects we stop tracking usage here when no export is used
						// This module won't be evaluated in this case
						if (module.factoryMeta.sideEffectFree) {
							if (module.usedExports === false) return;
							if (
								Array.isArray(module.usedExports) &&
								module.usedExports.length === 0
							)
								return;
						}

						queue.push([module, module, module.usedExports]);
					};

					const processDependenciesBlock = (module, depBlock, usedExports) => {
						for (const dep of depBlock.dependencies) {
							processDependency(module, dep);
						}
						for (const variable of depBlock.variables) {
							for (const dep of variable.dependencies) {
								processDependency(module, dep);
							}
						}
						for (const block of depBlock.blocks) {
							queue.push([module, block, usedExports]);
						}
					};

					const processDependency = (module, dep) => {
						const reference = compilation.getDependencyReference(module, dep);
						if (!reference) return;
						const referenceModule = reference.module;
						const importedNames = reference.importedNames;
						const oldUsed = referenceModule.used;
						const oldUsedExports = referenceModule.usedExports;
						if (
							!oldUsed ||
							(importedNames &&
								(!oldUsedExports || !isSubset(oldUsedExports, importedNames)))
						) {
							processModule(referenceModule, importedNames);
						}
					};

					for (const module of modules) {
						module.used = false;
					}

					/** @type {[Module, DependenciesBlock, UsedExports][]} */
					const queue = [];
					for (const preparedEntrypoint of compilation._preparedEntrypoints) {
						if (preparedEntrypoint.module) {
							processModule(preparedEntrypoint.module, true);
						}
					}

					while (queue.length) {
						const queueItem = queue.pop();
						processDependenciesBlock(queueItem[0], queueItem[1], queueItem[2]);
					}
				}
			);
		});
	}
}
module.exports = FlagDependencyUsagePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/FlagInitialModulesAsUsedPlugin.js":
/*!*******************************************************!*\
  !*** (webpack)/lib/FlagInitialModulesAsUsedPlugin.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class FlagInitialModulesAsUsedPlugin {
	constructor(explanation) {
		this.explanation = explanation;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"FlagInitialModulesAsUsedPlugin",
			compilation => {
				compilation.hooks.afterOptimizeChunks.tap(
					"FlagInitialModulesAsUsedPlugin",
					chunks => {
						for (const chunk of chunks) {
							if (!chunk.isOnlyInitial()) {
								return;
							}
							for (const module of chunk.modulesIterable) {
								module.used = true;
								module.usedExports = true;
								module.addReason(null, null, this.explanation);
							}
						}
					}
				);
			}
		);
	}
}

module.exports = FlagInitialModulesAsUsedPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/FunctionModulePlugin.js":
/*!*********************************************!*\
  !*** (webpack)/lib/FunctionModulePlugin.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const FunctionModuleTemplatePlugin = __webpack_require__(/*! ./FunctionModuleTemplatePlugin */ "./node_modules/webpack/lib/FunctionModuleTemplatePlugin.js");

class FunctionModulePlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("FunctionModulePlugin", compilation => {
			new FunctionModuleTemplatePlugin().apply(
				compilation.moduleTemplates.javascript
			);
		});
	}
}

module.exports = FunctionModulePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/FunctionModuleTemplatePlugin.js":
/*!*****************************************************!*\
  !*** (webpack)/lib/FunctionModuleTemplatePlugin.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

class FunctionModuleTemplatePlugin {
	apply(moduleTemplate) {
		moduleTemplate.hooks.render.tap(
			"FunctionModuleTemplatePlugin",
			(moduleSource, module) => {
				const source = new ConcatSource();
				const args = [module.moduleArgument];
				// TODO remove HACK checking type for javascript
				if (module.type && module.type.startsWith("javascript")) {
					args.push(module.exportsArgument);
					if (module.hasDependencies(d => d.requireWebpackRequire !== false)) {
						args.push("__webpack_require__");
					}
				} else if (module.type && module.type.startsWith("json")) {
					// no additional arguments needed
				} else {
					args.push(module.exportsArgument, "__webpack_require__");
				}
				source.add("/***/ (function(" + args.join(", ") + ") {\n\n");
				if (module.buildInfo.strict) source.add('"use strict";\n');
				source.add(moduleSource);
				source.add("\n\n/***/ })");
				return source;
			}
		);

		moduleTemplate.hooks.package.tap(
			"FunctionModuleTemplatePlugin",
			(moduleSource, module) => {
				if (moduleTemplate.runtimeTemplate.outputOptions.pathinfo) {
					const source = new ConcatSource();
					const req = module.readableIdentifier(
						moduleTemplate.runtimeTemplate.requestShortener
					);
					source.add("/*!****" + req.replace(/./g, "*") + "****!*\\\n");
					source.add("  !*** " + req.replace(/\*\//g, "*_/") + " ***!\n");
					source.add("  \\****" + req.replace(/./g, "*") + "****/\n");
					if (
						Array.isArray(module.buildMeta.providedExports) &&
						module.buildMeta.providedExports.length === 0
					) {
						source.add(Template.toComment("no exports provided") + "\n");
					} else if (Array.isArray(module.buildMeta.providedExports)) {
						source.add(
							Template.toComment(
								"exports provided: " +
									module.buildMeta.providedExports.join(", ")
							) + "\n"
						);
					} else if (module.buildMeta.providedExports) {
						source.add(Template.toComment("no static exports found") + "\n");
					}
					if (
						Array.isArray(module.usedExports) &&
						module.usedExports.length === 0
					) {
						source.add(Template.toComment("no exports used") + "\n");
					} else if (Array.isArray(module.usedExports)) {
						source.add(
							Template.toComment(
								"exports used: " + module.usedExports.join(", ")
							) + "\n"
						);
					} else if (module.usedExports) {
						source.add(Template.toComment("all exports used") + "\n");
					}
					if (module.optimizationBailout) {
						for (const text of module.optimizationBailout) {
							let code;
							if (typeof text === "function") {
								code = text(moduleTemplate.runtimeTemplate.requestShortener);
							} else {
								code = text;
							}
							source.add(Template.toComment(`${code}`) + "\n");
						}
					}
					source.add(moduleSource);
					return source;
				}
				return moduleSource;
			}
		);

		moduleTemplate.hooks.hash.tap("FunctionModuleTemplatePlugin", hash => {
			hash.update("FunctionModuleTemplatePlugin");
			hash.update("2");
		});
	}
}
module.exports = FunctionModuleTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/Generator.js":
/*!**********************************!*\
  !*** (webpack)/lib/Generator.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


/** @typedef {import("./NormalModule")} NormalModule */
/** @typedef {import("./RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./Dependency").DependencyTemplate} DependencyTemplate */

/**
 *
 */
class Generator {
	static byType(map) {
		return new ByTypeGenerator(map);
	}

	/**
	 * @abstract
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates
	 * @param {RuntimeTemplate} runtimeTemplate the runtime template
	 * @param {string} type which kind of code should be generated
	 * @returns {Source} generated code
	 */
	generate(module, dependencyTemplates, runtimeTemplate, type) {
		throw new Error("Generator.generate: must be overridden");
	}
}

class ByTypeGenerator extends Generator {
	constructor(map) {
		super();
		this.map = map;
	}

	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates
	 * @param {RuntimeTemplate} runtimeTemplate the runtime template
	 * @param {string} type which kind of code should be generated
	 * @returns {Source} generated code
	 */
	generate(module, dependencyTemplates, runtimeTemplate, type) {
		const generator = this.map[type];
		if (!generator) {
			throw new Error(`Generator.byType: no generator specified for ${type}`);
		}
		return generator.generate(
			module,
			dependencyTemplates,
			runtimeTemplate,
			type
		);
	}
}

module.exports = Generator;


/***/ }),

/***/ "./node_modules/webpack/lib/GraphHelpers.js":
/*!*************************************!*\
  !*** (webpack)/lib/GraphHelpers.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./ChunkGroup")} ChunkGroup */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./DependenciesBlock")} DependenciesBlock */
/** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */

/**
 * @param {ChunkGroup} chunkGroup the ChunkGroup to connect
 * @param {Chunk} chunk chunk to tie to ChunkGroup
 * @returns {void}
 */
const connectChunkGroupAndChunk = (chunkGroup, chunk) => {
	if (chunkGroup.pushChunk(chunk)) {
		chunk.addGroup(chunkGroup);
	}
};

/**
 * @param {ChunkGroup} parent parent ChunkGroup to connect
 * @param {ChunkGroup} child child ChunkGroup to connect
 * @returns {void}
 */
const connectChunkGroupParentAndChild = (parent, child) => {
	if (parent.addChild(child)) {
		child.addParent(parent);
	}
};

/**
 * @param {Chunk} chunk Chunk to connect to Module
 * @param {Module} module Module to connect to Chunk
 * @returns {void}
 */
const connectChunkAndModule = (chunk, module) => {
	if (module.addChunk(chunk)) {
		chunk.addModule(module);
	}
};

/**
 * @param {Chunk} chunk Chunk being disconnected
 * @param {Module} module Module being disconnected
 * @returns {void}
 */
const disconnectChunkAndModule = (chunk, module) => {
	chunk.removeModule(module);
	module.removeChunk(chunk);
};

/**
 * @param {AsyncDependenciesBlock} depBlock DepBlock being tied to ChunkGroup
 * @param {ChunkGroup} chunkGroup ChunkGroup being tied to DepBlock
 * @returns {void}
 */
const connectDependenciesBlockAndChunkGroup = (depBlock, chunkGroup) => {
	if (chunkGroup.addBlock(depBlock)) {
		depBlock.chunkGroup = chunkGroup;
	}
};

exports.connectChunkGroupAndChunk = connectChunkGroupAndChunk;
exports.connectChunkGroupParentAndChild = connectChunkGroupParentAndChild;
exports.connectChunkAndModule = connectChunkAndModule;
exports.disconnectChunkAndModule = disconnectChunkAndModule;
exports.connectDependenciesBlockAndChunkGroup = connectDependenciesBlockAndChunkGroup;


/***/ }),

/***/ "./node_modules/webpack/lib/HarmonyLinkingError.js":
/*!********************************************!*\
  !*** (webpack)/lib/HarmonyLinkingError.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

module.exports = class HarmonyLinkingError extends WebpackError {
	/** @param {string} message Error message */
	constructor(message) {
		super(message);
		this.name = "HarmonyLinkingError";
		this.hideStack = true;

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/HashedModuleIdsPlugin.js":
/*!**********************************************!*\
  !*** (webpack)/lib/HashedModuleIdsPlugin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const createHash = __webpack_require__(/*! ./util/createHash */ "./node_modules/webpack/lib/util/createHash.js");

const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/HashedModuleIdsPlugin.json */ "./node_modules/webpack/schemas/plugins/HashedModuleIdsPlugin.json");

/** @typedef {import("../declarations/plugins/HashedModuleIdsPlugin").HashedModuleIdsPluginOptions} HashedModuleIdsPluginOptions */

class HashedModuleIdsPlugin {
	/**
	 * @param {HashedModuleIdsPluginOptions=} options options object
	 */
	constructor(options) {
		if (!options) options = {};

		validateOptions(schema, options, "Hashed Module Ids Plugin");

		/** @type {HashedModuleIdsPluginOptions} */
		this.options = Object.assign(
			{
				context: null,
				hashFunction: "md4",
				hashDigest: "base64",
				hashDigestLength: 4
			},
			options
		);
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("HashedModuleIdsPlugin", compilation => {
			const usedIds = new Set();
			compilation.hooks.beforeModuleIds.tap(
				"HashedModuleIdsPlugin",
				modules => {
					for (const module of modules) {
						if (module.id === null && module.libIdent) {
							const id = module.libIdent({
								context: this.options.context || compiler.options.context
							});
							const hash = createHash(options.hashFunction);
							hash.update(id);
							const hashId = hash.digest(options.hashDigest);
							let len = options.hashDigestLength;
							while (usedIds.has(hashId.substr(0, len))) len++;
							module.id = hashId.substr(0, len);
							usedIds.add(module.id);
						}
					}
				}
			);
		});
	}
}

module.exports = HashedModuleIdsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/HotModuleReplacement.runtime.js":
/*!*****************************************************!*\
  !*** (webpack)/lib/HotModuleReplacement.runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*global $hash$ $requestTimeout$ installedModules $require$ hotDownloadManifest hotDownloadUpdateChunk hotDisposeChunk modules */
module.exports = function() {
	var hotApplyOnUpdate = true;
	// eslint-disable-next-line no-unused-vars
	var hotCurrentHash = $hash$;
	var hotRequestTimeout = $requestTimeout$;
	var hotCurrentModuleData = {};
	var hotCurrentChildModule;
	// eslint-disable-next-line no-unused-vars
	var hotCurrentParents = [];
	// eslint-disable-next-line no-unused-vars
	var hotCurrentParentsTemp = [];

	// eslint-disable-next-line no-unused-vars
	function hotCreateRequire(moduleId) {
		var me = installedModules[moduleId];
		if (!me) return $require$;
		var fn = function(request) {
			if (me.hot.active) {
				if (installedModules[request]) {
					if (installedModules[request].parents.indexOf(moduleId) === -1) {
						installedModules[request].parents.push(moduleId);
					}
				} else {
					hotCurrentParents = [moduleId];
					hotCurrentChildModule = request;
				}
				if (me.children.indexOf(request) === -1) {
					me.children.push(request);
				}
			} else {
				console.warn(
					"[HMR] unexpected require(" +
						request +
						") from disposed module " +
						moduleId
				);
				hotCurrentParents = [];
			}
			return $require$(request);
		};
		var ObjectFactory = function ObjectFactory(name) {
			return {
				configurable: true,
				enumerable: true,
				get: function() {
					return $require$[name];
				},
				set: function(value) {
					$require$[name] = value;
				}
			};
		};
		for (var name in $require$) {
			if (
				Object.prototype.hasOwnProperty.call($require$, name) &&
				name !== "e" &&
				name !== "t"
			) {
				Object.defineProperty(fn, name, ObjectFactory(name));
			}
		}
		fn.e = function(chunkId) {
			if (hotStatus === "ready") hotSetStatus("prepare");
			hotChunksLoading++;
			return $require$.e(chunkId).then(finishChunkLoading, function(err) {
				finishChunkLoading();
				throw err;
			});

			function finishChunkLoading() {
				hotChunksLoading--;
				if (hotStatus === "prepare") {
					if (!hotWaitingFilesMap[chunkId]) {
						hotEnsureUpdateChunk(chunkId);
					}
					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
						hotUpdateDownloaded();
					}
				}
			}
		};
		fn.t = function(value, mode) {
			if (mode & 1) value = fn(value);
			return $require$.t(value, mode & ~1);
		};
		return fn;
	}

	// eslint-disable-next-line no-unused-vars
	function hotCreateModule(moduleId) {
		var hot = {
			// private stuff
			_acceptedDependencies: {},
			_declinedDependencies: {},
			_selfAccepted: false,
			_selfDeclined: false,
			_disposeHandlers: [],
			_main: hotCurrentChildModule !== moduleId,

			// Module API
			active: true,
			accept: function(dep, callback) {
				if (dep === undefined) hot._selfAccepted = true;
				else if (typeof dep === "function") hot._selfAccepted = dep;
				else if (typeof dep === "object")
					for (var i = 0; i < dep.length; i++)
						hot._acceptedDependencies[dep[i]] = callback || function() {};
				else hot._acceptedDependencies[dep] = callback || function() {};
			},
			decline: function(dep) {
				if (dep === undefined) hot._selfDeclined = true;
				else if (typeof dep === "object")
					for (var i = 0; i < dep.length; i++)
						hot._declinedDependencies[dep[i]] = true;
				else hot._declinedDependencies[dep] = true;
			},
			dispose: function(callback) {
				hot._disposeHandlers.push(callback);
			},
			addDisposeHandler: function(callback) {
				hot._disposeHandlers.push(callback);
			},
			removeDisposeHandler: function(callback) {
				var idx = hot._disposeHandlers.indexOf(callback);
				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
			},

			// Management API
			check: hotCheck,
			apply: hotApply,
			status: function(l) {
				if (!l) return hotStatus;
				hotStatusHandlers.push(l);
			},
			addStatusHandler: function(l) {
				hotStatusHandlers.push(l);
			},
			removeStatusHandler: function(l) {
				var idx = hotStatusHandlers.indexOf(l);
				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
			},

			//inherit from previous dispose call
			data: hotCurrentModuleData[moduleId]
		};
		hotCurrentChildModule = undefined;
		return hot;
	}

	var hotStatusHandlers = [];
	var hotStatus = "idle";

	function hotSetStatus(newStatus) {
		hotStatus = newStatus;
		for (var i = 0; i < hotStatusHandlers.length; i++)
			hotStatusHandlers[i].call(null, newStatus);
	}

	// while downloading
	var hotWaitingFiles = 0;
	var hotChunksLoading = 0;
	var hotWaitingFilesMap = {};
	var hotRequestedFilesMap = {};
	var hotAvailableFilesMap = {};
	var hotDeferred;

	// The update info
	var hotUpdate, hotUpdateNewHash;

	function toModuleId(id) {
		var isNumber = +id + "" === id;
		return isNumber ? +id : id;
	}

	function hotCheck(apply) {
		if (hotStatus !== "idle") {
			throw new Error("check() is only allowed in idle status");
		}
		hotApplyOnUpdate = apply;
		hotSetStatus("check");
		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
			if (!update) {
				hotSetStatus("idle");
				return null;
			}
			hotRequestedFilesMap = {};
			hotWaitingFilesMap = {};
			hotAvailableFilesMap = update.c;
			hotUpdateNewHash = update.h;

			hotSetStatus("prepare");
			var promise = new Promise(function(resolve, reject) {
				hotDeferred = {
					resolve: resolve,
					reject: reject
				};
			});
			hotUpdate = {};
			/*foreachInstalledChunks*/
			// eslint-disable-next-line no-lone-blocks
			{
				/*globals chunkId */
				hotEnsureUpdateChunk(chunkId);
			}
			if (
				hotStatus === "prepare" &&
				hotChunksLoading === 0 &&
				hotWaitingFiles === 0
			) {
				hotUpdateDownloaded();
			}
			return promise;
		});
	}

	// eslint-disable-next-line no-unused-vars
	function hotAddUpdateChunk(chunkId, moreModules) {
		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
			return;
		hotRequestedFilesMap[chunkId] = false;
		for (var moduleId in moreModules) {
			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
				hotUpdate[moduleId] = moreModules[moduleId];
			}
		}
		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
			hotUpdateDownloaded();
		}
	}

	function hotEnsureUpdateChunk(chunkId) {
		if (!hotAvailableFilesMap[chunkId]) {
			hotWaitingFilesMap[chunkId] = true;
		} else {
			hotRequestedFilesMap[chunkId] = true;
			hotWaitingFiles++;
			hotDownloadUpdateChunk(chunkId);
		}
	}

	function hotUpdateDownloaded() {
		hotSetStatus("ready");
		var deferred = hotDeferred;
		hotDeferred = null;
		if (!deferred) return;
		if (hotApplyOnUpdate) {
			// Wrap deferred object in Promise to mark it as a well-handled Promise to
			// avoid triggering uncaught exception warning in Chrome.
			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
			Promise.resolve()
				.then(function() {
					return hotApply(hotApplyOnUpdate);
				})
				.then(
					function(result) {
						deferred.resolve(result);
					},
					function(err) {
						deferred.reject(err);
					}
				);
		} else {
			var outdatedModules = [];
			for (var id in hotUpdate) {
				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
					outdatedModules.push(toModuleId(id));
				}
			}
			deferred.resolve(outdatedModules);
		}
	}

	function hotApply(options) {
		if (hotStatus !== "ready")
			throw new Error("apply() is only allowed in ready status");
		options = options || {};

		var cb;
		var i;
		var j;
		var module;
		var moduleId;

		function getAffectedStuff(updateModuleId) {
			var outdatedModules = [updateModuleId];
			var outdatedDependencies = {};

			var queue = outdatedModules.slice().map(function(id) {
				return {
					chain: [id],
					id: id
				};
			});
			while (queue.length > 0) {
				var queueItem = queue.pop();
				var moduleId = queueItem.id;
				var chain = queueItem.chain;
				module = installedModules[moduleId];
				if (!module || module.hot._selfAccepted) continue;
				if (module.hot._selfDeclined) {
					return {
						type: "self-declined",
						chain: chain,
						moduleId: moduleId
					};
				}
				if (module.hot._main) {
					return {
						type: "unaccepted",
						chain: chain,
						moduleId: moduleId
					};
				}
				for (var i = 0; i < module.parents.length; i++) {
					var parentId = module.parents[i];
					var parent = installedModules[parentId];
					if (!parent) continue;
					if (parent.hot._declinedDependencies[moduleId]) {
						return {
							type: "declined",
							chain: chain.concat([parentId]),
							moduleId: moduleId,
							parentId: parentId
						};
					}
					if (outdatedModules.indexOf(parentId) !== -1) continue;
					if (parent.hot._acceptedDependencies[moduleId]) {
						if (!outdatedDependencies[parentId])
							outdatedDependencies[parentId] = [];
						addAllToSet(outdatedDependencies[parentId], [moduleId]);
						continue;
					}
					delete outdatedDependencies[parentId];
					outdatedModules.push(parentId);
					queue.push({
						chain: chain.concat([parentId]),
						id: parentId
					});
				}
			}

			return {
				type: "accepted",
				moduleId: updateModuleId,
				outdatedModules: outdatedModules,
				outdatedDependencies: outdatedDependencies
			};
		}

		function addAllToSet(a, b) {
			for (var i = 0; i < b.length; i++) {
				var item = b[i];
				if (a.indexOf(item) === -1) a.push(item);
			}
		}

		// at begin all updates modules are outdated
		// the "outdated" status can propagate to parents if they don't accept the children
		var outdatedDependencies = {};
		var outdatedModules = [];
		var appliedUpdate = {};

		var warnUnexpectedRequire = function warnUnexpectedRequire() {
			console.warn(
				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
			);
		};

		for (var id in hotUpdate) {
			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
				moduleId = toModuleId(id);
				/** @type {TODO} */
				var result;
				if (hotUpdate[id]) {
					result = getAffectedStuff(moduleId);
				} else {
					result = {
						type: "disposed",
						moduleId: id
					};
				}
				/** @type {Error|false} */
				var abortError = false;
				var doApply = false;
				var doDispose = false;
				var chainInfo = "";
				if (result.chain) {
					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
				}
				switch (result.type) {
					case "self-declined":
						if (options.onDeclined) options.onDeclined(result);
						if (!options.ignoreDeclined)
							abortError = new Error(
								"Aborted because of self decline: " +
									result.moduleId +
									chainInfo
							);
						break;
					case "declined":
						if (options.onDeclined) options.onDeclined(result);
						if (!options.ignoreDeclined)
							abortError = new Error(
								"Aborted because of declined dependency: " +
									result.moduleId +
									" in " +
									result.parentId +
									chainInfo
							);
						break;
					case "unaccepted":
						if (options.onUnaccepted) options.onUnaccepted(result);
						if (!options.ignoreUnaccepted)
							abortError = new Error(
								"Aborted because " + moduleId + " is not accepted" + chainInfo
							);
						break;
					case "accepted":
						if (options.onAccepted) options.onAccepted(result);
						doApply = true;
						break;
					case "disposed":
						if (options.onDisposed) options.onDisposed(result);
						doDispose = true;
						break;
					default:
						throw new Error("Unexception type " + result.type);
				}
				if (abortError) {
					hotSetStatus("abort");
					return Promise.reject(abortError);
				}
				if (doApply) {
					appliedUpdate[moduleId] = hotUpdate[moduleId];
					addAllToSet(outdatedModules, result.outdatedModules);
					for (moduleId in result.outdatedDependencies) {
						if (
							Object.prototype.hasOwnProperty.call(
								result.outdatedDependencies,
								moduleId
							)
						) {
							if (!outdatedDependencies[moduleId])
								outdatedDependencies[moduleId] = [];
							addAllToSet(
								outdatedDependencies[moduleId],
								result.outdatedDependencies[moduleId]
							);
						}
					}
				}
				if (doDispose) {
					addAllToSet(outdatedModules, [result.moduleId]);
					appliedUpdate[moduleId] = warnUnexpectedRequire;
				}
			}
		}

		// Store self accepted outdated modules to require them later by the module system
		var outdatedSelfAcceptedModules = [];
		for (i = 0; i < outdatedModules.length; i++) {
			moduleId = outdatedModules[i];
			if (
				installedModules[moduleId] &&
				installedModules[moduleId].hot._selfAccepted
			)
				outdatedSelfAcceptedModules.push({
					module: moduleId,
					errorHandler: installedModules[moduleId].hot._selfAccepted
				});
		}

		// Now in "dispose" phase
		hotSetStatus("dispose");
		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
			if (hotAvailableFilesMap[chunkId] === false) {
				hotDisposeChunk(chunkId);
			}
		});

		var idx;
		var queue = outdatedModules.slice();
		while (queue.length > 0) {
			moduleId = queue.pop();
			module = installedModules[moduleId];
			if (!module) continue;

			var data = {};

			// Call dispose handlers
			var disposeHandlers = module.hot._disposeHandlers;
			for (j = 0; j < disposeHandlers.length; j++) {
				cb = disposeHandlers[j];
				cb(data);
			}
			hotCurrentModuleData[moduleId] = data;

			// disable module (this disables requires from this module)
			module.hot.active = false;

			// remove module from cache
			delete installedModules[moduleId];

			// when disposing there is no need to call dispose handler
			delete outdatedDependencies[moduleId];

			// remove "parents" references from all children
			for (j = 0; j < module.children.length; j++) {
				var child = installedModules[module.children[j]];
				if (!child) continue;
				idx = child.parents.indexOf(moduleId);
				if (idx >= 0) {
					child.parents.splice(idx, 1);
				}
			}
		}

		// remove outdated dependency from module children
		var dependency;
		var moduleOutdatedDependencies;
		for (moduleId in outdatedDependencies) {
			if (
				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
			) {
				module = installedModules[moduleId];
				if (module) {
					moduleOutdatedDependencies = outdatedDependencies[moduleId];
					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
						dependency = moduleOutdatedDependencies[j];
						idx = module.children.indexOf(dependency);
						if (idx >= 0) module.children.splice(idx, 1);
					}
				}
			}
		}

		// Not in "apply" phase
		hotSetStatus("apply");

		hotCurrentHash = hotUpdateNewHash;

		// insert new code
		for (moduleId in appliedUpdate) {
			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
				modules[moduleId] = appliedUpdate[moduleId];
			}
		}

		// call accept handlers
		var error = null;
		for (moduleId in outdatedDependencies) {
			if (
				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
			) {
				module = installedModules[moduleId];
				if (module) {
					moduleOutdatedDependencies = outdatedDependencies[moduleId];
					var callbacks = [];
					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
						dependency = moduleOutdatedDependencies[i];
						cb = module.hot._acceptedDependencies[dependency];
						if (cb) {
							if (callbacks.indexOf(cb) !== -1) continue;
							callbacks.push(cb);
						}
					}
					for (i = 0; i < callbacks.length; i++) {
						cb = callbacks[i];
						try {
							cb(moduleOutdatedDependencies);
						} catch (err) {
							if (options.onErrored) {
								options.onErrored({
									type: "accept-errored",
									moduleId: moduleId,
									dependencyId: moduleOutdatedDependencies[i],
									error: err
								});
							}
							if (!options.ignoreErrored) {
								if (!error) error = err;
							}
						}
					}
				}
			}
		}

		// Load self accepted modules
		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
			var item = outdatedSelfAcceptedModules[i];
			moduleId = item.module;
			hotCurrentParents = [moduleId];
			try {
				$require$(moduleId);
			} catch (err) {
				if (typeof item.errorHandler === "function") {
					try {
						item.errorHandler(err);
					} catch (err2) {
						if (options.onErrored) {
							options.onErrored({
								type: "self-accept-error-handler-errored",
								moduleId: moduleId,
								error: err2,
								originalError: err
							});
						}
						if (!options.ignoreErrored) {
							if (!error) error = err2;
						}
						if (!error) error = err;
					}
				} else {
					if (options.onErrored) {
						options.onErrored({
							type: "self-accept-errored",
							moduleId: moduleId,
							error: err
						});
					}
					if (!options.ignoreErrored) {
						if (!error) error = err;
					}
				}
			}
		}

		// handle errors in accept handlers and self accepted module load
		if (error) {
			hotSetStatus("fail");
			return Promise.reject(error);
		}

		hotSetStatus("idle");
		return new Promise(function(resolve) {
			resolve(outdatedModules);
		});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/HotModuleReplacementPlugin.js":
/*!***************************************************!*\
  !*** (webpack)/lib/HotModuleReplacementPlugin.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { SyncBailHook } = __webpack_require__(/*! tapable */ "tapable");
const { RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");
const ModuleHotAcceptDependency = __webpack_require__(/*! ./dependencies/ModuleHotAcceptDependency */ "./node_modules/webpack/lib/dependencies/ModuleHotAcceptDependency.js");
const ModuleHotDeclineDependency = __webpack_require__(/*! ./dependencies/ModuleHotDeclineDependency */ "./node_modules/webpack/lib/dependencies/ModuleHotDeclineDependency.js");
const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");
const ParserHelpers = __webpack_require__(/*! ./ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");

module.exports = class HotModuleReplacementPlugin {
	constructor(options) {
		this.options = options || {};
		this.multiStep = this.options.multiStep;
		this.fullBuildTimeout = this.options.fullBuildTimeout || 200;
		this.requestTimeout = this.options.requestTimeout || 10000;
	}

	apply(compiler) {
		const multiStep = this.multiStep;
		const fullBuildTimeout = this.fullBuildTimeout;
		const requestTimeout = this.requestTimeout;
		const hotUpdateChunkFilename =
			compiler.options.output.hotUpdateChunkFilename;
		const hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;
		compiler.hooks.additionalPass.tapAsync(
			"HotModuleReplacementPlugin",
			callback => {
				if (multiStep) return setTimeout(callback, fullBuildTimeout);
				return callback();
			}
		);

		const addParserPlugins = (parser, parserOptions) => {
			parser.hooks.expression
				.for("__webpack_hash__")
				.tap(
					"HotModuleReplacementPlugin",
					ParserHelpers.toConstantDependencyWithWebpackRequire(
						parser,
						"__webpack_require__.h()"
					)
				);
			parser.hooks.evaluateTypeof
				.for("__webpack_hash__")
				.tap(
					"HotModuleReplacementPlugin",
					ParserHelpers.evaluateToString("string")
				);
			parser.hooks.evaluateIdentifier.for("module.hot").tap(
				{
					name: "HotModuleReplacementPlugin",
					before: "NodeStuffPlugin"
				},
				expr => {
					return ParserHelpers.evaluateToIdentifier(
						"module.hot",
						!!parser.state.compilation.hotUpdateChunkTemplate
					)(expr);
				}
			);
			// TODO webpack 5: refactor this, no custom hooks
			if (!parser.hooks.hotAcceptCallback) {
				parser.hooks.hotAcceptCallback = new SyncBailHook([
					"expression",
					"requests"
				]);
			}
			if (!parser.hooks.hotAcceptWithoutCallback) {
				parser.hooks.hotAcceptWithoutCallback = new SyncBailHook([
					"expression",
					"requests"
				]);
			}
			parser.hooks.call
				.for("module.hot.accept")
				.tap("HotModuleReplacementPlugin", expr => {
					if (!parser.state.compilation.hotUpdateChunkTemplate) {
						return false;
					}
					if (expr.arguments.length >= 1) {
						const arg = parser.evaluateExpression(expr.arguments[0]);
						let params = [];
						let requests = [];
						if (arg.isString()) {
							params = [arg];
						} else if (arg.isArray()) {
							params = arg.items.filter(param => param.isString());
						}
						if (params.length > 0) {
							params.forEach((param, idx) => {
								const request = param.string;
								const dep = new ModuleHotAcceptDependency(request, param.range);
								dep.optional = true;
								dep.loc = Object.create(expr.loc);
								dep.loc.index = idx;
								parser.state.module.addDependency(dep);
								requests.push(request);
							});
							if (expr.arguments.length > 1) {
								parser.hooks.hotAcceptCallback.call(
									expr.arguments[1],
									requests
								);
								parser.walkExpression(expr.arguments[1]); // other args are ignored
								return true;
							} else {
								parser.hooks.hotAcceptWithoutCallback.call(expr, requests);
								return true;
							}
						}
					}
				});
			parser.hooks.call
				.for("module.hot.decline")
				.tap("HotModuleReplacementPlugin", expr => {
					if (!parser.state.compilation.hotUpdateChunkTemplate) {
						return false;
					}
					if (expr.arguments.length === 1) {
						const arg = parser.evaluateExpression(expr.arguments[0]);
						let params = [];
						if (arg.isString()) {
							params = [arg];
						} else if (arg.isArray()) {
							params = arg.items.filter(param => param.isString());
						}
						params.forEach((param, idx) => {
							const dep = new ModuleHotDeclineDependency(
								param.string,
								param.range
							);
							dep.optional = true;
							dep.loc = Object.create(expr.loc);
							dep.loc.index = idx;
							parser.state.module.addDependency(dep);
						});
					}
				});
			parser.hooks.expression
				.for("module.hot")
				.tap("HotModuleReplacementPlugin", ParserHelpers.skipTraversal);
		};

		compiler.hooks.compilation.tap(
			"HotModuleReplacementPlugin",
			(compilation, { normalModuleFactory }) => {
				const hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;
				if (!hotUpdateChunkTemplate) return;

				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				compilation.dependencyFactories.set(
					ModuleHotAcceptDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ModuleHotAcceptDependency,
					new ModuleHotAcceptDependency.Template()
				);

				compilation.dependencyFactories.set(
					ModuleHotDeclineDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ModuleHotDeclineDependency,
					new ModuleHotDeclineDependency.Template()
				);

				compilation.hooks.record.tap(
					"HotModuleReplacementPlugin",
					(compilation, records) => {
						if (records.hash === compilation.hash) return;
						records.hash = compilation.hash;
						records.moduleHashs = {};
						for (const module of compilation.modules) {
							const identifier = module.identifier();
							records.moduleHashs[identifier] = module.hash;
						}
						records.chunkHashs = {};
						for (const chunk of compilation.chunks) {
							records.chunkHashs[chunk.id] = chunk.hash;
						}
						records.chunkModuleIds = {};
						for (const chunk of compilation.chunks) {
							records.chunkModuleIds[chunk.id] = Array.from(
								chunk.modulesIterable,
								m => m.id
							);
						}
					}
				);
				let initialPass = false;
				let recompilation = false;
				compilation.hooks.afterHash.tap("HotModuleReplacementPlugin", () => {
					let records = compilation.records;
					if (!records) {
						initialPass = true;
						return;
					}
					if (!records.hash) initialPass = true;
					const preHash = records.preHash || "x";
					const prepreHash = records.prepreHash || "x";
					if (preHash === compilation.hash) {
						recompilation = true;
						compilation.modifyHash(prepreHash);
						return;
					}
					records.prepreHash = records.hash || "x";
					records.preHash = compilation.hash;
					compilation.modifyHash(records.prepreHash);
				});
				compilation.hooks.shouldGenerateChunkAssets.tap(
					"HotModuleReplacementPlugin",
					() => {
						if (multiStep && !recompilation && !initialPass) return false;
					}
				);
				compilation.hooks.needAdditionalPass.tap(
					"HotModuleReplacementPlugin",
					() => {
						if (multiStep && !recompilation && !initialPass) return true;
					}
				);
				compilation.hooks.additionalChunkAssets.tap(
					"HotModuleReplacementPlugin",
					() => {
						const records = compilation.records;
						if (records.hash === compilation.hash) return;
						if (
							!records.moduleHashs ||
							!records.chunkHashs ||
							!records.chunkModuleIds
						)
							return;
						for (const module of compilation.modules) {
							const identifier = module.identifier();
							let hash = module.hash;
							module.hotUpdate = records.moduleHashs[identifier] !== hash;
						}
						const hotUpdateMainContent = {
							h: compilation.hash,
							c: {}
						};
						for (const key of Object.keys(records.chunkHashs)) {
							const chunkId = isNaN(+key) ? key : +key;
							const currentChunk = compilation.chunks.find(
								chunk => `${chunk.id}` === key
							);
							if (currentChunk) {
								const newModules = currentChunk
									.getModules()
									.filter(module => module.hotUpdate);
								const allModules = new Set();
								for (const module of currentChunk.modulesIterable) {
									allModules.add(module.id);
								}
								const removedModules = records.chunkModuleIds[chunkId].filter(
									id => !allModules.has(id)
								);
								if (newModules.length > 0 || removedModules.length > 0) {
									const source = hotUpdateChunkTemplate.render(
										chunkId,
										newModules,
										removedModules,
										compilation.hash,
										compilation.moduleTemplates.javascript,
										compilation.dependencyTemplates
									);
									const filename = compilation.getPath(hotUpdateChunkFilename, {
										hash: records.hash,
										chunk: currentChunk
									});
									compilation.additionalChunkAssets.push(filename);
									compilation.assets[filename] = source;
									hotUpdateMainContent.c[chunkId] = true;
									currentChunk.files.push(filename);
									compilation.hooks.chunkAsset.call(currentChunk, filename);
								}
							} else {
								hotUpdateMainContent.c[chunkId] = false;
							}
						}
						const source = new RawSource(JSON.stringify(hotUpdateMainContent));
						const filename = compilation.getPath(hotUpdateMainFilename, {
							hash: records.hash
						});
						compilation.assets[filename] = source;
					}
				);

				const mainTemplate = compilation.mainTemplate;

				mainTemplate.hooks.hash.tap("HotModuleReplacementPlugin", hash => {
					hash.update("HotMainTemplateDecorator");
				});

				mainTemplate.hooks.moduleRequire.tap(
					"HotModuleReplacementPlugin",
					(_, chunk, hash, varModuleId) => {
						return `hotCreateRequire(${varModuleId})`;
					}
				);

				mainTemplate.hooks.requireExtensions.tap(
					"HotModuleReplacementPlugin",
					source => {
						const buf = [source];
						buf.push("");
						buf.push("// __webpack_hash__");
						buf.push(
							mainTemplate.requireFn +
								".h = function() { return hotCurrentHash; };"
						);
						return Template.asString(buf);
					}
				);

				const needChunkLoadingCode = chunk => {
					for (const chunkGroup of chunk.groupsIterable) {
						if (chunkGroup.chunks.length > 1) return true;
						if (chunkGroup.getNumberOfChildren() > 0) return true;
					}
					return false;
				};

				mainTemplate.hooks.bootstrap.tap(
					"HotModuleReplacementPlugin",
					(source, chunk, hash) => {
						source = mainTemplate.hooks.hotBootstrap.call(source, chunk, hash);
						return Template.asString([
							source,
							"",
							hotInitCode
								.replace(/\$require\$/g, mainTemplate.requireFn)
								.replace(/\$hash\$/g, JSON.stringify(hash))
								.replace(/\$requestTimeout\$/g, requestTimeout)
								.replace(
									/\/\*foreachInstalledChunks\*\//g,
									needChunkLoadingCode(chunk)
										? "for(var chunkId in installedChunks)"
										: `var chunkId = ${JSON.stringify(chunk.id)};`
								)
						]);
					}
				);

				mainTemplate.hooks.globalHash.tap(
					"HotModuleReplacementPlugin",
					() => true
				);

				mainTemplate.hooks.currentHash.tap(
					"HotModuleReplacementPlugin",
					(_, length) => {
						if (isFinite(length)) {
							return `hotCurrentHash.substr(0, ${length})`;
						} else {
							return "hotCurrentHash";
						}
					}
				);

				mainTemplate.hooks.moduleObj.tap(
					"HotModuleReplacementPlugin",
					(source, chunk, hash, varModuleId) => {
						return Template.asString([
							`${source},`,
							`hot: hotCreateModule(${varModuleId}),`,
							"parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),",
							"children: []"
						]);
					}
				);

				// TODO add HMR support for javascript/esm
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("HotModuleReplacementPlugin", addParserPlugins);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("HotModuleReplacementPlugin", addParserPlugins);

				compilation.hooks.normalModuleLoader.tap(
					"HotModuleReplacementPlugin",
					context => {
						context.hot = true;
					}
				);
			}
		);
	}
};

const hotInitCode = Template.getFunctionContent(
	__webpack_require__(/*! ./HotModuleReplacement.runtime */ "./node_modules/webpack/lib/HotModuleReplacement.runtime.js")
);


/***/ }),

/***/ "./node_modules/webpack/lib/HotUpdateChunk.js":
/*!***************************************!*\
  !*** (webpack)/lib/HotUpdateChunk.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Chunk = __webpack_require__(/*! ./Chunk */ "./node_modules/webpack/lib/Chunk.js");

class HotUpdateChunk extends Chunk {
	constructor() {
		super();
		/** @type {(string|number)[]} */
		this.removedModules = undefined;
	}
}

module.exports = HotUpdateChunk;


/***/ }),

/***/ "./node_modules/webpack/lib/HotUpdateChunkTemplate.js":
/*!***********************************************!*\
  !*** (webpack)/lib/HotUpdateChunkTemplate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");
const HotUpdateChunk = __webpack_require__(/*! ./HotUpdateChunk */ "./node_modules/webpack/lib/HotUpdateChunk.js");
const { Tapable, SyncWaterfallHook, SyncHook } = __webpack_require__(/*! tapable */ "tapable");

module.exports = class HotUpdateChunkTemplate extends Tapable {
	constructor(outputOptions) {
		super();
		this.outputOptions = outputOptions || {};
		this.hooks = {
			modules: new SyncWaterfallHook([
				"source",
				"modules",
				"removedModules",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			render: new SyncWaterfallHook([
				"source",
				"modules",
				"removedModules",
				"hash",
				"id",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			hash: new SyncHook(["hash"])
		};
	}

	render(
		id,
		modules,
		removedModules,
		hash,
		moduleTemplate,
		dependencyTemplates
	) {
		const hotUpdateChunk = new HotUpdateChunk();
		hotUpdateChunk.id = id;
		hotUpdateChunk.setModules(modules);
		hotUpdateChunk.removedModules = removedModules;
		const modulesSource = Template.renderChunkModules(
			hotUpdateChunk,
			m => typeof m.source === "function",
			moduleTemplate,
			dependencyTemplates
		);
		const core = this.hooks.modules.call(
			modulesSource,
			modules,
			removedModules,
			moduleTemplate,
			dependencyTemplates
		);
		const source = this.hooks.render.call(
			core,
			modules,
			removedModules,
			hash,
			id,
			moduleTemplate,
			dependencyTemplates
		);
		return source;
	}

	updateHash(hash) {
		hash.update("HotUpdateChunkTemplate");
		hash.update("1");
		this.hooks.hash.call(hash);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/IgnorePlugin.js":
/*!*************************************!*\
  !*** (webpack)/lib/IgnorePlugin.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/IgnorePlugin.json */ "./node_modules/webpack/schemas/plugins/IgnorePlugin.json");

/** @typedef {import("../declarations/plugins/IgnorePlugin").IgnorePluginOptions} IgnorePluginOptions */
/** @typedef {import("./Compiler")} Compiler */

class IgnorePlugin {
	/**
	 * @param {IgnorePluginOptions} options IgnorePlugin options
	 */
	constructor(options) {
		// TODO webpack 5 remove this compat-layer
		if (arguments.length > 1 || options instanceof RegExp) {
			options = {
				resourceRegExp: arguments[0],
				contextRegExp: arguments[1]
			};
		}

		validateOptions(schema, options, "IgnorePlugin");
		this.options = options;

		/** @private @type {Function} */
		this.checkIgnore = this.checkIgnore.bind(this);
	}

	/**
	 * Note that if "contextRegExp" is given, both the "resourceRegExp"
	 * and "contextRegExp" have to match.
	 *
	 * @param {TODO} result result
	 * @returns {TODO|null} returns result or null if result should be ignored
	 */
	checkIgnore(result) {
		if (!result) return result;

		if (
			"checkResource" in this.options &&
			this.options.checkResource &&
			this.options.checkResource(result.request, result.context)
		) {
			// TODO webpack 5 remove checkContext, as checkResource already gets context
			if ("checkContext" in this.options && this.options.checkContext) {
				if (this.options.checkContext(result.context)) {
					return null;
				}
			} else {
				return null;
			}
		}

		if (
			"resourceRegExp" in this.options &&
			this.options.resourceRegExp &&
			this.options.resourceRegExp.test(result.request)
		) {
			if ("contextRegExp" in this.options && this.options.contextRegExp) {
				// if "contextRegExp" is given,
				// both the "resourceRegExp" and "contextRegExp" have to match.
				if (this.options.contextRegExp.test(result.context)) {
					return null;
				}
			} else {
				return null;
			}
		}

		return result;
	}

	/**
	 * @param {Compiler} compiler Webpack Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.normalModuleFactory.tap("IgnorePlugin", nmf => {
			nmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
		});
		compiler.hooks.contextModuleFactory.tap("IgnorePlugin", cmf => {
			cmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
		});
	}
}

module.exports = IgnorePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/JavascriptGenerator.js":
/*!********************************************!*\
  !*** (webpack)/lib/JavascriptGenerator.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { RawSource, ReplaceSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

// TODO: clean up this file
// replace with newer constructs

// TODO: remove DependencyVariables and replace them with something better

class JavascriptGenerator {
	generate(module, dependencyTemplates, runtimeTemplate) {
		const originalSource = module.originalSource();
		if (!originalSource) {
			return new RawSource("throw new Error('No source available');");
		}

		const source = new ReplaceSource(originalSource);

		this.sourceBlock(
			module,
			module,
			[],
			dependencyTemplates,
			source,
			runtimeTemplate
		);

		return source;
	}

	sourceBlock(
		module,
		block,
		availableVars,
		dependencyTemplates,
		source,
		runtimeTemplate
	) {
		for (const dependency of block.dependencies) {
			this.sourceDependency(
				dependency,
				dependencyTemplates,
				source,
				runtimeTemplate
			);
		}

		/**
		 * Get the variables of all blocks that we need to inject.
		 * These will contain the variable name and its expression.
		 * The name will be added as a parameter in a IIFE the expression as its value.
		 */
		const vars = block.variables.reduce((result, value) => {
			const variable = this.sourceVariables(
				value,
				availableVars,
				dependencyTemplates,
				runtimeTemplate
			);

			if (variable) {
				result.push(variable);
			}

			return result;
		}, []);

		/**
		 * if we actually have variables
		 * this is important as how #splitVariablesInUniqueNamedChunks works
		 * it will always return an array in an array which would lead to a IIFE wrapper around
		 * a module if we do this with an empty vars array.
		 */
		if (vars.length > 0) {
			/**
			 * Split all variables up into chunks of unique names.
			 * e.g. imagine you have the following variable names that need to be injected:
			 * [foo, bar, baz, foo, some, more]
			 * we can not inject "foo" twice, therefore we just make two IIFEs like so:
			 * (function(foo, bar, baz){
			 *   (function(foo, some, more){
			 *     …
			 *   }(…));
			 * }(…));
			 *
			 * "splitVariablesInUniqueNamedChunks" splits the variables shown above up to this:
			 * [[foo, bar, baz], [foo, some, more]]
			 */
			const injectionVariableChunks = this.splitVariablesInUniqueNamedChunks(
				vars
			);

			// create all the beginnings of IIFEs
			const functionWrapperStarts = injectionVariableChunks.map(
				variableChunk => {
					return this.variableInjectionFunctionWrapperStartCode(
						variableChunk.map(variable => variable.name)
					);
				}
			);

			// and all the ends
			const functionWrapperEnds = injectionVariableChunks.map(variableChunk => {
				return this.variableInjectionFunctionWrapperEndCode(
					module,
					variableChunk.map(variable => variable.expression),
					block
				);
			});

			// join them to one big string
			const varStartCode = functionWrapperStarts.join("");

			// reverse the ends first before joining them, as the last added must be the inner most
			const varEndCode = functionWrapperEnds.reverse().join("");

			// if we have anything, add it to the source
			if (varStartCode && varEndCode) {
				const start = block.range ? block.range[0] : -10;
				const end = block.range
					? block.range[1]
					: module.originalSource().size() + 1;
				source.insert(start + 0.5, varStartCode);
				source.insert(end + 0.5, "\n/* WEBPACK VAR INJECTION */" + varEndCode);
			}
		}

		for (const childBlock of block.blocks) {
			this.sourceBlock(
				module,
				childBlock,
				availableVars.concat(vars),
				dependencyTemplates,
				source,
				runtimeTemplate
			);
		}
	}

	sourceDependency(dependency, dependencyTemplates, source, runtimeTemplate) {
		const template = dependencyTemplates.get(dependency.constructor);
		if (!template) {
			throw new Error(
				"No template for dependency: " + dependency.constructor.name
			);
		}
		template.apply(dependency, source, runtimeTemplate, dependencyTemplates);
	}

	sourceVariables(
		variable,
		availableVars,
		dependencyTemplates,
		runtimeTemplate
	) {
		const name = variable.name;
		const expr = variable.expressionSource(
			dependencyTemplates,
			runtimeTemplate
		);

		if (
			availableVars.some(
				v => v.name === name && v.expression.source() === expr.source()
			)
		) {
			return;
		}
		return {
			name: name,
			expression: expr
		};
	}

	/*
	 * creates the start part of a IIFE around the module to inject a variable name
	 * (function(…){   <- this part
	 * }.call(…))
	 */
	variableInjectionFunctionWrapperStartCode(varNames) {
		const args = varNames.join(", ");
		return `/* WEBPACK VAR INJECTION */(function(${args}) {`;
	}

	contextArgument(module, block) {
		if (this === block) {
			return module.exportsArgument;
		}
		return "this";
	}

	/*
	 * creates the end part of a IIFE around the module to inject a variable name
	 * (function(…){
	 * }.call(…))   <- this part
	 */
	variableInjectionFunctionWrapperEndCode(module, varExpressions, block) {
		const firstParam = this.contextArgument(module, block);
		const furtherParams = varExpressions.map(e => e.source()).join(", ");
		return `}.call(${firstParam}, ${furtherParams}))`;
	}

	splitVariablesInUniqueNamedChunks(vars) {
		const startState = [[]];
		return vars.reduce((chunks, variable) => {
			const current = chunks[chunks.length - 1];
			// check if variable with same name exists already
			// if so create a new chunk of variables.
			const variableNameAlreadyExists = current.some(
				v => v.name === variable.name
			);

			if (variableNameAlreadyExists) {
				// start new chunk with current variable
				chunks.push([variable]);
			} else {
				// else add it to current chunk
				current.push(variable);
			}
			return chunks;
		}, startState);
	}
}

module.exports = JavascriptGenerator;


/***/ }),

/***/ "./node_modules/webpack/lib/JavascriptModulesPlugin.js":
/*!************************************************!*\
  !*** (webpack)/lib/JavascriptModulesPlugin.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Parser = __webpack_require__(/*! ./Parser */ "./node_modules/webpack/lib/Parser.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");
const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const JavascriptGenerator = __webpack_require__(/*! ./JavascriptGenerator */ "./node_modules/webpack/lib/JavascriptGenerator.js");
const createHash = __webpack_require__(/*! ./util/createHash */ "./node_modules/webpack/lib/util/createHash.js");

class JavascriptModulesPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"JavascriptModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				normalModuleFactory.hooks.createParser
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", options => {
						return new Parser(options, "auto");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", options => {
						return new Parser(options, "script");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", options => {
						return new Parser(options, "module");
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				compilation.mainTemplate.hooks.renderManifest.tap(
					"JavascriptModulesPlugin",
					(result, options) => {
						const chunk = options.chunk;
						const hash = options.hash;
						const fullHash = options.fullHash;
						const outputOptions = options.outputOptions;
						const moduleTemplates = options.moduleTemplates;
						const dependencyTemplates = options.dependencyTemplates;

						const filenameTemplate =
							chunk.filenameTemplate || outputOptions.filename;

						const useChunkHash = compilation.mainTemplate.useChunkHash(chunk);

						result.push({
							render: () =>
								compilation.mainTemplate.render(
									hash,
									chunk,
									moduleTemplates.javascript,
									dependencyTemplates
								),
							filenameTemplate,
							pathOptions: {
								noChunkHash: !useChunkHash,
								contentHashType: "javascript",
								chunk
							},
							identifier: `chunk${chunk.id}`,
							hash: useChunkHash ? chunk.hash : fullHash
						});
						return result;
					}
				);
				compilation.mainTemplate.hooks.modules.tap(
					"JavascriptModulesPlugin",
					(source, chunk, hash, moduleTemplate, dependencyTemplates) => {
						return Template.renderChunkModules(
							chunk,
							m => typeof m.source === "function",
							moduleTemplate,
							dependencyTemplates,
							"/******/ "
						);
					}
				);
				compilation.chunkTemplate.hooks.renderManifest.tap(
					"JavascriptModulesPlugin",
					(result, options) => {
						const chunk = options.chunk;
						const outputOptions = options.outputOptions;
						const moduleTemplates = options.moduleTemplates;
						const dependencyTemplates = options.dependencyTemplates;
						const filenameTemplate =
							chunk.filenameTemplate || outputOptions.chunkFilename;

						result.push({
							render: () =>
								this.renderJavascript(
									compilation.chunkTemplate,
									chunk,
									moduleTemplates.javascript,
									dependencyTemplates
								),
							filenameTemplate,
							pathOptions: {
								chunk,
								contentHashType: "javascript"
							},
							identifier: `chunk${chunk.id}`,
							hash: chunk.hash
						});

						return result;
					}
				);
				compilation.hooks.contentHash.tap("JavascriptModulesPlugin", chunk => {
					const outputOptions = compilation.outputOptions;
					const {
						hashSalt,
						hashDigest,
						hashDigestLength,
						hashFunction
					} = outputOptions;
					const hash = createHash(hashFunction);
					if (hashSalt) hash.update(hashSalt);
					const template = chunk.hasRuntime()
						? compilation.mainTemplate
						: compilation.chunkTemplate;
					hash.update(`${chunk.id} `);
					hash.update(chunk.ids ? chunk.ids.join(",") : "");
					template.updateHashForChunk(
						hash,
						chunk,
						compilation.moduleTemplates.javascript,
						compilation.dependencyTemplates
					);
					for (const m of chunk.modulesIterable) {
						if (typeof m.source === "function") {
							hash.update(m.hash);
						}
					}
					chunk.contentHash.javascript = hash
						.digest(hashDigest)
						.substr(0, hashDigestLength);
				});
			}
		);
	}

	renderJavascript(chunkTemplate, chunk, moduleTemplate, dependencyTemplates) {
		const moduleSources = Template.renderChunkModules(
			chunk,
			m => typeof m.source === "function",
			moduleTemplate,
			dependencyTemplates
		);
		const core = chunkTemplate.hooks.modules.call(
			moduleSources,
			chunk,
			moduleTemplate,
			dependencyTemplates
		);
		let source = chunkTemplate.hooks.render.call(
			core,
			chunk,
			moduleTemplate,
			dependencyTemplates
		);
		if (chunk.hasEntryModule()) {
			source = chunkTemplate.hooks.renderWithEntry.call(source, chunk);
		}
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	}
}

module.exports = JavascriptModulesPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/JsonGenerator.js":
/*!**************************************!*\
  !*** (webpack)/lib/JsonGenerator.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource, RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

const stringifySafe = data => {
	const stringified = JSON.stringify(data);
	if (!stringified) {
		return undefined; // Invalid JSON
	}

	return stringified.replace(
		/\u2028|\u2029/g,
		str => (str === "\u2029" ? "\\u2029" : "\\u2028")
	); // invalid in JavaScript but valid JSON
};

class JsonGenerator {
	generate(module, dependencyTemplates, runtimeTemplate) {
		const source = new ConcatSource();
		const data = module.buildInfo.jsonData;
		if (data === undefined) {
			return new RawSource(
				runtimeTemplate.missingModuleStatement({
					request: module.rawRequest
				})
			);
		}
		if (
			Array.isArray(module.buildMeta.providedExports) &&
			!module.isUsed("default")
		) {
			// Only some exports are used: We can optimize here, by only generating a part of the JSON
			const reducedJson = {};
			for (const exportName of module.buildMeta.providedExports) {
				if (exportName === "default") continue;
				const used = module.isUsed(exportName);
				if (used) {
					reducedJson[used] = data[exportName];
				}
			}
			source.add(
				`${module.moduleArgument}.exports = ${stringifySafe(reducedJson)};`
			);
		} else {
			source.add(`${module.moduleArgument}.exports = ${stringifySafe(data)};`);
		}
		return source;
	}
}

module.exports = JsonGenerator;


/***/ }),

/***/ "./node_modules/webpack/lib/JsonModulesPlugin.js":
/*!******************************************!*\
  !*** (webpack)/lib/JsonModulesPlugin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const JsonParser = __webpack_require__(/*! ./JsonParser */ "./node_modules/webpack/lib/JsonParser.js");
const JsonGenerator = __webpack_require__(/*! ./JsonGenerator */ "./node_modules/webpack/lib/JsonGenerator.js");

class JsonModulesPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"JsonModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				normalModuleFactory.hooks.createParser
					.for("json")
					.tap("JsonModulesPlugin", () => {
						return new JsonParser();
					});
				normalModuleFactory.hooks.createGenerator
					.for("json")
					.tap("JsonModulesPlugin", () => {
						return new JsonGenerator();
					});
			}
		);
	}
}

module.exports = JsonModulesPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/JsonParser.js":
/*!***********************************!*\
  !*** (webpack)/lib/JsonParser.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const parseJson = __webpack_require__(/*! json-parse-better-errors */ "json-parse-better-errors");
const JsonExportsDependency = __webpack_require__(/*! ./dependencies/JsonExportsDependency */ "./node_modules/webpack/lib/dependencies/JsonExportsDependency.js");

class JsonParser {
	constructor(options) {
		this.options = options;
	}

	parse(source, state) {
		const data = parseJson(source[0] === "\ufeff" ? source.slice(1) : source);
		state.module.buildInfo.jsonData = data;
		state.module.buildMeta.exportsType = "named";
		if (typeof data === "object" && data) {
			state.module.addDependency(new JsonExportsDependency(Object.keys(data)));
		}
		state.module.addDependency(new JsonExportsDependency(["default"]));
		return state;
	}
}

module.exports = JsonParser;


/***/ }),

/***/ "./node_modules/webpack/lib/LibManifestPlugin.js":
/*!******************************************!*\
  !*** (webpack)/lib/LibManifestPlugin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const path = __webpack_require__(/*! path */ "path");
const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");
const SingleEntryDependency = __webpack_require__(/*! ./dependencies/SingleEntryDependency */ "./node_modules/webpack/lib/dependencies/SingleEntryDependency.js");

class LibManifestPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.emit.tapAsync(
			"LibManifestPlugin",
			(compilation, callback) => {
				asyncLib.forEach(
					compilation.chunks,
					(chunk, callback) => {
						if (!chunk.isOnlyInitial()) {
							callback();
							return;
						}
						const targetPath = compilation.getPath(this.options.path, {
							hash: compilation.hash,
							chunk
						});
						const name =
							this.options.name &&
							compilation.getPath(this.options.name, {
								hash: compilation.hash,
								chunk
							});
						const manifest = {
							name,
							type: this.options.type,
							content: Array.from(chunk.modulesIterable, module => {
								if (
									this.options.entryOnly &&
									!module.reasons.some(
										r => r.dependency instanceof SingleEntryDependency
									)
								) {
									return;
								}
								if (module.libIdent) {
									const ident = module.libIdent({
										context: this.options.context || compiler.options.context
									});
									if (ident) {
										return {
											ident,
											data: {
												id: module.id,
												buildMeta: module.buildMeta
											}
										};
									}
								}
							})
								.filter(Boolean)
								.reduce((obj, item) => {
									obj[item.ident] = item.data;
									return obj;
								}, Object.create(null))
						};
						// Apply formatting to content if format flag is true;
						const manifestContent = this.options.format
							? JSON.stringify(manifest, null, 2)
							: JSON.stringify(manifest);
						const content = Buffer.from(manifestContent, "utf8");
						compiler.outputFileSystem.mkdirp(path.dirname(targetPath), err => {
							if (err) return callback(err);
							compiler.outputFileSystem.writeFile(
								targetPath,
								content,
								callback
							);
						});
					},
					callback
				);
			}
		);
	}
}
module.exports = LibManifestPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/LibraryTemplatePlugin.js":
/*!**********************************************!*\
  !*** (webpack)/lib/LibraryTemplatePlugin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const SetVarMainTemplatePlugin = __webpack_require__(/*! ./SetVarMainTemplatePlugin */ "./node_modules/webpack/lib/SetVarMainTemplatePlugin.js");

/** @typedef {import("../declarations/WebpackOptions").LibraryCustomUmdObject} LibraryCustomUmdObject */
/** @typedef {import("./Compiler")} Compiler */

/**
 * @param {string[]} accessor the accessor to convert to path
 * @returns {string} the path
 */
const accessorToObjectAccess = accessor => {
	return accessor.map(a => `[${JSON.stringify(a)}]`).join("");
};

/**
 * @param {string=} base the path prefix
 * @param {string|string[]|LibraryCustomUmdObject} accessor the accessor
 * @param {"amd" | "commonjs" | "root"} umdProperty property used when a custom umd object is provided
 * @param {string=} joinWith the element separator
 * @returns {string} the path
 */
const accessorAccess = (base, accessor, umdProperty, joinWith = "; ") => {
	const normalizedAccessor =
		typeof accessor === "object" && !Array.isArray(accessor)
			? accessor[umdProperty]
			: accessor;
	const accessors = Array.isArray(normalizedAccessor)
		? normalizedAccessor
		: [normalizedAccessor];
	return accessors
		.map((_, idx) => {
			const a = base
				? base + accessorToObjectAccess(accessors.slice(0, idx + 1))
				: accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));
			if (idx === accessors.length - 1) return a;
			if (idx === 0 && base === undefined) {
				return `${a} = typeof ${a} === "object" ? ${a} : {}`;
			}
			return `${a} = ${a} || {}`;
		})
		.join(joinWith);
};

class LibraryTemplatePlugin {
	/**
	 * @param {string|string[]|LibraryCustomUmdObject} name name of library
	 * @param {string} target type of library
	 * @param {boolean} umdNamedDefine setting this to true will name the UMD module
	 * @param {string|TODO} auxiliaryComment comment in the UMD wrapper
	 * @param {string|string[]} exportProperty which export should be exposed as library
	 */
	constructor(name, target, umdNamedDefine, auxiliaryComment, exportProperty) {
		this.name = name;
		this.target = target;
		this.umdNamedDefine = umdNamedDefine;
		this.auxiliaryComment = auxiliaryComment;
		this.exportProperty = exportProperty;
	}

	/**
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap("LibraryTemplatePlugin", compilation => {
			if (this.exportProperty) {
				const ExportPropertyMainTemplatePlugin = __webpack_require__(/*! ./ExportPropertyMainTemplatePlugin */ "./node_modules/webpack/lib/ExportPropertyMainTemplatePlugin.js");
				new ExportPropertyMainTemplatePlugin(this.exportProperty).apply(
					compilation
				);
			}
			switch (this.target) {
				case "var":
					if (
						!this.name ||
						(typeof this.name === "object" && !Array.isArray(this.name))
					) {
						throw new Error(
							"library name must be set and not an UMD custom object for non-UMD target"
						);
					}
					new SetVarMainTemplatePlugin(
						`var ${accessorAccess(undefined, this.name, "root")}`,
						false
					).apply(compilation);
					break;
				case "assign":
					new SetVarMainTemplatePlugin(
						accessorAccess(undefined, this.name, "root"),
						false
					).apply(compilation);
					break;
				case "this":
				case "self":
				case "window":
					if (this.name) {
						new SetVarMainTemplatePlugin(
							accessorAccess(this.target, this.name, "root"),
							false
						).apply(compilation);
					} else {
						new SetVarMainTemplatePlugin(this.target, true).apply(compilation);
					}
					break;
				case "global":
					if (this.name) {
						new SetVarMainTemplatePlugin(
							accessorAccess(
								compilation.runtimeTemplate.outputOptions.globalObject,
								this.name,
								"root"
							),
							false
						).apply(compilation);
					} else {
						new SetVarMainTemplatePlugin(
							compilation.runtimeTemplate.outputOptions.globalObject,
							true
						).apply(compilation);
					}
					break;
				case "commonjs":
					if (this.name) {
						new SetVarMainTemplatePlugin(
							accessorAccess("exports", this.name, "commonjs"),
							false
						).apply(compilation);
					} else {
						new SetVarMainTemplatePlugin("exports", true).apply(compilation);
					}
					break;
				case "commonjs2":
				case "commonjs-module":
					new SetVarMainTemplatePlugin("module.exports", false).apply(
						compilation
					);
					break;
				case "amd":
				case "amd-require": {
					const AmdMainTemplatePlugin = __webpack_require__(/*! ./AmdMainTemplatePlugin */ "./node_modules/webpack/lib/AmdMainTemplatePlugin.js");
					if (this.name && typeof this.name !== "string") {
						throw new Error("library name must be a string for amd target");
					}
					new AmdMainTemplatePlugin({
						name: this.name,
						requireAsWrapper: this.target === "amd-require"
					}).apply(compilation);
					break;
				}
				case "umd":
				case "umd2": {
					const UmdMainTemplatePlugin = __webpack_require__(/*! ./UmdMainTemplatePlugin */ "./node_modules/webpack/lib/UmdMainTemplatePlugin.js");
					new UmdMainTemplatePlugin(this.name, {
						optionalAmdExternalAsGlobal: this.target === "umd2",
						namedDefine: this.umdNamedDefine,
						auxiliaryComment: this.auxiliaryComment
					}).apply(compilation);
					break;
				}
				case "jsonp": {
					const JsonpExportMainTemplatePlugin = __webpack_require__(/*! ./web/JsonpExportMainTemplatePlugin */ "./node_modules/webpack/lib/web/JsonpExportMainTemplatePlugin.js");
					if (typeof this.name !== "string")
						throw new Error("library name must be a string for jsonp target");
					new JsonpExportMainTemplatePlugin(this.name).apply(compilation);
					break;
				}
				default:
					throw new Error(`${this.target} is not a valid Library target`);
			}
		});
	}
}

module.exports = LibraryTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/LoaderOptionsPlugin.js":
/*!********************************************!*\
  !*** (webpack)/lib/LoaderOptionsPlugin.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ModuleFilenameHelpers = __webpack_require__(/*! ./ModuleFilenameHelpers */ "./node_modules/webpack/lib/ModuleFilenameHelpers.js");

const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/LoaderOptionsPlugin.json */ "./node_modules/webpack/schemas/plugins/LoaderOptionsPlugin.json");

/** @typedef {import("../declarations/plugins/LoaderOptionsPlugin").LoaderOptionsPluginOptions} LoaderOptionsPluginOptions */

class LoaderOptionsPlugin {
	/**
	 * @param {LoaderOptionsPluginOptions} options options object
	 */
	constructor(options) {
		validateOptions(schema, options || {}, "Loader Options Plugin");

		if (typeof options !== "object") options = {};
		if (!options.test) {
			options.test = {
				test: () => true
			};
		}
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("LoaderOptionsPlugin", compilation => {
			compilation.hooks.normalModuleLoader.tap(
				"LoaderOptionsPlugin",
				(context, module) => {
					const resource = module.resource;
					if (!resource) return;
					const i = resource.indexOf("?");
					if (
						ModuleFilenameHelpers.matchObject(
							options,
							i < 0 ? resource : resource.substr(0, i)
						)
					) {
						for (const key of Object.keys(options)) {
							if (key === "include" || key === "exclude" || key === "test") {
								continue;
							}
							context[key] = options[key];
						}
					}
				}
			);
		});
	}
}

module.exports = LoaderOptionsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/LoaderTargetPlugin.js":
/*!*******************************************!*\
  !*** (webpack)/lib/LoaderTargetPlugin.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class LoaderTargetPlugin {
	constructor(target) {
		this.target = target;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap("LoaderTargetPlugin", compilation => {
			compilation.hooks.normalModuleLoader.tap(
				"LoaderTargetPlugin",
				loaderContext => {
					loaderContext.target = this.target;
				}
			);
		});
	}
}

module.exports = LoaderTargetPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/MainTemplate.js":
/*!*************************************!*\
  !*** (webpack)/lib/MainTemplate.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const {
	ConcatSource,
	OriginalSource,
	PrefixSource,
	RawSource
} = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const {
	Tapable,
	SyncWaterfallHook,
	SyncHook,
	SyncBailHook
} = __webpack_require__(/*! tapable */ "tapable");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

/** @typedef {import("webpack-sources").ConcatSource} ConcatSource */
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./ModuleTemplate")} ModuleTemplate */
/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./Module")} Module} */
/** @typedef {import("./util/createHash").Hash} Hash} */
/** @typedef {import("./Dependency").DependencyTemplate} DependencyTemplate} */

/**
 * @typedef {Object} RenderManifestOptions
 * @property {Chunk} chunk the chunk used to render
 * @property {string} hash
 * @property {string} fullHash
 * @property {TODO} outputOptions
 * @property {{javascript: ModuleTemplate, webassembly: ModuleTemplate}} moduleTemplates
 * @property {Map<TODO, TODO>} dependencyTemplates
 */

// require function shortcuts:
// __webpack_require__.s = the module id of the entry point
// __webpack_require__.c = the module cache
// __webpack_require__.m = the module functions
// __webpack_require__.p = the bundle public path
// __webpack_require__.i = the identity function used for harmony imports
// __webpack_require__.e = the chunk ensure function
// __webpack_require__.d = the exported property define getter function
// __webpack_require__.o = Object.prototype.hasOwnProperty.call
// __webpack_require__.r = define compatibility on export
// __webpack_require__.t = create a fake namespace object
// __webpack_require__.n = compatibility get default export
// __webpack_require__.h = the webpack hash
// __webpack_require__.w = an object containing all installed WebAssembly.Instance export objects keyed by module id
// __webpack_require__.oe = the uncaught error handler for the webpack runtime
// __webpack_require__.nc = the script nonce

module.exports = class MainTemplate extends Tapable {
	/**
	 *
	 * @param {TODO=} outputOptions output options for the MainTemplate
	 */
	constructor(outputOptions) {
		super();
		/** @type {TODO?} */
		this.outputOptions = outputOptions || {};
		this.hooks = {
			/** @type {SyncWaterfallHook<TODO[], RenderManifestOptions>} */
			renderManifest: new SyncWaterfallHook(["result", "options"]),
			modules: new SyncWaterfallHook([
				"modules",
				"chunk",
				"hash",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			moduleObj: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleIdExpression"
			]),
			requireEnsure: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"chunkIdExpression"
			]),
			bootstrap: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			localVars: new SyncWaterfallHook(["source", "chunk", "hash"]),
			require: new SyncWaterfallHook(["source", "chunk", "hash"]),
			requireExtensions: new SyncWaterfallHook(["source", "chunk", "hash"]),
			/** @type {SyncWaterfallHook<string, Chunk, string>} */
			beforeStartup: new SyncWaterfallHook(["source", "chunk", "hash"]),
			/** @type {SyncWaterfallHook<string, Chunk, string>} */
			startup: new SyncWaterfallHook(["source", "chunk", "hash"]),
			render: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			renderWithEntry: new SyncWaterfallHook(["source", "chunk", "hash"]),
			moduleRequire: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleIdExpression"
			]),
			addModule: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleIdExpression",
				"moduleExpression"
			]),
			currentHash: new SyncWaterfallHook(["source", "requestedLength"]),
			assetPath: new SyncWaterfallHook(["path", "options"]),
			hash: new SyncHook(["hash"]),
			hashForChunk: new SyncHook(["hash", "chunk"]),
			globalHashPaths: new SyncWaterfallHook(["paths"]),
			globalHash: new SyncBailHook(["chunk", "paths"]),

			// TODO this should be moved somewhere else
			// It's weird here
			hotBootstrap: new SyncWaterfallHook(["source", "chunk", "hash"])
		};
		this.hooks.startup.tap("MainTemplate", (source, chunk, hash) => {
			/** @type {string[]} */
			const buf = [];
			if (chunk.entryModule) {
				buf.push("// Load entry module and return exports");
				buf.push(
					`return ${this.renderRequireFunctionForModule(
						hash,
						chunk,
						JSON.stringify(chunk.entryModule.id)
					)}(${this.requireFn}.s = ${JSON.stringify(chunk.entryModule.id)});`
				);
			}
			return Template.asString(buf);
		});
		this.hooks.render.tap(
			"MainTemplate",
			(bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) => {
				const source = new ConcatSource();
				source.add("/******/ (function(modules) { // webpackBootstrap\n");
				source.add(new PrefixSource("/******/", bootstrapSource));
				source.add("/******/ })\n");
				source.add(
					"/************************************************************************/\n"
				);
				source.add("/******/ (");
				source.add(
					this.hooks.modules.call(
						new RawSource(""),
						chunk,
						hash,
						moduleTemplate,
						dependencyTemplates
					)
				);
				source.add(")");
				return source;
			}
		);
		this.hooks.localVars.tap("MainTemplate", (source, chunk, hash) => {
			return Template.asString([
				source,
				"// The module cache",
				"var installedModules = {};"
			]);
		});
		this.hooks.require.tap("MainTemplate", (source, chunk, hash) => {
			return Template.asString([
				source,
				"// Check if module is in cache",
				"if(installedModules[moduleId]) {",
				Template.indent("return installedModules[moduleId].exports;"),
				"}",
				"// Create a new module (and put it into the cache)",
				"var module = installedModules[moduleId] = {",
				Template.indent(this.hooks.moduleObj.call("", chunk, hash, "moduleId")),
				"};",
				"",
				Template.asString(
					outputOptions.strictModuleExceptionHandling
						? [
								"// Execute the module function",
								"var threw = true;",
								"try {",
								Template.indent([
									`modules[moduleId].call(module.exports, module, module.exports, ${this.renderRequireFunctionForModule(
										hash,
										chunk,
										"moduleId"
									)});`,
									"threw = false;"
								]),
								"} finally {",
								Template.indent([
									"if(threw) delete installedModules[moduleId];"
								]),
								"}"
						  ]
						: [
								"// Execute the module function",
								`modules[moduleId].call(module.exports, module, module.exports, ${this.renderRequireFunctionForModule(
									hash,
									chunk,
									"moduleId"
								)});`
						  ]
				),
				"",
				"// Flag the module as loaded",
				"module.l = true;",
				"",
				"// Return the exports of the module",
				"return module.exports;"
			]);
		});
		this.hooks.moduleObj.tap(
			"MainTemplate",
			(source, chunk, hash, varModuleId) => {
				return Template.asString(["i: moduleId,", "l: false,", "exports: {}"]);
			}
		);
		this.hooks.requireExtensions.tap("MainTemplate", (source, chunk, hash) => {
			const buf = [];
			const chunkMaps = chunk.getChunkMaps();
			// Check if there are non initial chunks which need to be imported using require-ensure
			if (Object.keys(chunkMaps.hash).length) {
				buf.push("// This file contains only the entry chunk.");
				buf.push("// The chunk loading function for additional chunks");
				buf.push(`${this.requireFn}.e = function requireEnsure(chunkId) {`);
				buf.push(Template.indent("var promises = [];"));
				buf.push(
					Template.indent(
						this.hooks.requireEnsure.call("", chunk, hash, "chunkId")
					)
				);
				buf.push(Template.indent("return Promise.all(promises);"));
				buf.push("};");
			} else if (
				chunk.hasModuleInGraph(m =>
					m.blocks.some(b => b.chunkGroup && b.chunkGroup.chunks.length > 0)
				)
			) {
				// There async blocks in the graph, so we need to add an empty requireEnsure
				// function anyway. This can happen with multiple entrypoints.
				buf.push("// The chunk loading function for additional chunks");
				buf.push("// Since all referenced chunks are already included");
				buf.push("// in this file, this function is empty here.");
				buf.push(`${this.requireFn}.e = function requireEnsure() {`);
				buf.push(Template.indent("return Promise.resolve();"));
				buf.push("};");
			}
			buf.push("");
			buf.push("// expose the modules object (__webpack_modules__)");
			buf.push(`${this.requireFn}.m = modules;`);

			buf.push("");
			buf.push("// expose the module cache");
			buf.push(`${this.requireFn}.c = installedModules;`);

			buf.push("");
			buf.push("// define getter function for harmony exports");
			buf.push(`${this.requireFn}.d = function(exports, name, getter) {`);
			buf.push(
				Template.indent([
					`if(!${this.requireFn}.o(exports, name)) {`,
					Template.indent([
						"Object.defineProperty(exports, name, { enumerable: true, get: getter });"
					]),
					"}"
				])
			);
			buf.push("};");

			buf.push("");
			buf.push("// define __esModule on exports");
			buf.push(`${this.requireFn}.r = function(exports) {`);
			buf.push(
				Template.indent([
					"if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {",
					Template.indent([
						"Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });"
					]),
					"}",
					"Object.defineProperty(exports, '__esModule', { value: true });"
				])
			);
			buf.push("};");

			buf.push("");
			buf.push("// create a fake namespace object");
			buf.push("// mode & 1: value is a module id, require it");
			buf.push("// mode & 2: merge all properties of value into the ns");
			buf.push("// mode & 4: return value when already ns object");
			buf.push("// mode & 8|1: behave like require");
			buf.push(`${this.requireFn}.t = function(value, mode) {`);
			buf.push(
				Template.indent([
					`if(mode & 1) value = ${this.requireFn}(value);`,
					`if(mode & 8) return value;`,
					"if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;",
					"var ns = Object.create(null);",
					`${this.requireFn}.r(ns);`,
					"Object.defineProperty(ns, 'default', { enumerable: true, value: value });",
					"if(mode & 2 && typeof value != 'string') for(var key in value) " +
						`${this.requireFn}.d(ns, key, function(key) { ` +
						"return value[key]; " +
						"}.bind(null, key));",
					"return ns;"
				])
			);
			buf.push("};");

			buf.push("");
			buf.push(
				"// getDefaultExport function for compatibility with non-harmony modules"
			);
			buf.push(this.requireFn + ".n = function(module) {");
			buf.push(
				Template.indent([
					"var getter = module && module.__esModule ?",
					Template.indent([
						"function getDefault() { return module['default']; } :",
						"function getModuleExports() { return module; };"
					]),
					`${this.requireFn}.d(getter, 'a', getter);`,
					"return getter;"
				])
			);
			buf.push("};");

			buf.push("");
			buf.push("// Object.prototype.hasOwnProperty.call");
			buf.push(
				`${
					this.requireFn
				}.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };`
			);

			const publicPath = this.getPublicPath({
				hash: hash
			});
			buf.push("");
			buf.push("// __webpack_public_path__");
			buf.push(`${this.requireFn}.p = ${JSON.stringify(publicPath)};`);
			return Template.asString(buf);
		});

		this.requireFn = "__webpack_require__";
	}

	/**
	 *
	 * @param {RenderManifestOptions} options render manifest options
	 * @returns {TODO[]} returns render manifest
	 */
	getRenderManifest(options) {
		const result = [];

		this.hooks.renderManifest.call(result, options);

		return result;
	}

	/**
	 * TODO webpack 5: remove moduleTemplate and dependencyTemplates
	 * @param {string} hash hash to be used for render call
	 * @param {Chunk} chunk Chunk instance
	 * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render
	 * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates
	 * @returns {string[]} the generated source of the bootstrap code
	 */
	renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates) {
		const buf = [];
		buf.push(
			this.hooks.bootstrap.call(
				"",
				chunk,
				hash,
				moduleTemplate,
				dependencyTemplates
			)
		);
		buf.push(this.hooks.localVars.call("", chunk, hash));
		buf.push("");
		buf.push("// The require function");
		buf.push(`function ${this.requireFn}(moduleId) {`);
		buf.push(Template.indent(this.hooks.require.call("", chunk, hash)));
		buf.push("}");
		buf.push("");
		buf.push(
			Template.asString(this.hooks.requireExtensions.call("", chunk, hash))
		);
		buf.push("");
		buf.push(Template.asString(this.hooks.beforeStartup.call("", chunk, hash)));
		buf.push(Template.asString(this.hooks.startup.call("", chunk, hash)));
		return buf;
	}

	/**
	 * @param {string} hash hash to be used for render call
	 * @param {Chunk} chunk Chunk instance
	 * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render
	 * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates
	 * @returns {ConcatSource} the newly generated source from rendering
	 */
	render(hash, chunk, moduleTemplate, dependencyTemplates) {
		const buf = this.renderBootstrap(
			hash,
			chunk,
			moduleTemplate,
			dependencyTemplates
		);
		let source = this.hooks.render.call(
			new OriginalSource(
				Template.prefix(buf, " \t") + "\n",
				"webpack/bootstrap"
			),
			chunk,
			hash,
			moduleTemplate,
			dependencyTemplates
		);
		if (chunk.hasEntryModule()) {
			source = this.hooks.renderWithEntry.call(source, chunk, hash);
		}
		if (!source) {
			throw new Error(
				"Compiler error: MainTemplate plugin 'render' should return something"
			);
		}
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	}

	/**
	 *
	 * @param {string} hash hash for render fn
	 * @param {Chunk} chunk Chunk instance for require
	 * @param {(number|string)=} varModuleId module id
	 * @returns {TODO} the moduleRequire hook call return signature
	 */
	renderRequireFunctionForModule(hash, chunk, varModuleId) {
		return this.hooks.moduleRequire.call(
			this.requireFn,
			chunk,
			hash,
			varModuleId
		);
	}

	/**
	 *
	 * @param {string} hash hash for render add fn
	 * @param {Chunk} chunk Chunk instance for require add fn
	 * @param {(string|number)=} varModuleId module id
	 * @param {Module} varModule Module instance
	 * @returns {TODO} renderAddModule call
	 */
	renderAddModule(hash, chunk, varModuleId, varModule) {
		return this.hooks.addModule.call(
			`modules[${varModuleId}] = ${varModule};`,
			chunk,
			hash,
			varModuleId,
			varModule
		);
	}

	/**
	 *
	 * @param {string} hash string hash
	 * @param {number=} length length
	 * @returns {string} call hook return
	 */
	renderCurrentHashCode(hash, length) {
		length = length || Infinity;
		return this.hooks.currentHash.call(
			JSON.stringify(hash.substr(0, length)),
			length
		);
	}

	/**
	 *
	 * @param {object} options get public path options
	 * @returns {string} hook call
	 */
	getPublicPath(options) {
		return this.hooks.assetPath.call(
			this.outputOptions.publicPath || "",
			options
		);
	}

	getAssetPath(path, options) {
		return this.hooks.assetPath.call(path, options);
	}

	/**
	 * Updates hash with information from this template
	 * @param {Hash} hash the hash to update
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update("maintemplate");
		hash.update("3");
		this.hooks.hash.call(hash);
	}

	/**
	 * TODO webpack 5: remove moduleTemplate and dependencyTemplates
	 * Updates hash with chunk-specific information from this template
	 * @param {Hash} hash the hash to update
	 * @param {Chunk} chunk the chunk
	 * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render
	 * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates
	 * @returns {void}
	 */
	updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {
		this.updateHash(hash);
		this.hooks.hashForChunk.call(hash, chunk);
		for (const line of this.renderBootstrap(
			"0000",
			chunk,
			moduleTemplate,
			dependencyTemplates
		)) {
			hash.update(line);
		}
	}

	useChunkHash(chunk) {
		const paths = this.hooks.globalHashPaths.call([]);
		return !this.hooks.globalHash.call(chunk, paths);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/MemoryOutputFileSystem.js":
/*!***********************************************!*\
  !*** (webpack)/lib/MemoryOutputFileSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = __webpack_require__(/*! memory-fs */ "memory-fs");


/***/ }),

/***/ "./node_modules/webpack/lib/Module.js":
/*!*******************************!*\
  !*** (webpack)/lib/Module.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const util = __webpack_require__(/*! util */ "util");

const DependenciesBlock = __webpack_require__(/*! ./DependenciesBlock */ "./node_modules/webpack/lib/DependenciesBlock.js");
const ModuleReason = __webpack_require__(/*! ./ModuleReason */ "./node_modules/webpack/lib/ModuleReason.js");
const SortableSet = __webpack_require__(/*! ./util/SortableSet */ "./node_modules/webpack/lib/util/SortableSet.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./RequestShortener")} RequestShortener */
/** @typedef {import("./WebpackError")} WebpackError */
/** @typedef {import("./util/createHash").Hash} Hash */

const EMPTY_RESOLVE_OPTIONS = {};

let debugId = 1000;

const sortById = (a, b) => {
	return a.id - b.id;
};

const sortByDebugId = (a, b) => {
	return a.debugId - b.debugId;
};

/** @typedef {(requestShortener: RequestShortener) => string} OptimizationBailoutFunction */

class Module extends DependenciesBlock {
	constructor(type, context = null) {
		super();
		/** @type {string} */
		this.type = type;
		/** @type {string} */
		this.context = context;

		// Unique Id
		/** @type {number} */
		this.debugId = debugId++;

		// Hash
		/** @type {string} */
		this.hash = undefined;
		/** @type {string} */
		this.renderedHash = undefined;

		// Info from Factory
		/** @type {TODO} */
		this.resolveOptions = EMPTY_RESOLVE_OPTIONS;
		/** @type {object} */
		this.factoryMeta = {};

		// Info from Build
		/** @type {WebpackError[]} */
		this.warnings = [];
		/** @type {WebpackError[]} */
		this.errors = [];
		/** @type {object} */
		this.buildMeta = undefined;
		/** @type {object} */
		this.buildInfo = undefined;

		// Graph (per Compilation)
		/** @type {ModuleReason[]} */
		this.reasons = [];
		/** @type {SortableSet<Chunk>} */
		this._chunks = new SortableSet(undefined, sortById);

		// Info from Compilation (per Compilation)
		/** @type {number|string} */
		this.id = null;
		/** @type {number} */
		this.index = null;
		/** @type {number} */
		this.index2 = null;
		/** @type {number} */
		this.depth = null;
		/** @type {Module} */
		this.issuer = null;
		/** @type {undefined | object} */
		this.profile = undefined;
		/** @type {boolean} */
		this.prefetched = false;
		/** @type {boolean} */
		this.built = false;

		// Info from Optimization (per Compilation)
		/** @type {null | boolean} */
		this.used = null;
		/** @type {false | true | string[]} */
		this.usedExports = null;
		/** @type {(string | OptimizationBailoutFunction)[]} */
		this.optimizationBailout = [];

		// delayed operations
		/** @type {undefined | {oldChunk: Chunk, newChunks: Chunk[]}[] } */
		this._rewriteChunkInReasons = undefined;

		/** @type {boolean} */
		this.useSourceMap = false;

		// info from build
		this._source = null;
	}

	get exportsArgument() {
		return (this.buildInfo && this.buildInfo.exportsArgument) || "exports";
	}

	get moduleArgument() {
		return (this.buildInfo && this.buildInfo.moduleArgument) || "module";
	}

	disconnect() {
		this.hash = undefined;
		this.renderedHash = undefined;

		this.reasons.length = 0;
		this._rewriteChunkInReasons = undefined;
		this._chunks.clear();

		this.id = null;
		this.index = null;
		this.index2 = null;
		this.depth = null;
		this.issuer = null;
		this.profile = undefined;
		this.prefetched = false;
		this.built = false;

		this.used = null;
		this.usedExports = null;
		this.optimizationBailout.length = 0;
		super.disconnect();
	}

	unseal() {
		this.id = null;
		this.index = null;
		this.index2 = null;
		this.depth = null;
		this._chunks.clear();
		super.unseal();
	}

	setChunks(chunks) {
		this._chunks = new SortableSet(chunks, sortById);
	}

	addChunk(chunk) {
		if (this._chunks.has(chunk)) return false;
		this._chunks.add(chunk);
		return true;
	}

	removeChunk(chunk) {
		if (this._chunks.delete(chunk)) {
			chunk.removeModule(this);
			return true;
		}
		return false;
	}

	isInChunk(chunk) {
		return this._chunks.has(chunk);
	}

	isEntryModule() {
		for (const chunk of this._chunks) {
			if (chunk.entryModule === this) return true;
		}
		return false;
	}

	get optional() {
		return (
			this.reasons.length > 0 &&
			this.reasons.every(r => r.dependency && r.dependency.optional)
		);
	}

	/**
	 * @returns {Chunk[]} all chunks which contain the module
	 */
	getChunks() {
		return Array.from(this._chunks);
	}

	getNumberOfChunks() {
		return this._chunks.size;
	}

	get chunksIterable() {
		return this._chunks;
	}

	hasEqualsChunks(otherModule) {
		if (this._chunks.size !== otherModule._chunks.size) return false;
		this._chunks.sortWith(sortByDebugId);
		otherModule._chunks.sortWith(sortByDebugId);
		const a = this._chunks[Symbol.iterator]();
		const b = otherModule._chunks[Symbol.iterator]();
		// eslint-disable-next-line no-constant-condition
		while (true) {
			const aItem = a.next();
			const bItem = b.next();
			if (aItem.done) return true;
			if (aItem.value !== bItem.value) return false;
		}
	}

	addReason(module, dependency, explanation) {
		this.reasons.push(new ModuleReason(module, dependency, explanation));
	}

	removeReason(module, dependency) {
		for (let i = 0; i < this.reasons.length; i++) {
			let r = this.reasons[i];
			if (r.module === module && r.dependency === dependency) {
				this.reasons.splice(i, 1);
				return true;
			}
		}
		return false;
	}

	hasReasonForChunk(chunk) {
		if (this._rewriteChunkInReasons) {
			for (const operation of this._rewriteChunkInReasons) {
				this._doRewriteChunkInReasons(operation.oldChunk, operation.newChunks);
			}
			this._rewriteChunkInReasons = undefined;
		}
		for (let i = 0; i < this.reasons.length; i++) {
			if (this.reasons[i].hasChunk(chunk)) return true;
		}
		return false;
	}

	hasReasons() {
		return this.reasons.length > 0;
	}

	rewriteChunkInReasons(oldChunk, newChunks) {
		// This is expensive. Delay operation until we really need the data
		if (this._rewriteChunkInReasons === undefined) {
			this._rewriteChunkInReasons = [];
		}
		this._rewriteChunkInReasons.push({
			oldChunk,
			newChunks
		});
	}

	_doRewriteChunkInReasons(oldChunk, newChunks) {
		for (let i = 0; i < this.reasons.length; i++) {
			this.reasons[i].rewriteChunks(oldChunk, newChunks);
		}
	}

	/**
	 * @param {string=} exportName the name of the export
	 * @returns {boolean|string} false if the export isn't used, true if no exportName is provided and the module is used, or the name to access it if the export is used
	 */
	isUsed(exportName) {
		if (!exportName) return this.used !== false;
		if (this.used === null || this.usedExports === null) return exportName;
		if (!this.used) return false;
		if (!this.usedExports) return false;
		if (this.usedExports === true) return exportName;
		let idx = this.usedExports.indexOf(exportName);
		if (idx < 0) return false;

		// Mangle export name if possible
		if (this.isProvided(exportName)) {
			if (this.buildMeta.exportsType === "namespace") {
				return Template.numberToIdentifer(idx);
			}
			if (
				this.buildMeta.exportsType === "named" &&
				!this.usedExports.includes("default")
			) {
				return Template.numberToIdentifer(idx);
			}
		}
		return exportName;
	}

	isProvided(exportName) {
		if (!Array.isArray(this.buildMeta.providedExports)) return null;
		return this.buildMeta.providedExports.includes(exportName);
	}

	toString() {
		return `Module[${this.id || this.debugId}]`;
	}

	needRebuild(fileTimestamps, contextTimestamps) {
		return true;
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update(`${this.id}`);
		hash.update(JSON.stringify(this.usedExports));
		super.updateHash(hash);
	}

	sortItems(sortChunks) {
		super.sortItems();
		if (sortChunks) this._chunks.sort();
		this.reasons.sort((a, b) => {
			if (a.module === b.module) return 0;
			if (!a.module) return -1;
			if (!b.module) return 1;
			return sortById(a.module, b.module);
		});
		if (Array.isArray(this.usedExports)) {
			this.usedExports.sort();
		}
	}

	unbuild() {
		this.dependencies.length = 0;
		this.blocks.length = 0;
		this.variables.length = 0;
		this.buildMeta = undefined;
		this.buildInfo = undefined;
		this.disconnect();
	}

	get arguments() {
		throw new Error("Module.arguments was removed, there is no replacement.");
	}

	set arguments(value) {
		throw new Error("Module.arguments was removed, there is no replacement.");
	}
}

// TODO remove in webpack 5
Object.defineProperty(Module.prototype, "forEachChunk", {
	configurable: false,
	value: util.deprecate(
		/**
		 * @deprecated
		 * @param {function(any, any, Set<any>): void} fn callback function
		 * @returns {void}
		 * @this {Module}
		 */
		function(fn) {
			this._chunks.forEach(fn);
		},
		"Module.forEachChunk: Use for(const chunk of module.chunksIterable) instead"
	)
});

// TODO remove in webpack 5
Object.defineProperty(Module.prototype, "mapChunks", {
	configurable: false,
	value: util.deprecate(
		/**
		 * @deprecated
		 * @param {function(any, any): void} fn Mapper function
		 * @returns {Array<TODO>} Array of chunks mapped
		 * @this {Module}
		 */
		function(fn) {
			return Array.from(this._chunks, fn);
		},
		"Module.mapChunks: Use Array.from(module.chunksIterable, fn) instead"
	)
});

// TODO remove in webpack 5
Object.defineProperty(Module.prototype, "entry", {
	configurable: false,
	get() {
		throw new Error("Module.entry was removed. Use Chunk.entryModule");
	},
	set() {
		throw new Error("Module.entry was removed. Use Chunk.entryModule");
	}
});

// TODO remove in webpack 5
Object.defineProperty(Module.prototype, "meta", {
	configurable: false,
	get: util.deprecate(
		/**
		 * @deprecated
		 * @returns {void}
		 * @this {Module}
		 */
		function() {
			return this.buildMeta;
		},
		"Module.meta was renamed to Module.buildMeta"
	),
	set: util.deprecate(
		/**
		 * @deprecated
		 * @param {TODO} value Value
		 * @returns {void}
		 * @this {Module}
		 */
		function(value) {
			this.buildMeta = value;
		},
		"Module.meta was renamed to Module.buildMeta"
	)
});

/** @type {function(): string} */
Module.prototype.identifier = null;

/** @type {function(RequestShortener): string} */
Module.prototype.readableIdentifier = null;

Module.prototype.build = null;
Module.prototype.source = null;
Module.prototype.size = null;
Module.prototype.nameForCondition = null;
/** @type {null | function(Chunk): boolean} */
Module.prototype.chunkCondition = null;
Module.prototype.updateCacheModule = null;

module.exports = Module;


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleBuildError.js":
/*!*****************************************!*\
  !*** (webpack)/lib/ModuleBuildError.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const { cutOffLoaderExecution } = __webpack_require__(/*! ./ErrorHelpers */ "./node_modules/webpack/lib/ErrorHelpers.js");

class ModuleBuildError extends WebpackError {
	constructor(module, err, { from = null } = {}) {
		let message = "Module build failed";
		let details = undefined;
		if (from) {
			message += ` (from ${from}):\n`;
		} else {
			message += ": ";
		}
		if (err !== null && typeof err === "object") {
			if (typeof err.stack === "string" && err.stack) {
				const stack = cutOffLoaderExecution(err.stack);
				if (!err.hideStack) {
					message += stack;
				} else {
					details = stack;
					if (typeof err.message === "string" && err.message) {
						message += err.message;
					} else {
						message += err;
					}
				}
			} else if (typeof err.message === "string" && err.message) {
				message += err.message;
			} else {
				message += err;
			}
		} else {
			message = err;
		}

		super(message);

		this.name = "ModuleBuildError";
		this.details = details;
		this.module = module;
		this.error = err;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleBuildError;


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleDependencyError.js":
/*!**********************************************!*\
  !*** (webpack)/lib/ModuleDependencyError.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

/** @typedef {import("./Module")} Module */

class ModuleDependencyError extends WebpackError {
	/**
	 * Creates an instance of ModuleDependencyError.
	 * @param {Module} module module tied to dependency
	 * @param {Error} err error thrown
	 * @param {TODO} loc location of dependency
	 */
	constructor(module, err, loc) {
		super(err.message);

		this.name = "ModuleDependencyError";
		this.details = err.stack
			.split("\n")
			.slice(1)
			.join("\n");
		this.module = module;
		this.loc = loc;
		this.error = err;
		this.origin = module.issuer;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleDependencyError;


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleDependencyWarning.js":
/*!************************************************!*\
  !*** (webpack)/lib/ModuleDependencyWarning.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

module.exports = class ModuleDependencyWarning extends WebpackError {
	constructor(module, err, loc) {
		super(err.message);

		this.name = "ModuleDependencyWarning";
		this.details = err.stack
			.split("\n")
			.slice(1)
			.join("\n");
		this.module = module;
		this.loc = loc;
		this.error = err;
		this.origin = module.issuer;

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleError.js":
/*!************************************!*\
  !*** (webpack)/lib/ModuleError.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const { cleanUp } = __webpack_require__(/*! ./ErrorHelpers */ "./node_modules/webpack/lib/ErrorHelpers.js");

class ModuleError extends WebpackError {
	constructor(module, err, { from = null } = {}) {
		let message = "Module Error";
		if (from) {
			message += ` (from ${from}):\n`;
		} else {
			message += ": ";
		}
		if (err && typeof err === "object" && err.message) {
			message += err.message;
		} else if (err) {
			message += err;
		}
		super(message);
		this.name = "ModuleError";
		this.module = module;
		this.error = err;
		this.details =
			err && typeof err === "object" && err.stack
				? cleanUp(err.stack, this.message)
				: undefined;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleError;


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleFilenameHelpers.js":
/*!**********************************************!*\
  !*** (webpack)/lib/ModuleFilenameHelpers.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const createHash = __webpack_require__(/*! ./util/createHash */ "./node_modules/webpack/lib/util/createHash.js");

const ModuleFilenameHelpers = exports;

ModuleFilenameHelpers.ALL_LOADERS_RESOURCE = "[all-loaders][resource]";
ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE = /\[all-?loaders\]\[resource\]/gi;
ModuleFilenameHelpers.LOADERS_RESOURCE = "[loaders][resource]";
ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE = /\[loaders\]\[resource\]/gi;
ModuleFilenameHelpers.RESOURCE = "[resource]";
ModuleFilenameHelpers.REGEXP_RESOURCE = /\[resource\]/gi;
ModuleFilenameHelpers.ABSOLUTE_RESOURCE_PATH = "[absolute-resource-path]";
ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH = /\[abs(olute)?-?resource-?path\]/gi;
ModuleFilenameHelpers.RESOURCE_PATH = "[resource-path]";
ModuleFilenameHelpers.REGEXP_RESOURCE_PATH = /\[resource-?path\]/gi;
ModuleFilenameHelpers.ALL_LOADERS = "[all-loaders]";
ModuleFilenameHelpers.REGEXP_ALL_LOADERS = /\[all-?loaders\]/gi;
ModuleFilenameHelpers.LOADERS = "[loaders]";
ModuleFilenameHelpers.REGEXP_LOADERS = /\[loaders\]/gi;
ModuleFilenameHelpers.QUERY = "[query]";
ModuleFilenameHelpers.REGEXP_QUERY = /\[query\]/gi;
ModuleFilenameHelpers.ID = "[id]";
ModuleFilenameHelpers.REGEXP_ID = /\[id\]/gi;
ModuleFilenameHelpers.HASH = "[hash]";
ModuleFilenameHelpers.REGEXP_HASH = /\[hash\]/gi;
ModuleFilenameHelpers.NAMESPACE = "[namespace]";
ModuleFilenameHelpers.REGEXP_NAMESPACE = /\[namespace\]/gi;

const getAfter = (str, token) => {
	const idx = str.indexOf(token);
	return idx < 0 ? "" : str.substr(idx);
};

const getBefore = (str, token) => {
	const idx = str.lastIndexOf(token);
	return idx < 0 ? "" : str.substr(0, idx);
};

const getHash = str => {
	const hash = createHash("md4");
	hash.update(str);
	return hash.digest("hex").substr(0, 4);
};

const asRegExp = test => {
	if (typeof test === "string") {
		test = new RegExp("^" + test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"));
	}
	return test;
};

ModuleFilenameHelpers.createFilename = (module, options, requestShortener) => {
	const opts = Object.assign(
		{
			namespace: "",
			moduleFilenameTemplate: ""
		},
		typeof options === "object"
			? options
			: {
					moduleFilenameTemplate: options
			  }
	);

	let absoluteResourcePath;
	let hash;
	let identifier;
	let moduleId;
	let shortIdentifier;
	if (module === undefined) module = "";
	if (typeof module === "string") {
		shortIdentifier = requestShortener.shorten(module);
		identifier = shortIdentifier;
		moduleId = "";
		absoluteResourcePath = module.split("!").pop();
		hash = getHash(identifier);
	} else {
		shortIdentifier = module.readableIdentifier(requestShortener);
		identifier = requestShortener.shorten(module.identifier());
		moduleId = module.id;
		absoluteResourcePath = module
			.identifier()
			.split("!")
			.pop();
		hash = getHash(identifier);
	}
	const resource = shortIdentifier.split("!").pop();
	const loaders = getBefore(shortIdentifier, "!");
	const allLoaders = getBefore(identifier, "!");
	const query = getAfter(resource, "?");
	const resourcePath = resource.substr(0, resource.length - query.length);
	if (typeof opts.moduleFilenameTemplate === "function") {
		return opts.moduleFilenameTemplate({
			identifier: identifier,
			shortIdentifier: shortIdentifier,
			resource: resource,
			resourcePath: resourcePath,
			absoluteResourcePath: absoluteResourcePath,
			allLoaders: allLoaders,
			query: query,
			moduleId: moduleId,
			hash: hash,
			namespace: opts.namespace
		});
	}
	return opts.moduleFilenameTemplate
		.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, identifier)
		.replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, shortIdentifier)
		.replace(ModuleFilenameHelpers.REGEXP_RESOURCE, resource)
		.replace(ModuleFilenameHelpers.REGEXP_RESOURCE_PATH, resourcePath)
		.replace(
			ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH,
			absoluteResourcePath
		)
		.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS, allLoaders)
		.replace(ModuleFilenameHelpers.REGEXP_LOADERS, loaders)
		.replace(ModuleFilenameHelpers.REGEXP_QUERY, query)
		.replace(ModuleFilenameHelpers.REGEXP_ID, moduleId)
		.replace(ModuleFilenameHelpers.REGEXP_HASH, hash)
		.replace(ModuleFilenameHelpers.REGEXP_NAMESPACE, opts.namespace);
};

ModuleFilenameHelpers.replaceDuplicates = (array, fn, comparator) => {
	const countMap = Object.create(null);
	const posMap = Object.create(null);
	array.forEach((item, idx) => {
		countMap[item] = countMap[item] || [];
		countMap[item].push(idx);
		posMap[item] = 0;
	});
	if (comparator) {
		Object.keys(countMap).forEach(item => {
			countMap[item].sort(comparator);
		});
	}
	return array.map((item, i) => {
		if (countMap[item].length > 1) {
			if (comparator && countMap[item][0] === i) return item;
			return fn(item, i, posMap[item]++);
		} else {
			return item;
		}
	});
};

ModuleFilenameHelpers.matchPart = (str, test) => {
	if (!test) return true;
	test = asRegExp(test);
	if (Array.isArray(test)) {
		return test.map(asRegExp).some(regExp => regExp.test(str));
	} else {
		return test.test(str);
	}
};

ModuleFilenameHelpers.matchObject = (obj, str) => {
	if (obj.test) {
		if (!ModuleFilenameHelpers.matchPart(str, obj.test)) {
			return false;
		}
	}
	if (obj.include) {
		if (!ModuleFilenameHelpers.matchPart(str, obj.include)) {
			return false;
		}
	}
	if (obj.exclude) {
		if (ModuleFilenameHelpers.matchPart(str, obj.exclude)) {
			return false;
		}
	}
	return true;
};


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleNotFoundError.js":
/*!********************************************!*\
  !*** (webpack)/lib/ModuleNotFoundError.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

class ModuleNotFoundError extends WebpackError {
	constructor(module, err) {
		super("Module not found: " + err);

		this.name = "ModuleNotFoundError";
		this.details = err.details;
		this.missing = err.missing;
		this.module = module;
		this.error = err;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleNotFoundError;


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleParseError.js":
/*!*****************************************!*\
  !*** (webpack)/lib/ModuleParseError.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

/** @typedef {import("./Module")} Module */

class ModuleParseError extends WebpackError {
	/**
	 * @param {Module} module the errored module
	 * @param {string} source source code
	 * @param {Error&any} err the parse error
	 */
	constructor(module, source, err) {
		let message = "Module parse failed: " + err.message;
		let loc = undefined;
		message += "\nYou may need an appropriate loader to handle this file type.";
		if (
			err.loc &&
			typeof err.loc === "object" &&
			typeof err.loc.line === "number"
		) {
			var lineNumber = err.loc.line;
			if (/[\0\u0001\u0002\u0003\u0004\u0005\u0006\u0007]/.test(source)) {
				// binary file
				message += "\n(Source code omitted for this binary file)";
			} else {
				const sourceLines = source.split("\n");
				const start = Math.max(0, lineNumber - 3);
				const linesBefore = sourceLines.slice(start, lineNumber - 1);
				const theLine = sourceLines[lineNumber - 1];
				const linesAfter = sourceLines.slice(lineNumber, lineNumber + 2);
				message +=
					linesBefore.map(l => `\n| ${l}`).join("") +
					`\n> ${theLine}` +
					linesAfter.map(l => `\n| ${l}`).join("");
			}
			loc = err.loc;
		} else {
			message += "\n" + err.stack;
		}

		super(message);

		this.name = "ModuleParseError";
		this.module = module;
		this.loc = loc;
		this.error = err;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleParseError;


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleReason.js":
/*!*************************************!*\
  !*** (webpack)/lib/ModuleReason.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


/** @typedef {import("./Module")} Module */
/** @typedef {import("./Dependency")} Dependency */

class ModuleReason {
	/**
	 * @param {Module} module the referencing module
	 * @param {Dependency} dependency the referencing dependency
	 * @param {string=} explanation some extra detail
	 */
	constructor(module, dependency, explanation) {
		this.module = module;
		this.dependency = dependency;
		this.explanation = explanation;
		this._chunks = null;
	}

	hasChunk(chunk) {
		if (this._chunks) {
			if (this._chunks.has(chunk)) return true;
		} else if (this.module && this.module._chunks.has(chunk)) return true;
		return false;
	}

	rewriteChunks(oldChunk, newChunks) {
		if (!this._chunks) {
			if (this.module) {
				if (!this.module._chunks.has(oldChunk)) return;
				this._chunks = new Set(this.module._chunks);
			} else {
				this._chunks = new Set();
			}
		}
		if (this._chunks.has(oldChunk)) {
			this._chunks.delete(oldChunk);
			for (let i = 0; i < newChunks.length; i++) {
				this._chunks.add(newChunks[i]);
			}
		}
	}
}

module.exports = ModuleReason;


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleTemplate.js":
/*!***************************************!*\
  !*** (webpack)/lib/ModuleTemplate.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { Tapable, SyncWaterfallHook, SyncHook } = __webpack_require__(/*! tapable */ "tapable");

/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./Module")} Module */

module.exports = class ModuleTemplate extends Tapable {
	constructor(runtimeTemplate, type) {
		super();
		this.runtimeTemplate = runtimeTemplate;
		this.type = type;
		this.hooks = {
			content: new SyncWaterfallHook([
				"source",
				"module",
				"options",
				"dependencyTemplates"
			]),
			module: new SyncWaterfallHook([
				"source",
				"module",
				"options",
				"dependencyTemplates"
			]),
			render: new SyncWaterfallHook([
				"source",
				"module",
				"options",
				"dependencyTemplates"
			]),
			package: new SyncWaterfallHook([
				"source",
				"module",
				"options",
				"dependencyTemplates"
			]),
			hash: new SyncHook(["hash"])
		};
	}

	/**
	 * @param {Module} module the module
	 * @param {TODO} dependencyTemplates templates for dependencies
	 * @param {TODO} options render options
	 * @returns {Source} the source
	 */
	render(module, dependencyTemplates, options) {
		try {
			const moduleSource = module.source(
				dependencyTemplates,
				this.runtimeTemplate,
				this.type
			);
			const moduleSourcePostContent = this.hooks.content.call(
				moduleSource,
				module,
				options,
				dependencyTemplates
			);
			const moduleSourcePostModule = this.hooks.module.call(
				moduleSourcePostContent,
				module,
				options,
				dependencyTemplates
			);
			const moduleSourcePostRender = this.hooks.render.call(
				moduleSourcePostModule,
				module,
				options,
				dependencyTemplates
			);
			return this.hooks.package.call(
				moduleSourcePostRender,
				module,
				options,
				dependencyTemplates
			);
		} catch (e) {
			e.message = `${module.identifier()}\n${e.message}`;
			throw e;
		}
	}

	updateHash(hash) {
		hash.update("1");
		this.hooks.hash.call(hash);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/ModuleWarning.js":
/*!**************************************!*\
  !*** (webpack)/lib/ModuleWarning.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const { cleanUp } = __webpack_require__(/*! ./ErrorHelpers */ "./node_modules/webpack/lib/ErrorHelpers.js");

class ModuleWarning extends WebpackError {
	constructor(module, warning, { from = null } = {}) {
		let message = "Module Warning";
		if (from) {
			message += ` (from ${from}):\n`;
		} else {
			message += ": ";
		}
		if (warning && typeof warning === "object" && warning.message) {
			message += warning.message;
		} else if (warning) {
			message += warning;
		}
		super(message);
		this.name = "ModuleWarning";
		this.module = module;
		this.warning = warning;
		this.details =
			warning && typeof warning === "object" && warning.stack
				? cleanUp(warning.stack, this.message)
				: undefined;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleWarning;


/***/ }),

/***/ "./node_modules/webpack/lib/MultiCompiler.js":
/*!**************************************!*\
  !*** (webpack)/lib/MultiCompiler.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { Tapable, SyncHook, MultiHook } = __webpack_require__(/*! tapable */ "tapable");
const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");
const MultiWatching = __webpack_require__(/*! ./MultiWatching */ "./node_modules/webpack/lib/MultiWatching.js");
const MultiStats = __webpack_require__(/*! ./MultiStats */ "./node_modules/webpack/lib/MultiStats.js");
const ConcurrentCompilationError = __webpack_require__(/*! ./ConcurrentCompilationError */ "./node_modules/webpack/lib/ConcurrentCompilationError.js");

module.exports = class MultiCompiler extends Tapable {
	constructor(compilers) {
		super();
		this.hooks = {
			done: new SyncHook(["stats"]),
			invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),
			run: new MultiHook(compilers.map(c => c.hooks.run)),
			watchClose: new SyncHook([]),
			watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun))
		};
		if (!Array.isArray(compilers)) {
			compilers = Object.keys(compilers).map(name => {
				compilers[name].name = name;
				return compilers[name];
			});
		}
		this.compilers = compilers;
		let doneCompilers = 0;
		let compilerStats = [];
		let index = 0;
		for (const compiler of this.compilers) {
			let compilerDone = false;
			const compilerIndex = index++;
			// eslint-disable-next-line no-loop-func
			compiler.hooks.done.tap("MultiCompiler", stats => {
				if (!compilerDone) {
					compilerDone = true;
					doneCompilers++;
				}
				compilerStats[compilerIndex] = stats;
				if (doneCompilers === this.compilers.length) {
					this.hooks.done.call(new MultiStats(compilerStats));
				}
			});
			// eslint-disable-next-line no-loop-func
			compiler.hooks.invalid.tap("MultiCompiler", () => {
				if (compilerDone) {
					compilerDone = false;
					doneCompilers--;
				}
			});
		}
		this.running = false;
	}

	get outputPath() {
		let commonPath = this.compilers[0].outputPath;
		for (const compiler of this.compilers) {
			while (
				compiler.outputPath.indexOf(commonPath) !== 0 &&
				/[/\\]/.test(commonPath)
			) {
				commonPath = commonPath.replace(/[/\\][^/\\]*$/, "");
			}
		}

		if (!commonPath && this.compilers[0].outputPath[0] === "/") return "/";
		return commonPath;
	}

	get inputFileSystem() {
		throw new Error("Cannot read inputFileSystem of a MultiCompiler");
	}

	get outputFileSystem() {
		throw new Error("Cannot read outputFileSystem of a MultiCompiler");
	}

	set inputFileSystem(value) {
		for (const compiler of this.compilers) {
			compiler.inputFileSystem = value;
		}
	}

	set outputFileSystem(value) {
		for (const compiler of this.compilers) {
			compiler.outputFileSystem = value;
		}
	}

	validateDependencies(callback) {
		const edges = new Set();
		const missing = [];
		const targetFound = compiler => {
			for (const edge of edges) {
				if (edge.target === compiler) {
					return true;
				}
			}
			return false;
		};
		const sortEdges = (e1, e2) => {
			return (
				e1.source.name.localeCompare(e2.source.name) ||
				e1.target.name.localeCompare(e2.target.name)
			);
		};
		for (const source of this.compilers) {
			if (source.dependencies) {
				for (const dep of source.dependencies) {
					const target = this.compilers.find(c => c.name === dep);
					if (!target) {
						missing.push(dep);
					} else {
						edges.add({
							source,
							target
						});
					}
				}
			}
		}
		const errors = missing.map(m => `Compiler dependency \`${m}\` not found.`);
		const stack = this.compilers.filter(c => !targetFound(c));
		while (stack.length > 0) {
			const current = stack.pop();
			for (const edge of edges) {
				if (edge.source === current) {
					edges.delete(edge);
					const target = edge.target;
					if (!targetFound(target)) {
						stack.push(target);
					}
				}
			}
		}
		if (edges.size > 0) {
			const lines = Array.from(edges)
				.sort(sortEdges)
				.map(edge => `${edge.source.name} -> ${edge.target.name}`);
			lines.unshift("Circular dependency found in compiler dependencies.");
			errors.unshift(lines.join("\n"));
		}
		if (errors.length > 0) {
			const message = errors.join("\n");
			callback(new Error(message));
			return false;
		}
		return true;
	}

	runWithDependencies(compilers, fn, callback) {
		const fulfilledNames = new Set();
		let remainingCompilers = compilers;
		const isDependencyFulfilled = d => fulfilledNames.has(d);
		const getReadyCompilers = () => {
			let readyCompilers = [];
			let list = remainingCompilers;
			remainingCompilers = [];
			for (const c of list) {
				const ready =
					!c.dependencies || c.dependencies.every(isDependencyFulfilled);
				if (ready) {
					readyCompilers.push(c);
				} else {
					remainingCompilers.push(c);
				}
			}
			return readyCompilers;
		};
		const runCompilers = callback => {
			if (remainingCompilers.length === 0) return callback();
			asyncLib.map(
				getReadyCompilers(),
				(compiler, callback) => {
					fn(compiler, err => {
						if (err) return callback(err);
						fulfilledNames.add(compiler.name);
						runCompilers(callback);
					});
				},
				callback
			);
		};
		runCompilers(callback);
	}

	watch(watchOptions, handler) {
		if (this.running) return handler(new ConcurrentCompilationError());

		let watchings = [];
		let allStats = this.compilers.map(() => null);
		let compilerStatus = this.compilers.map(() => false);
		if (this.validateDependencies(handler)) {
			this.running = true;
			this.runWithDependencies(
				this.compilers,
				(compiler, callback) => {
					const compilerIdx = this.compilers.indexOf(compiler);
					let firstRun = true;
					let watching = compiler.watch(
						Array.isArray(watchOptions)
							? watchOptions[compilerIdx]
							: watchOptions,
						(err, stats) => {
							if (err) handler(err);
							if (stats) {
								allStats[compilerIdx] = stats;
								compilerStatus[compilerIdx] = "new";
								if (compilerStatus.every(Boolean)) {
									const freshStats = allStats.filter((s, idx) => {
										return compilerStatus[idx] === "new";
									});
									compilerStatus.fill(true);
									const multiStats = new MultiStats(freshStats);
									handler(null, multiStats);
								}
							}
							if (firstRun && !err) {
								firstRun = false;
								callback();
							}
						}
					);
					watchings.push(watching);
				},
				() => {
					// ignore
				}
			);
		}

		return new MultiWatching(watchings, this);
	}

	run(callback) {
		if (this.running) {
			return callback(new ConcurrentCompilationError());
		}

		const finalCallback = (err, stats) => {
			this.running = false;

			if (callback !== undefined) {
				return callback(err, stats);
			}
		};

		const allStats = this.compilers.map(() => null);
		if (this.validateDependencies(callback)) {
			this.running = true;
			this.runWithDependencies(
				this.compilers,
				(compiler, callback) => {
					const compilerIdx = this.compilers.indexOf(compiler);
					compiler.run((err, stats) => {
						if (err) {
							return callback(err);
						}
						allStats[compilerIdx] = stats;
						callback();
					});
				},
				err => {
					if (err) {
						return finalCallback(err);
					}
					finalCallback(null, new MultiStats(allStats));
				}
			);
		}
	}

	purgeInputFileSystem() {
		for (const compiler of this.compilers) {
			if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {
				compiler.inputFileSystem.purge();
			}
		}
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/MultiEntryPlugin.js":
/*!*****************************************!*\
  !*** (webpack)/lib/MultiEntryPlugin.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const MultiEntryDependency = __webpack_require__(/*! ./dependencies/MultiEntryDependency */ "./node_modules/webpack/lib/dependencies/MultiEntryDependency.js");
const SingleEntryDependency = __webpack_require__(/*! ./dependencies/SingleEntryDependency */ "./node_modules/webpack/lib/dependencies/SingleEntryDependency.js");
const MultiModuleFactory = __webpack_require__(/*! ./MultiModuleFactory */ "./node_modules/webpack/lib/MultiModuleFactory.js");

/** @typedef {import("./Compiler")} Compiler */

class MultiEntryPlugin {
	/**
	 * The MultiEntryPlugin is invoked whenever this.options.entry value is an array of paths
	 * @param {string} context context path
	 * @param {string[]} entries array of entry paths
	 * @param {string} name entry key name
	 */
	constructor(context, entries, name) {
		this.context = context;
		this.entries = entries;
		this.name = name;
	}

	/**
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"MultiEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				const multiModuleFactory = new MultiModuleFactory();

				compilation.dependencyFactories.set(
					MultiEntryDependency,
					multiModuleFactory
				);
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.make.tapAsync(
			"MultiEntryPlugin",
			(compilation, callback) => {
				const { context, entries, name } = this;

				const dep = MultiEntryPlugin.createDependency(entries, name);
				compilation.addEntry(context, dep, name, callback);
			}
		);
	}

	/**
	 * @param {string[]} entries each entry path string
	 * @param {string} name name of the entry
	 * @returns {MultiEntryDependency} returns a constructed Dependency
	 */
	static createDependency(entries, name) {
		return new MultiEntryDependency(
			entries.map((e, idx) => {
				const dep = new SingleEntryDependency(e);
				// Because entrypoints are not dependencies found in an
				// existing module, we give it a synthetic id
				dep.loc = {
					name,
					index: idx
				};
				return dep;
			}),
			name
		);
	}
}

module.exports = MultiEntryPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/MultiModule.js":
/*!************************************!*\
  !*** (webpack)/lib/MultiModule.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Module = __webpack_require__(/*! ./Module */ "./node_modules/webpack/lib/Module.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");
const { RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

/** @typedef {import("./util/createHash").Hash} Hash */

class MultiModule extends Module {
	constructor(context, dependencies, name) {
		super("javascript/dynamic", context);

		// Info from Factory
		this.dependencies = dependencies;
		this.name = name;
		this._identifier = `multi ${this.dependencies
			.map(d => d.request)
			.join(" ")}`;
	}

	identifier() {
		return this._identifier;
	}

	readableIdentifier(requestShortener) {
		return `multi ${this.dependencies
			.map(d => requestShortener.shorten(d.request))
			.join(" ")}`;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {};
		return callback();
	}

	needRebuild() {
		return false;
	}

	size() {
		return 16 + this.dependencies.length * 12;
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update("multi module");
		hash.update(this.name || "");
		super.updateHash(hash);
	}

	source(dependencyTemplates, runtimeTemplate) {
		const str = [];
		let idx = 0;
		for (const dep of this.dependencies) {
			if (dep.module) {
				if (idx === this.dependencies.length - 1) {
					str.push("module.exports = ");
				}
				str.push("__webpack_require__(");
				if (runtimeTemplate.outputOptions.pathinfo) {
					str.push(Template.toComment(dep.request));
				}
				str.push(`${JSON.stringify(dep.module.id)}`);
				str.push(")");
			} else {
				const content = __webpack_require__(/*! ./dependencies/WebpackMissingModule */ "./node_modules/webpack/lib/dependencies/WebpackMissingModule.js").module(
					dep.request
				);
				str.push(content);
			}
			str.push(";\n");
			idx++;
		}
		return new RawSource(str.join(""));
	}
}

module.exports = MultiModule;


/***/ }),

/***/ "./node_modules/webpack/lib/MultiModuleFactory.js":
/*!*******************************************!*\
  !*** (webpack)/lib/MultiModuleFactory.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { Tapable } = __webpack_require__(/*! tapable */ "tapable");
const MultiModule = __webpack_require__(/*! ./MultiModule */ "./node_modules/webpack/lib/MultiModule.js");

module.exports = class MultiModuleFactory extends Tapable {
	constructor() {
		super();
		this.hooks = {};
	}

	create(data, callback) {
		const dependency = data.dependencies[0];
		callback(
			null,
			new MultiModule(data.context, dependency.dependencies, dependency.name)
		);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/MultiStats.js":
/*!***********************************!*\
  !*** (webpack)/lib/MultiStats.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Stats = __webpack_require__(/*! ./Stats */ "./node_modules/webpack/lib/Stats.js");

const optionOrFallback = (optionValue, fallbackValue) =>
	optionValue !== undefined ? optionValue : fallbackValue;

class MultiStats {
	constructor(stats) {
		this.stats = stats;
		this.hash = stats.map(stat => stat.hash).join("");
	}

	hasErrors() {
		return this.stats
			.map(stat => stat.hasErrors())
			.reduce((a, b) => a || b, false);
	}

	hasWarnings() {
		return this.stats
			.map(stat => stat.hasWarnings())
			.reduce((a, b) => a || b, false);
	}

	toJson(options, forToString) {
		if (typeof options === "boolean" || typeof options === "string") {
			options = Stats.presetToOptions(options);
		} else if (!options) {
			options = {};
		}
		const jsons = this.stats.map((stat, idx) => {
			const childOptions = Stats.getChildOptions(options, idx);
			const obj = stat.toJson(childOptions, forToString);
			obj.name = stat.compilation && stat.compilation.name;
			return obj;
		});
		const showVersion =
			options.version === undefined
				? jsons.every(j => j.version)
				: options.version !== false;
		const showHash =
			options.hash === undefined
				? jsons.every(j => j.hash)
				: options.hash !== false;
		if (showVersion) {
			for (const j of jsons) {
				delete j.version;
			}
		}
		const obj = {
			errors: jsons.reduce((arr, j) => {
				return arr.concat(
					j.errors.map(msg => {
						return `(${j.name}) ${msg}`;
					})
				);
			}, []),
			warnings: jsons.reduce((arr, j) => {
				return arr.concat(
					j.warnings.map(msg => {
						return `(${j.name}) ${msg}`;
					})
				);
			}, [])
		};
		if (showVersion) obj.version = __webpack_require__(/*! ../package.json */ "./node_modules/webpack/package.json").version;
		if (showHash) obj.hash = this.hash;
		if (options.children !== false) obj.children = jsons;
		return obj;
	}

	toString(options) {
		if (typeof options === "boolean" || typeof options === "string") {
			options = Stats.presetToOptions(options);
		} else if (!options) {
			options = {};
		}

		const useColors = optionOrFallback(options.colors, false);

		const obj = this.toJson(options, true);

		return Stats.jsonToString(obj, useColors);
	}
}

module.exports = MultiStats;


/***/ }),

/***/ "./node_modules/webpack/lib/MultiWatching.js":
/*!**************************************!*\
  !*** (webpack)/lib/MultiWatching.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");

class MultiWatching {
	constructor(watchings, compiler) {
		this.watchings = watchings;
		this.compiler = compiler;
	}

	invalidate() {
		for (const watching of this.watchings) {
			watching.invalidate();
		}
	}

	close(callback) {
		asyncLib.forEach(
			this.watchings,
			(watching, finishedCallback) => {
				watching.close(finishedCallback);
			},
			err => {
				this.compiler.hooks.watchClose.call();
				if (typeof callback === "function") {
					this.compiler.running = false;
					callback(err);
				}
			}
		);
	}
}

module.exports = MultiWatching;


/***/ }),

/***/ "./node_modules/webpack/lib/NamedChunksPlugin.js":
/*!******************************************!*\
  !*** (webpack)/lib/NamedChunksPlugin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class NamedChunksPlugin {
	static defaultNameResolver(chunk) {
		return chunk.name || null;
	}

	constructor(nameResolver) {
		this.nameResolver = nameResolver || NamedChunksPlugin.defaultNameResolver;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap("NamedChunksPlugin", compilation => {
			compilation.hooks.beforeChunkIds.tap("NamedChunksPlugin", chunks => {
				for (const chunk of chunks) {
					if (chunk.id === null) {
						chunk.id = this.nameResolver(chunk);
					}
				}
			});
		});
	}
}

module.exports = NamedChunksPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/NamedModulesPlugin.js":
/*!*******************************************!*\
  !*** (webpack)/lib/NamedModulesPlugin.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const createHash = __webpack_require__(/*! ./util/createHash */ "./node_modules/webpack/lib/util/createHash.js");
const RequestShortener = __webpack_require__(/*! ./RequestShortener */ "./node_modules/webpack/lib/RequestShortener.js");

const getHash = str => {
	const hash = createHash("md4");
	hash.update(str);
	return hash.digest("hex").substr(0, 4);
};

class NamedModulesPlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.hooks.compilation.tap("NamedModulesPlugin", compilation => {
			compilation.hooks.beforeModuleIds.tap("NamedModulesPlugin", modules => {
				const namedModules = new Map();
				const context = this.options.context || compiler.options.context;

				for (const module of modules) {
					if (module.id === null && module.libIdent) {
						module.id = module.libIdent({ context });
					}

					if (module.id !== null) {
						const namedModule = namedModules.get(module.id);
						if (namedModule !== undefined) {
							namedModule.push(module);
						} else {
							namedModules.set(module.id, [module]);
						}
					}
				}

				for (const namedModule of namedModules.values()) {
					if (namedModule.length > 1) {
						for (const module of namedModule) {
							const requestShortener = new RequestShortener(context);
							module.id = `${module.id}?${getHash(
								requestShortener.shorten(module.identifier())
							)}`;
						}
					}
				}
			});
		});
	}
}

module.exports = NamedModulesPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/NoEmitOnErrorsPlugin.js":
/*!*********************************************!*\
  !*** (webpack)/lib/NoEmitOnErrorsPlugin.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class NoEmitOnErrorsPlugin {
	apply(compiler) {
		compiler.hooks.shouldEmit.tap("NoEmitOnErrorsPlugin", compilation => {
			if (compilation.getStats().hasErrors()) return false;
		});
		compiler.hooks.compilation.tap("NoEmitOnErrorsPlugin", compilation => {
			compilation.hooks.shouldRecord.tap("NoEmitOnErrorsPlugin", () => {
				if (compilation.getStats().hasErrors()) return false;
			});
		});
	}
}

module.exports = NoEmitOnErrorsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/NoModeWarning.js":
/*!**************************************!*\
  !*** (webpack)/lib/NoModeWarning.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

module.exports = class NoModeWarning extends WebpackError {
	constructor(modules) {
		super();

		this.name = "NoModeWarning";
		this.message =
			"configuration\n" +
			"The 'mode' option has not been set, webpack will fallback to 'production' for this value. " +
			"Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\n" +
			"You can also set it to 'none' to disable any default behavior. " +
			"Learn more: https://webpack.js.org/concepts/mode/";

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/NodeStuffPlugin.js":
/*!****************************************!*\
  !*** (webpack)/lib/NodeStuffPlugin.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const path = __webpack_require__(/*! path */ "path");
const ParserHelpers = __webpack_require__(/*! ./ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");
const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");

const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

class NodeStuffPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"NodeStuffPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.node === false) return;

					let localOptions = options;
					if (parserOptions.node) {
						localOptions = Object.assign({}, localOptions, parserOptions.node);
					}

					const setConstant = (expressionName, value) => {
						parser.hooks.expression
							.for(expressionName)
							.tap("NodeStuffPlugin", () => {
								parser.state.current.addVariable(
									expressionName,
									JSON.stringify(value)
								);
								return true;
							});
					};

					const setModuleConstant = (expressionName, fn) => {
						parser.hooks.expression
							.for(expressionName)
							.tap("NodeStuffPlugin", () => {
								parser.state.current.addVariable(
									expressionName,
									JSON.stringify(fn(parser.state.module))
								);
								return true;
							});
					};
					const context = compiler.context;
					if (localOptions.__filename === "mock") {
						setConstant("__filename", "/index.js");
					} else if (localOptions.__filename) {
						setModuleConstant("__filename", module =>
							path.relative(context, module.resource)
						);
					}
					parser.hooks.evaluateIdentifier
						.for("__filename")
						.tap("NodeStuffPlugin", expr => {
							if (!parser.state.module) return;
							const resource = parser.state.module.resource;
							const i = resource.indexOf("?");
							return ParserHelpers.evaluateToString(
								i < 0 ? resource : resource.substr(0, i)
							)(expr);
						});
					if (localOptions.__dirname === "mock") {
						setConstant("__dirname", "/");
					} else if (localOptions.__dirname) {
						setModuleConstant("__dirname", module =>
							path.relative(context, module.context)
						);
					}
					parser.hooks.evaluateIdentifier
						.for("__dirname")
						.tap("NodeStuffPlugin", expr => {
							if (!parser.state.module) return;
							return ParserHelpers.evaluateToString(
								parser.state.module.context
							)(expr);
						});
					parser.hooks.expression
						.for("require.main")
						.tap(
							"NodeStuffPlugin",
							ParserHelpers.toConstantDependencyWithWebpackRequire(
								parser,
								"__webpack_require__.c[__webpack_require__.s]"
							)
						);
					parser.hooks.expression
						.for("require.extensions")
						.tap(
							"NodeStuffPlugin",
							ParserHelpers.expressionIsUnsupported(
								parser,
								"require.extensions is not supported by webpack. Use a loader instead."
							)
						);
					parser.hooks.expression
						.for("require.main.require")
						.tap(
							"NodeStuffPlugin",
							ParserHelpers.expressionIsUnsupported(
								parser,
								"require.main.require is not supported by webpack."
							)
						);
					parser.hooks.expression
						.for("module.parent.require")
						.tap(
							"NodeStuffPlugin",
							ParserHelpers.expressionIsUnsupported(
								parser,
								"module.parent.require is not supported by webpack."
							)
						);
					parser.hooks.expression
						.for("module.loaded")
						.tap("NodeStuffPlugin", expr => {
							parser.state.module.buildMeta.moduleConcatenationBailout =
								"module.loaded";
							return ParserHelpers.toConstantDependency(parser, "module.l")(
								expr
							);
						});
					parser.hooks.expression
						.for("module.id")
						.tap("NodeStuffPlugin", expr => {
							parser.state.module.buildMeta.moduleConcatenationBailout =
								"module.id";
							return ParserHelpers.toConstantDependency(parser, "module.i")(
								expr
							);
						});
					parser.hooks.expression
						.for("module.exports")
						.tap("NodeStuffPlugin", () => {
							const module = parser.state.module;
							const isHarmony =
								module.buildMeta && module.buildMeta.exportsType;
							if (!isHarmony) return true;
						});
					parser.hooks.evaluateIdentifier
						.for("module.hot")
						.tap(
							"NodeStuffPlugin",
							ParserHelpers.evaluateToIdentifier("module.hot", false)
						);
					parser.hooks.expression.for("module").tap("NodeStuffPlugin", () => {
						const module = parser.state.module;
						const isHarmony = module.buildMeta && module.buildMeta.exportsType;
						let moduleJsPath = path.join(
							__dirname,
							"..",
							"buildin",
							isHarmony ? "harmony-module.js" : "module.js"
						);
						if (module.context) {
							moduleJsPath = path.relative(
								parser.state.module.context,
								moduleJsPath
							);
							if (!/^[A-Z]:/i.test(moduleJsPath)) {
								moduleJsPath = `./${moduleJsPath.replace(/\\/g, "/")}`;
							}
						}
						return ParserHelpers.addParsedVariableToModule(
							parser,
							"module",
							`require(${JSON.stringify(moduleJsPath)})(module)`
						);
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("NodeStuffPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("NodeStuffPlugin", handler);
			}
		);
	}
}
module.exports = NodeStuffPlugin;

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/webpack/lib/NormalModule.js":
/*!*************************************!*\
  !*** (webpack)/lib/NormalModule.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const NativeModule = __webpack_require__(/*! module */ "module");

const {
	CachedSource,
	LineToLineMappedSource,
	OriginalSource,
	RawSource,
	SourceMapSource
} = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const { getContext, runLoaders } = __webpack_require__(/*! loader-runner */ "loader-runner");

const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const Module = __webpack_require__(/*! ./Module */ "./node_modules/webpack/lib/Module.js");
const ModuleParseError = __webpack_require__(/*! ./ModuleParseError */ "./node_modules/webpack/lib/ModuleParseError.js");
const ModuleBuildError = __webpack_require__(/*! ./ModuleBuildError */ "./node_modules/webpack/lib/ModuleBuildError.js");
const ModuleError = __webpack_require__(/*! ./ModuleError */ "./node_modules/webpack/lib/ModuleError.js");
const ModuleWarning = __webpack_require__(/*! ./ModuleWarning */ "./node_modules/webpack/lib/ModuleWarning.js");
const createHash = __webpack_require__(/*! ./util/createHash */ "./node_modules/webpack/lib/util/createHash.js");
const contextify = __webpack_require__(/*! ./util/identifier */ "./node_modules/webpack/lib/util/identifier.js").contextify;

/** @typedef {import("./util/createHash").Hash} Hash */

const asString = buf => {
	if (Buffer.isBuffer(buf)) {
		return buf.toString("utf-8");
	}
	return buf;
};

const asBuffer = str => {
	if (!Buffer.isBuffer(str)) {
		return Buffer.from(str, "utf-8");
	}
	return str;
};

class NonErrorEmittedError extends WebpackError {
	constructor(error) {
		super();

		this.name = "NonErrorEmittedError";
		this.message = "(Emitted value instead of an instance of Error) " + error;

		Error.captureStackTrace(this, this.constructor);
	}
}

/**
 * @typedef {Object} CachedSourceEntry
 * @property {TODO} source the generated source
 * @property {string} hash the hash value
 */

class NormalModule extends Module {
	constructor({
		type,
		request,
		userRequest,
		rawRequest,
		loaders,
		resource,
		matchResource,
		parser,
		generator,
		resolveOptions
	}) {
		super(type, getContext(resource));

		// Info from Factory
		this.request = request;
		this.userRequest = userRequest;
		this.rawRequest = rawRequest;
		this.binary = type.startsWith("webassembly");
		this.parser = parser;
		this.generator = generator;
		this.resource = resource;
		this.matchResource = matchResource;
		this.loaders = loaders;
		if (resolveOptions !== undefined) this.resolveOptions = resolveOptions;

		// Info from Build
		this.error = null;
		this._source = null;
		this._buildHash = "";
		this.buildTimestamp = undefined;
		/** @private @type {Map<string, CachedSourceEntry>} */
		this._cachedSources = new Map();

		// Options for the NormalModule set by plugins
		// TODO refactor this -> options object filled from Factory
		this.useSourceMap = false;
		this.lineToLine = false;

		// Cache
		this._lastSuccessfulBuildMeta = {};
	}

	identifier() {
		return this.request;
	}

	readableIdentifier(requestShortener) {
		return requestShortener.shorten(this.userRequest);
	}

	libIdent(options) {
		return contextify(options.context, this.userRequest);
	}

	nameForCondition() {
		const resource = this.matchResource || this.resource;
		const idx = resource.indexOf("?");
		if (idx >= 0) return resource.substr(0, idx);
		return resource;
	}

	updateCacheModule(module) {
		this.type = module.type;
		this.request = module.request;
		this.userRequest = module.userRequest;
		this.rawRequest = module.rawRequest;
		this.parser = module.parser;
		this.generator = module.generator;
		this.resource = module.resource;
		this.matchResource = module.matchResource;
		this.loaders = module.loaders;
		this.resolveOptions = module.resolveOptions;
	}

	createSourceForAsset(name, content, sourceMap) {
		if (!sourceMap) {
			return new RawSource(content);
		}

		if (typeof sourceMap === "string") {
			return new OriginalSource(content, sourceMap);
		}

		return new SourceMapSource(content, name, sourceMap);
	}

	createLoaderContext(resolver, options, compilation, fs) {
		const requestShortener = compilation.runtimeTemplate.requestShortener;
		const loaderContext = {
			version: 2,
			emitWarning: warning => {
				if (!(warning instanceof Error)) {
					warning = new NonErrorEmittedError(warning);
				}
				const currentLoader = this.getCurrentLoader(loaderContext);
				this.warnings.push(
					new ModuleWarning(this, warning, {
						from: requestShortener.shorten(currentLoader.loader)
					})
				);
			},
			emitError: error => {
				if (!(error instanceof Error)) {
					error = new NonErrorEmittedError(error);
				}
				const currentLoader = this.getCurrentLoader(loaderContext);
				this.errors.push(
					new ModuleError(this, error, {
						from: requestShortener.shorten(currentLoader.loader)
					})
				);
			},
			// TODO remove in webpack 5
			exec: (code, filename) => {
				// @ts-ignore Argument of type 'this' is not assignable to parameter of type 'Module'.
				const module = new NativeModule(filename, this);
				// @ts-ignore _nodeModulePaths is deprecated and undocumented Node.js API
				module.paths = NativeModule._nodeModulePaths(this.context);
				module.filename = filename;
				module._compile(code, filename);
				return module.exports;
			},
			resolve(context, request, callback) {
				resolver.resolve({}, context, request, {}, callback);
			},
			getResolve(options) {
				const child = options ? resolver.withOptions(options) : resolver;
				return (context, request, callback) => {
					if (callback) {
						child.resolve({}, context, request, {}, callback);
					} else {
						return new Promise((resolve, reject) => {
							child.resolve({}, context, request, {}, (err, result) => {
								if (err) reject(err);
								else resolve(result);
							});
						});
					}
				};
			},
			emitFile: (name, content, sourceMap) => {
				if (!this.buildInfo.assets) {
					this.buildInfo.assets = Object.create(null);
				}
				this.buildInfo.assets[name] = this.createSourceForAsset(
					name,
					content,
					sourceMap
				);
			},
			rootContext: options.context,
			webpack: true,
			sourceMap: !!this.useSourceMap,
			_module: this,
			_compilation: compilation,
			_compiler: compilation.compiler,
			fs: fs
		};

		compilation.hooks.normalModuleLoader.call(loaderContext, this);
		if (options.loader) {
			Object.assign(loaderContext, options.loader);
		}

		return loaderContext;
	}

	getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {
		if (
			this.loaders &&
			this.loaders.length &&
			index < this.loaders.length &&
			index >= 0 &&
			this.loaders[index]
		) {
			return this.loaders[index];
		}
		return null;
	}

	createSource(source, resourceBuffer, sourceMap) {
		// if there is no identifier return raw source
		if (!this.identifier) {
			return new RawSource(source);
		}

		// from here on we assume we have an identifier
		const identifier = this.identifier();

		if (this.lineToLine && resourceBuffer) {
			return new LineToLineMappedSource(
				source,
				identifier,
				asString(resourceBuffer)
			);
		}

		if (this.useSourceMap && sourceMap) {
			return new SourceMapSource(source, identifier, sourceMap);
		}

		if (Buffer.isBuffer(source)) {
			// @ts-ignore
			// TODO We need to fix @types/webpack-sources to allow RawSource to take a Buffer | string
			return new RawSource(source);
		}

		return new OriginalSource(source, identifier);
	}

	doBuild(options, compilation, resolver, fs, callback) {
		const loaderContext = this.createLoaderContext(
			resolver,
			options,
			compilation,
			fs
		);

		runLoaders(
			{
				resource: this.resource,
				loaders: this.loaders,
				context: loaderContext,
				readResource: fs.readFile.bind(fs)
			},
			(err, result) => {
				if (result) {
					this.buildInfo.cacheable = result.cacheable;
					this.buildInfo.fileDependencies = new Set(result.fileDependencies);
					this.buildInfo.contextDependencies = new Set(
						result.contextDependencies
					);
				}

				if (err) {
					if (!(err instanceof Error)) {
						err = new NonErrorEmittedError(err);
					}
					const currentLoader = this.getCurrentLoader(loaderContext);
					const error = new ModuleBuildError(this, err, {
						from:
							currentLoader &&
							compilation.runtimeTemplate.requestShortener.shorten(
								currentLoader.loader
							)
					});
					return callback(error);
				}

				const resourceBuffer = result.resourceBuffer;
				const source = result.result[0];
				const sourceMap = result.result.length >= 1 ? result.result[1] : null;
				const extraInfo = result.result.length >= 2 ? result.result[2] : null;

				if (!Buffer.isBuffer(source) && typeof source !== "string") {
					const currentLoader = this.getCurrentLoader(loaderContext, 0);
					const err = new Error(
						`Final loader (${
							currentLoader
								? compilation.runtimeTemplate.requestShortener.shorten(
										currentLoader.loader
								  )
								: "unknown"
						}) didn't return a Buffer or String`
					);
					const error = new ModuleBuildError(this, err);
					return callback(error);
				}

				this._source = this.createSource(
					this.binary ? asBuffer(source) : asString(source),
					resourceBuffer,
					sourceMap
				);
				this._ast =
					typeof extraInfo === "object" &&
					extraInfo !== null &&
					extraInfo.webpackAST !== undefined
						? extraInfo.webpackAST
						: null;
				return callback();
			}
		);
	}

	markModuleAsErrored(error) {
		// Restore build meta from successful build to keep importing state
		this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta);

		this.error = error;
		this.errors.push(this.error);
		this._source = new RawSource(
			"throw new Error(" + JSON.stringify(this.error.message) + ");"
		);
		this._ast = null;
	}

	applyNoParseRule(rule, content) {
		// must start with "rule" if rule is a string
		if (typeof rule === "string") {
			return content.indexOf(rule) === 0;
		}

		if (typeof rule === "function") {
			return rule(content);
		}
		// we assume rule is a regexp
		return rule.test(content);
	}

	// check if module should not be parsed
	// returns "true" if the module should !not! be parsed
	// returns "false" if the module !must! be parsed
	shouldPreventParsing(noParseRule, request) {
		// if no noParseRule exists, return false
		// the module !must! be parsed.
		if (!noParseRule) {
			return false;
		}

		// we only have one rule to check
		if (!Array.isArray(noParseRule)) {
			// returns "true" if the module is !not! to be parsed
			return this.applyNoParseRule(noParseRule, request);
		}

		for (let i = 0; i < noParseRule.length; i++) {
			const rule = noParseRule[i];
			// early exit on first truthy match
			// this module is !not! to be parsed
			if (this.applyNoParseRule(rule, request)) {
				return true;
			}
		}
		// no match found, so this module !should! be parsed
		return false;
	}

	_initBuildHash(compilation) {
		const hash = createHash(compilation.outputOptions.hashFunction);
		if (this._source) {
			hash.update("source");
			this._source.updateHash(hash);
		}
		hash.update("meta");
		hash.update(JSON.stringify(this.buildMeta));
		this._buildHash = hash.digest("hex");
	}

	build(options, compilation, resolver, fs, callback) {
		this.buildTimestamp = Date.now();
		this.built = true;
		this._source = null;
		this._ast = null;
		this._buildHash = "";
		this.error = null;
		this.errors.length = 0;
		this.warnings.length = 0;
		this.buildMeta = {};
		this.buildInfo = {
			cacheable: false,
			fileDependencies: new Set(),
			contextDependencies: new Set()
		};

		return this.doBuild(options, compilation, resolver, fs, err => {
			this._cachedSources.clear();

			// if we have an error mark module as failed and exit
			if (err) {
				this.markModuleAsErrored(err);
				this._initBuildHash(compilation);
				return callback();
			}

			// check if this module should !not! be parsed.
			// if so, exit here;
			const noParseRule = options.module && options.module.noParse;
			if (this.shouldPreventParsing(noParseRule, this.request)) {
				this._initBuildHash(compilation);
				return callback();
			}

			const handleParseError = e => {
				const source = this._source.source();
				const error = new ModuleParseError(this, source, e);
				this.markModuleAsErrored(error);
				this._initBuildHash(compilation);
				return callback();
			};

			const handleParseResult = result => {
				this._lastSuccessfulBuildMeta = this.buildMeta;
				this._initBuildHash(compilation);
				return callback();
			};

			try {
				const result = this.parser.parse(
					this._ast || this._source.source(),
					{
						current: this,
						module: this,
						compilation: compilation,
						options: options
					},
					(err, result) => {
						if (err) {
							handleParseError(err);
						} else {
							handleParseResult(result);
						}
					}
				);
				if (result !== undefined) {
					// parse is sync
					handleParseResult(result);
				}
			} catch (e) {
				handleParseError(e);
			}
		});
	}

	getHashDigest(dependencyTemplates) {
		// TODO webpack 5 refactor
		let dtHash = dependencyTemplates.get("hash");
		return `${this.hash}-${dtHash}`;
	}

	source(dependencyTemplates, runtimeTemplate, type = "javascript") {
		const hashDigest = this.getHashDigest(dependencyTemplates);
		const cacheEntry = this._cachedSources.get(type);
		if (cacheEntry !== undefined && cacheEntry.hash === hashDigest) {
			// We can reuse the cached source
			return cacheEntry.source;
		}

		const source = this.generator.generate(
			this,
			dependencyTemplates,
			runtimeTemplate,
			type
		);

		const cachedSource = new CachedSource(source);
		this._cachedSources.set(type, {
			source: cachedSource,
			hash: hashDigest
		});
		return cachedSource;
	}

	originalSource() {
		return this._source;
	}

	needRebuild(fileTimestamps, contextTimestamps) {
		// always try to rebuild in case of an error
		if (this.error) return true;

		// always rebuild when module is not cacheable
		if (!this.buildInfo.cacheable) return true;

		// Check timestamps of all dependencies
		// Missing timestamp -> need rebuild
		// Timestamp bigger than buildTimestamp -> need rebuild
		for (const file of this.buildInfo.fileDependencies) {
			const timestamp = fileTimestamps.get(file);
			if (!timestamp) return true;
			if (timestamp >= this.buildTimestamp) return true;
		}
		for (const file of this.buildInfo.contextDependencies) {
			const timestamp = contextTimestamps.get(file);
			if (!timestamp) return true;
			if (timestamp >= this.buildTimestamp) return true;
		}
		// elsewise -> no rebuild needed
		return false;
	}

	size() {
		return this._source ? this._source.size() : -1;
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update(this._buildHash);
		super.updateHash(hash);
	}
}

module.exports = NormalModule;


/***/ }),

/***/ "./node_modules/webpack/lib/NormalModuleFactory.js":
/*!********************************************!*\
  !*** (webpack)/lib/NormalModuleFactory.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */


const path = __webpack_require__(/*! path */ "path");
const asyncLib = __webpack_require__(/*! neo-async */ "neo-async");
const {
	Tapable,
	AsyncSeriesWaterfallHook,
	SyncWaterfallHook,
	SyncBailHook,
	SyncHook,
	HookMap
} = __webpack_require__(/*! tapable */ "tapable");
const NormalModule = __webpack_require__(/*! ./NormalModule */ "./node_modules/webpack/lib/NormalModule.js");
const RawModule = __webpack_require__(/*! ./RawModule */ "./node_modules/webpack/lib/RawModule.js");
const RuleSet = __webpack_require__(/*! ./RuleSet */ "./node_modules/webpack/lib/RuleSet.js");
const cachedMerge = __webpack_require__(/*! ./util/cachedMerge */ "./node_modules/webpack/lib/util/cachedMerge.js");

const EMPTY_RESOLVE_OPTIONS = {};

const MATCH_RESOURCE_REGEX = /^([^!]+)!=!/;

const loaderToIdent = data => {
	if (!data.options) {
		return data.loader;
	}
	if (typeof data.options === "string") {
		return data.loader + "?" + data.options;
	}
	if (typeof data.options !== "object") {
		throw new Error("loader options must be string or object");
	}
	if (data.ident) {
		return data.loader + "??" + data.ident;
	}
	return data.loader + "?" + JSON.stringify(data.options);
};

const identToLoaderRequest = resultString => {
	const idx = resultString.indexOf("?");
	if (idx >= 0) {
		const loader = resultString.substr(0, idx);
		const options = resultString.substr(idx + 1);
		return {
			loader,
			options
		};
	} else {
		return {
			loader: resultString,
			options: undefined
		};
	}
};

const dependencyCache = new WeakMap();

class NormalModuleFactory extends Tapable {
	constructor(context, resolverFactory, options) {
		super();
		this.hooks = {
			resolver: new SyncWaterfallHook(["resolver"]),
			factory: new SyncWaterfallHook(["factory"]),
			beforeResolve: new AsyncSeriesWaterfallHook(["data"]),
			afterResolve: new AsyncSeriesWaterfallHook(["data"]),
			createModule: new SyncBailHook(["data"]),
			module: new SyncWaterfallHook(["module", "data"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		};
		this._pluginCompat.tap("NormalModuleFactory", options => {
			switch (options.name) {
				case "before-resolve":
				case "after-resolve":
					options.async = true;
					break;
				case "parser":
					this.hooks.parser
						.for("javascript/auto")
						.tap(options.fn.name || "unnamed compat plugin", options.fn);
					return true;
			}
			let match;
			match = /^parser (.+)$/.exec(options.name);
			if (match) {
				this.hooks.parser
					.for(match[1])
					.tap(
						options.fn.name || "unnamed compat plugin",
						options.fn.bind(this)
					);
				return true;
			}
			match = /^create-parser (.+)$/.exec(options.name);
			if (match) {
				this.hooks.createParser
					.for(match[1])
					.tap(
						options.fn.name || "unnamed compat plugin",
						options.fn.bind(this)
					);
				return true;
			}
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = new RuleSet(options.defaultRules.concat(options.rules));
		this.cachePredicate =
			typeof options.unsafeCache === "function"
				? options.unsafeCache
				: Boolean.bind(null, options.unsafeCache);
		this.context = context || "";
		this.parserCache = Object.create(null);
		this.generatorCache = Object.create(null);
		this.hooks.factory.tap("NormalModuleFactory", () => (result, callback) => {
			let resolver = this.hooks.resolver.call(null);

			// Ignored
			if (!resolver) return callback();

			resolver(result, (err, data) => {
				if (err) return callback(err);

				// Ignored
				if (!data) return callback();

				// direct module
				if (typeof data.source === "function") return callback(null, data);

				this.hooks.afterResolve.callAsync(data, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (!result) return callback();

					let createdModule = this.hooks.createModule.call(result);
					if (!createdModule) {
						if (!result.request) {
							return callback(new Error("Empty dependency (no request)"));
						}

						createdModule = new NormalModule(result);
					}

					createdModule = this.hooks.module.call(createdModule, result);

					return callback(null, createdModule);
				});
			});
		});
		this.hooks.resolver.tap("NormalModuleFactory", () => (data, callback) => {
			const contextInfo = data.contextInfo;
			const context = data.context;
			const request = data.request;

			const loaderResolver = this.getResolver("loader");
			const normalResolver = this.getResolver("normal", data.resolveOptions);

			let matchResource = undefined;
			let requestWithoutMatchResource = request;
			const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
			if (matchResourceMatch) {
				matchResource = matchResourceMatch[1];
				if (/^\.\.?\//.test(matchResource)) {
					matchResource = path.join(context, matchResource);
				}
				requestWithoutMatchResource = request.substr(
					matchResourceMatch[0].length
				);
			}

			const noPreAutoLoaders = requestWithoutMatchResource.startsWith("-!");
			const noAutoLoaders =
				noPreAutoLoaders || requestWithoutMatchResource.startsWith("!");
			const noPrePostAutoLoaders = requestWithoutMatchResource.startsWith("!!");
			let elements = requestWithoutMatchResource
				.replace(/^-?!+/, "")
				.replace(/!!+/g, "!")
				.split("!");
			let resource = elements.pop();
			elements = elements.map(identToLoaderRequest);

			asyncLib.parallel(
				[
					callback =>
						this.resolveRequestArray(
							contextInfo,
							context,
							elements,
							loaderResolver,
							callback
						),
					callback => {
						if (resource === "" || resource[0] === "?") {
							return callback(null, {
								resource
							});
						}

						normalResolver.resolve(
							contextInfo,
							context,
							resource,
							{},
							(err, resource, resourceResolveData) => {
								if (err) return callback(err);
								callback(null, {
									resourceResolveData,
									resource
								});
							}
						);
					}
				],
				(err, results) => {
					if (err) return callback(err);
					let loaders = results[0];
					const resourceResolveData = results[1].resourceResolveData;
					resource = results[1].resource;

					// translate option idents
					try {
						for (const item of loaders) {
							if (typeof item.options === "string" && item.options[0] === "?") {
								const ident = item.options.substr(1);
								item.options = this.ruleSet.findOptionsByIdent(ident);
								item.ident = ident;
							}
						}
					} catch (e) {
						return callback(e);
					}

					if (resource === false) {
						// ignored
						return callback(
							null,
							new RawModule(
								"/* (ignored) */",
								`ignored ${context} ${request}`,
								`${request} (ignored)`
							)
						);
					}

					const userRequest =
						(matchResource !== undefined ? `${matchResource}!=!` : "") +
						loaders
							.map(loaderToIdent)
							.concat([resource])
							.join("!");

					let resourcePath =
						matchResource !== undefined ? matchResource : resource;
					let resourceQuery = "";
					const queryIndex = resourcePath.indexOf("?");
					if (queryIndex >= 0) {
						resourceQuery = resourcePath.substr(queryIndex);
						resourcePath = resourcePath.substr(0, queryIndex);
					}

					const result = this.ruleSet.exec({
						resource: resourcePath,
						realResource:
							matchResource !== undefined
								? resource.replace(/\?.*/, "")
								: resourcePath,
						resourceQuery,
						issuer: contextInfo.issuer,
						compiler: contextInfo.compiler
					});
					const settings = {};
					const useLoadersPost = [];
					const useLoaders = [];
					const useLoadersPre = [];
					for (const r of result) {
						if (r.type === "use") {
							if (r.enforce === "post" && !noPrePostAutoLoaders) {
								useLoadersPost.push(r.value);
							} else if (
								r.enforce === "pre" &&
								!noPreAutoLoaders &&
								!noPrePostAutoLoaders
							) {
								useLoadersPre.push(r.value);
							} else if (
								!r.enforce &&
								!noAutoLoaders &&
								!noPrePostAutoLoaders
							) {
								useLoaders.push(r.value);
							}
						} else if (
							typeof r.value === "object" &&
							r.value !== null &&
							typeof settings[r.type] === "object" &&
							settings[r.type] !== null
						) {
							settings[r.type] = cachedMerge(settings[r.type], r.value);
						} else {
							settings[r.type] = r.value;
						}
					}
					asyncLib.parallel(
						[
							this.resolveRequestArray.bind(
								this,
								contextInfo,
								this.context,
								useLoadersPost,
								loaderResolver
							),
							this.resolveRequestArray.bind(
								this,
								contextInfo,
								this.context,
								useLoaders,
								loaderResolver
							),
							this.resolveRequestArray.bind(
								this,
								contextInfo,
								this.context,
								useLoadersPre,
								loaderResolver
							)
						],
						(err, results) => {
							if (err) return callback(err);
							loaders = results[0].concat(loaders, results[1], results[2]);
							process.nextTick(() => {
								const type = settings.type;
								const resolveOptions = settings.resolve;
								callback(null, {
									context: context,
									request: loaders
										.map(loaderToIdent)
										.concat([resource])
										.join("!"),
									dependencies: data.dependencies,
									userRequest,
									rawRequest: request,
									loaders,
									resource,
									matchResource,
									resourceResolveData,
									settings,
									type,
									parser: this.getParser(type, settings.parser),
									generator: this.getGenerator(type, settings.generator),
									resolveOptions
								});
							});
						}
					);
				}
			);
		});
	}

	create(data, callback) {
		const dependencies = data.dependencies;
		const cacheEntry = dependencyCache.get(dependencies[0]);
		if (cacheEntry) return callback(null, cacheEntry);
		const context = data.context || this.context;
		const resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS;
		const request = dependencies[0].request;
		const contextInfo = data.contextInfo || {};
		this.hooks.beforeResolve.callAsync(
			{
				contextInfo,
				resolveOptions,
				context,
				request,
				dependencies
			},
			(err, result) => {
				if (err) return callback(err);

				// Ignored
				if (!result) return callback();

				const factory = this.hooks.factory.call(null);

				// Ignored
				if (!factory) return callback();

				factory(result, (err, module) => {
					if (err) return callback(err);

					if (module && this.cachePredicate(module)) {
						for (const d of dependencies) {
							dependencyCache.set(d, module);
						}
					}

					callback(null, module);
				});
			}
		);
	}

	resolveRequestArray(contextInfo, context, array, resolver, callback) {
		if (array.length === 0) return callback(null, []);
		asyncLib.map(
			array,
			(item, callback) => {
				resolver.resolve(
					contextInfo,
					context,
					item.loader,
					{},
					(err, result) => {
						if (
							err &&
							/^[^/]*$/.test(item.loader) &&
							!/-loader$/.test(item.loader)
						) {
							return resolver.resolve(
								contextInfo,
								context,
								item.loader + "-loader",
								{},
								err2 => {
									if (!err2) {
										err.message =
											err.message +
											"\n" +
											"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n" +
											`                 You need to specify '${
												item.loader
											}-loader' instead of '${item.loader}',\n` +
											"                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed";
									}
									callback(err);
								}
							);
						}
						if (err) return callback(err);

						const optionsOnly = item.options
							? {
									options: item.options
							  }
							: undefined;
						return callback(
							null,
							Object.assign({}, item, identToLoaderRequest(result), optionsOnly)
						);
					}
				);
			},
			callback
		);
	}

	getParser(type, parserOptions) {
		let ident = type;
		if (parserOptions) {
			if (parserOptions.ident) {
				ident = `${type}|${parserOptions.ident}`;
			} else {
				ident = JSON.stringify([type, parserOptions]);
			}
		}
		if (ident in this.parserCache) {
			return this.parserCache[ident];
		}
		return (this.parserCache[ident] = this.createParser(type, parserOptions));
	}

	createParser(type, parserOptions = {}) {
		const parser = this.hooks.createParser.for(type).call(parserOptions);
		if (!parser) {
			throw new Error(`No parser registered for ${type}`);
		}
		this.hooks.parser.for(type).call(parser, parserOptions);
		return parser;
	}

	getGenerator(type, generatorOptions) {
		let ident = type;
		if (generatorOptions) {
			if (generatorOptions.ident) {
				ident = `${type}|${generatorOptions.ident}`;
			} else {
				ident = JSON.stringify([type, generatorOptions]);
			}
		}
		if (ident in this.generatorCache) {
			return this.generatorCache[ident];
		}
		return (this.generatorCache[ident] = this.createGenerator(
			type,
			generatorOptions
		));
	}

	createGenerator(type, generatorOptions = {}) {
		const generator = this.hooks.createGenerator
			.for(type)
			.call(generatorOptions);
		if (!generator) {
			throw new Error(`No generator registered for ${type}`);
		}
		this.hooks.generator.for(type).call(generator, generatorOptions);
		return generator;
	}

	getResolver(type, resolveOptions) {
		return this.resolverFactory.get(
			type,
			resolveOptions || EMPTY_RESOLVE_OPTIONS
		);
	}
}

module.exports = NormalModuleFactory;


/***/ }),

/***/ "./node_modules/webpack/lib/NormalModuleReplacementPlugin.js":
/*!******************************************************!*\
  !*** (webpack)/lib/NormalModuleReplacementPlugin.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const path = __webpack_require__(/*! path */ "path");

class NormalModuleReplacementPlugin {
	constructor(resourceRegExp, newResource) {
		this.resourceRegExp = resourceRegExp;
		this.newResource = newResource;
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const newResource = this.newResource;
		compiler.hooks.normalModuleFactory.tap(
			"NormalModuleReplacementPlugin",
			nmf => {
				nmf.hooks.beforeResolve.tap("NormalModuleReplacementPlugin", result => {
					if (!result) return;
					if (resourceRegExp.test(result.request)) {
						if (typeof newResource === "function") {
							newResource(result);
						} else {
							result.request = newResource;
						}
					}
					return result;
				});
				nmf.hooks.afterResolve.tap("NormalModuleReplacementPlugin", result => {
					if (!result) return;
					if (resourceRegExp.test(result.resource)) {
						if (typeof newResource === "function") {
							newResource(result);
						} else {
							result.resource = path.resolve(
								path.dirname(result.resource),
								newResource
							);
						}
					}
					return result;
				});
			}
		);
	}
}

module.exports = NormalModuleReplacementPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/NullFactory.js":
/*!************************************!*\
  !*** (webpack)/lib/NullFactory.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class NullFactory {
	create(data, callback) {
		return callback();
	}
}
module.exports = NullFactory;


/***/ }),

/***/ "./node_modules/webpack/lib/OptionsApply.js":
/*!*************************************!*\
  !*** (webpack)/lib/OptionsApply.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class OptionsApply {
	process(options, compiler) {}
}
module.exports = OptionsApply;


/***/ }),

/***/ "./node_modules/webpack/lib/OptionsDefaulter.js":
/*!*****************************************!*\
  !*** (webpack)/lib/OptionsDefaulter.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const getProperty = (obj, name) => {
	name = name.split(".");
	for (let i = 0; i < name.length - 1; i++) {
		obj = obj[name[i]];
		if (typeof obj !== "object" || !obj || Array.isArray(obj)) return;
	}
	return obj[name.pop()];
};

const setProperty = (obj, name, value) => {
	name = name.split(".");
	for (let i = 0; i < name.length - 1; i++) {
		if (typeof obj[name[i]] !== "object" && obj[name[i]] !== undefined) return;
		if (Array.isArray(obj[name[i]])) return;
		if (!obj[name[i]]) obj[name[i]] = {};
		obj = obj[name[i]];
	}
	obj[name.pop()] = value;
};

class OptionsDefaulter {
	constructor() {
		this.defaults = {};
		this.config = {};
	}

	process(options) {
		options = Object.assign({}, options);
		for (let name in this.defaults) {
			switch (this.config[name]) {
				case undefined:
					if (getProperty(options, name) === undefined) {
						setProperty(options, name, this.defaults[name]);
					}
					break;
				case "call":
					setProperty(
						options,
						name,
						this.defaults[name].call(this, getProperty(options, name), options)
					);
					break;
				case "make":
					if (getProperty(options, name) === undefined) {
						setProperty(options, name, this.defaults[name].call(this, options));
					}
					break;
				case "append": {
					let oldValue = getProperty(options, name);
					if (!Array.isArray(oldValue)) {
						oldValue = [];
					}
					oldValue.push(...this.defaults[name]);
					setProperty(options, name, oldValue);
					break;
				}
				default:
					throw new Error(
						"OptionsDefaulter cannot process " + this.config[name]
					);
			}
		}
		return options;
	}

	set(name, config, def) {
		if (def !== undefined) {
			this.defaults[name] = def;
			this.config[name] = config;
		} else {
			this.defaults[name] = config;
			delete this.config[name];
		}
	}
}

module.exports = OptionsDefaulter;


/***/ }),

/***/ "./node_modules/webpack/lib/Parser.js":
/*!*******************************!*\
  !*** (webpack)/lib/Parser.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API

const acorn = __webpack_require__(/*! acorn */ "acorn");
const acornDynamicImport = __webpack_require__(/*! acorn-dynamic-import */ "acorn-dynamic-import").default;
const { Tapable, SyncBailHook, HookMap } = __webpack_require__(/*! tapable */ "tapable");
const util = __webpack_require__(/*! util */ "util");
const vm = __webpack_require__(/*! vm */ "vm");
const BasicEvaluatedExpression = __webpack_require__(/*! ./BasicEvaluatedExpression */ "./node_modules/webpack/lib/BasicEvaluatedExpression.js");
const StackedSetMap = __webpack_require__(/*! ./util/StackedSetMap */ "./node_modules/webpack/lib/util/StackedSetMap.js");
const TrackingSet = __webpack_require__(/*! ./util/TrackingSet */ "./node_modules/webpack/lib/util/TrackingSet.js");

const acornParser = acorn.Parser.extend(acornDynamicImport);

const joinRanges = (startRange, endRange) => {
	if (!endRange) return startRange;
	if (!startRange) return endRange;
	return [startRange[0], endRange[1]];
};

const defaultParserOptions = {
	ranges: true,
	locations: true,
	ecmaVersion: 2019,
	sourceType: "module",
	onComment: null
};

// regexp to match at lease one "magic comment"
const webpackCommentRegExp = new RegExp(/(^|\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);

const EMPTY_ARRAY = [];

const EMPTY_COMMENT_OPTIONS = {
	options: null,
	errors: null
};

class Parser extends Tapable {
	constructor(options, sourceType = "auto") {
		super();
		this.hooks = {
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			statement: new SyncBailHook(["statement"]),
			statementIf: new SyncBailHook(["statement"]),
			label: new HookMap(() => new SyncBailHook(["statement"])),
			import: new SyncBailHook(["statement", "source"]),
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			export: new SyncBailHook(["statement"]),
			exportImport: new SyncBailHook(["statement", "source"]),
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			assigned: new HookMap(() => new SyncBailHook(["expression"])),
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			importCall: new SyncBailHook(["expression"]),
			call: new HookMap(() => new SyncBailHook(["expression"])),
			callAnyMember: new HookMap(() => new SyncBailHook(["expression"])),
			new: new HookMap(() => new SyncBailHook(["expression"])),
			expression: new HookMap(() => new SyncBailHook(["expression"])),
			expressionAnyMember: new HookMap(() => new SyncBailHook(["expression"])),
			expressionConditionalOperator: new SyncBailHook(["expression"]),
			expressionLogicalOperator: new SyncBailHook(["expression"]),
			program: new SyncBailHook(["ast", "comments"])
		};
		const HOOK_MAP_COMPAT_CONFIG = {
			evaluateTypeof: /^evaluate typeof (.+)$/,
			evaluateIdentifier: /^evaluate Identifier (.+)$/,
			evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,
			evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,
			evaluate: /^evaluate (.+)$/,
			label: /^label (.+)$/,
			varDeclarationLet: /^var-let (.+)$/,
			varDeclarationConst: /^var-const (.+)$/,
			varDeclarationVar: /^var-var (.+)$/,
			varDeclaration: /^var (.+)$/,
			canRename: /^can-rename (.+)$/,
			rename: /^rename (.+)$/,
			typeof: /^typeof (.+)$/,
			assigned: /^assigned (.+)$/,
			assign: /^assign (.+)$/,
			callAnyMember: /^call (.+)\.\*$/,
			call: /^call (.+)$/,
			new: /^new (.+)$/,
			expressionConditionalOperator: /^expression \?:$/,
			expressionAnyMember: /^expression (.+)\.\*$/,
			expression: /^expression (.+)$/
		};
		this._pluginCompat.tap("Parser", options => {
			for (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {
				const regexp = HOOK_MAP_COMPAT_CONFIG[name];
				const match = regexp.exec(options.name);
				if (match) {
					if (match[1]) {
						this.hooks[name].tap(
							match[1],
							options.fn.name || "unnamed compat plugin",
							options.fn.bind(this)
						);
					} else {
						this.hooks[name].tap(
							options.fn.name || "unnamed compat plugin",
							options.fn.bind(this)
						);
					}
					return true;
				}
			}
		});
		this.options = options;
		this.sourceType = sourceType;
		this.scope = undefined;
		this.state = undefined;
		this.comments = undefined;
		this.initializeEvaluating();
	}

	initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("Parser", expr => {
			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("LogicalExpression").tap("Parser", expr => {
			let left;
			let leftAsBool;
			let right;
			if (expr.operator === "&&") {
				left = this.evaluateExpression(expr.left);
				leftAsBool = left && left.asBool();
				if (leftAsBool === false) return left.setRange(expr.range);
				if (leftAsBool !== true) return;
				right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			} else if (expr.operator === "||") {
				left = this.evaluateExpression(expr.left);
				leftAsBool = left && left.asBool();
				if (leftAsBool === true) return left.setRange(expr.range);
				if (leftAsBool !== false) return;
				right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("BinaryExpression").tap("Parser", expr => {
			let left;
			let right;
			let res;
			if (expr.operator === "+") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				res = new BasicEvaluatedExpression();
				if (left.isString()) {
					if (right.isString()) {
						res.setString(left.string + right.string);
					} else if (right.isNumber()) {
						res.setString(left.string + right.number);
					} else if (
						right.isWrapped() &&
						right.prefix &&
						right.prefix.isString()
					) {
						// "left" + ("prefix" + inner + "postfix")
						// => ("leftprefix" + inner + "postfix")
						res.setWrapped(
							new BasicEvaluatedExpression()
								.setString(left.string + right.prefix.string)
								.setRange(joinRanges(left.range, right.prefix.range)),
							right.postfix,
							right.wrappedInnerExpressions
						);
					} else if (right.isWrapped()) {
						// "left" + ([null] + inner + "postfix")
						// => ("left" + inner + "postfix")
						res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);
					} else {
						// "left" + expr
						// => ("left" + expr + "")
						res.setWrapped(left, null, [right]);
					}
				} else if (left.isNumber()) {
					if (right.isString()) {
						res.setString(left.number + right.string);
					} else if (right.isNumber()) {
						res.setNumber(left.number + right.number);
					} else {
						return;
					}
				} else if (left.isWrapped()) {
					if (left.postfix && left.postfix.isString() && right.isString()) {
						// ("prefix" + inner + "postfix") + "right"
						// => ("prefix" + inner + "postfixright")
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(left.postfix.string + right.string)
								.setRange(joinRanges(left.postfix.range, right.range)),
							left.wrappedInnerExpressions
						);
					} else if (
						left.postfix &&
						left.postfix.isString() &&
						right.isNumber()
					) {
						// ("prefix" + inner + "postfix") + 123
						// => ("prefix" + inner + "postfix123")
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(left.postfix.string + right.number)
								.setRange(joinRanges(left.postfix.range, right.range)),
							left.wrappedInnerExpressions
						);
					} else if (right.isString()) {
						// ("prefix" + inner + [null]) + "right"
						// => ("prefix" + inner + "right")
						res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
					} else if (right.isNumber()) {
						// ("prefix" + inner + [null]) + 123
						// => ("prefix" + inner + "123")
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(right.number + "")
								.setRange(right.range),
							left.wrappedInnerExpressions
						);
					} else if (right.isWrapped()) {
						// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
						// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
						res.setWrapped(
							left.prefix,
							right.postfix,
							left.wrappedInnerExpressions &&
								right.wrappedInnerExpressions &&
								left.wrappedInnerExpressions
									.concat(left.postfix ? [left.postfix] : [])
									.concat(right.prefix ? [right.prefix] : [])
									.concat(right.wrappedInnerExpressions)
						);
					} else {
						// ("prefix" + inner + postfix) + expr
						// => ("prefix" + inner + postfix + expr + [null])
						res.setWrapped(
							left.prefix,
							null,
							left.wrappedInnerExpressions &&
								left.wrappedInnerExpressions.concat(
									left.postfix ? [left.postfix, right] : [right]
								)
						);
					}
				} else {
					if (right.isString()) {
						// left + "right"
						// => ([null] + left + "right")
						res.setWrapped(null, right, [left]);
					} else if (right.isWrapped()) {
						// left + (prefix + inner + "postfix")
						// => ([null] + left + prefix + inner + "postfix")
						res.setWrapped(
							null,
							right.postfix,
							right.wrappedInnerExpressions &&
								(right.prefix ? [left, right.prefix] : [left]).concat(
									right.wrappedInnerExpressions
								)
						);
					} else {
						return;
					}
				}
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "-") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number - right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "*") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number * right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "/") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number / right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "**") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(Math.pow(left.number, right.number));
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "==" || expr.operator === "===") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if (left.isString() && right.isString()) {
					return res.setBoolean(left.string === right.string);
				} else if (left.isNumber() && right.isNumber()) {
					return res.setBoolean(left.number === right.number);
				} else if (left.isBoolean() && right.isBoolean()) {
					return res.setBoolean(left.bool === right.bool);
				}
			} else if (expr.operator === "!=" || expr.operator === "!==") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if (left.isString() && right.isString()) {
					return res.setBoolean(left.string !== right.string);
				} else if (left.isNumber() && right.isNumber()) {
					return res.setBoolean(left.number !== right.number);
				} else if (left.isBoolean() && right.isBoolean()) {
					return res.setBoolean(left.bool !== right.bool);
				}
			} else if (expr.operator === "&") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number & right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "|") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number | right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "^") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number ^ right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === ">>>") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number >>> right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === ">>") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number >> right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "<<") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number << right.number);
				res.setRange(expr.range);
				return res;
			}
		});
		this.hooks.evaluate.for("UnaryExpression").tap("Parser", expr => {
			if (expr.operator === "typeof") {
				let res;
				let name;
				if (expr.argument.type === "Identifier") {
					name =
						this.scope.renames.get(expr.argument.name) || expr.argument.name;
					if (!this.scope.definitions.has(name)) {
						const hook = this.hooks.evaluateTypeof.get(name);
						if (hook !== undefined) {
							res = hook.call(expr);
							if (res !== undefined) return res;
						}
					}
				}
				if (expr.argument.type === "MemberExpression") {
					const exprName = this.getNameForExpression(expr.argument);
					if (exprName && exprName.free) {
						const hook = this.hooks.evaluateTypeof.get(exprName.name);
						if (hook !== undefined) {
							res = hook.call(expr);
							if (res !== undefined) return res;
						}
					}
				}
				if (expr.argument.type === "FunctionExpression") {
					return new BasicEvaluatedExpression()
						.setString("function")
						.setRange(expr.range);
				}
				const arg = this.evaluateExpression(expr.argument);
				if (arg.isString() || arg.isWrapped()) {
					return new BasicEvaluatedExpression()
						.setString("string")
						.setRange(expr.range);
				}
				if (arg.isNumber()) {
					return new BasicEvaluatedExpression()
						.setString("number")
						.setRange(expr.range);
				}
				if (arg.isBoolean()) {
					return new BasicEvaluatedExpression()
						.setString("boolean")
						.setRange(expr.range);
				}
				if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {
					return new BasicEvaluatedExpression()
						.setString("object")
						.setRange(expr.range);
				}
			} else if (expr.operator === "!") {
				const argument = this.evaluateExpression(expr.argument);
				if (!argument) return;
				if (argument.isBoolean()) {
					return new BasicEvaluatedExpression()
						.setBoolean(!argument.bool)
						.setRange(expr.range);
				}
				if (argument.isTruthy()) {
					return new BasicEvaluatedExpression()
						.setBoolean(false)
						.setRange(expr.range);
				}
				if (argument.isFalsy()) {
					return new BasicEvaluatedExpression()
						.setBoolean(true)
						.setRange(expr.range);
				}
				if (argument.isString()) {
					return new BasicEvaluatedExpression()
						.setBoolean(!argument.string)
						.setRange(expr.range);
				}
				if (argument.isNumber()) {
					return new BasicEvaluatedExpression()
						.setBoolean(!argument.number)
						.setRange(expr.range);
				}
			} else if (expr.operator === "~") {
				const argument = this.evaluateExpression(expr.argument);
				if (!argument) return;
				if (!argument.isNumber()) return;
				const res = new BasicEvaluatedExpression();
				res.setNumber(~argument.number);
				res.setRange(expr.range);
				return res;
			}
		});
		this.hooks.evaluateTypeof.for("undefined").tap("Parser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("Parser", expr => {
			const name = this.scope.renames.get(expr.name) || expr.name;
			if (!this.scope.definitions.has(expr.name)) {
				const hook = this.hooks.evaluateIdentifier.get(name);
				if (hook !== undefined) {
					const result = hook.call(expr);
					if (result) return result;
				}
				return new BasicEvaluatedExpression()
					.setIdentifier(name)
					.setRange(expr.range);
			} else {
				const hook = this.hooks.evaluateDefinedIdentifier.get(name);
				if (hook !== undefined) {
					return hook.call(expr);
				}
			}
		});
		this.hooks.evaluate.for("ThisExpression").tap("Parser", expr => {
			const name = this.scope.renames.get("this");
			if (name) {
				const hook = this.hooks.evaluateIdentifier.get(name);
				if (hook !== undefined) {
					const result = hook.call(expr);
					if (result) return result;
				}
				return new BasicEvaluatedExpression()
					.setIdentifier(name)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("MemberExpression").tap("Parser", expression => {
			let exprName = this.getNameForExpression(expression);
			if (exprName) {
				if (exprName.free) {
					const hook = this.hooks.evaluateIdentifier.get(exprName.name);
					if (hook !== undefined) {
						const result = hook.call(expression);
						if (result) return result;
					}
					return new BasicEvaluatedExpression()
						.setIdentifier(exprName.name)
						.setRange(expression.range);
				} else {
					const hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);
					if (hook !== undefined) {
						return hook.call(expression);
					}
				}
			}
		});
		this.hooks.evaluate.for("CallExpression").tap("Parser", expr => {
			if (expr.callee.type !== "MemberExpression") return;
			if (
				expr.callee.property.type !==
				(expr.callee.computed ? "Literal" : "Identifier")
			)
				return;
			const param = this.evaluateExpression(expr.callee.object);
			if (!param) return;
			const property = expr.callee.property.name || expr.callee.property.value;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("Parser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				arg1 = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				arg2 = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1, arg2))
					.setRange(expr.range);
			});
		["substr", "substring"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("Parser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setRange(expr.range);
				});
		});

		/**
		 * @param {string} kind "cooked" | "raw"
		 * @param {TODO} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			const quasis = [];
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (typeof exprAsString === "string") {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate.for("TemplateLiteral").tap("Parser", node => {
			const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
			if (parts.length === 1) {
				return parts[0].setRange(node.range);
			}
			return new BasicEvaluatedExpression()
				.setTemplateString(quasis, parts, "cooked")
				.setRange(node.range);
		});
		this.hooks.evaluate.for("TaggedTemplateExpression").tap("Parser", node => {
			if (this.evaluateExpression(node.tag).identifier !== "String.raw") return;
			const { quasis, parts } = getSimplifiedTemplateResult("raw", node.quasi);
			if (parts.length === 1) {
				return parts[0].setRange(node.range);
			}
			return new BasicEvaluatedExpression()
				.setTemplateString(quasis, parts, "raw")
				.setRange(node.range);
		});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("Parser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const argExpr = this.evaluateExpression(expr.arguments[i]);
					if (!argExpr.isString() && !argExpr.isNumber()) {
						hasUnknownParams = true;
						break;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("Parser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setRange(expr.range);
			});
		this.hooks.evaluate.for("ConditionalExpression").tap("Parser", expr => {
			const condition = this.evaluateExpression(expr.test);
			const conditionValue = condition.asBool();
			let res;
			if (conditionValue === undefined) {
				const consequent = this.evaluateExpression(expr.consequent);
				const alternate = this.evaluateExpression(expr.alternate);
				if (!consequent || !alternate) return;
				res = new BasicEvaluatedExpression();
				if (consequent.isConditional()) {
					res.setOptions(consequent.options);
				} else {
					res.setOptions([consequent]);
				}
				if (alternate.isConditional()) {
					res.addOptions(alternate.options);
				} else {
					res.addOptions([alternate]);
				}
			} else {
				res = this.evaluateExpression(
					conditionValue ? expr.consequent : expr.alternate
				);
			}
			res.setRange(expr.range);
			return res;
		});
		this.hooks.evaluate.for("ArrayExpression").tap("Parser", expr => {
			const items = expr.elements.map(element => {
				return element !== null && this.evaluateExpression(element);
			});
			if (!items.every(Boolean)) return;
			return new BasicEvaluatedExpression()
				.setItems(items)
				.setRange(expr.range);
		});
	}

	getRenameIdentifier(expr) {
		const result = this.evaluateExpression(expr);
		if (result && result.isIdentifier()) {
			return result.identifier;
		}
	}

	walkClass(classy) {
		if (classy.superClass) this.walkExpression(classy.superClass);
		if (classy.body && classy.body.type === "ClassBody") {
			const wasTopLevel = this.scope.topLevelScope;
			this.scope.topLevelScope = false;
			for (const methodDefinition of classy.body.body) {
				if (methodDefinition.type === "MethodDefinition") {
					this.walkMethodDefinition(methodDefinition);
				}
			}
			this.scope.topLevelScope = wasTopLevel;
		}
	}

	walkMethodDefinition(methodDefinition) {
		if (methodDefinition.computed && methodDefinition.key) {
			this.walkExpression(methodDefinition.key);
		}
		if (methodDefinition.value) {
			this.walkExpression(methodDefinition.value);
		}
	}

	// Prewalking iterates the scope for variable declarations
	prewalkStatements(statements) {
		for (let index = 0, len = statements.length; index < len; index++) {
			const statement = statements[index];
			this.prewalkStatement(statement);
		}
	}

	// Walking iterates the statements and expressions and processes them
	walkStatements(statements) {
		for (let index = 0, len = statements.length; index < len; index++) {
			const statement = statements[index];
			this.walkStatement(statement);
		}
	}

	prewalkStatement(statement) {
		switch (statement.type) {
			case "BlockStatement":
				this.prewalkBlockStatement(statement);
				break;
			case "ClassDeclaration":
				this.prewalkClassDeclaration(statement);
				break;
			case "DoWhileStatement":
				this.prewalkDoWhileStatement(statement);
				break;
			case "ExportAllDeclaration":
				this.prewalkExportAllDeclaration(statement);
				break;
			case "ExportDefaultDeclaration":
				this.prewalkExportDefaultDeclaration(statement);
				break;
			case "ExportNamedDeclaration":
				this.prewalkExportNamedDeclaration(statement);
				break;
			case "ForInStatement":
				this.prewalkForInStatement(statement);
				break;
			case "ForOfStatement":
				this.prewalkForOfStatement(statement);
				break;
			case "ForStatement":
				this.prewalkForStatement(statement);
				break;
			case "FunctionDeclaration":
				this.prewalkFunctionDeclaration(statement);
				break;
			case "IfStatement":
				this.prewalkIfStatement(statement);
				break;
			case "ImportDeclaration":
				this.prewalkImportDeclaration(statement);
				break;
			case "LabeledStatement":
				this.prewalkLabeledStatement(statement);
				break;
			case "SwitchStatement":
				this.prewalkSwitchStatement(statement);
				break;
			case "TryStatement":
				this.prewalkTryStatement(statement);
				break;
			case "VariableDeclaration":
				this.prewalkVariableDeclaration(statement);
				break;
			case "WhileStatement":
				this.prewalkWhileStatement(statement);
				break;
			case "WithStatement":
				this.prewalkWithStatement(statement);
				break;
		}
	}

	walkStatement(statement) {
		if (this.hooks.statement.call(statement) !== undefined) return;
		switch (statement.type) {
			case "BlockStatement":
				this.walkBlockStatement(statement);
				break;
			case "ClassDeclaration":
				this.walkClassDeclaration(statement);
				break;
			case "DoWhileStatement":
				this.walkDoWhileStatement(statement);
				break;
			case "ExportDefaultDeclaration":
				this.walkExportDefaultDeclaration(statement);
				break;
			case "ExportNamedDeclaration":
				this.walkExportNamedDeclaration(statement);
				break;
			case "ExpressionStatement":
				this.walkExpressionStatement(statement);
				break;
			case "ForInStatement":
				this.walkForInStatement(statement);
				break;
			case "ForOfStatement":
				this.walkForOfStatement(statement);
				break;
			case "ForStatement":
				this.walkForStatement(statement);
				break;
			case "FunctionDeclaration":
				this.walkFunctionDeclaration(statement);
				break;
			case "IfStatement":
				this.walkIfStatement(statement);
				break;
			case "LabeledStatement":
				this.walkLabeledStatement(statement);
				break;
			case "ReturnStatement":
				this.walkReturnStatement(statement);
				break;
			case "SwitchStatement":
				this.walkSwitchStatement(statement);
				break;
			case "ThrowStatement":
				this.walkThrowStatement(statement);
				break;
			case "TryStatement":
				this.walkTryStatement(statement);
				break;
			case "VariableDeclaration":
				this.walkVariableDeclaration(statement);
				break;
			case "WhileStatement":
				this.walkWhileStatement(statement);
				break;
			case "WithStatement":
				this.walkWithStatement(statement);
				break;
		}
	}

	// Real Statements
	prewalkBlockStatement(statement) {
		this.prewalkStatements(statement.body);
	}

	walkBlockStatement(statement) {
		this.walkStatements(statement.body);
	}

	walkExpressionStatement(statement) {
		this.walkExpression(statement.expression);
	}

	prewalkIfStatement(statement) {
		this.prewalkStatement(statement.consequent);
		if (statement.alternate) {
			this.prewalkStatement(statement.alternate);
		}
	}

	walkIfStatement(statement) {
		const result = this.hooks.statementIf.call(statement);
		if (result === undefined) {
			this.walkExpression(statement.test);
			this.walkStatement(statement.consequent);
			if (statement.alternate) {
				this.walkStatement(statement.alternate);
			}
		} else {
			if (result) {
				this.walkStatement(statement.consequent);
			} else if (statement.alternate) {
				this.walkStatement(statement.alternate);
			}
		}
	}

	prewalkLabeledStatement(statement) {
		this.prewalkStatement(statement.body);
	}

	walkLabeledStatement(statement) {
		const hook = this.hooks.label.get(statement.label.name);
		if (hook !== undefined) {
			const result = hook.call(statement);
			if (result === true) return;
		}
		this.walkStatement(statement.body);
	}

	prewalkWithStatement(statement) {
		this.prewalkStatement(statement.body);
	}

	walkWithStatement(statement) {
		this.walkExpression(statement.object);
		this.walkStatement(statement.body);
	}

	prewalkSwitchStatement(statement) {
		this.prewalkSwitchCases(statement.cases);
	}

	walkSwitchStatement(statement) {
		this.walkExpression(statement.discriminant);
		this.walkSwitchCases(statement.cases);
	}

	walkTerminatingStatement(statement) {
		if (statement.argument) this.walkExpression(statement.argument);
	}

	walkReturnStatement(statement) {
		this.walkTerminatingStatement(statement);
	}

	walkThrowStatement(statement) {
		this.walkTerminatingStatement(statement);
	}

	prewalkTryStatement(statement) {
		this.prewalkStatement(statement.block);
	}

	walkTryStatement(statement) {
		if (this.scope.inTry) {
			this.walkStatement(statement.block);
		} else {
			this.scope.inTry = true;
			this.walkStatement(statement.block);
			this.scope.inTry = false;
		}
		if (statement.handler) this.walkCatchClause(statement.handler);
		if (statement.finalizer) this.walkStatement(statement.finalizer);
	}

	prewalkWhileStatement(statement) {
		this.prewalkStatement(statement.body);
	}

	walkWhileStatement(statement) {
		this.walkExpression(statement.test);
		this.walkStatement(statement.body);
	}

	prewalkDoWhileStatement(statement) {
		this.prewalkStatement(statement.body);
	}

	walkDoWhileStatement(statement) {
		this.walkStatement(statement.body);
		this.walkExpression(statement.test);
	}

	prewalkForStatement(statement) {
		if (statement.init) {
			if (statement.init.type === "VariableDeclaration") {
				this.prewalkStatement(statement.init);
			}
		}
		this.prewalkStatement(statement.body);
	}

	walkForStatement(statement) {
		if (statement.init) {
			if (statement.init.type === "VariableDeclaration") {
				this.walkStatement(statement.init);
			} else {
				this.walkExpression(statement.init);
			}
		}
		if (statement.test) {
			this.walkExpression(statement.test);
		}
		if (statement.update) {
			this.walkExpression(statement.update);
		}
		this.walkStatement(statement.body);
	}

	prewalkForInStatement(statement) {
		if (statement.left.type === "VariableDeclaration") {
			this.prewalkVariableDeclaration(statement.left);
		}
		this.prewalkStatement(statement.body);
	}

	walkForInStatement(statement) {
		if (statement.left.type === "VariableDeclaration") {
			this.walkVariableDeclaration(statement.left);
		} else {
			this.walkPattern(statement.left);
		}
		this.walkExpression(statement.right);
		this.walkStatement(statement.body);
	}

	prewalkForOfStatement(statement) {
		if (statement.left.type === "VariableDeclaration") {
			this.prewalkVariableDeclaration(statement.left);
		}
		this.prewalkStatement(statement.body);
	}

	walkForOfStatement(statement) {
		if (statement.left.type === "VariableDeclaration") {
			this.walkVariableDeclaration(statement.left);
		} else {
			this.walkPattern(statement.left);
		}
		this.walkExpression(statement.right);
		this.walkStatement(statement.body);
	}

	// Declarations
	prewalkFunctionDeclaration(statement) {
		if (statement.id) {
			this.scope.renames.set(statement.id.name, null);
			this.scope.definitions.add(statement.id.name);
		}
	}

	walkFunctionDeclaration(statement) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		this.inScope(statement.params, () => {
			for (const param of statement.params) {
				this.walkPattern(param);
			}
			if (statement.body.type === "BlockStatement") {
				this.detectStrictMode(statement.body.body);
				this.prewalkStatement(statement.body);
				this.walkStatement(statement.body);
			} else {
				this.walkExpression(statement.body);
			}
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	prewalkImportDeclaration(statement) {
		const source = statement.source.value;
		this.hooks.import.call(statement, source);
		for (const specifier of statement.specifiers) {
			const name = specifier.local.name;
			this.scope.renames.set(name, null);
			this.scope.definitions.add(name);
			switch (specifier.type) {
				case "ImportDefaultSpecifier":
					this.hooks.importSpecifier.call(statement, source, "default", name);
					break;
				case "ImportSpecifier":
					this.hooks.importSpecifier.call(
						statement,
						source,
						specifier.imported.name,
						name
					);
					break;
				case "ImportNamespaceSpecifier":
					this.hooks.importSpecifier.call(statement, source, null, name);
					break;
			}
		}
	}

	prewalkExportNamedDeclaration(statement) {
		let source;
		if (statement.source) {
			source = statement.source.value;
			this.hooks.exportImport.call(statement, source);
		} else {
			this.hooks.export.call(statement);
		}
		if (statement.declaration) {
			if (
				!this.hooks.exportDeclaration.call(statement, statement.declaration)
			) {
				const originalDefinitions = this.scope.definitions;
				const tracker = new TrackingSet(this.scope.definitions);
				this.scope.definitions = tracker;
				this.prewalkStatement(statement.declaration);
				const newDefs = Array.from(tracker.getAddedItems());
				this.scope.definitions = originalDefinitions;
				for (let index = newDefs.length - 1; index >= 0; index--) {
					const def = newDefs[index];
					this.hooks.exportSpecifier.call(statement, def, def, index);
				}
			}
		}
		if (statement.specifiers) {
			for (
				let specifierIndex = 0;
				specifierIndex < statement.specifiers.length;
				specifierIndex++
			) {
				const specifier = statement.specifiers[specifierIndex];
				switch (specifier.type) {
					case "ExportSpecifier": {
						const name = specifier.exported.name;
						if (source) {
							this.hooks.exportImportSpecifier.call(
								statement,
								source,
								specifier.local.name,
								name,
								specifierIndex
							);
						} else {
							this.hooks.exportSpecifier.call(
								statement,
								specifier.local.name,
								name,
								specifierIndex
							);
						}
						break;
					}
				}
			}
		}
	}

	walkExportNamedDeclaration(statement) {
		if (statement.declaration) {
			this.walkStatement(statement.declaration);
		}
	}

	prewalkExportDefaultDeclaration(statement) {
		if (statement.declaration.id) {
			const originalDefinitions = this.scope.definitions;
			const tracker = new TrackingSet(this.scope.definitions);
			this.scope.definitions = tracker;
			this.prewalkStatement(statement.declaration);
			const newDefs = Array.from(tracker.getAddedItems());
			this.scope.definitions = originalDefinitions;
			for (let index = 0, len = newDefs.length; index < len; index++) {
				const def = newDefs[index];
				this.hooks.exportSpecifier.call(statement, def, "default");
			}
		}
	}

	walkExportDefaultDeclaration(statement) {
		this.hooks.export.call(statement);
		if (
			statement.declaration.id &&
			statement.declaration.type !== "FunctionExpression" &&
			statement.declaration.type !== "ClassExpression"
		) {
			if (
				!this.hooks.exportDeclaration.call(statement, statement.declaration)
			) {
				this.walkStatement(statement.declaration);
			}
		} else {
			// Acorn parses `export default function() {}` as `FunctionDeclaration` and
			// `export default class {}` as `ClassDeclaration`, both with `id = null`.
			// These nodes must be treated as expressions.
			if (statement.declaration.type === "FunctionDeclaration") {
				this.walkFunctionDeclaration(statement.declaration);
			} else if (statement.declaration.type === "ClassDeclaration") {
				this.walkClassDeclaration(statement.declaration);
			} else {
				this.walkExpression(statement.declaration);
			}
			if (!this.hooks.exportExpression.call(statement, statement.declaration)) {
				this.hooks.exportSpecifier.call(
					statement,
					statement.declaration,
					"default"
				);
			}
		}
	}

	prewalkExportAllDeclaration(statement) {
		const source = statement.source.value;
		this.hooks.exportImport.call(statement, source);
		this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);
	}

	prewalkVariableDeclaration(statement) {
		const hookMap =
			statement.kind === "const"
				? this.hooks.varDeclarationConst
				: statement.kind === "let"
					? this.hooks.varDeclarationLet
					: this.hooks.varDeclarationVar;
		for (const declarator of statement.declarations) {
			switch (declarator.type) {
				case "VariableDeclarator": {
					this.enterPattern(declarator.id, (name, decl) => {
						let hook = hookMap.get(name);
						if (hook === undefined || !hook.call(decl)) {
							hook = this.hooks.varDeclaration.get(name);
							if (hook === undefined || !hook.call(decl)) {
								this.scope.renames.set(name, null);
								this.scope.definitions.add(name);
							}
						}
					});
					break;
				}
			}
		}
	}

	walkVariableDeclaration(statement) {
		for (const declarator of statement.declarations) {
			switch (declarator.type) {
				case "VariableDeclarator": {
					const renameIdentifier =
						declarator.init && this.getRenameIdentifier(declarator.init);
					if (renameIdentifier && declarator.id.type === "Identifier") {
						const hook = this.hooks.canRename.get(renameIdentifier);
						if (hook !== undefined && hook.call(declarator.init)) {
							// renaming with "var a = b;"
							const hook = this.hooks.rename.get(renameIdentifier);
							if (hook === undefined || !hook.call(declarator.init)) {
								this.scope.renames.set(
									declarator.id.name,
									this.scope.renames.get(renameIdentifier) || renameIdentifier
								);
								this.scope.definitions.delete(declarator.id.name);
							}
							break;
						}
					}
					this.walkPattern(declarator.id);
					if (declarator.init) this.walkExpression(declarator.init);
					break;
				}
			}
		}
	}

	prewalkClassDeclaration(statement) {
		if (statement.id) {
			this.scope.renames.set(statement.id.name, null);
			this.scope.definitions.add(statement.id.name);
		}
	}

	walkClassDeclaration(statement) {
		this.walkClass(statement);
	}

	prewalkSwitchCases(switchCases) {
		for (let index = 0, len = switchCases.length; index < len; index++) {
			const switchCase = switchCases[index];
			this.prewalkStatements(switchCase.consequent);
		}
	}

	walkSwitchCases(switchCases) {
		for (let index = 0, len = switchCases.length; index < len; index++) {
			const switchCase = switchCases[index];

			if (switchCase.test) {
				this.walkExpression(switchCase.test);
			}
			this.walkStatements(switchCase.consequent);
		}
	}

	walkCatchClause(catchClause) {
		// Error binding is optional in catch clause since ECMAScript 2019
		const errorBinding =
			catchClause.param === null ? EMPTY_ARRAY : [catchClause.param];

		this.inScope(errorBinding, () => {
			this.prewalkStatement(catchClause.body);
			this.walkStatement(catchClause.body);
		});
	}

	walkPattern(pattern) {
		switch (pattern.type) {
			case "ArrayPattern":
				this.walkArrayPattern(pattern);
				break;
			case "AssignmentPattern":
				this.walkAssignmentPattern(pattern);
				break;
			case "MemberExpression":
				this.walkMemberExpression(pattern);
				break;
			case "ObjectPattern":
				this.walkObjectPattern(pattern);
				break;
			case "RestElement":
				this.walkRestElement(pattern);
				break;
		}
	}

	walkAssignmentPattern(pattern) {
		this.walkExpression(pattern.right);
		this.walkPattern(pattern.left);
	}

	walkObjectPattern(pattern) {
		for (let i = 0, len = pattern.properties.length; i < len; i++) {
			const prop = pattern.properties[i];
			if (prop) {
				if (prop.computed) this.walkExpression(prop.key);
				if (prop.value) this.walkPattern(prop.value);
			}
		}
	}

	walkArrayPattern(pattern) {
		for (let i = 0, len = pattern.elements.length; i < len; i++) {
			const element = pattern.elements[i];
			if (element) this.walkPattern(element);
		}
	}

	walkRestElement(pattern) {
		this.walkPattern(pattern.argument);
	}

	walkExpressions(expressions) {
		for (const expression of expressions) {
			if (expression) {
				this.walkExpression(expression);
			}
		}
	}

	walkExpression(expression) {
		switch (expression.type) {
			case "ArrayExpression":
				this.walkArrayExpression(expression);
				break;
			case "ArrowFunctionExpression":
				this.walkArrowFunctionExpression(expression);
				break;
			case "AssignmentExpression":
				this.walkAssignmentExpression(expression);
				break;
			case "AwaitExpression":
				this.walkAwaitExpression(expression);
				break;
			case "BinaryExpression":
				this.walkBinaryExpression(expression);
				break;
			case "CallExpression":
				this.walkCallExpression(expression);
				break;
			case "ClassExpression":
				this.walkClassExpression(expression);
				break;
			case "ConditionalExpression":
				this.walkConditionalExpression(expression);
				break;
			case "FunctionExpression":
				this.walkFunctionExpression(expression);
				break;
			case "Identifier":
				this.walkIdentifier(expression);
				break;
			case "LogicalExpression":
				this.walkLogicalExpression(expression);
				break;
			case "MemberExpression":
				this.walkMemberExpression(expression);
				break;
			case "NewExpression":
				this.walkNewExpression(expression);
				break;
			case "ObjectExpression":
				this.walkObjectExpression(expression);
				break;
			case "SequenceExpression":
				this.walkSequenceExpression(expression);
				break;
			case "SpreadElement":
				this.walkSpreadElement(expression);
				break;
			case "TaggedTemplateExpression":
				this.walkTaggedTemplateExpression(expression);
				break;
			case "TemplateLiteral":
				this.walkTemplateLiteral(expression);
				break;
			case "ThisExpression":
				this.walkThisExpression(expression);
				break;
			case "UnaryExpression":
				this.walkUnaryExpression(expression);
				break;
			case "UpdateExpression":
				this.walkUpdateExpression(expression);
				break;
			case "YieldExpression":
				this.walkYieldExpression(expression);
				break;
		}
	}

	walkAwaitExpression(expression) {
		this.walkExpression(expression.argument);
	}

	walkArrayExpression(expression) {
		if (expression.elements) {
			this.walkExpressions(expression.elements);
		}
	}

	walkSpreadElement(expression) {
		if (expression.argument) {
			this.walkExpression(expression.argument);
		}
	}

	walkObjectExpression(expression) {
		for (
			let propIndex = 0, len = expression.properties.length;
			propIndex < len;
			propIndex++
		) {
			const prop = expression.properties[propIndex];
			if (prop.type === "SpreadElement") {
				this.walkExpression(prop.argument);
				continue;
			}
			if (prop.computed) {
				this.walkExpression(prop.key);
			}
			if (prop.shorthand) {
				this.scope.inShorthand = true;
			}
			this.walkExpression(prop.value);
			if (prop.shorthand) {
				this.scope.inShorthand = false;
			}
		}
	}

	walkFunctionExpression(expression) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		this.inScope(expression.params, () => {
			for (const param of expression.params) {
				this.walkPattern(param);
			}
			if (expression.body.type === "BlockStatement") {
				this.detectStrictMode(expression.body.body);
				this.prewalkStatement(expression.body);
				this.walkStatement(expression.body);
			} else {
				this.walkExpression(expression.body);
			}
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	walkArrowFunctionExpression(expression) {
		this.inScope(expression.params, () => {
			for (const param of expression.params) {
				this.walkPattern(param);
			}
			if (expression.body.type === "BlockStatement") {
				this.detectStrictMode(expression.body.body);
				this.prewalkStatement(expression.body);
				this.walkStatement(expression.body);
			} else {
				this.walkExpression(expression.body);
			}
		});
	}

	walkSequenceExpression(expression) {
		if (expression.expressions) this.walkExpressions(expression.expressions);
	}

	walkUpdateExpression(expression) {
		this.walkExpression(expression.argument);
	}

	walkUnaryExpression(expression) {
		if (expression.operator === "typeof") {
			const exprName = this.getNameForExpression(expression.argument);
			if (exprName && exprName.free) {
				const hook = this.hooks.typeof.get(exprName.name);
				if (hook !== undefined) {
					const result = hook.call(expression);
					if (result === true) return;
				}
			}
		}
		this.walkExpression(expression.argument);
	}

	walkLeftRightExpression(expression) {
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	}

	walkBinaryExpression(expression) {
		this.walkLeftRightExpression(expression);
	}

	walkLogicalExpression(expression) {
		const result = this.hooks.expressionLogicalOperator.call(expression);
		if (result === undefined) {
			this.walkLeftRightExpression(expression);
		} else {
			if (result) {
				this.walkExpression(expression.right);
			}
		}
	}

	walkAssignmentExpression(expression) {
		const renameIdentifier = this.getRenameIdentifier(expression.right);
		if (expression.left.type === "Identifier" && renameIdentifier) {
			const hook = this.hooks.canRename.get(renameIdentifier);
			if (hook !== undefined && hook.call(expression.right)) {
				// renaming "a = b;"
				const hook = this.hooks.rename.get(renameIdentifier);
				if (hook === undefined || !hook.call(expression.right)) {
					this.scope.renames.set(expression.left.name, renameIdentifier);
					this.scope.definitions.delete(expression.left.name);
				}
				return;
			}
		}
		if (expression.left.type === "Identifier") {
			const assignedHook = this.hooks.assigned.get(expression.left.name);
			if (assignedHook === undefined || !assignedHook.call(expression)) {
				this.walkExpression(expression.right);
			}
			this.scope.renames.set(expression.left.name, null);
			const assignHook = this.hooks.assign.get(expression.left.name);
			if (assignHook === undefined || !assignHook.call(expression)) {
				this.walkExpression(expression.left);
			}
			return;
		}
		this.walkExpression(expression.right);
		this.walkPattern(expression.left);
		this.enterPattern(expression.left, (name, decl) => {
			this.scope.renames.set(name, null);
		});
	}

	walkConditionalExpression(expression) {
		const result = this.hooks.expressionConditionalOperator.call(expression);
		if (result === undefined) {
			this.walkExpression(expression.test);
			this.walkExpression(expression.consequent);
			if (expression.alternate) {
				this.walkExpression(expression.alternate);
			}
		} else {
			if (result) {
				this.walkExpression(expression.consequent);
			} else if (expression.alternate) {
				this.walkExpression(expression.alternate);
			}
		}
	}

	walkNewExpression(expression) {
		const callee = this.evaluateExpression(expression.callee);
		if (callee.isIdentifier()) {
			const hook = this.hooks.new.get(callee.identifier);
			if (hook !== undefined) {
				const result = hook.call(expression);
				if (result === true) {
					return;
				}
			}
		}

		this.walkExpression(expression.callee);
		if (expression.arguments) {
			this.walkExpressions(expression.arguments);
		}
	}

	walkYieldExpression(expression) {
		if (expression.argument) {
			this.walkExpression(expression.argument);
		}
	}

	walkTemplateLiteral(expression) {
		if (expression.expressions) {
			this.walkExpressions(expression.expressions);
		}
	}

	walkTaggedTemplateExpression(expression) {
		if (expression.tag) {
			this.walkExpression(expression.tag);
		}
		if (expression.quasi && expression.quasi.expressions) {
			this.walkExpressions(expression.quasi.expressions);
		}
	}

	walkClassExpression(expression) {
		this.walkClass(expression);
	}

	_walkIIFE(functionExpression, options, currentThis) {
		const renameArgOrThis = argOrThis => {
			const renameIdentifier = this.getRenameIdentifier(argOrThis);
			if (renameIdentifier) {
				const hook = this.hooks.canRename.get(renameIdentifier);
				if (hook !== undefined && hook.call(argOrThis)) {
					const hook = this.hooks.rename.get(renameIdentifier);
					if (hook === undefined || !hook.call(argOrThis)) {
						return renameIdentifier;
					}
				}
			}
			this.walkExpression(argOrThis);
		};
		const params = functionExpression.params;
		const renameThis = currentThis ? renameArgOrThis(currentThis) : null;
		const args = options.map(renameArgOrThis);
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		this.inScope(params.filter((identifier, idx) => !args[idx]), () => {
			if (renameThis) {
				this.scope.renames.set("this", renameThis);
			}
			for (let i = 0; i < args.length; i++) {
				const param = args[i];
				if (!param) continue;
				if (!params[i] || params[i].type !== "Identifier") continue;
				this.scope.renames.set(params[i].name, param);
			}
			if (functionExpression.body.type === "BlockStatement") {
				this.prewalkStatement(functionExpression.body);
				this.walkStatement(functionExpression.body);
			} else {
				this.walkExpression(functionExpression.body);
			}
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	walkCallExpression(expression) {
		if (
			expression.callee.type === "MemberExpression" &&
			expression.callee.object.type === "FunctionExpression" &&
			!expression.callee.computed &&
			(expression.callee.property.name === "call" ||
				expression.callee.property.name === "bind") &&
			expression.arguments.length > 0
		) {
			// (function(…) { }.call/bind(?, …))
			this._walkIIFE(
				expression.callee.object,
				expression.arguments.slice(1),
				expression.arguments[0]
			);
		} else if (expression.callee.type === "FunctionExpression") {
			// (function(…) { }(…))
			this._walkIIFE(expression.callee, expression.arguments, null);
		} else if (expression.callee.type === "Import") {
			let result = this.hooks.importCall.call(expression);
			if (result === true) return;

			if (expression.arguments) this.walkExpressions(expression.arguments);
		} else {
			const callee = this.evaluateExpression(expression.callee);
			if (callee.isIdentifier()) {
				const callHook = this.hooks.call.get(callee.identifier);
				if (callHook !== undefined) {
					let result = callHook.call(expression);
					if (result === true) return;
				}
				let identifier = callee.identifier.replace(/\.[^.]+$/, "");
				if (identifier !== callee.identifier) {
					const callAnyHook = this.hooks.callAnyMember.get(identifier);
					if (callAnyHook !== undefined) {
						let result = callAnyHook.call(expression);
						if (result === true) return;
					}
				}
			}

			if (expression.callee) this.walkExpression(expression.callee);
			if (expression.arguments) this.walkExpressions(expression.arguments);
		}
	}

	walkMemberExpression(expression) {
		const exprName = this.getNameForExpression(expression);
		if (exprName && exprName.free) {
			const expressionHook = this.hooks.expression.get(exprName.name);
			if (expressionHook !== undefined) {
				const result = expressionHook.call(expression);
				if (result === true) return;
			}
			const expressionAnyMemberHook = this.hooks.expressionAnyMember.get(
				exprName.nameGeneral
			);
			if (expressionAnyMemberHook !== undefined) {
				const result = expressionAnyMemberHook.call(expression);
				if (result === true) return;
			}
		}
		this.walkExpression(expression.object);
		if (expression.computed === true) this.walkExpression(expression.property);
	}

	walkThisExpression(expression) {
		const expressionHook = this.hooks.expression.get("this");
		if (expressionHook !== undefined) {
			expressionHook.call(expression);
		}
	}

	walkIdentifier(expression) {
		if (!this.scope.definitions.has(expression.name)) {
			const hook = this.hooks.expression.get(
				this.scope.renames.get(expression.name) || expression.name
			);
			if (hook !== undefined) {
				const result = hook.call(expression);
				if (result === true) return;
			}
		}
	}

	inScope(params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			isStrict: oldScope.isStrict,
			definitions: oldScope.definitions.createChild(),
			renames: oldScope.renames.createChild()
		};

		this.scope.renames.set("this", null);

		for (const param of params) {
			if (typeof param !== "string") {
				this.enterPattern(param, param => {
					this.scope.renames.set(param, null);
					this.scope.definitions.add(param);
				});
			} else if (param) {
				this.scope.renames.set(param, null);
				this.scope.definitions.add(param);
			}
		}

		fn();
		this.scope = oldScope;
	}

	detectStrictMode(statements) {
		const isStrict =
			statements.length >= 1 &&
			statements[0].type === "ExpressionStatement" &&
			statements[0].expression.type === "Literal" &&
			statements[0].expression.value === "use strict";
		if (isStrict) {
			this.scope.isStrict = true;
		}
	}

	enterPattern(pattern, onIdent) {
		if (!pattern) return;
		switch (pattern.type) {
			case "ArrayPattern":
				this.enterArrayPattern(pattern, onIdent);
				break;
			case "AssignmentPattern":
				this.enterAssignmentPattern(pattern, onIdent);
				break;
			case "Identifier":
				this.enterIdentifier(pattern, onIdent);
				break;
			case "ObjectPattern":
				this.enterObjectPattern(pattern, onIdent);
				break;
			case "RestElement":
				this.enterRestElement(pattern, onIdent);
				break;
		}
	}

	enterIdentifier(pattern, onIdent) {
		onIdent(pattern.name, pattern);
	}

	enterObjectPattern(pattern, onIdent) {
		for (
			let propIndex = 0, len = pattern.properties.length;
			propIndex < len;
			propIndex++
		) {
			const prop = pattern.properties[propIndex];
			this.enterPattern(prop.value, onIdent);
		}
	}

	enterArrayPattern(pattern, onIdent) {
		for (
			let elementIndex = 0, len = pattern.elements.length;
			elementIndex < len;
			elementIndex++
		) {
			const element = pattern.elements[elementIndex];
			this.enterPattern(element, onIdent);
		}
	}

	enterRestElement(pattern, onIdent) {
		this.enterPattern(pattern.argument, onIdent);
	}

	enterAssignmentPattern(pattern, onIdent) {
		this.enterPattern(pattern.left, onIdent);
	}

	evaluateExpression(expression) {
		try {
			const hook = this.hooks.evaluate.get(expression.type);
			if (hook !== undefined) {
				const result = hook.call(expression);
				if (result !== undefined) {
					if (result) {
						result.setExpression(expression);
					}
					return result;
				}
			}
		} catch (e) {
			console.warn(e);
			// ignore error
		}
		return new BasicEvaluatedExpression()
			.setRange(expression.range)
			.setExpression(expression);
	}

	parseString(expression) {
		switch (expression.type) {
			case "BinaryExpression":
				if (expression.operator === "+") {
					return (
						this.parseString(expression.left) +
						this.parseString(expression.right)
					);
				}
				break;
			case "Literal":
				return expression.value + "";
		}
		throw new Error(
			expression.type + " is not supported as parameter for require"
		);
	}

	parseCalculatedString(expression) {
		switch (expression.type) {
			case "BinaryExpression":
				if (expression.operator === "+") {
					const left = this.parseCalculatedString(expression.left);
					const right = this.parseCalculatedString(expression.right);
					if (left.code) {
						return {
							range: left.range,
							value: left.value,
							code: true,
							conditional: false
						};
					} else if (right.code) {
						return {
							range: [
								left.range[0],
								right.range ? right.range[1] : left.range[1]
							],
							value: left.value + right.value,
							code: true,
							conditional: false
						};
					} else {
						return {
							range: [left.range[0], right.range[1]],
							value: left.value + right.value,
							code: false,
							conditional: false
						};
					}
				}
				break;
			case "ConditionalExpression": {
				const consequent = this.parseCalculatedString(expression.consequent);
				const alternate = this.parseCalculatedString(expression.alternate);
				const items = [];
				if (consequent.conditional) {
					items.push(...consequent.conditional);
				} else if (!consequent.code) {
					items.push(consequent);
				} else {
					break;
				}
				if (alternate.conditional) {
					items.push(...alternate.conditional);
				} else if (!alternate.code) {
					items.push(alternate);
				} else {
					break;
				}
				return {
					range: undefined,
					value: "",
					code: true,
					conditional: items
				};
			}
			case "Literal":
				return {
					range: expression.range,
					value: expression.value + "",
					code: false,
					conditional: false
				};
		}
		return {
			range: undefined,
			value: "",
			code: true,
			conditional: false
		};
	}

	parse(source, initialState) {
		let ast;
		let comments;
		if (typeof source === "object" && source !== null) {
			ast = source;
			comments = source.comments;
		} else {
			comments = [];
			ast = Parser.parse(source, {
				sourceType: this.sourceType,
				onComment: comments
			});
		}

		const oldScope = this.scope;
		const oldState = this.state;
		const oldComments = this.comments;
		this.scope = {
			topLevelScope: true,
			inTry: false,
			inShorthand: false,
			isStrict: false,
			definitions: new StackedSetMap(),
			renames: new StackedSetMap()
		};
		const state = (this.state = initialState || {});
		this.comments = comments;
		if (this.hooks.program.call(ast, comments) === undefined) {
			this.detectStrictMode(ast.body);
			this.prewalkStatements(ast.body);
			this.walkStatements(ast.body);
		}
		this.scope = oldScope;
		this.state = oldState;
		this.comments = oldComments;
		return state;
	}

	evaluate(source) {
		const ast = Parser.parse("(" + source + ")", {
			sourceType: this.sourceType,
			locations: false
		});
		// TODO(https://github.com/acornjs/acorn/issues/741)
		// @ts-ignore
		if (ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement") {
			throw new Error("evaluate: Source is not a expression");
		}
		// TODO(https://github.com/acornjs/acorn/issues/741)
		// @ts-ignore
		return this.evaluateExpression(ast.body[0].expression);
	}

	getComments(range) {
		return this.comments.filter(
			comment => comment.range[0] >= range[0] && comment.range[1] <= range[1]
		);
	}

	parseCommentOptions(range) {
		const comments = this.getComments(range);
		if (comments.length === 0) {
			return EMPTY_COMMENT_OPTIONS;
		}
		let options = {};
		let errors = [];
		for (const comment of comments) {
			const { value } = comment;
			if (value && webpackCommentRegExp.test(value)) {
				// try compile only if webpack options comment is present
				try {
					const val = vm.runInNewContext(`(function(){return {${value}};})()`);
					Object.assign(options, val);
				} catch (e) {
					e.comment = comment;
					errors.push(e);
				}
			}
		}
		return { options, errors };
	}

	getNameForExpression(expression) {
		let expr = expression;
		const exprName = [];
		while (
			expr.type === "MemberExpression" &&
			expr.property.type === (expr.computed ? "Literal" : "Identifier")
		) {
			exprName.push(expr.computed ? expr.property.value : expr.property.name);
			expr = expr.object;
		}
		let free;
		if (expr.type === "Identifier") {
			free = !this.scope.definitions.has(expr.name);
			exprName.push(this.scope.renames.get(expr.name) || expr.name);
		} else if (
			expr.type === "ThisExpression" &&
			this.scope.renames.get("this")
		) {
			free = true;
			exprName.push(this.scope.renames.get("this"));
		} else if (expr.type === "ThisExpression") {
			free = this.scope.topLevelScope;
			exprName.push("this");
		} else {
			return null;
		}
		let prefix = "";
		for (let i = exprName.length - 1; i >= 2; i--) {
			prefix += exprName[i] + ".";
		}
		if (exprName.length > 1) {
			prefix += exprName[1];
		}
		const name = prefix ? prefix + "." + exprName[0] : exprName[0];
		const nameGeneral = prefix;
		return {
			name,
			nameGeneral,
			free
		};
	}

	static parse(code, options) {
		const type = options ? options.sourceType : "module";
		const parserOptions = Object.assign(
			Object.create(null),
			defaultParserOptions,
			options
		);

		if (type === "auto") {
			parserOptions.sourceType = "module";
		}

		let ast;
		let error;
		let threw = false;
		try {
			ast = acornParser.parse(code, parserOptions);
		} catch (e) {
			error = e;
			threw = true;
		}

		if (threw && type === "auto") {
			parserOptions.sourceType = "script";
			if (Array.isArray(parserOptions.onComment)) {
				parserOptions.onComment.length = 0;
			}
			try {
				ast = acornParser.parse(code, parserOptions);
				threw = false;
			} catch (e) {
				threw = true;
			}
		}

		if (threw) {
			throw error;
		}

		return ast;
	}
}

// TODO remove in webpack 5
Object.defineProperty(Parser.prototype, "getCommentOptions", {
	configurable: false,
	value: util.deprecate(
		/**
		 * @deprecated
		 * @param {TODO} range Range
		 * @returns {void}
		 * @this {Parser}
		 */
		function(range) {
			return this.parseCommentOptions(range).options;
		},
		"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead"
	)
});

module.exports = Parser;


/***/ }),

/***/ "./node_modules/webpack/lib/ParserHelpers.js":
/*!**************************************!*\
  !*** (webpack)/lib/ParserHelpers.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const path = __webpack_require__(/*! path */ "path");

const BasicEvaluatedExpression = __webpack_require__(/*! ./BasicEvaluatedExpression */ "./node_modules/webpack/lib/BasicEvaluatedExpression.js");
const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const UnsupportedFeatureWarning = __webpack_require__(/*! ./UnsupportedFeatureWarning */ "./node_modules/webpack/lib/UnsupportedFeatureWarning.js");

const ParserHelpers = exports;

ParserHelpers.addParsedVariableToModule = (parser, name, expression) => {
	if (!parser.state.current.addVariable) return false;
	var deps = [];
	parser.parse(expression, {
		current: {
			addDependency: dep => {
				dep.userRequest = name;
				deps.push(dep);
			}
		},
		module: parser.state.module
	});
	parser.state.current.addVariable(name, expression, deps);
	return true;
};

ParserHelpers.requireFileAsExpression = (context, pathToModule) => {
	var moduleJsPath = path.relative(context, pathToModule);
	if (!/^[A-Z]:/i.test(moduleJsPath)) {
		moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/");
	}
	return "require(" + JSON.stringify(moduleJsPath) + ")";
};

ParserHelpers.toConstantDependency = (parser, value) => {
	return function constDependency(expr) {
		var dep = new ConstDependency(value, expr.range, false);
		dep.loc = expr.loc;
		parser.state.current.addDependency(dep);
		return true;
	};
};

ParserHelpers.toConstantDependencyWithWebpackRequire = (parser, value) => {
	return function constDependencyWithWebpackRequire(expr) {
		var dep = new ConstDependency(value, expr.range, true);
		dep.loc = expr.loc;
		parser.state.current.addDependency(dep);
		return true;
	};
};

ParserHelpers.evaluateToString = value => {
	return function stringExpression(expr) {
		return new BasicEvaluatedExpression().setString(value).setRange(expr.range);
	};
};

ParserHelpers.evaluateToBoolean = value => {
	return function booleanExpression(expr) {
		return new BasicEvaluatedExpression()
			.setBoolean(value)
			.setRange(expr.range);
	};
};

ParserHelpers.evaluateToIdentifier = (identifier, truthy) => {
	return function identifierExpression(expr) {
		let evex = new BasicEvaluatedExpression()
			.setIdentifier(identifier)
			.setRange(expr.range);
		if (truthy === true) {
			evex = evex.setTruthy();
		} else if (truthy === false) {
			evex = evex.setFalsy();
		}
		return evex;
	};
};

ParserHelpers.expressionIsUnsupported = (parser, message) => {
	return function unsupportedExpression(expr) {
		var dep = new ConstDependency("(void 0)", expr.range, false);
		dep.loc = expr.loc;
		parser.state.current.addDependency(dep);
		if (!parser.state.module) return;
		parser.state.module.warnings.push(
			new UnsupportedFeatureWarning(parser.state.module, message, expr.loc)
		);
		return true;
	};
};

ParserHelpers.skipTraversal = function skipTraversal() {
	return true;
};

ParserHelpers.approve = function approve() {
	return true;
};


/***/ }),

/***/ "./node_modules/webpack/lib/PrefetchPlugin.js":
/*!***************************************!*\
  !*** (webpack)/lib/PrefetchPlugin.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const PrefetchDependency = __webpack_require__(/*! ./dependencies/PrefetchDependency */ "./node_modules/webpack/lib/dependencies/PrefetchDependency.js");

class PrefetchPlugin {
	constructor(context, request) {
		if (!request) {
			this.request = context;
		} else {
			this.context = context;
			this.request = request;
		}
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"PrefetchPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					PrefetchDependency,
					normalModuleFactory
				);
			}
		);
		compiler.hooks.make.tapAsync("PrefetchPlugin", (compilation, callback) => {
			compilation.prefetch(
				this.context || compiler.context,
				new PrefetchDependency(this.request),
				callback
			);
		});
	}
}
module.exports = PrefetchPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ProgressPlugin.js":
/*!***************************************!*\
  !*** (webpack)/lib/ProgressPlugin.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/ProgressPlugin.json */ "./node_modules/webpack/schemas/plugins/ProgressPlugin.json");

/** @typedef {import("../declarations/plugins/ProgressPlugin").ProgressPluginArgument} ProgressPluginArgument */
/** @typedef {import("../declarations/plugins/ProgressPlugin").ProgressPluginOptions} ProgressPluginOptions */

const createDefaultHandler = profile => {
	let lineCaretPosition = 0;
	let lastMessage = "";
	let lastState;
	let lastStateTime;

	const defaultHandler = (percentage, msg, ...args) => {
		let state = msg;
		const details = args;
		if (percentage < 1) {
			percentage = Math.floor(percentage * 100);
			msg = `${percentage}% ${msg}`;
			if (percentage < 100) {
				msg = ` ${msg}`;
			}
			if (percentage < 10) {
				msg = ` ${msg}`;
			}
			for (let detail of details) {
				if (!detail) continue;
				if (detail.length > 40) {
					detail = `...${detail.substr(detail.length - 39)}`;
				}
				msg += ` ${detail}`;
			}
		}
		if (profile) {
			state = state.replace(/^\d+\/\d+\s+/, "");
			if (percentage === 0) {
				lastState = null;
				lastStateTime = Date.now();
			} else if (state !== lastState || percentage === 1) {
				const now = Date.now();
				if (lastState) {
					const stateMsg = `${now - lastStateTime}ms ${lastState}`;
					goToLineStart(stateMsg);
					process.stderr.write(stateMsg + "\n");
					lineCaretPosition = 0;
				}
				lastState = state;
				lastStateTime = now;
			}
		}
		if (lastMessage !== msg) {
			goToLineStart(msg);
			process.stderr.write(msg);
			lastMessage = msg;
		}
	};

	const goToLineStart = nextMessage => {
		let str = "";
		for (; lineCaretPosition > nextMessage.length; lineCaretPosition--) {
			str += "\b \b";
		}
		for (var i = 0; i < lineCaretPosition; i++) {
			str += "\b";
		}
		lineCaretPosition = nextMessage.length;
		if (str) process.stderr.write(str);
	};

	return defaultHandler;
};

class ProgressPlugin {
	/**
	 * @param {ProgressPluginArgument} options options
	 */
	constructor(options) {
		if (typeof options === "function") {
			options = {
				handler: options
			};
		}

		options = options || {};
		validateOptions(schema, options, "Progress Plugin");
		options = Object.assign({}, ProgressPlugin.defaultOptions, options);

		this.profile = options.profile;
		this.handler = options.handler;
		this.modulesCount = options.modulesCount;
		this.showEntries = options.entries;
		this.showModules = options.modules;
		this.showActiveModules = options.activeModules;
	}

	apply(compiler) {
		const { modulesCount } = this;
		const handler = this.handler || createDefaultHandler(this.profile);
		const showEntries = this.showEntries;
		const showModules = this.showModules;
		const showActiveModules = this.showActiveModules;
		if (compiler.compilers) {
			const states = new Array(compiler.compilers.length);
			compiler.compilers.forEach((compiler, idx) => {
				new ProgressPlugin((p, msg, ...args) => {
					states[idx] = [p, msg, ...args];
					handler(
						states
							.map(state => (state && state[0]) || 0)
							.reduce((a, b) => a + b) / states.length,
						`[${idx}] ${msg}`,
						...args
					);
				}).apply(compiler);
			});
		} else {
			let lastModulesCount = 0;
			let lastEntriesCount = 0;
			let moduleCount = modulesCount;
			let entriesCount = 1;
			let doneModules = 0;
			let doneEntries = 0;
			const activeModules = new Set();
			let lastActiveModule = "";

			const update = () => {
				const percentByModules =
					doneModules / Math.max(lastModulesCount, moduleCount);
				const percentByEntries =
					doneEntries / Math.max(lastEntriesCount, entriesCount);

				const items = [
					0.1 + Math.max(percentByModules, percentByEntries) * 0.6,
					"building"
				];
				if (showEntries) {
					items.push(`${doneEntries}/${entriesCount} entries`);
				}
				if (showModules) {
					items.push(`${doneModules}/${moduleCount} modules`);
				}
				if (showActiveModules) {
					items.push(`${activeModules.size} active`);
					items.push(lastActiveModule);
				}
				handler(...items);
			};

			const moduleAdd = module => {
				moduleCount++;
				if (showActiveModules) {
					const ident = module.identifier();
					if (ident) {
						activeModules.add(ident);
						lastActiveModule = ident;
					}
				}
				update();
			};

			const entryAdd = (entry, name) => {
				entriesCount++;
				update();
			};

			const moduleDone = module => {
				doneModules++;
				if (showActiveModules) {
					const ident = module.identifier();
					if (ident) {
						activeModules.delete(ident);
						if (lastActiveModule === ident) {
							lastActiveModule = "";
							for (const m of activeModules) {
								lastActiveModule = m;
							}
						}
					}
				}
				update();
			};

			const entryDone = (entry, name) => {
				doneEntries++;
				update();
			};

			compiler.hooks.compilation.tap("ProgressPlugin", compilation => {
				if (compilation.compiler.isChild()) return;
				lastModulesCount = moduleCount;
				lastEntriesCount = entriesCount;
				moduleCount = entriesCount = 0;
				doneModules = doneEntries = 0;
				handler(0, "compiling");

				compilation.hooks.buildModule.tap("ProgressPlugin", moduleAdd);
				compilation.hooks.failedModule.tap("ProgressPlugin", moduleDone);
				compilation.hooks.succeedModule.tap("ProgressPlugin", moduleDone);

				compilation.hooks.addEntry.tap("ProgressPlugin", entryAdd);
				compilation.hooks.failedEntry.tap("ProgressPlugin", entryDone);
				compilation.hooks.succeedEntry.tap("ProgressPlugin", entryDone);

				const hooks = {
					finishModules: "finish module graph",
					seal: "sealing",
					beforeChunks: "chunk graph",
					afterChunks: "after chunk graph",
					optimizeDependenciesBasic: "basic dependencies optimization",
					optimizeDependencies: "dependencies optimization",
					optimizeDependenciesAdvanced: "advanced dependencies optimization",
					afterOptimizeDependencies: "after dependencies optimization",
					optimize: "optimizing",
					optimizeModulesBasic: "basic module optimization",
					optimizeModules: "module optimization",
					optimizeModulesAdvanced: "advanced module optimization",
					afterOptimizeModules: "after module optimization",
					optimizeChunksBasic: "basic chunk optimization",
					optimizeChunks: "chunk optimization",
					optimizeChunksAdvanced: "advanced chunk optimization",
					afterOptimizeChunks: "after chunk optimization",
					optimizeTree: "module and chunk tree optimization",
					afterOptimizeTree: "after module and chunk tree optimization",
					optimizeChunkModulesBasic: "basic chunk modules optimization",
					optimizeChunkModules: "chunk modules optimization",
					optimizeChunkModulesAdvanced: "advanced chunk modules optimization",
					afterOptimizeChunkModules: "after chunk modules optimization",
					reviveModules: "module reviving",
					optimizeModuleOrder: "module order optimization",
					advancedOptimizeModuleOrder: "advanced module order optimization",
					beforeModuleIds: "before module ids",
					moduleIds: "module ids",
					optimizeModuleIds: "module id optimization",
					afterOptimizeModuleIds: "module id optimization",
					reviveChunks: "chunk reviving",
					optimizeChunkOrder: "chunk order optimization",
					beforeChunkIds: "before chunk ids",
					optimizeChunkIds: "chunk id optimization",
					afterOptimizeChunkIds: "after chunk id optimization",
					recordModules: "record modules",
					recordChunks: "record chunks",
					beforeHash: "hashing",
					contentHash: "content hashing",
					afterHash: "after hashing",
					recordHash: "record hash",
					beforeModuleAssets: "module assets processing",
					beforeChunkAssets: "chunk assets processing",
					additionalChunkAssets: "additional chunk assets processing",
					record: "recording",
					additionalAssets: "additional asset processing",
					optimizeChunkAssets: "chunk asset optimization",
					afterOptimizeChunkAssets: "after chunk asset optimization",
					optimizeAssets: "asset optimization",
					afterOptimizeAssets: "after asset optimization",
					afterSeal: "after seal"
				};
				const numberOfHooks = Object.keys(hooks).length;
				Object.keys(hooks).forEach((name, idx) => {
					const title = hooks[name];
					const percentage = (idx / numberOfHooks) * 0.25 + 0.7;
					compilation.hooks[name].intercept({
						name: "ProgressPlugin",
						context: true,
						call: () => {
							handler(percentage, title);
						},
						tap: (context, tap) => {
							if (context) {
								// p is percentage from 0 to 1
								// args is any number of messages in a hierarchical matter
								context.reportProgress = (p, ...args) => {
									handler(percentage, title, tap.name, ...args);
								};
							}
							handler(percentage, title, tap.name);
						}
					});
				});
			});
			compiler.hooks.emit.intercept({
				name: "ProgressPlugin",
				context: true,
				call: () => {
					handler(0.95, "emitting");
				},
				tap: (context, tap) => {
					if (context) {
						context.reportProgress = (p, ...args) => {
							handler(0.95, "emitting", tap.name, ...args);
						};
					}
					handler(0.95, "emitting", tap.name);
				}
			});
			compiler.hooks.afterEmit.intercept({
				name: "ProgressPlugin",
				context: true,
				call: () => {
					handler(0.98, "after emitting");
				},
				tap: (context, tap) => {
					if (context) {
						context.reportProgress = (p, ...args) => {
							handler(0.98, "after emitting", tap.name, ...args);
						};
					}
					handler(0.98, "after emitting", tap.name);
				}
			});
			compiler.hooks.done.tap("ProgressPlugin", () => {
				handler(1, "");
			});
		}
	}
}

ProgressPlugin.defaultOptions = {
	profile: false,
	modulesCount: 500,
	modules: true,
	activeModules: true,
	// TODO webpack 5 default this to true
	entries: false
};

module.exports = ProgressPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/ProvidePlugin.js":
/*!**************************************!*\
  !*** (webpack)/lib/ProvidePlugin.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ParserHelpers = __webpack_require__(/*! ./ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");
const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");

const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

class ProvidePlugin {
	constructor(definitions) {
		this.definitions = definitions;
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.hooks.compilation.tap(
			"ProvidePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);
				const handler = (parser, parserOptions) => {
					Object.keys(definitions).forEach(name => {
						var request = [].concat(definitions[name]);
						var splittedName = name.split(".");
						if (splittedName.length > 0) {
							splittedName.slice(1).forEach((_, i) => {
								const name = splittedName.slice(0, i + 1).join(".");
								parser.hooks.canRename
									.for(name)
									.tap("ProvidePlugin", ParserHelpers.approve);
							});
						}
						parser.hooks.expression.for(name).tap("ProvidePlugin", expr => {
							let nameIdentifier = name;
							const scopedName = name.includes(".");
							let expression = `require(${JSON.stringify(request[0])})`;
							if (scopedName) {
								nameIdentifier = `__webpack_provided_${name.replace(
									/\./g,
									"_dot_"
								)}`;
							}
							if (request.length > 1) {
								expression += request
									.slice(1)
									.map(r => `[${JSON.stringify(r)}]`)
									.join("");
							}
							if (
								!ParserHelpers.addParsedVariableToModule(
									parser,
									nameIdentifier,
									expression
								)
							) {
								return false;
							}
							if (scopedName) {
								ParserHelpers.toConstantDependency(parser, nameIdentifier)(
									expr
								);
							}
							return true;
						});
					});
				};
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ProvidePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ProvidePlugin", handler);

				// Disable ProvidePlugin for javascript/esm, see https://github.com/webpack/webpack/issues/7032
			}
		);
	}
}
module.exports = ProvidePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/RawModule.js":
/*!**********************************!*\
  !*** (webpack)/lib/RawModule.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Module = __webpack_require__(/*! ./Module */ "./node_modules/webpack/lib/Module.js");
const { OriginalSource, RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

module.exports = class RawModule extends Module {
	constructor(source, identifier, readableIdentifier) {
		super("javascript/dynamic", null);
		this.sourceStr = source;
		this.identifierStr = identifier || this.sourceStr;
		this.readableIdentifierStr = readableIdentifier || this.identifierStr;
		this.built = false;
	}

	identifier() {
		return this.identifierStr;
	}

	size() {
		return this.sourceStr.length;
	}

	readableIdentifier(requestShortener) {
		return requestShortener.shorten(this.readableIdentifierStr);
	}

	needRebuild() {
		return false;
	}

	build(options, compilations, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {
			cacheable: true
		};
		callback();
	}

	source() {
		if (this.useSourceMap) {
			return new OriginalSource(this.sourceStr, this.identifier());
		} else {
			return new RawSource(this.sourceStr);
		}
	}

	updateHash(hash) {
		hash.update(this.sourceStr);
		super.updateHash(hash);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/RecordIdsPlugin.js":
/*!****************************************!*\
  !*** (webpack)/lib/RecordIdsPlugin.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const identifierUtils = __webpack_require__(/*! ./util/identifier */ "./node_modules/webpack/lib/util/identifier.js");

/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./Module")} Module */

/**
 * @typedef {Object} RecordsChunks
 * @property {Record<string, number>=} byName
 * @property {Record<string, number>=} bySource
 * @property {number[]=} usedIds
 */

/**
 * @typedef {Object} RecordsModules
 * @property {Record<string, number>=} byIdentifier
 * @property {Record<string, number>=} bySource
 * @property {Record<number, number>=} usedIds
 */

/**
 * @typedef {Object} Records
 * @property {RecordsChunks=} chunks
 * @property {RecordsModules=} modules
 */

class RecordIdsPlugin {
	/**
	 * @param {Object} options Options object
	 * @param {boolean=} options.portableIds true, when ids need to be portable
	 */
	constructor(options) {
		this.options = options || {};
	}

	/**
	 * @param {Compiler} compiler the Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		const portableIds = this.options.portableIds;
		compiler.hooks.compilation.tap("RecordIdsPlugin", compilation => {
			compilation.hooks.recordModules.tap(
				"RecordIdsPlugin",
				/**
				 * @param {Module[]} modules the modules array
				 * @param {Records} records the records object
				 * @returns {void}
				 */
				(modules, records) => {
					if (!records.modules) records.modules = {};
					if (!records.modules.byIdentifier) records.modules.byIdentifier = {};
					if (!records.modules.usedIds) records.modules.usedIds = {};
					for (const module of modules) {
						if (typeof module.id !== "number") continue;
						const identifier = portableIds
							? identifierUtils.makePathsRelative(
									compiler.context,
									module.identifier(),
									compilation.cache
							  )
							: module.identifier();
						records.modules.byIdentifier[identifier] = module.id;
						records.modules.usedIds[module.id] = module.id;
					}
				}
			);
			compilation.hooks.reviveModules.tap(
				"RecordIdsPlugin",
				/**
				 * @param {Module[]} modules the modules array
				 * @param {Records} records the records object
				 * @returns {void}
				 */
				(modules, records) => {
					if (!records.modules) return;
					if (records.modules.byIdentifier) {
						/** @type {Set<number>} */
						const usedIds = new Set();
						for (const module of modules) {
							if (module.id !== null) continue;
							const identifier = portableIds
								? identifierUtils.makePathsRelative(
										compiler.context,
										module.identifier(),
										compilation.cache
								  )
								: module.identifier();
							const id = records.modules.byIdentifier[identifier];
							if (id === undefined) continue;
							if (usedIds.has(id)) continue;
							usedIds.add(id);
							module.id = id;
						}
					}
					if (Array.isArray(records.modules.usedIds)) {
						compilation.usedModuleIds = new Set(records.modules.usedIds);
					}
				}
			);

			/**
			 * @param {Module} module the module
			 * @returns {string} the (portable) identifier
			 */
			const getModuleIdentifier = module => {
				if (portableIds) {
					return identifierUtils.makePathsRelative(
						compiler.context,
						module.identifier(),
						compilation.cache
					);
				}
				return module.identifier();
			};

			/**
			 * @param {Chunk} chunk the chunk
			 * @returns {string[]} sources of the chunk
			 */
			const getChunkSources = chunk => {
				/** @type {string[]} */
				const sources = [];
				for (const chunkGroup of chunk.groupsIterable) {
					const index = chunkGroup.chunks.indexOf(chunk);
					for (const origin of chunkGroup.origins) {
						if (origin.module) {
							if (origin.request) {
								sources.push(
									`${index} ${getModuleIdentifier(origin.module)} ${
										origin.request
									}`
								);
							} else if (typeof origin.loc === "string") {
								sources.push(
									`${index} ${getModuleIdentifier(origin.module)} ${origin.loc}`
								);
							} else if (
								origin.loc &&
								typeof origin.loc === "object" &&
								origin.loc.start
							) {
								sources.push(
									`${index} ${getModuleIdentifier(
										origin.module
									)} ${JSON.stringify(origin.loc.start)}`
								);
							}
						}
					}
				}
				return sources;
			};

			compilation.hooks.recordChunks.tap(
				"RecordIdsPlugin",
				/**
				 * @param {Chunk[]} chunks the chunks array
				 * @param {Records} records the records object
				 * @returns {void}
				 */
				(chunks, records) => {
					if (!records.chunks) records.chunks = {};
					if (!records.chunks.byName) records.chunks.byName = {};
					if (!records.chunks.bySource) records.chunks.bySource = {};
					/** @type {Set<number>} */
					const usedIds = new Set();
					for (const chunk of chunks) {
						if (typeof chunk.id !== "number") continue;
						const name = chunk.name;
						if (name) records.chunks.byName[name] = chunk.id;
						const sources = getChunkSources(chunk);
						for (const source of sources) {
							records.chunks.bySource[source] = chunk.id;
						}
						usedIds.add(chunk.id);
					}
					records.chunks.usedIds = Array.from(usedIds).sort();
				}
			);
			compilation.hooks.reviveChunks.tap(
				"RecordIdsPlugin",
				/**
				 * @param {Chunk[]} chunks the chunks array
				 * @param {Records} records the records object
				 * @returns {void}
				 */
				(chunks, records) => {
					if (!records.chunks) return;
					/** @type {Set<number>} */
					const usedIds = new Set();
					if (records.chunks.byName) {
						for (const chunk of chunks) {
							if (chunk.id !== null) continue;
							if (!chunk.name) continue;
							const id = records.chunks.byName[chunk.name];
							if (id === undefined) continue;
							if (usedIds.has(id)) continue;
							usedIds.add(id);
							chunk.id = id;
						}
					}
					if (records.chunks.bySource) {
						for (const chunk of chunks) {
							const sources = getChunkSources(chunk);
							for (const source of sources) {
								const id = records.chunks.bySource[source];
								if (id === undefined) continue;
								if (usedIds.has(id)) continue;
								usedIds.add(id);
								chunk.id = id;
								break;
							}
						}
					}
					if (Array.isArray(records.chunks.usedIds)) {
						compilation.usedChunkIds = new Set(records.chunks.usedIds);
					}
				}
			);
		});
	}
}
module.exports = RecordIdsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/RemovedPluginError.js":
/*!*******************************************!*\
  !*** (webpack)/lib/RemovedPluginError.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

module.exports = class RemovedPluginError extends WebpackError {
	constructor(message) {
		super(message);

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/RequestShortener.js":
/*!*****************************************!*\
  !*** (webpack)/lib/RequestShortener.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const path = __webpack_require__(/*! path */ "path");
const NORMALIZE_SLASH_DIRECTION_REGEXP = /\\/g;
const PATH_CHARS_REGEXP = /[-[\]{}()*+?.,\\^$|#\s]/g;
const SEPARATOR_REGEXP = /[/\\]$/;
const FRONT_OR_BACK_BANG_REGEXP = /^!|!$/g;
const INDEX_JS_REGEXP = /\/index.js(!|\?|\(query\))/g;
const MATCH_RESOURCE_REGEXP = /!=!/;

const normalizeBackSlashDirection = request => {
	return request.replace(NORMALIZE_SLASH_DIRECTION_REGEXP, "/");
};

const createRegExpForPath = path => {
	const regexpTypePartial = path.replace(PATH_CHARS_REGEXP, "\\$&");
	return new RegExp(`(^|!)${regexpTypePartial}`, "g");
};

class RequestShortener {
	constructor(directory) {
		directory = normalizeBackSlashDirection(directory);
		if (SEPARATOR_REGEXP.test(directory)) {
			directory = directory.substr(0, directory.length - 1);
		}

		if (directory) {
			this.currentDirectoryRegExp = createRegExpForPath(directory);
		}

		const dirname = path.dirname(directory);
		const endsWithSeparator = SEPARATOR_REGEXP.test(dirname);
		const parentDirectory = endsWithSeparator
			? dirname.substr(0, dirname.length - 1)
			: dirname;
		if (parentDirectory && parentDirectory !== directory) {
			this.parentDirectoryRegExp = createRegExpForPath(parentDirectory);
		}

		if (__dirname.length >= 2) {
			const buildins = normalizeBackSlashDirection(path.join(__dirname, ".."));
			const buildinsAsModule =
				this.currentDirectoryRegExp &&
				this.currentDirectoryRegExp.test(buildins);
			this.buildinsAsModule = buildinsAsModule;
			this.buildinsRegExp = createRegExpForPath(buildins);
		}

		this.cache = new Map();
	}

	shorten(request) {
		if (!request) return request;
		const cacheEntry = this.cache.get(request);
		if (cacheEntry !== undefined) {
			return cacheEntry;
		}
		let result = normalizeBackSlashDirection(request);
		if (this.buildinsAsModule && this.buildinsRegExp) {
			result = result.replace(this.buildinsRegExp, "!(webpack)");
		}
		if (this.currentDirectoryRegExp) {
			result = result.replace(this.currentDirectoryRegExp, "!.");
		}
		if (this.parentDirectoryRegExp) {
			result = result.replace(this.parentDirectoryRegExp, "!..");
		}
		if (!this.buildinsAsModule && this.buildinsRegExp) {
			result = result.replace(this.buildinsRegExp, "!(webpack)");
		}
		result = result.replace(INDEX_JS_REGEXP, "$1");
		result = result.replace(FRONT_OR_BACK_BANG_REGEXP, "");
		result = result.replace(MATCH_RESOURCE_REGEXP, " = ");
		this.cache.set(request, result);
		return result;
	}
}

module.exports = RequestShortener;

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/webpack/lib/RequireJsStuffPlugin.js":
/*!*********************************************!*\
  !*** (webpack)/lib/RequireJsStuffPlugin.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ParserHelpers = __webpack_require__(/*! ./ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");
const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const NullFactory = __webpack_require__(/*! ./NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

module.exports = class RequireJsStuffPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireJsStuffPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);
				const handler = (parser, parserOptions) => {
					if (parserOptions.requireJs !== undefined && !parserOptions.requireJs)
						return;

					parser.hooks.call
						.for("require.config")
						.tap(
							"RequireJsStuffPlugin",
							ParserHelpers.toConstantDependency(parser, "undefined")
						);
					parser.hooks.call
						.for("requirejs.config")
						.tap(
							"RequireJsStuffPlugin",
							ParserHelpers.toConstantDependency(parser, "undefined")
						);

					parser.hooks.expression
						.for("require.version")
						.tap(
							"RequireJsStuffPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("0.0.0")
							)
						);
					parser.hooks.expression
						.for("requirejs.onError")
						.tap(
							"RequireJsStuffPlugin",
							ParserHelpers.toConstantDependencyWithWebpackRequire(
								parser,
								"__webpack_require__.oe"
							)
						);
				};
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireJsStuffPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("RequireJsStuffPlugin", handler);
			}
		);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/ResolverFactory.js":
/*!****************************************!*\
  !*** (webpack)/lib/ResolverFactory.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */


const { Tapable, HookMap, SyncHook, SyncWaterfallHook } = __webpack_require__(/*! tapable */ "tapable");
const Factory = __webpack_require__(/*! enhanced-resolve */ "enhanced-resolve").ResolverFactory;

/** @typedef {import("enhanced-resolve").Resolver} Resolver */

module.exports = class ResolverFactory extends Tapable {
	constructor() {
		super();
		this.hooks = {
			resolveOptions: new HookMap(
				() => new SyncWaterfallHook(["resolveOptions"])
			),
			resolver: new HookMap(() => new SyncHook(["resolver", "resolveOptions"]))
		};
		this._pluginCompat.tap("ResolverFactory", options => {
			let match;
			match = /^resolve-options (.+)$/.exec(options.name);
			if (match) {
				this.hooks.resolveOptions.tap(
					match[1],
					options.fn.name || "unnamed compat plugin",
					options.fn
				);
				return true;
			}
			match = /^resolver (.+)$/.exec(options.name);
			if (match) {
				this.hooks.resolver.tap(
					match[1],
					options.fn.name || "unnamed compat plugin",
					options.fn
				);
				return true;
			}
		});
		this.cache1 = new WeakMap();
		this.cache2 = new Map();
	}

	get(type, resolveOptions) {
		const cachedResolver = this.cache1.get(resolveOptions);
		if (cachedResolver) return cachedResolver();
		const ident = `${type}|${JSON.stringify(resolveOptions)}`;
		const resolver = this.cache2.get(ident);
		if (resolver) return resolver;
		const newResolver = this._create(type, resolveOptions);
		this.cache2.set(ident, newResolver);
		return newResolver;
	}

	_create(type, resolveOptions) {
		const originalResolveOptions = Object.assign({}, resolveOptions);
		resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);
		const resolver = Factory.createResolver(resolveOptions);
		if (!resolver) {
			throw new Error("No resolver created");
		}
		/** @type {Map<Object, Resolver>} */
		const childCache = new Map();
		resolver.withOptions = options => {
			const cacheEntry = childCache.get(options);
			if (cacheEntry !== undefined) return cacheEntry;
			const mergedOptions = Object.assign({}, originalResolveOptions, options);
			const resolver = this.get(type, mergedOptions);
			childCache.set(options, resolver);
			return resolver;
		};
		this.hooks.resolver.for(type).call(resolver, resolveOptions);
		return resolver;
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/RuleSet.js":
/*!********************************!*\
  !*** (webpack)/lib/RuleSet.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*
<rules>: <rule>
<rules>: [<rule>]
<rule>: {
	resource: {
		test: <condition>,
		include: <condition>,
		exclude: <condition>,
	},
	resource: <condition>, -> resource.test
	test: <condition>, -> resource.test
	include: <condition>, -> resource.include
	exclude: <condition>, -> resource.exclude
	resourceQuery: <condition>,
	compiler: <condition>,
	issuer: <condition>,
	use: "loader", -> use[0].loader
	loader: <>, -> use[0].loader
	loaders: <>, -> use
	options: {}, -> use[0].options,
	query: {}, -> options
	parser: {},
	use: [
		"loader" -> use[x].loader
	],
	use: [
		{
			loader: "loader",
			options: {}
		}
	],
	rules: [
		<rule>
	],
	oneOf: [
		<rule>
	]
}

<condition>: /regExp/
<condition>: function(arg) {}
<condition>: "starting"
<condition>: [<condition>] // or
<condition>: { and: [<condition>] }
<condition>: { or: [<condition>] }
<condition>: { not: [<condition>] }
<condition>: { test: <condition>, include: <condition>, exclude: <condition> }


normalized:

{
	resource: function(),
	resourceQuery: function(),
	compiler: function(),
	issuer: function(),
	use: [
		{
			loader: string,
			options: string,
			<any>: <any>
		}
	],
	rules: [<rule>],
	oneOf: [<rule>],
	<any>: <any>,
}

*/



const notMatcher = matcher => {
	return str => {
		return !matcher(str);
	};
};

const orMatcher = items => {
	return str => {
		for (let i = 0; i < items.length; i++) {
			if (items[i](str)) return true;
		}
		return false;
	};
};

const andMatcher = items => {
	return str => {
		for (let i = 0; i < items.length; i++) {
			if (!items[i](str)) return false;
		}
		return true;
	};
};

module.exports = class RuleSet {
	constructor(rules) {
		this.references = Object.create(null);
		this.rules = RuleSet.normalizeRules(rules, this.references, "ref-");
	}

	static normalizeRules(rules, refs, ident) {
		if (Array.isArray(rules)) {
			return rules.map((rule, idx) => {
				return RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`);
			});
		} else if (rules) {
			return [RuleSet.normalizeRule(rules, refs, ident)];
		} else {
			return [];
		}
	}

	static normalizeRule(rule, refs, ident) {
		if (typeof rule === "string") {
			return {
				use: [
					{
						loader: rule
					}
				]
			};
		}
		if (!rule) {
			throw new Error("Unexcepted null when object was expected as rule");
		}
		if (typeof rule !== "object") {
			throw new Error(
				"Unexcepted " +
					typeof rule +
					" when object was expected as rule (" +
					rule +
					")"
			);
		}

		const newRule = {};
		let useSource;
		let resourceSource;
		let condition;

		const checkUseSource = newSource => {
			if (useSource && useSource !== newSource) {
				throw new Error(
					RuleSet.buildErrorMessage(
						rule,
						new Error(
							"Rule can only have one result source (provided " +
								newSource +
								" and " +
								useSource +
								")"
						)
					)
				);
			}
			useSource = newSource;
		};

		const checkResourceSource = newSource => {
			if (resourceSource && resourceSource !== newSource) {
				throw new Error(
					RuleSet.buildErrorMessage(
						rule,
						new Error(
							"Rule can only have one resource source (provided " +
								newSource +
								" and " +
								resourceSource +
								")"
						)
					)
				);
			}
			resourceSource = newSource;
		};

		if (rule.test || rule.include || rule.exclude) {
			checkResourceSource("test + include + exclude");
			condition = {
				test: rule.test,
				include: rule.include,
				exclude: rule.exclude
			};
			try {
				newRule.resource = RuleSet.normalizeCondition(condition);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(condition, error));
			}
		}

		if (rule.resource) {
			checkResourceSource("resource");
			try {
				newRule.resource = RuleSet.normalizeCondition(rule.resource);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.resource, error));
			}
		}

		if (rule.realResource) {
			try {
				newRule.realResource = RuleSet.normalizeCondition(rule.realResource);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));
			}
		}

		if (rule.resourceQuery) {
			try {
				newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));
			}
		}

		if (rule.compiler) {
			try {
				newRule.compiler = RuleSet.normalizeCondition(rule.compiler);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));
			}
		}

		if (rule.issuer) {
			try {
				newRule.issuer = RuleSet.normalizeCondition(rule.issuer);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));
			}
		}

		if (rule.loader && rule.loaders) {
			throw new Error(
				RuleSet.buildErrorMessage(
					rule,
					new Error(
						"Provided loader and loaders for rule (use only one of them)"
					)
				)
			);
		}

		const loader = rule.loaders || rule.loader;
		if (typeof loader === "string" && !rule.options && !rule.query) {
			checkUseSource("loader");
			newRule.use = RuleSet.normalizeUse(loader.split("!"), ident);
		} else if (typeof loader === "string" && (rule.options || rule.query)) {
			checkUseSource("loader + options/query");
			newRule.use = RuleSet.normalizeUse(
				{
					loader: loader,
					options: rule.options,
					query: rule.query
				},
				ident
			);
		} else if (loader && (rule.options || rule.query)) {
			throw new Error(
				RuleSet.buildErrorMessage(
					rule,
					new Error(
						"options/query cannot be used with loaders (use options for each array item)"
					)
				)
			);
		} else if (loader) {
			checkUseSource("loaders");
			newRule.use = RuleSet.normalizeUse(loader, ident);
		} else if (rule.options || rule.query) {
			throw new Error(
				RuleSet.buildErrorMessage(
					rule,
					new Error(
						"options/query provided without loader (use loader + options)"
					)
				)
			);
		}

		if (rule.use) {
			checkUseSource("use");
			newRule.use = RuleSet.normalizeUse(rule.use, ident);
		}

		if (rule.rules) {
			newRule.rules = RuleSet.normalizeRules(
				rule.rules,
				refs,
				`${ident}-rules`
			);
		}

		if (rule.oneOf) {
			newRule.oneOf = RuleSet.normalizeRules(
				rule.oneOf,
				refs,
				`${ident}-oneOf`
			);
		}

		const keys = Object.keys(rule).filter(key => {
			return ![
				"resource",
				"resourceQuery",
				"compiler",
				"test",
				"include",
				"exclude",
				"issuer",
				"loader",
				"options",
				"query",
				"loaders",
				"use",
				"rules",
				"oneOf"
			].includes(key);
		});
		for (const key of keys) {
			newRule[key] = rule[key];
		}

		if (Array.isArray(newRule.use)) {
			for (const item of newRule.use) {
				if (item.ident) {
					refs[item.ident] = item.options;
				}
			}
		}

		return newRule;
	}

	static buildErrorMessage(condition, error) {
		const conditionAsText = JSON.stringify(
			condition,
			(key, value) => {
				return value === undefined ? "undefined" : value;
			},
			2
		);
		return error.message + " in " + conditionAsText;
	}

	static normalizeUse(use, ident) {
		if (typeof use === "function") {
			return data => RuleSet.normalizeUse(use(data), ident);
		}
		if (Array.isArray(use)) {
			return use
				.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`))
				.reduce((arr, items) => arr.concat(items), []);
		}
		return [RuleSet.normalizeUseItem(use, ident)];
	}

	static normalizeUseItemString(useItemString) {
		const idx = useItemString.indexOf("?");
		if (idx >= 0) {
			return {
				loader: useItemString.substr(0, idx),
				options: useItemString.substr(idx + 1)
			};
		}
		return {
			loader: useItemString,
			options: undefined
		};
	}

	static normalizeUseItem(item, ident) {
		if (typeof item === "string") {
			return RuleSet.normalizeUseItemString(item);
		}

		const newItem = {};

		if (item.options && item.query) {
			throw new Error("Provided options and query in use");
		}

		if (!item.loader) {
			throw new Error("No loader specified");
		}

		newItem.options = item.options || item.query;

		if (typeof newItem.options === "object" && newItem.options) {
			if (newItem.options.ident) {
				newItem.ident = newItem.options.ident;
			} else {
				newItem.ident = ident;
			}
		}

		const keys = Object.keys(item).filter(function(key) {
			return !["options", "query"].includes(key);
		});

		for (const key of keys) {
			newItem[key] = item[key];
		}

		return newItem;
	}

	static normalizeCondition(condition) {
		if (!condition) throw new Error("Expected condition but got falsy value");
		if (typeof condition === "string") {
			return str => str.indexOf(condition) === 0;
		}
		if (typeof condition === "function") {
			return condition;
		}
		if (condition instanceof RegExp) {
			return condition.test.bind(condition);
		}
		if (Array.isArray(condition)) {
			const items = condition.map(c => RuleSet.normalizeCondition(c));
			return orMatcher(items);
		}
		if (typeof condition !== "object") {
			throw Error(
				"Unexcepted " +
					typeof condition +
					" when condition was expected (" +
					condition +
					")"
			);
		}

		const matchers = [];
		Object.keys(condition).forEach(key => {
			const value = condition[key];
			switch (key) {
				case "or":
				case "include":
				case "test":
					if (value) matchers.push(RuleSet.normalizeCondition(value));
					break;
				case "and":
					if (value) {
						const items = value.map(c => RuleSet.normalizeCondition(c));
						matchers.push(andMatcher(items));
					}
					break;
				case "not":
				case "exclude":
					if (value) {
						const matcher = RuleSet.normalizeCondition(value);
						matchers.push(notMatcher(matcher));
					}
					break;
				default:
					throw new Error("Unexcepted property " + key + " in condition");
			}
		});
		if (matchers.length === 0) {
			throw new Error("Excepted condition but got " + condition);
		}
		if (matchers.length === 1) {
			return matchers[0];
		}
		return andMatcher(matchers);
	}

	exec(data) {
		const result = [];
		this._run(
			data,
			{
				rules: this.rules
			},
			result
		);
		return result;
	}

	_run(data, rule, result) {
		// test conditions
		if (rule.resource && !data.resource) return false;
		if (rule.realResource && !data.realResource) return false;
		if (rule.resourceQuery && !data.resourceQuery) return false;
		if (rule.compiler && !data.compiler) return false;
		if (rule.issuer && !data.issuer) return false;
		if (rule.resource && !rule.resource(data.resource)) return false;
		if (rule.realResource && !rule.realResource(data.realResource))
			return false;
		if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;
		if (
			data.resourceQuery &&
			rule.resourceQuery &&
			!rule.resourceQuery(data.resourceQuery)
		) {
			return false;
		}
		if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {
			return false;
		}

		// apply
		const keys = Object.keys(rule).filter(key => {
			return ![
				"resource",
				"realResource",
				"resourceQuery",
				"compiler",
				"issuer",
				"rules",
				"oneOf",
				"use",
				"enforce"
			].includes(key);
		});
		for (const key of keys) {
			result.push({
				type: key,
				value: rule[key]
			});
		}

		if (rule.use) {
			const process = use => {
				if (typeof use === "function") {
					process(use(data));
				} else if (Array.isArray(use)) {
					use.forEach(process);
				} else {
					result.push({
						type: "use",
						value: use,
						enforce: rule.enforce
					});
				}
			};
			process(rule.use);
		}

		if (rule.rules) {
			for (let i = 0; i < rule.rules.length; i++) {
				this._run(data, rule.rules[i], result);
			}
		}

		if (rule.oneOf) {
			for (let i = 0; i < rule.oneOf.length; i++) {
				if (this._run(data, rule.oneOf[i], result)) break;
			}
		}

		return true;
	}

	findOptionsByIdent(ident) {
		const options = this.references[ident];
		if (!options) {
			throw new Error("Can't find options with ident '" + ident + "'");
		}
		return options;
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/RuntimeTemplate.js":
/*!****************************************!*\
  !*** (webpack)/lib/RuntimeTemplate.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

/** @typedef {import("./Module")} Module */

module.exports = class RuntimeTemplate {
	constructor(outputOptions, requestShortener) {
		this.outputOptions = outputOptions || {};
		this.requestShortener = requestShortener;
	}

	/**
	 * Add a comment
	 * @param {object} options Information content of the comment
	 * @param {string=} options.request request string used originally
	 * @param {string=} options.chunkName name of the chunk referenced
	 * @param {string=} options.chunkReason reason information of the chunk
	 * @param {string=} options.message additional message
	 * @param {string=} options.exportName name of the export
	 * @returns {string} comment
	 */
	comment({ request, chunkName, chunkReason, message, exportName }) {
		let content;
		if (this.outputOptions.pathinfo) {
			content = [message, request, chunkName, chunkReason]
				.filter(Boolean)
				.map(item => this.requestShortener.shorten(item))
				.join(" | ");
		} else {
			content = [message, chunkName, chunkReason]
				.filter(Boolean)
				.map(item => this.requestShortener.shorten(item))
				.join(" | ");
		}
		if (!content) return "";
		if (this.outputOptions.pathinfo) {
			return Template.toComment(content) + " ";
		} else {
			return Template.toNormalComment(content) + " ";
		}
	}

	throwMissingModuleErrorFunction({ request }) {
		const err = `Cannot find module '${request}'`;
		return `function webpackMissingModule() { var e = new Error(${JSON.stringify(
			err
		)}); e.code = 'MODULE_NOT_FOUND'; throw e; }`;
	}

	missingModule({ request }) {
		return `!(${this.throwMissingModuleErrorFunction({ request })}())`;
	}

	missingModuleStatement({ request }) {
		return `${this.missingModule({ request })};\n`;
	}

	missingModulePromise({ request }) {
		return `Promise.resolve().then(${this.throwMissingModuleErrorFunction({
			request
		})})`;
	}

	moduleId({ module, request }) {
		if (!module) {
			return this.missingModule({
				request
			});
		}
		if (module.id === null) {
			throw new Error(
				`RuntimeTemplate.moduleId(): Module ${module.identifier()} has no id. This should not happen.`
			);
		}
		return `${this.comment({ request })}${JSON.stringify(module.id)}`;
	}

	moduleRaw({ module, request }) {
		if (!module) {
			return this.missingModule({
				request
			});
		}
		return `__webpack_require__(${this.moduleId({ module, request })})`;
	}

	moduleExports({ module, request }) {
		return this.moduleRaw({
			module,
			request
		});
	}

	moduleNamespace({ module, request, strict }) {
		if (!module) {
			return this.missingModule({
				request
			});
		}
		const moduleId = this.moduleId({
			module,
			request
		});
		const exportsType = module.buildMeta && module.buildMeta.exportsType;
		if (exportsType === "namespace") {
			const rawModule = this.moduleRaw({
				module,
				request
			});
			return rawModule;
		} else if (exportsType === "named") {
			return `__webpack_require__.t(${moduleId}, 3)`;
		} else if (strict) {
			return `__webpack_require__.t(${moduleId}, 1)`;
		} else {
			return `__webpack_require__.t(${moduleId}, 7)`;
		}
	}

	moduleNamespacePromise({ block, module, request, message, strict, weak }) {
		if (!module) {
			return this.missingModulePromise({
				request
			});
		}
		if (module.id === null) {
			throw new Error(
				`RuntimeTemplate.moduleNamespacePromise(): Module ${module.identifier()} has no id. This should not happen.`
			);
		}
		const promise = this.blockPromise({
			block,
			message
		});

		let getModuleFunction;
		let idExpr = JSON.stringify(module.id);
		const comment = this.comment({
			request
		});
		let header = "";
		if (weak) {
			if (idExpr.length > 8) {
				// 'var x="nnnnnn";x,"+x+",x' vs '"nnnnnn",nnnnnn,"nnnnnn"'
				header += `var id = ${idExpr}; `;
				idExpr = "id";
			}
			header += `if(!__webpack_require__.m[${idExpr}]) { var e = new Error("Module '" + ${idExpr} + "' is not available (weak dependency)"); e.code = 'MODULE_NOT_FOUND'; throw e; } `;
		}
		const moduleId = this.moduleId({
			module,
			request
		});
		const exportsType = module.buildMeta && module.buildMeta.exportsType;
		if (exportsType === "namespace") {
			if (header) {
				const rawModule = this.moduleRaw({
					module,
					request
				});
				getModuleFunction = `function() { ${header}return ${rawModule}; }`;
			} else {
				getModuleFunction = `__webpack_require__.bind(null, ${comment}${idExpr})`;
			}
		} else if (exportsType === "named") {
			if (header) {
				getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 3); }`;
			} else {
				getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 3)`;
			}
		} else if (strict) {
			if (header) {
				getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 1); }`;
			} else {
				getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 1)`;
			}
		} else {
			if (header) {
				getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 7); }`;
			} else {
				getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 7)`;
			}
		}

		return `${promise || "Promise.resolve()"}.then(${getModuleFunction})`;
	}

	/**
	 *
	 * @param {Object} options options object
	 * @param {boolean=} options.update whether a new variable should be created or the existing one updated
	 * @param {Module} options.module the module
	 * @param {string} options.request the request that should be printed as comment
	 * @param {string} options.importVar name of the import variable
	 * @param {Module} options.originModule module in which the statement is emitted
	 * @returns {string} the import statement
	 */
	importStatement({ update, module, request, importVar, originModule }) {
		if (!module) {
			return this.missingModuleStatement({
				request
			});
		}
		const moduleId = this.moduleId({
			module,
			request
		});
		const optDeclaration = update ? "" : "var ";

		const exportsType = module.buildMeta && module.buildMeta.exportsType;
		let content = `/* harmony import */ ${optDeclaration}${importVar} = __webpack_require__(${moduleId});\n`;

		if (!exportsType && !originModule.buildMeta.strictHarmonyModule) {
			content += `/* harmony import */ ${optDeclaration}${importVar}_default = /*#__PURE__*/__webpack_require__.n(${importVar});\n`;
		}
		if (exportsType === "named") {
			if (Array.isArray(module.buildMeta.providedExports)) {
				content += `${optDeclaration}${importVar}_namespace = /*#__PURE__*/__webpack_require__.t(${moduleId}, 1);\n`;
			} else {
				content += `${optDeclaration}${importVar}_namespace = /*#__PURE__*/__webpack_require__.t(${moduleId});\n`;
			}
		}
		return content;
	}

	exportFromImport({
		module,
		request,
		exportName,
		originModule,
		asiSafe,
		isCall,
		callContext,
		importVar
	}) {
		if (!module) {
			return this.missingModule({
				request
			});
		}
		const exportsType = module.buildMeta && module.buildMeta.exportsType;

		if (!exportsType) {
			if (exportName === "default") {
				if (!originModule.buildMeta.strictHarmonyModule) {
					if (isCall) {
						return `${importVar}_default()`;
					} else if (asiSafe) {
						return `(${importVar}_default())`;
					} else {
						return `${importVar}_default.a`;
					}
				} else {
					return importVar;
				}
			} else if (originModule.buildMeta.strictHarmonyModule) {
				if (exportName) {
					return "/* non-default import from non-esm module */undefined";
				} else {
					return `/*#__PURE__*/__webpack_require__.t(${importVar})`;
				}
			}
		}

		if (exportsType === "named") {
			if (exportName === "default") {
				return importVar;
			} else if (!exportName) {
				return `${importVar}_namespace`;
			}
		}

		if (exportName) {
			const used = module.isUsed(exportName);
			if (!used) {
				const comment = Template.toNormalComment(`unused export ${exportName}`);
				return `${comment} undefined`;
			}
			const comment =
				used !== exportName ? Template.toNormalComment(exportName) + " " : "";
			const access = `${importVar}[${comment}${JSON.stringify(used)}]`;
			if (isCall) {
				if (callContext === false && asiSafe) {
					return `(0,${access})`;
				} else if (callContext === false) {
					return `Object(${access})`;
				}
			}
			return access;
		} else {
			return importVar;
		}
	}

	blockPromise({ block, message }) {
		if (!block || !block.chunkGroup || block.chunkGroup.chunks.length === 0) {
			const comment = this.comment({
				message
			});
			return `Promise.resolve(${comment.trim()})`;
		}
		const chunks = block.chunkGroup.chunks.filter(
			chunk => !chunk.hasRuntime() && chunk.id !== null
		);
		const comment = this.comment({
			message,
			chunkName: block.chunkName,
			chunkReason: block.chunkReason
		});
		if (chunks.length === 1) {
			const chunkId = JSON.stringify(chunks[0].id);
			return `__webpack_require__.e(${comment}${chunkId})`;
		} else if (chunks.length > 0) {
			const requireChunkId = chunk =>
				`__webpack_require__.e(${JSON.stringify(chunk.id)})`;
			return `Promise.all(${comment.trim()}[${chunks
				.map(requireChunkId)
				.join(", ")}])`;
		} else {
			return `Promise.resolve(${comment.trim()})`;
		}
	}

	onError() {
		return "__webpack_require__.oe";
	}

	defineEsModuleFlagStatement({ exportsArgument }) {
		return `__webpack_require__.r(${exportsArgument});\n`;
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/SetVarMainTemplatePlugin.js":
/*!*************************************************!*\
  !*** (webpack)/lib/SetVarMainTemplatePlugin.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

/** @typedef {import("./Compilation")} Compilation */

class SetVarMainTemplatePlugin {
	/**
	 * @param {string} varExpression the accessor where the library is exported
	 * @param {boolean} copyObject specify copying the exports
	 */
	constructor(varExpression, copyObject) {
		/** @type {string} */
		this.varExpression = varExpression;
		/** @type {boolean} */
		this.copyObject = copyObject;
	}

	/**
	 * @param {Compilation} compilation the compilation instance
	 * @returns {void}
	 */
	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const varExpression = mainTemplate.getAssetPath(this.varExpression, {
				hash,
				chunk
			});
			if (this.copyObject) {
				return new ConcatSource(
					`(function(e, a) { for(var i in a) e[i] = a[i]; }(${varExpression}, `,
					source,
					"))"
				);
			} else {
				const prefix = `${varExpression} =\n`;
				return new ConcatSource(prefix, source);
			}
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"SetVarMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap(
			"SetVarMainTemplatePlugin",
			paths => {
				if (this.varExpression) paths.push(this.varExpression);
				return paths;
			}
		);
		mainTemplate.hooks.hash.tap("SetVarMainTemplatePlugin", hash => {
			hash.update("set var");
			hash.update(`${this.varExpression}`);
			hash.update(`${this.copyObject}`);
		});
	}
}

module.exports = SetVarMainTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/SingleEntryPlugin.js":
/*!******************************************!*\
  !*** (webpack)/lib/SingleEntryPlugin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const SingleEntryDependency = __webpack_require__(/*! ./dependencies/SingleEntryDependency */ "./node_modules/webpack/lib/dependencies/SingleEntryDependency.js");

/** @typedef {import("./Compiler")} Compiler */

class SingleEntryPlugin {
	/**
	 * An entry plugin which will handle
	 * creation of the SingleEntryDependency
	 *
	 * @param {string} context context path
	 * @param {string} entry entry path
	 * @param {string} name entry key name
	 */
	constructor(context, entry, name) {
		this.context = context;
		this.entry = entry;
		this.name = name;
	}

	/**
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"SingleEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.make.tapAsync(
			"SingleEntryPlugin",
			(compilation, callback) => {
				const { entry, name, context } = this;

				const dep = SingleEntryPlugin.createDependency(entry, name);
				compilation.addEntry(context, dep, name, callback);
			}
		);
	}

	/**
	 * @param {string} entry entry request
	 * @param {string} name entry name
	 * @returns {SingleEntryDependency} the dependency
	 */
	static createDependency(entry, name) {
		const dep = new SingleEntryDependency(entry);
		dep.loc = { name };
		return dep;
	}
}

module.exports = SingleEntryPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/SizeFormatHelpers.js":
/*!******************************************!*\
  !*** (webpack)/lib/SizeFormatHelpers.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/


const SizeFormatHelpers = exports;

SizeFormatHelpers.formatSize = size => {
	if (typeof size !== "number" || Number.isNaN(size) === true) {
		return "unknown size";
	}

	if (size <= 0) {
		return "0 bytes";
	}

	const abbreviations = ["bytes", "KiB", "MiB", "GiB"];
	const index = Math.floor(Math.log(size) / Math.log(1024));

	return `${+(size / Math.pow(1024, index)).toPrecision(3)} ${
		abbreviations[index]
	}`;
};


/***/ }),

/***/ "./node_modules/webpack/lib/SourceMapDevToolModuleOptionsPlugin.js":
/*!************************************************************!*\
  !*** (webpack)/lib/SourceMapDevToolModuleOptionsPlugin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ModuleFilenameHelpers = __webpack_require__(/*! ./ModuleFilenameHelpers */ "./node_modules/webpack/lib/ModuleFilenameHelpers.js");

class SourceMapDevToolModuleOptionsPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compilation) {
		const options = this.options;
		if (options.module !== false) {
			compilation.hooks.buildModule.tap(
				"SourceMapDevToolModuleOptionsPlugin",
				module => {
					module.useSourceMap = true;
				}
			);
		}
		if (options.lineToLine === true) {
			compilation.hooks.buildModule.tap(
				"SourceMapDevToolModuleOptionsPlugin",
				module => {
					module.lineToLine = true;
				}
			);
		} else if (options.lineToLine) {
			compilation.hooks.buildModule.tap(
				"SourceMapDevToolModuleOptionsPlugin",
				module => {
					if (!module.resource) return;
					let resourcePath = module.resource;
					const idx = resourcePath.indexOf("?");
					if (idx >= 0) resourcePath = resourcePath.substr(0, idx);
					module.lineToLine = ModuleFilenameHelpers.matchObject(
						options.lineToLine,
						resourcePath
					);
				}
			);
		}
	}
}

module.exports = SourceMapDevToolModuleOptionsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/SourceMapDevToolPlugin.js":
/*!***********************************************!*\
  !*** (webpack)/lib/SourceMapDevToolPlugin.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const path = __webpack_require__(/*! path */ "path");
const { ConcatSource, RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const ModuleFilenameHelpers = __webpack_require__(/*! ./ModuleFilenameHelpers */ "./node_modules/webpack/lib/ModuleFilenameHelpers.js");
const SourceMapDevToolModuleOptionsPlugin = __webpack_require__(/*! ./SourceMapDevToolModuleOptionsPlugin */ "./node_modules/webpack/lib/SourceMapDevToolModuleOptionsPlugin.js");
const createHash = __webpack_require__(/*! ./util/createHash */ "./node_modules/webpack/lib/util/createHash.js");

const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/SourceMapDevToolPlugin.json */ "./node_modules/webpack/schemas/plugins/SourceMapDevToolPlugin.json");

/** @typedef {import("../declarations/plugins/SourceMapDevToolPlugin").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */

const basename = name => {
	if (!name.includes("/")) return name;
	return name.substr(name.lastIndexOf("/") + 1);
};

const assetsCache = new WeakMap();

const getTaskForFile = (file, chunk, options, compilation) => {
	const asset = compilation.assets[file];
	const cache = assetsCache.get(asset);
	if (cache && cache.file === file) {
		for (const cachedFile in cache.assets) {
			compilation.assets[cachedFile] = cache.assets[cachedFile];
			if (cachedFile !== file) chunk.files.push(cachedFile);
		}
		return;
	}
	let source, sourceMap;
	if (asset.sourceAndMap) {
		const sourceAndMap = asset.sourceAndMap(options);
		sourceMap = sourceAndMap.map;
		source = sourceAndMap.source;
	} else {
		sourceMap = asset.map(options);
		source = asset.source();
	}
	if (sourceMap) {
		return {
			chunk,
			file,
			asset,
			source,
			sourceMap,
			modules: undefined
		};
	}
};

class SourceMapDevToolPlugin {
	/**
	 * @param {SourceMapDevToolPluginOptions=} options options object
	 */
	constructor(options) {
		if (arguments.length > 1) {
			throw new Error(
				"SourceMapDevToolPlugin only takes one argument (pass an options object)"
			);
		}

		if (!options) options = {};

		validateOptions(schema, options, "SourceMap DevTool Plugin");

		this.sourceMapFilename = options.filename;
		/** @type {string | false} */
		this.sourceMappingURLComment =
			options.append === false
				? false
				: options.append || "\n//# sourceMappingURL=[url]";
		this.moduleFilenameTemplate =
			options.moduleFilenameTemplate || "webpack://[namespace]/[resourcePath]";
		this.fallbackModuleFilenameTemplate =
			options.fallbackModuleFilenameTemplate ||
			"webpack://[namespace]/[resourcePath]?[hash]";
		this.namespace = options.namespace || "";
		this.options = options;
	}

	apply(compiler) {
		const sourceMapFilename = this.sourceMapFilename;
		const sourceMappingURLComment = this.sourceMappingURLComment;
		const moduleFilenameTemplate = this.moduleFilenameTemplate;
		const namespace = this.namespace;
		const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;
		const requestShortener = compiler.requestShortener;
		const options = this.options;
		options.test = options.test || /\.(m?js|css)($|\?)/i;

		const matchObject = ModuleFilenameHelpers.matchObject.bind(
			undefined,
			options
		);

		compiler.hooks.compilation.tap("SourceMapDevToolPlugin", compilation => {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);

			compilation.hooks.afterOptimizeChunkAssets.tap(
				{
					name: "SourceMapDevToolPlugin",
					context: true
				},
				(context, chunks) => {
					const moduleToSourceNameMapping = new Map();
					const reportProgress =
						context && context.reportProgress
							? context.reportProgress
							: () => {};

					const files = [];
					for (const chunk of chunks) {
						for (const file of chunk.files) {
							if (matchObject(file)) {
								files.push({
									file,
									chunk
								});
							}
						}
					}

					reportProgress(0.0);
					const tasks = [];
					files.forEach(({ file, chunk }, idx) => {
						reportProgress(
							(0.5 * idx) / files.length,
							file,
							"generate SourceMap"
						);
						const task = getTaskForFile(file, chunk, options, compilation);

						if (task) {
							const modules = task.sourceMap.sources.map(source => {
								const module = compilation.findModule(source);
								return module || source;
							});

							for (let idx = 0; idx < modules.length; idx++) {
								const module = modules[idx];
								if (!moduleToSourceNameMapping.get(module)) {
									moduleToSourceNameMapping.set(
										module,
										ModuleFilenameHelpers.createFilename(
											module,
											{
												moduleFilenameTemplate: moduleFilenameTemplate,
												namespace: namespace
											},
											requestShortener
										)
									);
								}
							}

							task.modules = modules;

							tasks.push(task);
						}
					});

					reportProgress(0.5, "resolve sources");
					const usedNamesSet = new Set(moduleToSourceNameMapping.values());
					const conflictDetectionSet = new Set();

					// all modules in defined order (longest identifier first)
					const allModules = Array.from(moduleToSourceNameMapping.keys()).sort(
						(a, b) => {
							const ai = typeof a === "string" ? a : a.identifier();
							const bi = typeof b === "string" ? b : b.identifier();
							return ai.length - bi.length;
						}
					);

					// find modules with conflicting source names
					for (let idx = 0; idx < allModules.length; idx++) {
						const module = allModules[idx];
						let sourceName = moduleToSourceNameMapping.get(module);
						let hasName = conflictDetectionSet.has(sourceName);
						if (!hasName) {
							conflictDetectionSet.add(sourceName);
							continue;
						}

						// try the fallback name first
						sourceName = ModuleFilenameHelpers.createFilename(
							module,
							{
								moduleFilenameTemplate: fallbackModuleFilenameTemplate,
								namespace: namespace
							},
							requestShortener
						);
						hasName = usedNamesSet.has(sourceName);
						if (!hasName) {
							moduleToSourceNameMapping.set(module, sourceName);
							usedNamesSet.add(sourceName);
							continue;
						}

						// elsewise just append stars until we have a valid name
						while (hasName) {
							sourceName += "*";
							hasName = usedNamesSet.has(sourceName);
						}
						moduleToSourceNameMapping.set(module, sourceName);
						usedNamesSet.add(sourceName);
					}
					tasks.forEach((task, index) => {
						reportProgress(
							0.5 + (0.5 * index) / tasks.length,
							task.file,
							"attach SourceMap"
						);
						const assets = Object.create(null);
						const chunk = task.chunk;
						const file = task.file;
						const asset = task.asset;
						const sourceMap = task.sourceMap;
						const source = task.source;
						const modules = task.modules;
						const moduleFilenames = modules.map(m =>
							moduleToSourceNameMapping.get(m)
						);
						sourceMap.sources = moduleFilenames;
						if (options.noSources) {
							sourceMap.sourcesContent = undefined;
						}
						sourceMap.sourceRoot = options.sourceRoot || "";
						sourceMap.file = file;
						assetsCache.set(asset, { file, assets });
						/** @type {string | false} */
						let currentSourceMappingURLComment = sourceMappingURLComment;
						if (
							currentSourceMappingURLComment !== false &&
							/\.css($|\?)/i.test(file)
						) {
							currentSourceMappingURLComment = currentSourceMappingURLComment.replace(
								/^\n\/\/(.*)$/,
								"\n/*$1*/"
							);
						}
						const sourceMapString = JSON.stringify(sourceMap);
						if (sourceMapFilename) {
							let filename = file;
							let query = "";
							const idx = filename.indexOf("?");
							if (idx >= 0) {
								query = filename.substr(idx);
								filename = filename.substr(0, idx);
							}
							let sourceMapFile = compilation.getPath(sourceMapFilename, {
								chunk,
								filename: options.fileContext
									? path.relative(options.fileContext, filename)
									: filename,
								query,
								basename: basename(filename),
								contentHash: createHash("md4")
									.update(sourceMapString)
									.digest("hex")
							});
							const sourceMapUrl = options.publicPath
								? options.publicPath + sourceMapFile.replace(/\\/g, "/")
								: path
										.relative(path.dirname(file), sourceMapFile)
										.replace(/\\/g, "/");
							if (currentSourceMappingURLComment !== false) {
								assets[file] = compilation.assets[file] = new ConcatSource(
									new RawSource(source),
									currentSourceMappingURLComment.replace(
										/\[url\]/g,
										sourceMapUrl
									)
								);
							}
							assets[sourceMapFile] = compilation.assets[
								sourceMapFile
							] = new RawSource(sourceMapString);
							chunk.files.push(sourceMapFile);
						} else {
							if (currentSourceMappingURLComment === false) {
								throw new Error(
									"SourceMapDevToolPlugin: append can't be false when no filename is provided"
								);
							}
							assets[file] = compilation.assets[file] = new ConcatSource(
								new RawSource(source),
								currentSourceMappingURLComment
									.replace(/\[map\]/g, () => sourceMapString)
									.replace(
										/\[url\]/g,
										() =>
											`data:application/json;charset=utf-8;base64,${Buffer.from(
												sourceMapString,
												"utf-8"
											).toString("base64")}`
									)
							);
						}
					});
					reportProgress(1.0);
				}
			);
		});
	}
}

module.exports = SourceMapDevToolPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/Stats.js":
/*!******************************!*\
  !*** (webpack)/lib/Stats.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const RequestShortener = __webpack_require__(/*! ./RequestShortener */ "./node_modules/webpack/lib/RequestShortener.js");
const SizeFormatHelpers = __webpack_require__(/*! ./SizeFormatHelpers */ "./node_modules/webpack/lib/SizeFormatHelpers.js");
const formatLocation = __webpack_require__(/*! ./formatLocation */ "./node_modules/webpack/lib/formatLocation.js");
const identifierUtils = __webpack_require__(/*! ./util/identifier */ "./node_modules/webpack/lib/util/identifier.js");
const compareLocations = __webpack_require__(/*! ./compareLocations */ "./node_modules/webpack/lib/compareLocations.js");

const optionsOrFallback = (...args) => {
	let optionValues = [];
	optionValues.push(...args);
	return optionValues.find(optionValue => optionValue !== undefined);
};

const compareId = (a, b) => {
	if (typeof a !== typeof b) {
		return typeof a < typeof b ? -1 : 1;
	}
	if (a < b) return -1;
	if (a > b) return 1;
	return 0;
};

class Stats {
	constructor(compilation) {
		this.compilation = compilation;
		this.hash = compilation.hash;
		this.startTime = undefined;
		this.endTime = undefined;
	}

	static filterWarnings(warnings, warningsFilter) {
		// we dont have anything to filter so all warnings can be shown
		if (!warningsFilter) {
			return warnings;
		}

		// create a chain of filters
		// if they return "true" a warning should be suppressed
		const normalizedWarningsFilters = [].concat(warningsFilter).map(filter => {
			if (typeof filter === "string") {
				return warning => warning.includes(filter);
			}

			if (filter instanceof RegExp) {
				return warning => filter.test(warning);
			}

			if (typeof filter === "function") {
				return filter;
			}

			throw new Error(
				`Can only filter warnings with Strings or RegExps. (Given: ${filter})`
			);
		});
		return warnings.filter(warning => {
			return !normalizedWarningsFilters.some(check => check(warning));
		});
	}

	formatFilePath(filePath) {
		const OPTIONS_REGEXP = /^(\s|\S)*!/;
		return filePath.includes("!")
			? `${filePath.replace(OPTIONS_REGEXP, "")} (${filePath})`
			: `${filePath}`;
	}

	hasWarnings() {
		return (
			this.compilation.warnings.length > 0 ||
			this.compilation.children.some(child => child.getStats().hasWarnings())
		);
	}

	hasErrors() {
		return (
			this.compilation.errors.length > 0 ||
			this.compilation.children.some(child => child.getStats().hasErrors())
		);
	}

	// remove a prefixed "!" that can be specified to reverse sort order
	normalizeFieldKey(field) {
		if (field[0] === "!") {
			return field.substr(1);
		}
		return field;
	}

	// if a field is prefixed by a "!" reverse sort order
	sortOrderRegular(field) {
		if (field[0] === "!") {
			return false;
		}
		return true;
	}

	toJson(options, forToString) {
		if (typeof options === "boolean" || typeof options === "string") {
			options = Stats.presetToOptions(options);
		} else if (!options) {
			options = {};
		}

		const optionOrLocalFallback = (v, def) =>
			v !== undefined ? v : options.all !== undefined ? options.all : def;

		const testAgainstGivenOption = item => {
			if (typeof item === "string") {
				const regExp = new RegExp(
					`[\\\\/]${item.replace(
						// eslint-disable-next-line no-useless-escape
						/[-[\]{}()*+?.\\^$|]/g,
						"\\$&"
					)}([\\\\/]|$|!|\\?)`
				);
				return ident => regExp.test(ident);
			}
			if (item && typeof item === "object" && typeof item.test === "function") {
				return ident => item.test(ident);
			}
			if (typeof item === "function") {
				return item;
			}
			if (typeof item === "boolean") {
				return () => item;
			}
		};

		const compilation = this.compilation;
		const context = optionsOrFallback(
			options.context,
			compilation.compiler.context
		);
		const requestShortener =
			compilation.compiler.context === context
				? compilation.requestShortener
				: new RequestShortener(context);
		const showPerformance = optionOrLocalFallback(options.performance, true);
		const showHash = optionOrLocalFallback(options.hash, true);
		const showEnv = optionOrLocalFallback(options.env, false);
		const showVersion = optionOrLocalFallback(options.version, true);
		const showTimings = optionOrLocalFallback(options.timings, true);
		const showBuiltAt = optionOrLocalFallback(options.builtAt, true);
		const showAssets = optionOrLocalFallback(options.assets, true);
		const showEntrypoints = optionOrLocalFallback(options.entrypoints, true);
		const showChunkGroups = optionOrLocalFallback(
			options.chunkGroups,
			!forToString
		);
		const showChunks = optionOrLocalFallback(options.chunks, !forToString);
		const showChunkModules = optionOrLocalFallback(options.chunkModules, true);
		const showChunkOrigins = optionOrLocalFallback(
			options.chunkOrigins,
			!forToString
		);
		const showModules = optionOrLocalFallback(options.modules, true);
		const showNestedModules = optionOrLocalFallback(
			options.nestedModules,
			true
		);
		const showModuleAssets = optionOrLocalFallback(
			options.moduleAssets,
			!forToString
		);
		const showDepth = optionOrLocalFallback(options.depth, !forToString);
		const showCachedModules = optionOrLocalFallback(options.cached, true);
		const showCachedAssets = optionOrLocalFallback(options.cachedAssets, true);
		const showReasons = optionOrLocalFallback(options.reasons, !forToString);
		const showUsedExports = optionOrLocalFallback(
			options.usedExports,
			!forToString
		);
		const showProvidedExports = optionOrLocalFallback(
			options.providedExports,
			!forToString
		);
		const showOptimizationBailout = optionOrLocalFallback(
			options.optimizationBailout,
			!forToString
		);
		const showChildren = optionOrLocalFallback(options.children, true);
		const showSource = optionOrLocalFallback(options.source, !forToString);
		const showModuleTrace = optionOrLocalFallback(options.moduleTrace, true);
		const showErrors = optionOrLocalFallback(options.errors, true);
		const showErrorDetails = optionOrLocalFallback(
			options.errorDetails,
			!forToString
		);
		const showWarnings = optionOrLocalFallback(options.warnings, true);
		const warningsFilter = optionsOrFallback(options.warningsFilter, null);
		const showPublicPath = optionOrLocalFallback(
			options.publicPath,
			!forToString
		);
		const excludeModules = []
			.concat(optionsOrFallback(options.excludeModules, options.exclude, []))
			.map(testAgainstGivenOption);
		const excludeAssets = []
			.concat(optionsOrFallback(options.excludeAssets, []))
			.map(testAgainstGivenOption);
		const maxModules = optionsOrFallback(
			options.maxModules,
			forToString ? 15 : Infinity
		);
		const sortModules = optionsOrFallback(options.modulesSort, "id");
		const sortChunks = optionsOrFallback(options.chunksSort, "id");
		const sortAssets = optionsOrFallback(options.assetsSort, "");
		const showOutputPath = optionOrLocalFallback(
			options.outputPath,
			!forToString
		);

		if (!showCachedModules) {
			excludeModules.push((ident, module) => !module.built);
		}

		const createModuleFilter = () => {
			let i = 0;
			return module => {
				if (excludeModules.length > 0) {
					const ident = requestShortener.shorten(module.resource);
					const excluded = excludeModules.some(fn => fn(ident, module));
					if (excluded) return false;
				}
				const result = i < maxModules;
				i++;
				return result;
			};
		};

		const createAssetFilter = () => {
			return asset => {
				if (excludeAssets.length > 0) {
					const ident = asset.name;
					const excluded = excludeAssets.some(fn => fn(ident, asset));
					if (excluded) return false;
				}
				return showCachedAssets || asset.emitted;
			};
		};

		const sortByFieldAndOrder = (fieldKey, a, b) => {
			if (a[fieldKey] === null && b[fieldKey] === null) return 0;
			if (a[fieldKey] === null) return 1;
			if (b[fieldKey] === null) return -1;
			if (a[fieldKey] === b[fieldKey]) return 0;
			if (typeof a[fieldKey] !== typeof b[fieldKey])
				return typeof a[fieldKey] < typeof b[fieldKey] ? -1 : 1;
			return a[fieldKey] < b[fieldKey] ? -1 : 1;
		};

		const sortByField = (field, originalArray) => {
			const originalMap = originalArray.reduce((map, v, i) => {
				map.set(v, i);
				return map;
			}, new Map());
			return (a, b) => {
				if (field) {
					const fieldKey = this.normalizeFieldKey(field);

					// if a field is prefixed with a "!" the sort is reversed!
					const sortIsRegular = this.sortOrderRegular(field);

					const cmp = sortByFieldAndOrder(
						fieldKey,
						sortIsRegular ? a : b,
						sortIsRegular ? b : a
					);
					if (cmp) return cmp;
				}
				return originalMap.get(a) - originalMap.get(b);
			};
		};

		const formatError = e => {
			let text = "";
			if (typeof e === "string") {
				e = { message: e };
			}
			if (e.chunk) {
				text += `chunk ${e.chunk.name || e.chunk.id}${
					e.chunk.hasRuntime()
						? " [entry]"
						: e.chunk.canBeInitial()
							? " [initial]"
							: ""
				}\n`;
			}
			if (e.file) {
				text += `${e.file}\n`;
			}
			if (
				e.module &&
				e.module.readableIdentifier &&
				typeof e.module.readableIdentifier === "function"
			) {
				text += this.formatFilePath(
					e.module.readableIdentifier(requestShortener)
				);
				if (typeof e.loc === "object") {
					const locInfo = formatLocation(e.loc);
					if (locInfo) text += ` ${locInfo}`;
				}
				text += "\n";
			}
			text += e.message;
			if (showErrorDetails && e.details) {
				text += `\n${e.details}`;
			}
			if (showErrorDetails && e.missing) {
				text += e.missing.map(item => `\n[${item}]`).join("");
			}
			if (showModuleTrace && e.origin) {
				text += `\n @ ${this.formatFilePath(
					e.origin.readableIdentifier(requestShortener)
				)}`;
				if (typeof e.originLoc === "object") {
					const locInfo = formatLocation(e.originLoc);
					if (locInfo) text += ` ${locInfo}`;
				}
				if (e.dependencies) {
					for (const dep of e.dependencies) {
						if (!dep.loc) continue;
						if (typeof dep.loc === "string") continue;
						const locInfo = formatLocation(dep.loc);
						if (!locInfo) continue;
						text += ` ${locInfo}`;
					}
				}
				let current = e.origin;
				while (current.issuer) {
					current = current.issuer;
					text += `\n @ ${current.readableIdentifier(requestShortener)}`;
				}
			}
			return text;
		};

		const obj = {
			errors: compilation.errors.map(formatError),
			warnings: Stats.filterWarnings(
				compilation.warnings.map(formatError),
				warningsFilter
			)
		};

		//We just hint other renderers since actually omitting
		//errors/warnings from the JSON would be kind of weird.
		Object.defineProperty(obj, "_showWarnings", {
			value: showWarnings,
			enumerable: false
		});
		Object.defineProperty(obj, "_showErrors", {
			value: showErrors,
			enumerable: false
		});

		if (showVersion) {
			obj.version = __webpack_require__(/*! ../package.json */ "./node_modules/webpack/package.json").version;
		}

		if (showHash) obj.hash = this.hash;
		if (showTimings && this.startTime && this.endTime) {
			obj.time = this.endTime - this.startTime;
		}

		if (showBuiltAt && this.endTime) {
			obj.builtAt = this.endTime;
		}

		if (showEnv && options._env) {
			obj.env = options._env;
		}

		if (compilation.needAdditionalPass) {
			obj.needAdditionalPass = true;
		}
		if (showPublicPath) {
			obj.publicPath = this.compilation.mainTemplate.getPublicPath({
				hash: this.compilation.hash
			});
		}
		if (showOutputPath) {
			obj.outputPath = this.compilation.mainTemplate.outputOptions.path;
		}
		if (showAssets) {
			const assetsByFile = {};
			const compilationAssets = Object.keys(compilation.assets).sort();
			obj.assetsByChunkName = {};
			obj.assets = compilationAssets
				.map(asset => {
					const obj = {
						name: asset,
						size: compilation.assets[asset].size(),
						chunks: [],
						chunkNames: [],
						// TODO webpack 5: remove .emitted
						emitted:
							compilation.assets[asset].emitted ||
							compilation.emittedAssets.has(asset)
					};

					if (showPerformance) {
						obj.isOverSizeLimit = compilation.assets[asset].isOverSizeLimit;
					}

					assetsByFile[asset] = obj;
					return obj;
				})
				.filter(createAssetFilter());
			obj.filteredAssets = compilationAssets.length - obj.assets.length;

			for (const chunk of compilation.chunks) {
				for (const asset of chunk.files) {
					if (assetsByFile[asset]) {
						for (const id of chunk.ids) {
							assetsByFile[asset].chunks.push(id);
						}
						if (chunk.name) {
							assetsByFile[asset].chunkNames.push(chunk.name);
							if (obj.assetsByChunkName[chunk.name]) {
								obj.assetsByChunkName[chunk.name] = []
									.concat(obj.assetsByChunkName[chunk.name])
									.concat([asset]);
							} else {
								obj.assetsByChunkName[chunk.name] = asset;
							}
						}
					}
				}
			}
			obj.assets.sort(sortByField(sortAssets, obj.assets));
		}

		const fnChunkGroup = groupMap => {
			const obj = {};
			for (const keyValuePair of groupMap) {
				const name = keyValuePair[0];
				const cg = keyValuePair[1];
				const children = cg.getChildrenByOrders();
				obj[name] = {
					chunks: cg.chunks.map(c => c.id),
					assets: cg.chunks.reduce(
						(array, c) => array.concat(c.files || []),
						[]
					),
					children: Object.keys(children).reduce((obj, key) => {
						const groups = children[key];
						obj[key] = groups.map(group => ({
							name: group.name,
							chunks: group.chunks.map(c => c.id),
							assets: group.chunks.reduce(
								(array, c) => array.concat(c.files || []),
								[]
							)
						}));
						return obj;
					}, Object.create(null)),
					childAssets: Object.keys(children).reduce((obj, key) => {
						const groups = children[key];
						obj[key] = Array.from(
							groups.reduce((set, group) => {
								for (const chunk of group.chunks) {
									for (const asset of chunk.files) {
										set.add(asset);
									}
								}
								return set;
							}, new Set())
						);
						return obj;
					}, Object.create(null))
				};
				if (showPerformance) {
					obj[name].isOverSizeLimit = cg.isOverSizeLimit;
				}
			}

			return obj;
		};

		if (showEntrypoints) {
			obj.entrypoints = fnChunkGroup(compilation.entrypoints);
		}

		if (showChunkGroups) {
			obj.namedChunkGroups = fnChunkGroup(compilation.namedChunkGroups);
		}

		const fnModule = module => {
			const path = [];
			let current = module;
			while (current.issuer) {
				path.push((current = current.issuer));
			}
			path.reverse();
			const obj = {
				id: module.id,
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener),
				index: module.index,
				index2: module.index2,
				size: module.size(),
				cacheable: module.buildInfo.cacheable,
				built: !!module.built,
				optional: module.optional,
				prefetched: module.prefetched,
				chunks: Array.from(module.chunksIterable, chunk => chunk.id),
				issuer: module.issuer && module.issuer.identifier(),
				issuerId: module.issuer && module.issuer.id,
				issuerName:
					module.issuer && module.issuer.readableIdentifier(requestShortener),
				issuerPath:
					module.issuer &&
					path.map(module => ({
						id: module.id,
						identifier: module.identifier(),
						name: module.readableIdentifier(requestShortener),
						profile: module.profile
					})),
				profile: module.profile,
				failed: !!module.error,
				errors: module.errors ? module.errors.length : 0,
				warnings: module.warnings ? module.warnings.length : 0
			};
			if (showModuleAssets) {
				obj.assets = Object.keys(module.buildInfo.assets || {});
			}
			if (showReasons) {
				obj.reasons = module.reasons
					.sort((a, b) => {
						if (a.module && !b.module) return -1;
						if (!a.module && b.module) return 1;
						if (a.module && b.module) {
							const cmp = compareId(a.module.id, b.module.id);
							if (cmp) return cmp;
						}
						if (a.dependency && !b.dependency) return -1;
						if (!a.dependency && b.dependency) return 1;
						if (a.dependency && b.dependency) {
							const cmp = compareLocations(a.dependency.loc, b.dependency.loc);
							if (cmp) return cmp;
							if (a.dependency.type < b.dependency.type) return -1;
							if (a.dependency.type > b.dependency.type) return 1;
						}
						return 0;
					})
					.map(reason => {
						const obj = {
							moduleId: reason.module ? reason.module.id : null,
							moduleIdentifier: reason.module
								? reason.module.identifier()
								: null,
							module: reason.module
								? reason.module.readableIdentifier(requestShortener)
								: null,
							moduleName: reason.module
								? reason.module.readableIdentifier(requestShortener)
								: null,
							type: reason.dependency ? reason.dependency.type : null,
							explanation: reason.explanation,
							userRequest: reason.dependency
								? reason.dependency.userRequest
								: null
						};
						if (reason.dependency) {
							const locInfo = formatLocation(reason.dependency.loc);
							if (locInfo) {
								obj.loc = locInfo;
							}
						}
						return obj;
					});
			}
			if (showUsedExports) {
				if (module.used === true) {
					obj.usedExports = module.usedExports;
				} else if (module.used === false) {
					obj.usedExports = false;
				}
			}
			if (showProvidedExports) {
				obj.providedExports = Array.isArray(module.buildMeta.providedExports)
					? module.buildMeta.providedExports
					: null;
			}
			if (showOptimizationBailout) {
				obj.optimizationBailout = module.optimizationBailout.map(item => {
					if (typeof item === "function") return item(requestShortener);
					return item;
				});
			}
			if (showDepth) {
				obj.depth = module.depth;
			}
			if (showNestedModules) {
				if (module.modules) {
					const modules = module.modules;
					obj.modules = modules
						.sort(sortByField("depth", modules))
						.filter(createModuleFilter())
						.map(fnModule);
					obj.filteredModules = modules.length - obj.modules.length;
					obj.modules.sort(sortByField(sortModules, obj.modules));
				}
			}
			if (showSource && module._source) {
				obj.source = module._source.source();
			}
			return obj;
		};
		if (showChunks) {
			obj.chunks = compilation.chunks.map(chunk => {
				const parents = new Set();
				const children = new Set();
				const siblings = new Set();
				const childIdByOrder = chunk.getChildIdsByOrders();
				for (const chunkGroup of chunk.groupsIterable) {
					for (const parentGroup of chunkGroup.parentsIterable) {
						for (const chunk of parentGroup.chunks) {
							parents.add(chunk.id);
						}
					}
					for (const childGroup of chunkGroup.childrenIterable) {
						for (const chunk of childGroup.chunks) {
							children.add(chunk.id);
						}
					}
					for (const sibling of chunkGroup.chunks) {
						if (sibling !== chunk) siblings.add(sibling.id);
					}
				}
				const obj = {
					id: chunk.id,
					rendered: chunk.rendered,
					initial: chunk.canBeInitial(),
					entry: chunk.hasRuntime(),
					recorded: chunk.recorded,
					reason: chunk.chunkReason,
					size: chunk.modulesSize(),
					names: chunk.name ? [chunk.name] : [],
					files: chunk.files.slice(),
					hash: chunk.renderedHash,
					siblings: Array.from(siblings).sort(compareId),
					parents: Array.from(parents).sort(compareId),
					children: Array.from(children).sort(compareId),
					childrenByOrder: childIdByOrder
				};
				if (showChunkModules) {
					const modules = chunk.getModules();
					obj.modules = modules
						.slice()
						.sort(sortByField("depth", modules))
						.filter(createModuleFilter())
						.map(fnModule);
					obj.filteredModules = chunk.getNumberOfModules() - obj.modules.length;
					obj.modules.sort(sortByField(sortModules, obj.modules));
				}
				if (showChunkOrigins) {
					obj.origins = Array.from(chunk.groupsIterable, g => g.origins)
						.reduce((a, b) => a.concat(b), [])
						.map(origin => ({
							moduleId: origin.module ? origin.module.id : undefined,
							module: origin.module ? origin.module.identifier() : "",
							moduleIdentifier: origin.module ? origin.module.identifier() : "",
							moduleName: origin.module
								? origin.module.readableIdentifier(requestShortener)
								: "",
							loc: formatLocation(origin.loc),
							request: origin.request,
							reasons: origin.reasons || []
						}))
						.sort((a, b) => {
							const cmp1 = compareId(a.moduleId, b.moduleId);
							if (cmp1) return cmp1;
							const cmp2 = compareId(a.loc, b.loc);
							if (cmp2) return cmp2;
							const cmp3 = compareId(a.request, b.request);
							if (cmp3) return cmp3;
							return 0;
						});
				}
				return obj;
			});
			obj.chunks.sort(sortByField(sortChunks, obj.chunks));
		}
		if (showModules) {
			obj.modules = compilation.modules
				.slice()
				.sort(sortByField("depth", compilation.modules))
				.filter(createModuleFilter())
				.map(fnModule);
			obj.filteredModules = compilation.modules.length - obj.modules.length;
			obj.modules.sort(sortByField(sortModules, obj.modules));
		}
		if (showChildren) {
			obj.children = compilation.children.map((child, idx) => {
				const childOptions = Stats.getChildOptions(options, idx);
				const obj = new Stats(child).toJson(childOptions, forToString);
				delete obj.hash;
				delete obj.version;
				if (child.name) {
					obj.name = identifierUtils.makePathsRelative(
						context,
						child.name,
						compilation.cache
					);
				}
				return obj;
			});
		}

		return obj;
	}

	toString(options) {
		if (typeof options === "boolean" || typeof options === "string") {
			options = Stats.presetToOptions(options);
		} else if (!options) {
			options = {};
		}

		const useColors = optionsOrFallback(options.colors, false);

		const obj = this.toJson(options, true);

		return Stats.jsonToString(obj, useColors);
	}

	static jsonToString(obj, useColors) {
		const buf = [];

		const defaultColors = {
			bold: "\u001b[1m",
			yellow: "\u001b[1m\u001b[33m",
			red: "\u001b[1m\u001b[31m",
			green: "\u001b[1m\u001b[32m",
			cyan: "\u001b[1m\u001b[36m",
			magenta: "\u001b[1m\u001b[35m"
		};

		const colors = Object.keys(defaultColors).reduce(
			(obj, color) => {
				obj[color] = str => {
					if (useColors) {
						buf.push(
							useColors === true || useColors[color] === undefined
								? defaultColors[color]
								: useColors[color]
						);
					}
					buf.push(str);
					if (useColors) {
						buf.push("\u001b[39m\u001b[22m");
					}
				};
				return obj;
			},
			{
				normal: str => buf.push(str)
			}
		);

		const coloredTime = time => {
			let times = [800, 400, 200, 100];
			if (obj.time) {
				times = [obj.time / 2, obj.time / 4, obj.time / 8, obj.time / 16];
			}
			if (time < times[3]) colors.normal(`${time}ms`);
			else if (time < times[2]) colors.bold(`${time}ms`);
			else if (time < times[1]) colors.green(`${time}ms`);
			else if (time < times[0]) colors.yellow(`${time}ms`);
			else colors.red(`${time}ms`);
		};

		const newline = () => buf.push("\n");

		const getText = (arr, row, col) => {
			return arr[row][col].value;
		};

		const table = (array, align, splitter) => {
			const rows = array.length;
			const cols = array[0].length;
			const colSizes = new Array(cols);
			for (let col = 0; col < cols; col++) {
				colSizes[col] = 0;
			}
			for (let row = 0; row < rows; row++) {
				for (let col = 0; col < cols; col++) {
					const value = `${getText(array, row, col)}`;
					if (value.length > colSizes[col]) {
						colSizes[col] = value.length;
					}
				}
			}
			for (let row = 0; row < rows; row++) {
				for (let col = 0; col < cols; col++) {
					const format = array[row][col].color;
					const value = `${getText(array, row, col)}`;
					let l = value.length;
					if (align[col] === "l") {
						format(value);
					}
					for (; l < colSizes[col] && col !== cols - 1; l++) {
						colors.normal(" ");
					}
					if (align[col] === "r") {
						format(value);
					}
					if (col + 1 < cols && colSizes[col] !== 0) {
						colors.normal(splitter || "  ");
					}
				}
				newline();
			}
		};

		const getAssetColor = (asset, defaultColor) => {
			if (asset.isOverSizeLimit) {
				return colors.yellow;
			}

			return defaultColor;
		};

		if (obj.hash) {
			colors.normal("Hash: ");
			colors.bold(obj.hash);
			newline();
		}
		if (obj.version) {
			colors.normal("Version: webpack ");
			colors.bold(obj.version);
			newline();
		}
		if (typeof obj.time === "number") {
			colors.normal("Time: ");
			colors.bold(obj.time);
			colors.normal("ms");
			newline();
		}
		if (typeof obj.builtAt === "number") {
			const builtAtDate = new Date(obj.builtAt);
			colors.normal("Built at: ");
			colors.normal(
				builtAtDate.toLocaleDateString(undefined, {
					day: "2-digit",
					month: "2-digit",
					year: "numeric"
				})
			);
			colors.normal(" ");
			colors.bold(builtAtDate.toLocaleTimeString());
			newline();
		}
		if (obj.env) {
			colors.normal("Environment (--env): ");
			colors.bold(JSON.stringify(obj.env, null, 2));
			newline();
		}
		if (obj.publicPath) {
			colors.normal("PublicPath: ");
			colors.bold(obj.publicPath);
			newline();
		}

		if (obj.assets && obj.assets.length > 0) {
			const t = [
				[
					{
						value: "Asset",
						color: colors.bold
					},
					{
						value: "Size",
						color: colors.bold
					},
					{
						value: "Chunks",
						color: colors.bold
					},
					{
						value: "",
						color: colors.bold
					},
					{
						value: "",
						color: colors.bold
					},
					{
						value: "Chunk Names",
						color: colors.bold
					}
				]
			];
			for (const asset of obj.assets) {
				t.push([
					{
						value: asset.name,
						color: getAssetColor(asset, colors.green)
					},
					{
						value: SizeFormatHelpers.formatSize(asset.size),
						color: getAssetColor(asset, colors.normal)
					},
					{
						value: asset.chunks.join(", "),
						color: colors.bold
					},
					{
						value: asset.emitted ? "[emitted]" : "",
						color: colors.green
					},
					{
						value: asset.isOverSizeLimit ? "[big]" : "",
						color: getAssetColor(asset, colors.normal)
					},
					{
						value: asset.chunkNames.join(", "),
						color: colors.normal
					}
				]);
			}
			table(t, "rrrlll");
		}
		if (obj.filteredAssets > 0) {
			colors.normal(" ");
			if (obj.assets.length > 0) colors.normal("+ ");
			colors.normal(obj.filteredAssets);
			if (obj.assets.length > 0) colors.normal(" hidden");
			colors.normal(obj.filteredAssets !== 1 ? " assets" : " asset");
			newline();
		}

		const processChunkGroups = (namedGroups, prefix) => {
			for (const name of Object.keys(namedGroups)) {
				const cg = namedGroups[name];
				colors.normal(`${prefix} `);
				colors.bold(name);
				if (cg.isOverSizeLimit) {
					colors.normal(" ");
					colors.yellow("[big]");
				}
				colors.normal(" =");
				for (const asset of cg.assets) {
					colors.normal(" ");
					colors.green(asset);
				}
				for (const name of Object.keys(cg.childAssets)) {
					const assets = cg.childAssets[name];
					if (assets && assets.length > 0) {
						colors.normal(" ");
						colors.magenta(`(${name}:`);
						for (const asset of assets) {
							colors.normal(" ");
							colors.green(asset);
						}
						colors.magenta(")");
					}
				}
				newline();
			}
		};

		if (obj.entrypoints) {
			processChunkGroups(obj.entrypoints, "Entrypoint");
		}

		if (obj.namedChunkGroups) {
			let outputChunkGroups = obj.namedChunkGroups;
			if (obj.entrypoints) {
				outputChunkGroups = Object.keys(outputChunkGroups)
					.filter(name => !obj.entrypoints[name])
					.reduce((result, name) => {
						result[name] = obj.namedChunkGroups[name];
						return result;
					}, {});
			}
			processChunkGroups(outputChunkGroups, "Chunk Group");
		}

		const modulesByIdentifier = {};
		if (obj.modules) {
			for (const module of obj.modules) {
				modulesByIdentifier[`$${module.identifier}`] = module;
			}
		} else if (obj.chunks) {
			for (const chunk of obj.chunks) {
				if (chunk.modules) {
					for (const module of chunk.modules) {
						modulesByIdentifier[`$${module.identifier}`] = module;
					}
				}
			}
		}

		const processModuleAttributes = module => {
			colors.normal(" ");
			colors.normal(SizeFormatHelpers.formatSize(module.size));
			if (module.chunks) {
				for (const chunk of module.chunks) {
					colors.normal(" {");
					colors.yellow(chunk);
					colors.normal("}");
				}
			}
			if (typeof module.depth === "number") {
				colors.normal(` [depth ${module.depth}]`);
			}
			if (module.cacheable === false) {
				colors.red(" [not cacheable]");
			}
			if (module.optional) {
				colors.yellow(" [optional]");
			}
			if (module.built) {
				colors.green(" [built]");
			}
			if (module.assets && module.assets.length) {
				colors.magenta(
					` [${module.assets.length} asset${
						module.assets.length === 1 ? "" : "s"
					}]`
				);
			}
			if (module.prefetched) {
				colors.magenta(" [prefetched]");
			}
			if (module.failed) colors.red(" [failed]");
			if (module.warnings) {
				colors.yellow(
					` [${module.warnings} warning${module.warnings === 1 ? "" : "s"}]`
				);
			}
			if (module.errors) {
				colors.red(
					` [${module.errors} error${module.errors === 1 ? "" : "s"}]`
				);
			}
		};

		const processModuleContent = (module, prefix) => {
			if (Array.isArray(module.providedExports)) {
				colors.normal(prefix);
				if (module.providedExports.length === 0) {
					colors.cyan("[no exports]");
				} else {
					colors.cyan(`[exports: ${module.providedExports.join(", ")}]`);
				}
				newline();
			}
			if (module.usedExports !== undefined) {
				if (module.usedExports !== true) {
					colors.normal(prefix);
					if (module.usedExports === null) {
						colors.cyan("[used exports unknown]");
					} else if (module.usedExports === false) {
						colors.cyan("[no exports used]");
					} else if (
						Array.isArray(module.usedExports) &&
						module.usedExports.length === 0
					) {
						colors.cyan("[no exports used]");
					} else if (Array.isArray(module.usedExports)) {
						const providedExportsCount = Array.isArray(module.providedExports)
							? module.providedExports.length
							: null;
						if (
							providedExportsCount !== null &&
							providedExportsCount === module.usedExports.length
						) {
							colors.cyan("[all exports used]");
						} else {
							colors.cyan(
								`[only some exports used: ${module.usedExports.join(", ")}]`
							);
						}
					}
					newline();
				}
			}
			if (Array.isArray(module.optimizationBailout)) {
				for (const item of module.optimizationBailout) {
					colors.normal(prefix);
					colors.yellow(item);
					newline();
				}
			}
			if (module.reasons) {
				for (const reason of module.reasons) {
					colors.normal(prefix);
					if (reason.type) {
						colors.normal(reason.type);
						colors.normal(" ");
					}
					if (reason.userRequest) {
						colors.cyan(reason.userRequest);
						colors.normal(" ");
					}
					if (reason.moduleId !== null) {
						colors.normal("[");
						colors.normal(reason.moduleId);
						colors.normal("]");
					}
					if (reason.module && reason.module !== reason.moduleId) {
						colors.normal(" ");
						colors.magenta(reason.module);
					}
					if (reason.loc) {
						colors.normal(" ");
						colors.normal(reason.loc);
					}
					if (reason.explanation) {
						colors.normal(" ");
						colors.cyan(reason.explanation);
					}
					newline();
				}
			}
			if (module.profile) {
				colors.normal(prefix);
				let sum = 0;
				if (module.issuerPath) {
					for (const m of module.issuerPath) {
						colors.normal("[");
						colors.normal(m.id);
						colors.normal("] ");
						if (m.profile) {
							const time = (m.profile.factory || 0) + (m.profile.building || 0);
							coloredTime(time);
							sum += time;
							colors.normal(" ");
						}
						colors.normal("-> ");
					}
				}
				for (const key of Object.keys(module.profile)) {
					colors.normal(`${key}:`);
					const time = module.profile[key];
					coloredTime(time);
					colors.normal(" ");
					sum += time;
				}
				colors.normal("= ");
				coloredTime(sum);
				newline();
			}
			if (module.modules) {
				processModulesList(module, prefix + "| ");
			}
		};

		const processModulesList = (obj, prefix) => {
			if (obj.modules) {
				let maxModuleId = 0;
				for (const module of obj.modules) {
					if (typeof module.id === "number") {
						if (maxModuleId < module.id) maxModuleId = module.id;
					}
				}
				let contentPrefix = prefix + "    ";
				if (maxModuleId >= 10) contentPrefix += " ";
				if (maxModuleId >= 100) contentPrefix += " ";
				if (maxModuleId >= 1000) contentPrefix += " ";
				for (const module of obj.modules) {
					colors.normal(prefix);
					const name = module.name || module.identifier;
					if (typeof module.id === "string" || typeof module.id === "number") {
						if (typeof module.id === "number") {
							if (module.id < 1000 && maxModuleId >= 1000) colors.normal(" ");
							if (module.id < 100 && maxModuleId >= 100) colors.normal(" ");
							if (module.id < 10 && maxModuleId >= 10) colors.normal(" ");
						} else {
							if (maxModuleId >= 1000) colors.normal(" ");
							if (maxModuleId >= 100) colors.normal(" ");
							if (maxModuleId >= 10) colors.normal(" ");
						}
						if (name !== module.id) {
							colors.normal("[");
							colors.normal(module.id);
							colors.normal("]");
							colors.normal(" ");
						} else {
							colors.normal("[");
							colors.bold(module.id);
							colors.normal("]");
						}
					}
					if (name !== module.id) {
						colors.bold(name);
					}
					processModuleAttributes(module);
					newline();
					processModuleContent(module, contentPrefix);
				}
				if (obj.filteredModules > 0) {
					colors.normal(prefix);
					colors.normal("   ");
					if (obj.modules.length > 0) colors.normal(" + ");
					colors.normal(obj.filteredModules);
					if (obj.modules.length > 0) colors.normal(" hidden");
					colors.normal(obj.filteredModules !== 1 ? " modules" : " module");
					newline();
				}
			}
		};

		if (obj.chunks) {
			for (const chunk of obj.chunks) {
				colors.normal("chunk ");
				if (chunk.id < 1000) colors.normal(" ");
				if (chunk.id < 100) colors.normal(" ");
				if (chunk.id < 10) colors.normal(" ");
				colors.normal("{");
				colors.yellow(chunk.id);
				colors.normal("} ");
				colors.green(chunk.files.join(", "));
				if (chunk.names && chunk.names.length > 0) {
					colors.normal(" (");
					colors.normal(chunk.names.join(", "));
					colors.normal(")");
				}
				colors.normal(" ");
				colors.normal(SizeFormatHelpers.formatSize(chunk.size));
				for (const id of chunk.parents) {
					colors.normal(" <{");
					colors.yellow(id);
					colors.normal("}>");
				}
				for (const id of chunk.siblings) {
					colors.normal(" ={");
					colors.yellow(id);
					colors.normal("}=");
				}
				for (const id of chunk.children) {
					colors.normal(" >{");
					colors.yellow(id);
					colors.normal("}<");
				}
				if (chunk.childrenByOrder) {
					for (const name of Object.keys(chunk.childrenByOrder)) {
						const children = chunk.childrenByOrder[name];
						colors.normal(" ");
						colors.magenta(`(${name}:`);
						for (const id of children) {
							colors.normal(" {");
							colors.yellow(id);
							colors.normal("}");
						}
						colors.magenta(")");
					}
				}
				if (chunk.entry) {
					colors.yellow(" [entry]");
				} else if (chunk.initial) {
					colors.yellow(" [initial]");
				}
				if (chunk.rendered) {
					colors.green(" [rendered]");
				}
				if (chunk.recorded) {
					colors.green(" [recorded]");
				}
				if (chunk.reason) {
					colors.yellow(` ${chunk.reason}`);
				}
				newline();
				if (chunk.origins) {
					for (const origin of chunk.origins) {
						colors.normal("    > ");
						if (origin.reasons && origin.reasons.length) {
							colors.yellow(origin.reasons.join(" "));
							colors.normal(" ");
						}
						if (origin.request) {
							colors.normal(origin.request);
							colors.normal(" ");
						}
						if (origin.module) {
							colors.normal("[");
							colors.normal(origin.moduleId);
							colors.normal("] ");
							const module = modulesByIdentifier[`$${origin.module}`];
							if (module) {
								colors.bold(module.name);
								colors.normal(" ");
							}
						}
						if (origin.loc) {
							colors.normal(origin.loc);
						}
						newline();
					}
				}
				processModulesList(chunk, " ");
			}
		}

		processModulesList(obj, "");

		if (obj._showWarnings && obj.warnings) {
			for (const warning of obj.warnings) {
				newline();
				colors.yellow(`WARNING in ${warning}`);
				newline();
			}
		}
		if (obj._showErrors && obj.errors) {
			for (const error of obj.errors) {
				newline();
				colors.red(`ERROR in ${error}`);
				newline();
			}
		}
		if (obj.children) {
			for (const child of obj.children) {
				const childString = Stats.jsonToString(child, useColors);
				if (childString) {
					if (child.name) {
						colors.normal("Child ");
						colors.bold(child.name);
						colors.normal(":");
					} else {
						colors.normal("Child");
					}
					newline();
					buf.push("    ");
					buf.push(childString.replace(/\n/g, "\n    "));
					newline();
				}
			}
		}
		if (obj.needAdditionalPass) {
			colors.yellow(
				"Compilation needs an additional pass and will compile again."
			);
		}

		while (buf[buf.length - 1] === "\n") {
			buf.pop();
		}
		return buf.join("");
	}

	static presetToOptions(name) {
		// Accepted values: none, errors-only, minimal, normal, detailed, verbose
		// Any other falsy value will behave as 'none', truthy values as 'normal'
		const pn =
			(typeof name === "string" && name.toLowerCase()) || name || "none";
		switch (pn) {
			case "none":
				return {
					all: false
				};
			case "verbose":
				return {
					entrypoints: true,
					chunkGroups: true,
					modules: false,
					chunks: true,
					chunkModules: true,
					chunkOrigins: true,
					depth: true,
					env: true,
					reasons: true,
					usedExports: true,
					providedExports: true,
					optimizationBailout: true,
					errorDetails: true,
					publicPath: true,
					exclude: false,
					maxModules: Infinity
				};
			case "detailed":
				return {
					entrypoints: true,
					chunkGroups: true,
					chunks: true,
					chunkModules: false,
					chunkOrigins: true,
					depth: true,
					usedExports: true,
					providedExports: true,
					optimizationBailout: true,
					errorDetails: true,
					publicPath: true,
					exclude: false,
					maxModules: Infinity
				};
			case "minimal":
				return {
					all: false,
					modules: true,
					maxModules: 0,
					errors: true,
					warnings: true
				};
			case "errors-only":
				return {
					all: false,
					errors: true,
					moduleTrace: true
				};
			default:
				return {};
		}
	}

	static getChildOptions(options, idx) {
		let innerOptions;
		if (Array.isArray(options.children)) {
			if (idx < options.children.length) {
				innerOptions = options.children[idx];
			}
		} else if (typeof options.children === "object" && options.children) {
			innerOptions = options.children;
		}
		if (typeof innerOptions === "boolean" || typeof innerOptions === "string") {
			innerOptions = Stats.presetToOptions(innerOptions);
		}
		if (!innerOptions) {
			return options;
		}
		const childOptions = Object.assign({}, options);
		delete childOptions.children; // do not inherit children
		return Object.assign(childOptions, innerOptions);
	}
}

module.exports = Stats;


/***/ }),

/***/ "./node_modules/webpack/lib/Template.js":
/*!*********************************!*\
  !*** (webpack)/lib/Template.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/** @typedef {import("./Module")} Module */
/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./ModuleTemplate")} ModuleTemplate */
/** @typedef {import("webpack-sources").ConcatSource} ConcatSource */

const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const HotUpdateChunk = __webpack_require__(/*! ./HotUpdateChunk */ "./node_modules/webpack/lib/HotUpdateChunk.js");

const START_LOWERCASE_ALPHABET_CODE = "a".charCodeAt(0);
const START_UPPERCASE_ALPHABET_CODE = "A".charCodeAt(0);
const DELTA_A_TO_Z = "z".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1;
const FUNCTION_CONTENT_REGEX = /^function\s?\(\)\s?\{\r?\n?|\r?\n?\}$/g;
const INDENT_MULTILINE_REGEX = /^\t/gm;
const LINE_SEPARATOR_REGEX = /\r?\n/g;
const IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/;
const IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g;
const COMMENT_END_REGEX = /\*\//g;
const PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\-^°]+/g;
const MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g;

/** @typedef {import("webpack-sources").Source} Source */

/**
 * @typedef {Object} HasId
 * @property {number | string} id
 */

/**
 * @typedef {function(Module, number): boolean} ModuleFilterPredicate
 */

/**
 * @param {HasId} a first id object to be sorted
 * @param {HasId} b second id object to be sorted against
 * @returns {-1|0|1} the sort value
 */
const stringifyIdSortPredicate = (a, b) => {
	const aId = a.id + "";
	const bId = b.id + "";
	if (aId < bId) return -1;
	if (aId > bId) return 1;
	return 0;
};

class Template {
	/**
	 *
	 * @param {Function} fn - a runtime function (.runtime.js) "template"
	 * @returns {string} the updated and normalized function string
	 */
	static getFunctionContent(fn) {
		return fn
			.toString()
			.replace(FUNCTION_CONTENT_REGEX, "")
			.replace(INDENT_MULTILINE_REGEX, "")
			.replace(LINE_SEPARATOR_REGEX, "\n");
	}

	/**
	 * @param {string} str the string converted to identifier
	 * @returns {string} created identifier
	 */
	static toIdentifier(str) {
		if (typeof str !== "string") return "";
		return str
			.replace(IDENTIFIER_NAME_REPLACE_REGEX, "_$1")
			.replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, "_");
	}
	/**
	 *
	 * @param {string} str string to be converted to commented in bundle code
	 * @returns {string} returns a commented version of string
	 */
	static toComment(str) {
		if (!str) return "";
		return `/*! ${str.replace(COMMENT_END_REGEX, "* /")} */`;
	}

	/**
	 *
	 * @param {string} str string to be converted to "normal comment"
	 * @returns {string} returns a commented version of string
	 */
	static toNormalComment(str) {
		if (!str) return "";
		return `/* ${str.replace(COMMENT_END_REGEX, "* /")} */`;
	}

	/**
	 * @param {string} str string path to be normalized
	 * @returns {string} normalized bundle-safe path
	 */
	static toPath(str) {
		if (typeof str !== "string") return "";
		return str
			.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, "-")
			.replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, "");
	}

	// map number to a single character a-z, A-Z or <_ + number> if number is too big
	/**
	 *
	 * @param {number} n number to convert to ident
	 * @returns {string} returns single character ident
	 */
	static numberToIdentifer(n) {
		// lower case
		if (n < DELTA_A_TO_Z) {
			return String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n);
		}

		// upper case
		if (n < DELTA_A_TO_Z * 2) {
			return String.fromCharCode(
				START_UPPERCASE_ALPHABET_CODE + n - DELTA_A_TO_Z
			);
		}

		// use multiple letters
		return (
			Template.numberToIdentifer(n % (2 * DELTA_A_TO_Z)) +
			Template.numberToIdentifer(Math.floor(n / (2 * DELTA_A_TO_Z)))
		);
	}

	/**
	 *
	 * @param {string | string[]} s string to convert to identity
	 * @returns {string} converted identity
	 */
	static indent(s) {
		if (Array.isArray(s)) {
			return s.map(Template.indent).join("\n");
		} else {
			const str = s.trimRight();
			if (!str) return "";
			const ind = str[0] === "\n" ? "" : "\t";
			return ind + str.replace(/\n([^\n])/g, "\n\t$1");
		}
	}

	/**
	 *
	 * @param {string|string[]} s string to create prefix for
	 * @param {string} prefix prefix to compose
	 * @returns {string} returns new prefix string
	 */
	static prefix(s, prefix) {
		const str = Template.asString(s).trim();
		if (!str) return "";
		const ind = str[0] === "\n" ? "" : prefix;
		return ind + str.replace(/\n([^\n])/g, "\n" + prefix + "$1");
	}

	/**
	 *
	 * @param {string|string[]} str string or string collection
	 * @returns {string} returns a single string from array
	 */
	static asString(str) {
		if (Array.isArray(str)) {
			return str.join("\n");
		}
		return str;
	}

	/**
	 * @typedef {Object} WithId
	 * @property {string|number} id
	 */

	/**
	 * @param {WithId[]} modules a collection of modules to get array bounds for
	 * @returns {[number, number] | false} returns the upper and lower array bounds
	 * or false if not every module has a number based id
	 */
	static getModulesArrayBounds(modules) {
		let maxId = -Infinity;
		let minId = Infinity;
		for (const module of modules) {
			if (typeof module.id !== "number") return false;
			if (maxId < module.id) maxId = /** @type {number} */ (module.id);
			if (minId > module.id) minId = /** @type {number} */ (module.id);
		}
		if (minId < 16 + ("" + minId).length) {
			// add minId x ',' instead of 'Array(minId).concat(…)'
			minId = 0;
		}
		const objectOverhead = modules
			.map(module => (module.id + "").length + 2)
			.reduce((a, b) => a + b, -1);
		const arrayOverhead =
			minId === 0 ? maxId : 16 + ("" + minId).length + maxId;
		return arrayOverhead < objectOverhead ? [minId, maxId] : false;
	}

	/**
	 * @param {Chunk} chunk chunk whose modules will be rendered
	 * @param {ModuleFilterPredicate} filterFn function used to filter modules from chunk to render
	 * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance used to render modules
	 * @param {TODO | TODO[]} dependencyTemplates templates needed for each module to render dependencies
	 * @param {string=} prefix applying prefix strings
	 * @returns {ConcatSource} rendered chunk modules in a Source object
	 */
	static renderChunkModules(
		chunk,
		filterFn,
		moduleTemplate,
		dependencyTemplates,
		prefix = ""
	) {
		const source = new ConcatSource();
		const modules = chunk.getModules().filter(filterFn);
		let removedModules;
		if (chunk instanceof HotUpdateChunk) {
			removedModules = chunk.removedModules;
		}
		if (
			modules.length === 0 &&
			(!removedModules || removedModules.length === 0)
		) {
			source.add("[]");
			return source;
		}
		/** @type {{id: string|number, source: Source|string}[]} */
		const allModules = modules.map(module => {
			return {
				id: module.id,
				source: moduleTemplate.render(module, dependencyTemplates, {
					chunk
				})
			};
		});
		if (removedModules && removedModules.length > 0) {
			for (const id of removedModules) {
				allModules.push({
					id,
					source: "false"
				});
			}
		}
		const bounds = Template.getModulesArrayBounds(allModules);
		if (bounds) {
			// Render a spare array
			const minId = bounds[0];
			const maxId = bounds[1];
			if (minId !== 0) {
				source.add(`Array(${minId}).concat(`);
			}
			source.add("[\n");
			/** @type {Map<string|number, {id: string|number, source: Source|string}>} */
			const modules = new Map();
			for (const module of allModules) {
				modules.set(module.id, module);
			}
			for (let idx = minId; idx <= maxId; idx++) {
				const module = modules.get(idx);
				if (idx !== minId) {
					source.add(",\n");
				}
				source.add(`/* ${idx} */`);
				if (module) {
					source.add("\n");
					source.add(module.source);
				}
			}
			source.add("\n" + prefix + "]");
			if (minId !== 0) {
				source.add(")");
			}
		} else {
			// Render an object
			source.add("{\n");
			allModules.sort(stringifyIdSortPredicate).forEach((module, idx) => {
				if (idx !== 0) {
					source.add(",\n");
				}
				source.add(`\n/***/ ${JSON.stringify(module.id)}:\n`);
				source.add(module.source);
			});
			source.add(`\n\n${prefix}}`);
		}
		return source;
	}
}

module.exports = Template;


/***/ }),

/***/ "./node_modules/webpack/lib/TemplatedPathPlugin.js":
/*!********************************************!*\
  !*** (webpack)/lib/TemplatedPathPlugin.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Jason Anderson @diurnalist
*/


const REGEXP_HASH = /\[hash(?::(\d+))?\]/gi,
	REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/gi,
	REGEXP_MODULEHASH = /\[modulehash(?::(\d+))?\]/gi,
	REGEXP_CONTENTHASH = /\[contenthash(?::(\d+))?\]/gi,
	REGEXP_NAME = /\[name\]/gi,
	REGEXP_ID = /\[id\]/gi,
	REGEXP_MODULEID = /\[moduleid\]/gi,
	REGEXP_FILE = /\[file\]/gi,
	REGEXP_QUERY = /\[query\]/gi,
	REGEXP_FILEBASE = /\[filebase\]/gi;

// Using global RegExp for .test is dangerous
// We use a normal RegExp instead of .test
const REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, "i"),
	REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, "i"),
	REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, "i"),
	REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, "i");

const withHashLength = (replacer, handlerFn) => {
	const fn = (match, hashLength, ...args) => {
		const length = hashLength && parseInt(hashLength, 10);
		if (length && handlerFn) {
			return handlerFn(length);
		}
		const hash = replacer(match, hashLength, ...args);
		return length ? hash.slice(0, length) : hash;
	};
	return fn;
};

const getReplacer = (value, allowEmpty) => {
	const fn = (match, ...args) => {
		// last argument in replacer is the entire input string
		const input = args[args.length - 1];
		if (value === null || value === undefined) {
			if (!allowEmpty) {
				throw new Error(
					`Path variable ${match} not implemented in this context: ${input}`
				);
			}
			return "";
		} else {
			return `${value}`;
		}
	};
	return fn;
};

const replacePathVariables = (path, data) => {
	const chunk = data.chunk;
	const chunkId = chunk && chunk.id;
	const chunkName = chunk && (chunk.name || chunk.id);
	const chunkHash = chunk && (chunk.renderedHash || chunk.hash);
	const chunkHashWithLength = chunk && chunk.hashWithLength;
	const contentHashType = data.contentHashType;
	const contentHash =
		(chunk && chunk.contentHash && chunk.contentHash[contentHashType]) ||
		data.contentHash;
	const contentHashWithLength =
		(chunk &&
			chunk.contentHashWithLength &&
			chunk.contentHashWithLength[contentHashType]) ||
		data.contentHashWithLength;
	const module = data.module;
	const moduleId = module && module.id;
	const moduleHash = module && (module.renderedHash || module.hash);
	const moduleHashWithLength = module && module.hashWithLength;

	if (typeof path === "function") {
		path = path(data);
	}

	if (
		data.noChunkHash &&
		(REGEXP_CHUNKHASH_FOR_TEST.test(path) ||
			REGEXP_CONTENTHASH_FOR_TEST.test(path))
	) {
		throw new Error(
			`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`
		);
	}

	return (
		path
			.replace(
				REGEXP_HASH,
				withHashLength(getReplacer(data.hash), data.hashWithLength)
			)
			.replace(
				REGEXP_CHUNKHASH,
				withHashLength(getReplacer(chunkHash), chunkHashWithLength)
			)
			.replace(
				REGEXP_CONTENTHASH,
				withHashLength(getReplacer(contentHash), contentHashWithLength)
			)
			.replace(
				REGEXP_MODULEHASH,
				withHashLength(getReplacer(moduleHash), moduleHashWithLength)
			)
			.replace(REGEXP_ID, getReplacer(chunkId))
			.replace(REGEXP_MODULEID, getReplacer(moduleId))
			.replace(REGEXP_NAME, getReplacer(chunkName))
			.replace(REGEXP_FILE, getReplacer(data.filename))
			.replace(REGEXP_FILEBASE, getReplacer(data.basename))
			// query is optional, it's OK if it's in a path but there's nothing to replace it with
			.replace(REGEXP_QUERY, getReplacer(data.query, true))
	);
};

class TemplatedPathPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("TemplatedPathPlugin", compilation => {
			const mainTemplate = compilation.mainTemplate;

			mainTemplate.hooks.assetPath.tap(
				"TemplatedPathPlugin",
				replacePathVariables
			);

			mainTemplate.hooks.globalHash.tap(
				"TemplatedPathPlugin",
				(chunk, paths) => {
					const outputOptions = mainTemplate.outputOptions;
					const publicPath = outputOptions.publicPath || "";
					const filename = outputOptions.filename || "";
					const chunkFilename =
						outputOptions.chunkFilename || outputOptions.filename;
					if (
						REGEXP_HASH_FOR_TEST.test(publicPath) ||
						REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) ||
						REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) ||
						REGEXP_NAME_FOR_TEST.test(publicPath)
					)
						return true;
					if (REGEXP_HASH_FOR_TEST.test(filename)) return true;
					if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;
					if (REGEXP_HASH_FOR_TEST.test(paths.join("|"))) return true;
				}
			);

			mainTemplate.hooks.hashForChunk.tap(
				"TemplatedPathPlugin",
				(hash, chunk) => {
					const outputOptions = mainTemplate.outputOptions;
					const chunkFilename =
						outputOptions.chunkFilename || outputOptions.filename;
					if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {
						hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));
					}
					if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {
						hash.update(
							JSON.stringify(
								chunk.getChunkMaps(true).contentHash.javascript || {}
							)
						);
					}
					if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {
						hash.update(JSON.stringify(chunk.getChunkMaps(true).name));
					}
				}
			);
		});
	}
}

module.exports = TemplatedPathPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/UmdMainTemplatePlugin.js":
/*!**********************************************!*\
  !*** (webpack)/lib/UmdMainTemplatePlugin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource, OriginalSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

/** @typedef {import("../declarations/WebpackOptions").LibraryCustomUmdObject} LibraryCustomUmdObject */
/** @typedef {import("./Compilation")} Compilation */

/**
 * @param {string[]} accessor the accessor to convert to path
 * @returns {string} the path
 */
const accessorToObjectAccess = accessor => {
	return accessor.map(a => `[${JSON.stringify(a)}]`).join("");
};

/**
 * @param {string=} base the path prefix
 * @param {string|string[]} accessor the accessor
 * @param {string=} joinWith the element separator
 * @returns {string} the path
 */
const accessorAccess = (base, accessor, joinWith = ", ") => {
	const accessors = Array.isArray(accessor) ? accessor : [accessor];
	return accessors
		.map((_, idx) => {
			const a = base
				? base + accessorToObjectAccess(accessors.slice(0, idx + 1))
				: accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));
			if (idx === accessors.length - 1) return a;
			if (idx === 0 && base === undefined)
				return `${a} = typeof ${a} === "object" ? ${a} : {}`;
			return `${a} = ${a} || {}`;
		})
		.join(joinWith);
};

/** @typedef {string | string[] | LibraryCustomUmdObject} UmdMainTemplatePluginName */

/**
 * @typedef {Object} AuxiliaryCommentObject
 * @property {string} root
 * @property {string} commonjs
 * @property {string} commonjs2
 * @property {string} amd
 */

/**
 * @typedef {Object} UmdMainTemplatePluginOption
 * @property {boolean=} optionalAmdExternalAsGlobal
 * @property {boolean} namedDefine
 * @property {string | AuxiliaryCommentObject} auxiliaryComment
 */

class UmdMainTemplatePlugin {
	/**
	 * @param {UmdMainTemplatePluginName} name the name of the UMD library
	 * @param {UmdMainTemplatePluginOption} options the plugin option
	 */
	constructor(name, options) {
		if (typeof name === "object" && !Array.isArray(name)) {
			this.name = name.root || name.amd || name.commonjs;
			this.names = name;
		} else {
			this.name = name;
			this.names = {
				commonjs: name,
				root: name,
				amd: name
			};
		}
		this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;
		this.namedDefine = options.namedDefine;
		this.auxiliaryComment = options.auxiliaryComment;
	}

	/**
	 * @param {Compilation} compilation the compilation instance
	 * @returns {void}
	 */
	apply(compilation) {
		const { mainTemplate, chunkTemplate, runtimeTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			let externals = chunk
				.getModules()
				.filter(
					m =>
						m.external &&
						(m.externalType === "umd" || m.externalType === "umd2")
				);
			const optionalExternals = [];
			let requiredExternals = [];
			if (this.optionalAmdExternalAsGlobal) {
				for (const m of externals) {
					if (m.optional) {
						optionalExternals.push(m);
					} else {
						requiredExternals.push(m);
					}
				}
				externals = requiredExternals.concat(optionalExternals);
			} else {
				requiredExternals = externals;
			}

			const replaceKeys = str => {
				return mainTemplate.getAssetPath(str, {
					hash,
					chunk
				});
			};

			const externalsDepsArray = modules => {
				return `[${replaceKeys(
					modules
						.map(m =>
							JSON.stringify(
								typeof m.request === "object" ? m.request.amd : m.request
							)
						)
						.join(", ")
				)}]`;
			};

			const externalsRootArray = modules => {
				return replaceKeys(
					modules
						.map(m => {
							let request = m.request;
							if (typeof request === "object") request = request.root;
							return `root${accessorToObjectAccess([].concat(request))}`;
						})
						.join(", ")
				);
			};

			const externalsRequireArray = type => {
				return replaceKeys(
					externals
						.map(m => {
							let expr;
							let request = m.request;
							if (typeof request === "object") {
								request = request[type];
							}
							if (request === undefined) {
								throw new Error(
									"Missing external configuration for type:" + type
								);
							}
							if (Array.isArray(request)) {
								expr = `require(${JSON.stringify(
									request[0]
								)})${accessorToObjectAccess(request.slice(1))}`;
							} else {
								expr = `require(${JSON.stringify(request)})`;
							}
							if (m.optional) {
								expr = `(function webpackLoadOptionalExternalModule() { try { return ${expr}; } catch(e) {} }())`;
							}
							return expr;
						})
						.join(", ")
				);
			};

			const externalsArguments = modules => {
				return modules
					.map(
						m =>
							`__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${m.id}`)}__`
					)
					.join(", ");
			};

			const libraryName = library => {
				return JSON.stringify(replaceKeys([].concat(library).pop()));
			};

			let amdFactory;
			if (optionalExternals.length > 0) {
				const wrapperArguments = externalsArguments(requiredExternals);
				const factoryArguments =
					requiredExternals.length > 0
						? externalsArguments(requiredExternals) +
						  ", " +
						  externalsRootArray(optionalExternals)
						: externalsRootArray(optionalExternals);
				amdFactory =
					`function webpackLoadOptionalExternalModuleAmd(${wrapperArguments}) {\n` +
					`			return factory(${factoryArguments});\n` +
					"		}";
			} else {
				amdFactory = "factory";
			}

			const auxiliaryComment = this.auxiliaryComment;

			const getAuxilaryComment = type => {
				if (auxiliaryComment) {
					if (typeof auxiliaryComment === "string")
						return "\t//" + auxiliaryComment + "\n";
					if (auxiliaryComment[type])
						return "\t//" + auxiliaryComment[type] + "\n";
				}
				return "";
			};

			return new ConcatSource(
				new OriginalSource(
					"(function webpackUniversalModuleDefinition(root, factory) {\n" +
						getAuxilaryComment("commonjs2") +
						"	if(typeof exports === 'object' && typeof module === 'object')\n" +
						"		module.exports = factory(" +
						externalsRequireArray("commonjs2") +
						");\n" +
						getAuxilaryComment("amd") +
						"	else if(typeof define === 'function' && define.amd)\n" +
						(requiredExternals.length > 0
							? this.names.amd && this.namedDefine === true
								? "		define(" +
								  libraryName(this.names.amd) +
								  ", " +
								  externalsDepsArray(requiredExternals) +
								  ", " +
								  amdFactory +
								  ");\n"
								: "		define(" +
								  externalsDepsArray(requiredExternals) +
								  ", " +
								  amdFactory +
								  ");\n"
							: this.names.amd && this.namedDefine === true
								? "		define(" +
								  libraryName(this.names.amd) +
								  ", [], " +
								  amdFactory +
								  ");\n"
								: "		define([], " + amdFactory + ");\n") +
						(this.names.root || this.names.commonjs
							? getAuxilaryComment("commonjs") +
							  "	else if(typeof exports === 'object')\n" +
							  "		exports[" +
							  libraryName(this.names.commonjs || this.names.root) +
							  "] = factory(" +
							  externalsRequireArray("commonjs") +
							  ");\n" +
							  getAuxilaryComment("root") +
							  "	else\n" +
							  "		" +
							  replaceKeys(
									accessorAccess("root", this.names.root || this.names.commonjs)
							  ) +
							  " = factory(" +
							  externalsRootArray(externals) +
							  ");\n"
							: "	else {\n" +
							  (externals.length > 0
									? "		var a = typeof exports === 'object' ? factory(" +
									  externalsRequireArray("commonjs") +
									  ") : factory(" +
									  externalsRootArray(externals) +
									  ");\n"
									: "		var a = factory();\n") +
							  "		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n" +
							  "	}\n") +
						`})(${
							runtimeTemplate.outputOptions.globalObject
						}, function(${externalsArguments(externals)}) {\nreturn `,
					"webpack/universalModuleDefinition"
				),
				source,
				";\n})"
			);
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"UmdMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap("UmdMainTemplatePlugin", paths => {
			if (this.names.root) paths = paths.concat(this.names.root);
			if (this.names.amd) paths = paths.concat(this.names.amd);
			if (this.names.commonjs) paths = paths.concat(this.names.commonjs);
			return paths;
		});

		mainTemplate.hooks.hash.tap("UmdMainTemplatePlugin", hash => {
			hash.update("umd");
			hash.update(`${this.names.root}`);
			hash.update(`${this.names.amd}`);
			hash.update(`${this.names.commonjs}`);
		});
	}
}

module.exports = UmdMainTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/UnsupportedFeatureWarning.js":
/*!**************************************************!*\
  !*** (webpack)/lib/UnsupportedFeatureWarning.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

/** @typedef {import("./Module")} Module */
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */

class UnsupportedFeatureWarning extends WebpackError {
	/**
	 * @param {Module} module module relevant to warning
	 * @param {string} message description of warning
	 * @param {DependencyLocation} loc location start and end positions of the module
	 */
	constructor(module, message, loc) {
		super(message);

		this.name = "UnsupportedFeatureWarning";
		this.module = module;
		this.loc = loc;
		this.hideStack = true;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = UnsupportedFeatureWarning;


/***/ }),

/***/ "./node_modules/webpack/lib/UseStrictPlugin.js":
/*!****************************************!*\
  !*** (webpack)/lib/UseStrictPlugin.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ConstDependency = __webpack_require__(/*! ./dependencies/ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");

/** @typedef {import("./Compiler")} Compiler */

class UseStrictPlugin {
	/**
	 * @param {Compiler} compiler Webpack Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"UseStrictPlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = parser => {
					parser.hooks.program.tap("UseStrictPlugin", ast => {
						const firstNode = ast.body[0];
						if (
							firstNode &&
							firstNode.type === "ExpressionStatement" &&
							firstNode.expression.type === "Literal" &&
							firstNode.expression.value === "use strict"
						) {
							// Remove "use strict" expression. It will be added later by the renderer again.
							// This is necessary in order to not break the strict mode when webpack prepends code.
							// @see https://github.com/webpack/webpack/issues/1970
							const dep = new ConstDependency("", firstNode.range);
							dep.loc = firstNode.loc;
							parser.state.current.addDependency(dep);
							parser.state.module.buildInfo.strict = true;
						}
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("UseStrictPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("UseStrictPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("UseStrictPlugin", handler);
			}
		);
	}
}

module.exports = UseStrictPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/WarnCaseSensitiveModulesPlugin.js":
/*!*******************************************************!*\
  !*** (webpack)/lib/WarnCaseSensitiveModulesPlugin.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const CaseSensitiveModulesWarning = __webpack_require__(/*! ./CaseSensitiveModulesWarning */ "./node_modules/webpack/lib/CaseSensitiveModulesWarning.js");

class WarnCaseSensitiveModulesPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"WarnCaseSensitiveModulesPlugin",
			compilation => {
				compilation.hooks.seal.tap("WarnCaseSensitiveModulesPlugin", () => {
					const moduleWithoutCase = new Map();
					for (const module of compilation.modules) {
						const identifier = module.identifier().toLowerCase();
						const array = moduleWithoutCase.get(identifier);
						if (array) {
							array.push(module);
						} else {
							moduleWithoutCase.set(identifier, [module]);
						}
					}
					for (const pair of moduleWithoutCase) {
						const array = pair[1];
						if (array.length > 1) {
							compilation.warnings.push(new CaseSensitiveModulesWarning(array));
						}
					}
				});
			}
		);
	}
}

module.exports = WarnCaseSensitiveModulesPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/WarnNoModeSetPlugin.js":
/*!********************************************!*\
  !*** (webpack)/lib/WarnNoModeSetPlugin.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const NoModeWarning = __webpack_require__(/*! ./NoModeWarning */ "./node_modules/webpack/lib/NoModeWarning.js");

class WarnNoModeSetPlugin {
	apply(compiler) {
		compiler.hooks.thisCompilation.tap("WarnNoModeSetPlugin", compilation => {
			compilation.warnings.push(new NoModeWarning());
		});
	}
}

module.exports = WarnNoModeSetPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/WatchIgnorePlugin.js":
/*!******************************************!*\
  !*** (webpack)/lib/WatchIgnorePlugin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../schemas/plugins/WatchIgnorePlugin.json */ "./node_modules/webpack/schemas/plugins/WatchIgnorePlugin.json");

/** @typedef {import("../declarations/plugins/WatchIgnorePlugin").WatchIgnorePluginOptions} WatchIgnorePluginOptions */

class IgnoringWatchFileSystem {
	constructor(wfs, paths) {
		this.wfs = wfs;
		this.paths = paths;
	}

	watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
		const ignored = path =>
			this.paths.some(
				p => (p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0)
			);

		const notIgnored = path => !ignored(path);

		const ignoredFiles = files.filter(ignored);
		const ignoredDirs = dirs.filter(ignored);

		const watcher = this.wfs.watch(
			files.filter(notIgnored),
			dirs.filter(notIgnored),
			missing,
			startTime,
			options,
			(
				err,
				filesModified,
				dirsModified,
				missingModified,
				fileTimestamps,
				dirTimestamps,
				removedFiles
			) => {
				if (err) return callback(err);
				for (const path of ignoredFiles) {
					fileTimestamps.set(path, 1);
				}

				for (const path of ignoredDirs) {
					dirTimestamps.set(path, 1);
				}

				callback(
					err,
					filesModified,
					dirsModified,
					missingModified,
					fileTimestamps,
					dirTimestamps,
					removedFiles
				);
			},
			callbackUndelayed
		);

		return {
			close: () => watcher.close(),
			pause: () => watcher.pause(),
			getContextTimestamps: () => {
				const dirTimestamps = watcher.getContextTimestamps();
				for (const path of ignoredDirs) {
					dirTimestamps.set(path, 1);
				}
				return dirTimestamps;
			},
			getFileTimestamps: () => {
				const fileTimestamps = watcher.getFileTimestamps();
				for (const path of ignoredFiles) {
					fileTimestamps.set(path, 1);
				}
				return fileTimestamps;
			}
		};
	}
}

class WatchIgnorePlugin {
	/**
	 * @param {WatchIgnorePluginOptions} paths list of paths
	 */
	constructor(paths) {
		validateOptions(schema, paths, "Watch Ignore Plugin");
		this.paths = paths;
	}

	apply(compiler) {
		compiler.hooks.afterEnvironment.tap("WatchIgnorePlugin", () => {
			compiler.watchFileSystem = new IgnoringWatchFileSystem(
				compiler.watchFileSystem,
				this.paths
			);
		});
	}
}

module.exports = WatchIgnorePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/Watching.js":
/*!*********************************!*\
  !*** (webpack)/lib/Watching.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Stats = __webpack_require__(/*! ./Stats */ "./node_modules/webpack/lib/Stats.js");

class Watching {
	constructor(compiler, watchOptions, handler) {
		this.startTime = null;
		this.invalid = false;
		this.handler = handler;
		this.callbacks = [];
		this.closed = false;
		if (typeof watchOptions === "number") {
			this.watchOptions = {
				aggregateTimeout: watchOptions
			};
		} else if (watchOptions && typeof watchOptions === "object") {
			this.watchOptions = Object.assign({}, watchOptions);
		} else {
			this.watchOptions = {};
		}
		this.watchOptions.aggregateTimeout =
			this.watchOptions.aggregateTimeout || 200;
		this.compiler = compiler;
		this.running = true;
		this.compiler.readRecords(err => {
			if (err) return this._done(err);

			this._go();
		});
	}

	_go() {
		this.startTime = Date.now();
		this.running = true;
		this.invalid = false;
		this.compiler.hooks.watchRun.callAsync(this.compiler, err => {
			if (err) return this._done(err);
			const onCompiled = (err, compilation) => {
				if (err) return this._done(err);
				if (this.invalid) return this._done();

				if (this.compiler.hooks.shouldEmit.call(compilation) === false) {
					return this._done(null, compilation);
				}

				this.compiler.emitAssets(compilation, err => {
					if (err) return this._done(err);
					if (this.invalid) return this._done();
					this.compiler.emitRecords(err => {
						if (err) return this._done(err);

						if (compilation.hooks.needAdditionalPass.call()) {
							compilation.needAdditionalPass = true;

							const stats = new Stats(compilation);
							stats.startTime = this.startTime;
							stats.endTime = Date.now();
							this.compiler.hooks.done.callAsync(stats, err => {
								if (err) return this._done(err);

								this.compiler.hooks.additionalPass.callAsync(err => {
									if (err) return this._done(err);
									this.compiler.compile(onCompiled);
								});
							});
							return;
						}
						return this._done(null, compilation);
					});
				});
			};
			this.compiler.compile(onCompiled);
		});
	}

	_getStats(compilation) {
		const stats = new Stats(compilation);
		stats.startTime = this.startTime;
		stats.endTime = Date.now();
		return stats;
	}

	_done(err, compilation) {
		this.running = false;
		if (this.invalid) return this._go();

		const stats = compilation ? this._getStats(compilation) : null;
		if (err) {
			this.compiler.hooks.failed.call(err);
			this.handler(err, stats);
			return;
		}
		this.compiler.hooks.done.callAsync(stats, () => {
			this.handler(null, stats);
			if (!this.closed) {
				this.watch(
					Array.from(compilation.fileDependencies),
					Array.from(compilation.contextDependencies),
					Array.from(compilation.missingDependencies)
				);
			}
			for (const cb of this.callbacks) cb();
			this.callbacks.length = 0;
		});
	}

	watch(files, dirs, missing) {
		this.pausedWatcher = null;
		this.watcher = this.compiler.watchFileSystem.watch(
			files,
			dirs,
			missing,
			this.startTime,
			this.watchOptions,
			(
				err,
				filesModified,
				contextModified,
				missingModified,
				fileTimestamps,
				contextTimestamps,
				removedFiles
			) => {
				this.pausedWatcher = this.watcher;
				this.watcher = null;
				if (err) {
					return this.handler(err);
				}
				this.compiler.fileTimestamps = fileTimestamps;
				this.compiler.contextTimestamps = contextTimestamps;
				this.compiler.removedFiles = removedFiles;
				this._invalidate();
			},
			(fileName, changeTime) => {
				this.compiler.hooks.invalid.call(fileName, changeTime);
			}
		);
	}

	invalidate(callback) {
		if (callback) {
			this.callbacks.push(callback);
		}
		if (this.watcher) {
			this.compiler.fileTimestamps = this.watcher.getFileTimestamps();
			this.compiler.contextTimestamps = this.watcher.getContextTimestamps();
		}
		return this._invalidate();
	}

	_invalidate() {
		if (this.watcher) {
			this.pausedWatcher = this.watcher;
			this.watcher.pause();
			this.watcher = null;
		}
		if (this.running) {
			this.invalid = true;
			return false;
		} else {
			this._go();
		}
	}

	close(callback) {
		const finalCallback = () => {
			this.compiler.hooks.watchClose.call();
			this.compiler.running = false;
			this.compiler.watchMode = false;
			if (callback !== undefined) callback();
		};

		this.closed = true;
		if (this.watcher) {
			this.watcher.close();
			this.watcher = null;
		}
		if (this.pausedWatcher) {
			this.pausedWatcher.close();
			this.pausedWatcher = null;
		}
		if (this.running) {
			this.invalid = true;
			this._done = finalCallback;
		} else {
			finalCallback();
		}
	}
}

module.exports = Watching;


/***/ }),

/***/ "./node_modules/webpack/lib/WebpackError.js":
/*!*************************************!*\
  !*** (webpack)/lib/WebpackError.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Jarid Margolin @jaridmargolin
*/


class WebpackError extends Error {
	/**
	 * Creates an instance of WebpackError.
	 * @param {string=} message error message
	 */
	constructor(message) {
		super(message);

		this.details = undefined;
		this.missing = undefined;
		this.origin = undefined;
		this.dependencies = undefined;
		this.module = undefined;

		Error.captureStackTrace(this, this.constructor);
	}

	inspect() {
		return this.stack + (this.details ? `\n${this.details}` : "");
	}
}

module.exports = WebpackError;


/***/ }),

/***/ "./node_modules/webpack/lib/WebpackOptionsApply.js":
/*!********************************************!*\
  !*** (webpack)/lib/WebpackOptionsApply.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const OptionsApply = __webpack_require__(/*! ./OptionsApply */ "./node_modules/webpack/lib/OptionsApply.js");

const JavascriptModulesPlugin = __webpack_require__(/*! ./JavascriptModulesPlugin */ "./node_modules/webpack/lib/JavascriptModulesPlugin.js");
const JsonModulesPlugin = __webpack_require__(/*! ./JsonModulesPlugin */ "./node_modules/webpack/lib/JsonModulesPlugin.js");
const WebAssemblyModulesPlugin = __webpack_require__(/*! ./wasm/WebAssemblyModulesPlugin */ "./node_modules/webpack/lib/wasm/WebAssemblyModulesPlugin.js");

const LoaderTargetPlugin = __webpack_require__(/*! ./LoaderTargetPlugin */ "./node_modules/webpack/lib/LoaderTargetPlugin.js");
const FunctionModulePlugin = __webpack_require__(/*! ./FunctionModulePlugin */ "./node_modules/webpack/lib/FunctionModulePlugin.js");
const EvalDevToolModulePlugin = __webpack_require__(/*! ./EvalDevToolModulePlugin */ "./node_modules/webpack/lib/EvalDevToolModulePlugin.js");
const SourceMapDevToolPlugin = __webpack_require__(/*! ./SourceMapDevToolPlugin */ "./node_modules/webpack/lib/SourceMapDevToolPlugin.js");
const EvalSourceMapDevToolPlugin = __webpack_require__(/*! ./EvalSourceMapDevToolPlugin */ "./node_modules/webpack/lib/EvalSourceMapDevToolPlugin.js");

const EntryOptionPlugin = __webpack_require__(/*! ./EntryOptionPlugin */ "./node_modules/webpack/lib/EntryOptionPlugin.js");
const RecordIdsPlugin = __webpack_require__(/*! ./RecordIdsPlugin */ "./node_modules/webpack/lib/RecordIdsPlugin.js");

const APIPlugin = __webpack_require__(/*! ./APIPlugin */ "./node_modules/webpack/lib/APIPlugin.js");
const ConstPlugin = __webpack_require__(/*! ./ConstPlugin */ "./node_modules/webpack/lib/ConstPlugin.js");
const RequireJsStuffPlugin = __webpack_require__(/*! ./RequireJsStuffPlugin */ "./node_modules/webpack/lib/RequireJsStuffPlugin.js");
const NodeStuffPlugin = __webpack_require__(/*! ./NodeStuffPlugin */ "./node_modules/webpack/lib/NodeStuffPlugin.js");
const CompatibilityPlugin = __webpack_require__(/*! ./CompatibilityPlugin */ "./node_modules/webpack/lib/CompatibilityPlugin.js");

const TemplatedPathPlugin = __webpack_require__(/*! ./TemplatedPathPlugin */ "./node_modules/webpack/lib/TemplatedPathPlugin.js");
const WarnCaseSensitiveModulesPlugin = __webpack_require__(/*! ./WarnCaseSensitiveModulesPlugin */ "./node_modules/webpack/lib/WarnCaseSensitiveModulesPlugin.js");
const UseStrictPlugin = __webpack_require__(/*! ./UseStrictPlugin */ "./node_modules/webpack/lib/UseStrictPlugin.js");

const LoaderPlugin = __webpack_require__(/*! ./dependencies/LoaderPlugin */ "./node_modules/webpack/lib/dependencies/LoaderPlugin.js");
const CommonJsPlugin = __webpack_require__(/*! ./dependencies/CommonJsPlugin */ "./node_modules/webpack/lib/dependencies/CommonJsPlugin.js");
const HarmonyModulesPlugin = __webpack_require__(/*! ./dependencies/HarmonyModulesPlugin */ "./node_modules/webpack/lib/dependencies/HarmonyModulesPlugin.js");
const SystemPlugin = __webpack_require__(/*! ./dependencies/SystemPlugin */ "./node_modules/webpack/lib/dependencies/SystemPlugin.js");
const ImportPlugin = __webpack_require__(/*! ./dependencies/ImportPlugin */ "./node_modules/webpack/lib/dependencies/ImportPlugin.js");
const AMDPlugin = __webpack_require__(/*! ./dependencies/AMDPlugin */ "./node_modules/webpack/lib/dependencies/AMDPlugin.js");
const RequireContextPlugin = __webpack_require__(/*! ./dependencies/RequireContextPlugin */ "./node_modules/webpack/lib/dependencies/RequireContextPlugin.js");
const RequireEnsurePlugin = __webpack_require__(/*! ./dependencies/RequireEnsurePlugin */ "./node_modules/webpack/lib/dependencies/RequireEnsurePlugin.js");
const RequireIncludePlugin = __webpack_require__(/*! ./dependencies/RequireIncludePlugin */ "./node_modules/webpack/lib/dependencies/RequireIncludePlugin.js");

const WarnNoModeSetPlugin = __webpack_require__(/*! ./WarnNoModeSetPlugin */ "./node_modules/webpack/lib/WarnNoModeSetPlugin.js");

const EnsureChunkConditionsPlugin = __webpack_require__(/*! ./optimize/EnsureChunkConditionsPlugin */ "./node_modules/webpack/lib/optimize/EnsureChunkConditionsPlugin.js");
const RemoveParentModulesPlugin = __webpack_require__(/*! ./optimize/RemoveParentModulesPlugin */ "./node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js");
const RemoveEmptyChunksPlugin = __webpack_require__(/*! ./optimize/RemoveEmptyChunksPlugin */ "./node_modules/webpack/lib/optimize/RemoveEmptyChunksPlugin.js");
const MergeDuplicateChunksPlugin = __webpack_require__(/*! ./optimize/MergeDuplicateChunksPlugin */ "./node_modules/webpack/lib/optimize/MergeDuplicateChunksPlugin.js");
const FlagIncludedChunksPlugin = __webpack_require__(/*! ./optimize/FlagIncludedChunksPlugin */ "./node_modules/webpack/lib/optimize/FlagIncludedChunksPlugin.js");
const OccurrenceChunkOrderPlugin = __webpack_require__(/*! ./optimize/OccurrenceChunkOrderPlugin */ "./node_modules/webpack/lib/optimize/OccurrenceChunkOrderPlugin.js");
const OccurrenceModuleOrderPlugin = __webpack_require__(/*! ./optimize/OccurrenceModuleOrderPlugin */ "./node_modules/webpack/lib/optimize/OccurrenceModuleOrderPlugin.js");
const NaturalChunkOrderPlugin = __webpack_require__(/*! ./optimize/NaturalChunkOrderPlugin */ "./node_modules/webpack/lib/optimize/NaturalChunkOrderPlugin.js");
const SideEffectsFlagPlugin = __webpack_require__(/*! ./optimize/SideEffectsFlagPlugin */ "./node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js");
const FlagDependencyUsagePlugin = __webpack_require__(/*! ./FlagDependencyUsagePlugin */ "./node_modules/webpack/lib/FlagDependencyUsagePlugin.js");
const FlagDependencyExportsPlugin = __webpack_require__(/*! ./FlagDependencyExportsPlugin */ "./node_modules/webpack/lib/FlagDependencyExportsPlugin.js");
const ModuleConcatenationPlugin = __webpack_require__(/*! ./optimize/ModuleConcatenationPlugin */ "./node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.js");
const SplitChunksPlugin = __webpack_require__(/*! ./optimize/SplitChunksPlugin */ "./node_modules/webpack/lib/optimize/SplitChunksPlugin.js");
const RuntimeChunkPlugin = __webpack_require__(/*! ./optimize/RuntimeChunkPlugin */ "./node_modules/webpack/lib/optimize/RuntimeChunkPlugin.js");
const NoEmitOnErrorsPlugin = __webpack_require__(/*! ./NoEmitOnErrorsPlugin */ "./node_modules/webpack/lib/NoEmitOnErrorsPlugin.js");
const NamedModulesPlugin = __webpack_require__(/*! ./NamedModulesPlugin */ "./node_modules/webpack/lib/NamedModulesPlugin.js");
const NamedChunksPlugin = __webpack_require__(/*! ./NamedChunksPlugin */ "./node_modules/webpack/lib/NamedChunksPlugin.js");
const HashedModuleIdsPlugin = __webpack_require__(/*! ./HashedModuleIdsPlugin */ "./node_modules/webpack/lib/HashedModuleIdsPlugin.js");
const DefinePlugin = __webpack_require__(/*! ./DefinePlugin */ "./node_modules/webpack/lib/DefinePlugin.js");
const SizeLimitsPlugin = __webpack_require__(/*! ./performance/SizeLimitsPlugin */ "./node_modules/webpack/lib/performance/SizeLimitsPlugin.js");
const WasmFinalizeExportsPlugin = __webpack_require__(/*! ./wasm/WasmFinalizeExportsPlugin */ "./node_modules/webpack/lib/wasm/WasmFinalizeExportsPlugin.js");

/** @typedef {import("../declarations/WebpackOptions").WebpackOptions} WebpackOptions */
/** @typedef {import("./Compiler")} Compiler */

class WebpackOptionsApply extends OptionsApply {
	constructor() {
		super();
	}

	/**
	 * @param {WebpackOptions} options options object
	 * @param {Compiler} compiler compiler object
	 * @returns {WebpackOptions} options object
	 */
	process(options, compiler) {
		let ExternalsPlugin;
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
		compiler.recordsOutputPath =
			options.recordsOutputPath || options.recordsPath;
		compiler.name = options.name;
		// TODO webpack 5 refactor this to MultiCompiler.setDependencies() with a WeakMap
		// @ts-ignore TODO
		compiler.dependencies = options.dependencies;
		if (typeof options.target === "string") {
			let JsonpTemplatePlugin;
			let FetchCompileWasmTemplatePlugin;
			let ReadFileCompileWasmTemplatePlugin;
			let NodeSourcePlugin;
			let NodeTargetPlugin;
			let NodeTemplatePlugin;

			switch (options.target) {
				case "web":
					JsonpTemplatePlugin = __webpack_require__(/*! ./web/JsonpTemplatePlugin */ "./node_modules/webpack/lib/web/JsonpTemplatePlugin.js");
					FetchCompileWasmTemplatePlugin = __webpack_require__(/*! ./web/FetchCompileWasmTemplatePlugin */ "./node_modules/webpack/lib/web/FetchCompileWasmTemplatePlugin.js");
					NodeSourcePlugin = __webpack_require__(/*! ./node/NodeSourcePlugin */ "./node_modules/webpack/lib/node/NodeSourcePlugin.js");
					new JsonpTemplatePlugin().apply(compiler);
					new FetchCompileWasmTemplatePlugin({
						mangleImports: options.optimization.mangleWasmImports
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeSourcePlugin(options.node).apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				case "webworker": {
					let WebWorkerTemplatePlugin = __webpack_require__(/*! ./webworker/WebWorkerTemplatePlugin */ "./node_modules/webpack/lib/webworker/WebWorkerTemplatePlugin.js");
					FetchCompileWasmTemplatePlugin = __webpack_require__(/*! ./web/FetchCompileWasmTemplatePlugin */ "./node_modules/webpack/lib/web/FetchCompileWasmTemplatePlugin.js");
					NodeSourcePlugin = __webpack_require__(/*! ./node/NodeSourcePlugin */ "./node_modules/webpack/lib/node/NodeSourcePlugin.js");
					new WebWorkerTemplatePlugin().apply(compiler);
					new FetchCompileWasmTemplatePlugin({
						mangleImports: options.optimization.mangleWasmImports
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeSourcePlugin(options.node).apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				}
				case "node":
				case "async-node":
					NodeTemplatePlugin = __webpack_require__(/*! ./node/NodeTemplatePlugin */ "./node_modules/webpack/lib/node/NodeTemplatePlugin.js");
					ReadFileCompileWasmTemplatePlugin = __webpack_require__(/*! ./node/ReadFileCompileWasmTemplatePlugin */ "./node_modules/webpack/lib/node/ReadFileCompileWasmTemplatePlugin.js");
					NodeTargetPlugin = __webpack_require__(/*! ./node/NodeTargetPlugin */ "./node_modules/webpack/lib/node/NodeTargetPlugin.js");
					new NodeTemplatePlugin({
						asyncChunkLoading: options.target === "async-node"
					}).apply(compiler);
					new ReadFileCompileWasmTemplatePlugin({
						mangleImports: options.optimization.mangleWasmImports
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeTargetPlugin().apply(compiler);
					new LoaderTargetPlugin("node").apply(compiler);
					break;
				case "node-webkit":
					JsonpTemplatePlugin = __webpack_require__(/*! ./web/JsonpTemplatePlugin */ "./node_modules/webpack/lib/web/JsonpTemplatePlugin.js");
					NodeTargetPlugin = __webpack_require__(/*! ./node/NodeTargetPlugin */ "./node_modules/webpack/lib/node/NodeTargetPlugin.js");
					ExternalsPlugin = __webpack_require__(/*! ./ExternalsPlugin */ "./node_modules/webpack/lib/ExternalsPlugin.js");
					new JsonpTemplatePlugin().apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeTargetPlugin().apply(compiler);
					new ExternalsPlugin("commonjs", "nw.gui").apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				case "electron-main":
					NodeTemplatePlugin = __webpack_require__(/*! ./node/NodeTemplatePlugin */ "./node_modules/webpack/lib/node/NodeTemplatePlugin.js");
					NodeTargetPlugin = __webpack_require__(/*! ./node/NodeTargetPlugin */ "./node_modules/webpack/lib/node/NodeTargetPlugin.js");
					ExternalsPlugin = __webpack_require__(/*! ./ExternalsPlugin */ "./node_modules/webpack/lib/ExternalsPlugin.js");
					new NodeTemplatePlugin({
						asyncChunkLoading: true
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeTargetPlugin().apply(compiler);
					new ExternalsPlugin("commonjs", [
						"app",
						"auto-updater",
						"browser-window",
						"clipboard",
						"content-tracing",
						"crash-reporter",
						"dialog",
						"electron",
						"global-shortcut",
						"ipc",
						"ipc-main",
						"menu",
						"menu-item",
						"native-image",
						"original-fs",
						"power-monitor",
						"power-save-blocker",
						"protocol",
						"screen",
						"session",
						"shell",
						"tray",
						"web-contents"
					]).apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				case "electron-renderer":
					JsonpTemplatePlugin = __webpack_require__(/*! ./web/JsonpTemplatePlugin */ "./node_modules/webpack/lib/web/JsonpTemplatePlugin.js");
					FetchCompileWasmTemplatePlugin = __webpack_require__(/*! ./web/FetchCompileWasmTemplatePlugin */ "./node_modules/webpack/lib/web/FetchCompileWasmTemplatePlugin.js");
					NodeTargetPlugin = __webpack_require__(/*! ./node/NodeTargetPlugin */ "./node_modules/webpack/lib/node/NodeTargetPlugin.js");
					ExternalsPlugin = __webpack_require__(/*! ./ExternalsPlugin */ "./node_modules/webpack/lib/ExternalsPlugin.js");
					new JsonpTemplatePlugin().apply(compiler);
					new FetchCompileWasmTemplatePlugin({
						mangleImports: options.optimization.mangleWasmImports
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeTargetPlugin().apply(compiler);
					new ExternalsPlugin("commonjs", [
						"clipboard",
						"crash-reporter",
						"desktop-capturer",
						"electron",
						"ipc",
						"ipc-renderer",
						"native-image",
						"original-fs",
						"remote",
						"screen",
						"shell",
						"web-frame"
					]).apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				default:
					throw new Error("Unsupported target '" + options.target + "'.");
			}
		}
		// @ts-ignore This is always true, which is good this way
		else if (options.target !== false) {
			options.target(compiler);
		} else {
			throw new Error("Unsupported target '" + options.target + "'.");
		}

		if (options.output.library || options.output.libraryTarget !== "var") {
			const LibraryTemplatePlugin = __webpack_require__(/*! ./LibraryTemplatePlugin */ "./node_modules/webpack/lib/LibraryTemplatePlugin.js");
			new LibraryTemplatePlugin(
				options.output.library,
				options.output.libraryTarget,
				options.output.umdNamedDefine,
				options.output.auxiliaryComment || "",
				options.output.libraryExport
			).apply(compiler);
		}
		if (options.externals) {
			ExternalsPlugin = __webpack_require__(/*! ./ExternalsPlugin */ "./node_modules/webpack/lib/ExternalsPlugin.js");
			new ExternalsPlugin(
				options.output.libraryTarget,
				options.externals
			).apply(compiler);
		}

		let noSources;
		let legacy;
		let modern;
		let comment;
		if (
			options.devtool &&
			(options.devtool.includes("sourcemap") ||
				options.devtool.includes("source-map"))
		) {
			const hidden = options.devtool.includes("hidden");
			const inline = options.devtool.includes("inline");
			const evalWrapped = options.devtool.includes("eval");
			const cheap = options.devtool.includes("cheap");
			const moduleMaps = options.devtool.includes("module");
			noSources = options.devtool.includes("nosources");
			legacy = options.devtool.includes("@");
			modern = options.devtool.includes("#");
			comment =
				legacy && modern
					? "\n/*\n//@ source" +
					  "MappingURL=[url]\n//# source" +
					  "MappingURL=[url]\n*/"
					: legacy
						? "\n/*\n//@ source" + "MappingURL=[url]\n*/"
						: modern
							? "\n//# source" + "MappingURL=[url]"
							: null;
			const Plugin = evalWrapped
				? EvalSourceMapDevToolPlugin
				: SourceMapDevToolPlugin;
			new Plugin({
				filename: inline ? null : options.output.sourceMapFilename,
				moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
				fallbackModuleFilenameTemplate:
					options.output.devtoolFallbackModuleFilenameTemplate,
				append: hidden ? false : comment,
				module: moduleMaps ? true : cheap ? false : true,
				columns: cheap ? false : true,
				lineToLine: options.output.devtoolLineToLine,
				noSources: noSources,
				namespace: options.output.devtoolNamespace
			}).apply(compiler);
		} else if (options.devtool && options.devtool.includes("eval")) {
			legacy = options.devtool.includes("@");
			modern = options.devtool.includes("#");
			comment =
				legacy && modern
					? "\n//@ sourceURL=[url]\n//# sourceURL=[url]"
					: legacy
						? "\n//@ sourceURL=[url]"
						: modern
							? "\n//# sourceURL=[url]"
							: null;
			new EvalDevToolModulePlugin({
				sourceUrlComment: comment,
				moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
				namespace: options.output.devtoolNamespace
			}).apply(compiler);
		}

		new JavascriptModulesPlugin().apply(compiler);
		new JsonModulesPlugin().apply(compiler);
		new WebAssemblyModulesPlugin({
			mangleImports: options.optimization.mangleWasmImports
		}).apply(compiler);

		new EntryOptionPlugin().apply(compiler);
		compiler.hooks.entryOption.call(options.context, options.entry);

		new CompatibilityPlugin().apply(compiler);
		new HarmonyModulesPlugin(options.module).apply(compiler);
		new AMDPlugin(options.module, options.amd || {}).apply(compiler);
		new CommonJsPlugin(options.module).apply(compiler);
		new LoaderPlugin().apply(compiler);
		new NodeStuffPlugin(options.node).apply(compiler);
		new RequireJsStuffPlugin().apply(compiler);
		new APIPlugin().apply(compiler);
		new ConstPlugin().apply(compiler);
		new UseStrictPlugin().apply(compiler);
		new RequireIncludePlugin().apply(compiler);
		new RequireEnsurePlugin().apply(compiler);
		new RequireContextPlugin(
			options.resolve.modules,
			options.resolve.extensions,
			options.resolve.mainFiles
		).apply(compiler);
		new ImportPlugin(options.module).apply(compiler);
		new SystemPlugin(options.module).apply(compiler);

		if (typeof options.mode !== "string") {
			new WarnNoModeSetPlugin().apply(compiler);
		}

		new EnsureChunkConditionsPlugin().apply(compiler);
		if (options.optimization.removeAvailableModules) {
			new RemoveParentModulesPlugin().apply(compiler);
		}
		if (options.optimization.removeEmptyChunks) {
			new RemoveEmptyChunksPlugin().apply(compiler);
		}
		if (options.optimization.mergeDuplicateChunks) {
			new MergeDuplicateChunksPlugin().apply(compiler);
		}
		if (options.optimization.flagIncludedChunks) {
			new FlagIncludedChunksPlugin().apply(compiler);
		}
		if (options.optimization.sideEffects) {
			new SideEffectsFlagPlugin().apply(compiler);
		}
		if (options.optimization.providedExports) {
			new FlagDependencyExportsPlugin().apply(compiler);
		}
		if (options.optimization.usedExports) {
			new FlagDependencyUsagePlugin().apply(compiler);
		}
		if (options.optimization.concatenateModules) {
			new ModuleConcatenationPlugin().apply(compiler);
		}
		if (options.optimization.splitChunks) {
			new SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
		}
		if (options.optimization.runtimeChunk) {
			new RuntimeChunkPlugin(options.optimization.runtimeChunk).apply(compiler);
		}
		if (options.optimization.noEmitOnErrors) {
			new NoEmitOnErrorsPlugin().apply(compiler);
		}
		if (options.optimization.checkWasmTypes) {
			new WasmFinalizeExportsPlugin().apply(compiler);
		}
		let moduleIds = options.optimization.moduleIds;
		if (moduleIds === undefined) {
			// TODO webpack 5 remove all these options
			if (options.optimization.occurrenceOrder) {
				moduleIds = "size";
			}
			if (options.optimization.namedModules) {
				moduleIds = "named";
			}
			if (options.optimization.hashedModuleIds) {
				moduleIds = "hashed";
			}
			if (moduleIds === undefined) {
				moduleIds = "natural";
			}
		}
		if (moduleIds) {
			switch (moduleIds) {
				case "natural":
					// TODO webpack 5: see hint in Compilation.sortModules
					break;
				case "named":
					new NamedModulesPlugin().apply(compiler);
					break;
				case "hashed":
					new HashedModuleIdsPlugin().apply(compiler);
					break;
				case "size":
					new OccurrenceModuleOrderPlugin({
						prioritiseInitial: true
					}).apply(compiler);
					break;
				case "total-size":
					new OccurrenceModuleOrderPlugin({
						prioritiseInitial: false
					}).apply(compiler);
					break;
				default:
					throw new Error(
						`webpack bug: moduleIds: ${moduleIds} is not implemented`
					);
			}
		}
		let chunkIds = options.optimization.chunkIds;
		if (chunkIds === undefined) {
			// TODO webpack 5 remove all these options
			if (options.optimization.occurrenceOrder) {
				// This looks weird but it's for backward-compat
				// This bug already existed before adding this feature
				chunkIds = "total-size";
			}
			if (options.optimization.namedChunks) {
				chunkIds = "named";
			}
			if (chunkIds === undefined) {
				chunkIds = "natural";
			}
		}
		if (chunkIds) {
			switch (chunkIds) {
				case "natural":
					new NaturalChunkOrderPlugin().apply(compiler);
					break;
				case "named":
					// TODO webapck 5: for backward-compat this need to have OccurrenceChunkOrderPlugin too
					// The NamedChunksPlugin doesn't give every chunk a name
					// This should be fixed, and the OccurrenceChunkOrderPlugin should be removed here.
					new OccurrenceChunkOrderPlugin({
						prioritiseInitial: false
					}).apply(compiler);
					new NamedChunksPlugin().apply(compiler);
					break;
				case "size":
					new OccurrenceChunkOrderPlugin({
						prioritiseInitial: true
					}).apply(compiler);
					break;
				case "total-size":
					new OccurrenceChunkOrderPlugin({
						prioritiseInitial: false
					}).apply(compiler);
					break;
				default:
					throw new Error(
						`webpack bug: chunkIds: ${chunkIds} is not implemented`
					);
			}
		}
		if (options.optimization.nodeEnv) {
			new DefinePlugin({
				"process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
			}).apply(compiler);
		}
		if (options.optimization.minimize) {
			for (const minimizer of options.optimization.minimizer) {
				if (typeof minimizer === "function") {
					minimizer.call(compiler, compiler);
				} else {
					minimizer.apply(compiler);
				}
			}
		}

		if (options.performance) {
			new SizeLimitsPlugin(options.performance).apply(compiler);
		}

		new TemplatedPathPlugin().apply(compiler);

		new RecordIdsPlugin({
			portableIds: options.optimization.portableRecords
		}).apply(compiler);

		new WarnCaseSensitiveModulesPlugin().apply(compiler);

		if (options.cache) {
			const CachePlugin = __webpack_require__(/*! ./CachePlugin */ "./node_modules/webpack/lib/CachePlugin.js");
			new CachePlugin(
				typeof options.cache === "object" ? options.cache : null
			).apply(compiler);
		}

		compiler.hooks.afterPlugins.call(compiler);
		if (!compiler.inputFileSystem) {
			throw new Error("No input filesystem provided");
		}
		compiler.resolverFactory.hooks.resolveOptions
			.for("normal")
			.tap("WebpackOptionsApply", resolveOptions => {
				return Object.assign(
					{
						fileSystem: compiler.inputFileSystem
					},
					options.resolve,
					resolveOptions
				);
			});
		compiler.resolverFactory.hooks.resolveOptions
			.for("context")
			.tap("WebpackOptionsApply", resolveOptions => {
				return Object.assign(
					{
						fileSystem: compiler.inputFileSystem,
						resolveToContext: true
					},
					options.resolve,
					resolveOptions
				);
			});
		compiler.resolverFactory.hooks.resolveOptions
			.for("loader")
			.tap("WebpackOptionsApply", resolveOptions => {
				return Object.assign(
					{
						fileSystem: compiler.inputFileSystem
					},
					options.resolveLoader,
					resolveOptions
				);
			});
		compiler.hooks.afterResolvers.call(compiler);
		return options;
	}
}

module.exports = WebpackOptionsApply;


/***/ }),

/***/ "./node_modules/webpack/lib/WebpackOptionsDefaulter.js":
/*!************************************************!*\
  !*** (webpack)/lib/WebpackOptionsDefaulter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const path = __webpack_require__(/*! path */ "path");

const OptionsDefaulter = __webpack_require__(/*! ./OptionsDefaulter */ "./node_modules/webpack/lib/OptionsDefaulter.js");
const Template = __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js");

const isProductionLikeMode = options => {
	return options.mode === "production" || !options.mode;
};

const isWebLikeTarget = options => {
	return options.target === "web" || options.target === "webworker";
};

const getDevtoolNamespace = library => {
	// if options.output.library is a string
	if (Array.isArray(library)) {
		return library.join(".");
	} else if (typeof library === "object") {
		return getDevtoolNamespace(library.root);
	}
	return library || "";
};

class WebpackOptionsDefaulter extends OptionsDefaulter {
	constructor() {
		super();

		this.set("entry", "./src");

		this.set(
			"devtool",
			"make",
			options => (options.mode === "development" ? "eval" : false)
		);
		this.set("cache", "make", options => options.mode === "development");

		this.set("context", process.cwd());
		this.set("target", "web");

		this.set("module", "call", value => Object.assign({}, value));
		this.set("module.unknownContextRequest", ".");
		this.set("module.unknownContextRegExp", false);
		this.set("module.unknownContextRecursive", true);
		this.set("module.unknownContextCritical", true);
		this.set("module.exprContextRequest", ".");
		this.set("module.exprContextRegExp", false);
		this.set("module.exprContextRecursive", true);
		this.set("module.exprContextCritical", true);
		this.set("module.wrappedContextRegExp", /.*/);
		this.set("module.wrappedContextRecursive", true);
		this.set("module.wrappedContextCritical", false);
		this.set("module.strictExportPresence", false);
		this.set("module.strictThisContextOnImports", false);
		this.set("module.unsafeCache", "make", options => !!options.cache);
		this.set("module.rules", []);
		this.set("module.defaultRules", "make", options => [
			{
				type: "javascript/auto",
				resolve: {}
			},
			{
				test: /\.mjs$/i,
				type: "javascript/esm",
				resolve: {
					mainFields:
						options.target === "web" ||
						options.target === "webworker" ||
						options.target === "electron-renderer"
							? ["browser", "main"]
							: ["main"]
				}
			},
			{
				test: /\.json$/i,
				type: "json"
			},
			{
				test: /\.wasm$/i,
				type: "webassembly/experimental"
			}
		]);

		this.set("output", "call", (value, options) => {
			if (typeof value === "string") {
				return {
					filename: value
				};
			} else if (typeof value !== "object") {
				return {};
			} else {
				return Object.assign({}, value);
			}
		});

		this.set("output.filename", "[name].js");
		this.set("output.chunkFilename", "make", options => {
			const filename = options.output.filename;
			if (typeof filename !== "function") {
				const hasName = filename.includes("[name]");
				const hasId = filename.includes("[id]");
				const hasChunkHash = filename.includes("[chunkhash]");
				// Anything changing depending on chunk is fine
				if (hasChunkHash || hasName || hasId) return filename;
				// Elsewise prefix "[id]." in front of the basename to make it changing
				return filename.replace(/(^|\/)([^/]*(?:\?|$))/, "$1[id].$2");
			}
			return "[id].js";
		});
		this.set("output.webassemblyModuleFilename", "[modulehash].module.wasm");
		this.set("output.library", "");
		this.set("output.hotUpdateFunction", "make", options => {
			return Template.toIdentifier(
				"webpackHotUpdate" + Template.toIdentifier(options.output.library)
			);
		});
		this.set("output.jsonpFunction", "make", options => {
			return Template.toIdentifier(
				"webpackJsonp" + Template.toIdentifier(options.output.library)
			);
		});
		this.set("output.chunkCallbackName", "make", options => {
			return Template.toIdentifier(
				"webpackChunk" + Template.toIdentifier(options.output.library)
			);
		});
		this.set("output.globalObject", "make", options => {
			switch (options.target) {
				case "web":
				case "electron-renderer":
				case "node-webkit":
					return "window";
				case "webworker":
					return "self";
				case "node":
				case "async-node":
				case "electron-main":
					return "global";
				default:
					return "self";
			}
		});
		this.set("output.devtoolNamespace", "make", options => {
			return getDevtoolNamespace(options.output.library);
		});
		this.set("output.libraryTarget", "var");
		this.set("output.path", path.join(process.cwd(), "dist"));
		this.set(
			"output.pathinfo",
			"make",
			options => options.mode === "development"
		);
		this.set("output.sourceMapFilename", "[file].map[query]");
		this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js");
		this.set("output.hotUpdateMainFilename", "[hash].hot-update.json");
		this.set("output.crossOriginLoading", false);
		this.set("output.jsonpScriptType", false);
		this.set("output.chunkLoadTimeout", 120000);
		this.set("output.hashFunction", "md4");
		this.set("output.hashDigest", "hex");
		this.set("output.hashDigestLength", 20);
		this.set("output.devtoolLineToLine", false);
		this.set("output.strictModuleExceptionHandling", false);

		this.set("node", "call", value => {
			if (typeof value === "boolean") {
				return value;
			} else {
				return Object.assign({}, value);
			}
		});
		this.set("node.console", false);
		this.set("node.process", true);
		this.set("node.global", true);
		this.set("node.Buffer", true);
		this.set("node.setImmediate", true);
		this.set("node.__filename", "mock");
		this.set("node.__dirname", "mock");

		this.set("performance", "call", (value, options) => {
			if (value === false) return false;
			if (
				value === undefined &&
				(!isProductionLikeMode(options) || !isWebLikeTarget(options))
			)
				return false;
			return Object.assign({}, value);
		});
		this.set("performance.maxAssetSize", 250000);
		this.set("performance.maxEntrypointSize", 250000);
		this.set(
			"performance.hints",
			"make",
			options => (isProductionLikeMode(options) ? "warning" : false)
		);

		this.set("optimization", "call", value => Object.assign({}, value));
		this.set("optimization.removeAvailableModules", true);
		this.set("optimization.removeEmptyChunks", true);
		this.set("optimization.mergeDuplicateChunks", true);
		this.set("optimization.flagIncludedChunks", "make", options =>
			isProductionLikeMode(options)
		);
		// TODO webpack 5 add `moduleIds: "named"` default for development
		// TODO webpack 5 add `moduleIds: "size"` default for production
		// TODO webpack 5 remove optimization.occurrenceOrder
		this.set("optimization.occurrenceOrder", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.sideEffects", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.providedExports", true);
		this.set("optimization.usedExports", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.concatenateModules", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.splitChunks", {});
		this.set("optimization.splitChunks.hidePathInfo", "make", options => {
			return isProductionLikeMode(options);
		});
		this.set("optimization.splitChunks.chunks", "async");
		this.set("optimization.splitChunks.minSize", "make", options => {
			return isProductionLikeMode(options) ? 30000 : 10000;
		});
		this.set("optimization.splitChunks.minChunks", 1);
		this.set("optimization.splitChunks.maxAsyncRequests", "make", options => {
			return isProductionLikeMode(options) ? 5 : Infinity;
		});
		this.set("optimization.splitChunks.automaticNameDelimiter", "~");
		this.set("optimization.splitChunks.maxInitialRequests", "make", options => {
			return isProductionLikeMode(options) ? 3 : Infinity;
		});
		this.set("optimization.splitChunks.name", true);
		this.set("optimization.splitChunks.cacheGroups", {});
		this.set("optimization.splitChunks.cacheGroups.default", {
			automaticNamePrefix: "",
			reuseExistingChunk: true,
			minChunks: 2,
			priority: -20
		});
		this.set("optimization.splitChunks.cacheGroups.vendors", {
			automaticNamePrefix: "vendors",
			test: /[\\/]node_modules[\\/]/,
			priority: -10
		});
		this.set("optimization.runtimeChunk", "call", value => {
			if (value === "single") {
				return {
					name: "runtime"
				};
			}
			if (value === true || value === "multiple") {
				return {
					name: entrypoint => `runtime~${entrypoint.name}`
				};
			}
			return value;
		});
		this.set("optimization.noEmitOnErrors", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.checkWasmTypes", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.mangleWasmImports", false);
		// TODO webpack 5 remove optimization.namedModules
		this.set(
			"optimization.namedModules",
			"make",
			options => options.mode === "development"
		);
		this.set("optimization.hashedModuleIds", false);
		// TODO webpack 5 add `chunkIds: "named"` default for development
		// TODO webpack 5 add `chunkIds: "size"` default for production
		// TODO webpack 5 remove optimization.namedChunks
		this.set(
			"optimization.namedChunks",
			"make",
			options => options.mode === "development"
		);
		this.set(
			"optimization.portableRecords",
			"make",
			options =>
				!!(
					options.recordsInputPath ||
					options.recordsOutputPath ||
					options.recordsPath
				)
		);
		this.set("optimization.minimize", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.minimizer", "make", options => [
			{
				apply: compiler => {
					// Lazy load the Terser plugin
					const TerserPlugin = __webpack_require__(/*! terser-webpack-plugin */ "terser-webpack-plugin");
					const SourceMapDevToolPlugin = __webpack_require__(/*! ./SourceMapDevToolPlugin */ "./node_modules/webpack/lib/SourceMapDevToolPlugin.js");
					new TerserPlugin({
						cache: true,
						parallel: true,
						sourceMap:
							(options.devtool && /source-?map/.test(options.devtool)) ||
							(options.plugins &&
								options.plugins.some(p => p instanceof SourceMapDevToolPlugin))
					}).apply(compiler);
				}
			}
		]);
		this.set("optimization.nodeEnv", "make", options => {
			// TODO: In webpack 5, it should return `false` when mode is `none`
			return options.mode || "production";
		});

		this.set("resolve", "call", value => Object.assign({}, value));
		this.set("resolve.unsafeCache", true);
		this.set("resolve.modules", ["node_modules"]);
		this.set("resolve.extensions", [".wasm", ".mjs", ".js", ".json"]);
		this.set("resolve.mainFiles", ["index"]);
		this.set("resolve.aliasFields", "make", options => {
			if (
				options.target === "web" ||
				options.target === "webworker" ||
				options.target === "electron-renderer"
			) {
				return ["browser"];
			} else {
				return [];
			}
		});
		this.set("resolve.mainFields", "make", options => {
			if (
				options.target === "web" ||
				options.target === "webworker" ||
				options.target === "electron-renderer"
			) {
				return ["browser", "module", "main"];
			} else {
				return ["module", "main"];
			}
		});
		this.set("resolve.cacheWithContext", "make", options => {
			return (
				Array.isArray(options.resolve.plugins) &&
				options.resolve.plugins.length > 0
			);
		});

		this.set("resolveLoader", "call", value => Object.assign({}, value));
		this.set("resolveLoader.unsafeCache", true);
		this.set("resolveLoader.mainFields", ["loader", "main"]);
		this.set("resolveLoader.extensions", [".js", ".json"]);
		this.set("resolveLoader.mainFiles", ["index"]);
		this.set("resolveLoader.cacheWithContext", "make", options => {
			return (
				Array.isArray(options.resolveLoader.plugins) &&
				options.resolveLoader.plugins.length > 0
			);
		});
	}
}

module.exports = WebpackOptionsDefaulter;


/***/ }),

/***/ "./node_modules/webpack/lib/WebpackOptionsValidationError.js":
/*!******************************************************!*\
  !*** (webpack)/lib/WebpackOptionsValidationError.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Gajus Kuizinas @gajus
*/


const WebpackError = __webpack_require__(/*! ./WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const webpackOptionsSchema = __webpack_require__(/*! ../schemas/WebpackOptions.json */ "./node_modules/webpack/schemas/WebpackOptions.json");

const getSchemaPart = (path, parents, additionalPath) => {
	parents = parents || 0;
	path = path.split("/");
	path = path.slice(0, path.length - parents);
	if (additionalPath) {
		additionalPath = additionalPath.split("/");
		path = path.concat(additionalPath);
	}
	let schemaPart = webpackOptionsSchema;
	for (let i = 1; i < path.length; i++) {
		const inner = schemaPart[path[i]];
		if (inner) schemaPart = inner;
	}
	return schemaPart;
};

const getSchemaPartText = (schemaPart, additionalPath) => {
	if (additionalPath) {
		for (let i = 0; i < additionalPath.length; i++) {
			const inner = schemaPart[additionalPath[i]];
			if (inner) schemaPart = inner;
		}
	}
	while (schemaPart.$ref) {
		schemaPart = getSchemaPart(schemaPart.$ref);
	}
	let schemaText = WebpackOptionsValidationError.formatSchema(schemaPart);
	if (schemaPart.description) {
		schemaText += `\n-> ${schemaPart.description}`;
	}
	return schemaText;
};

const getSchemaPartDescription = schemaPart => {
	while (schemaPart.$ref) {
		schemaPart = getSchemaPart(schemaPart.$ref);
	}
	if (schemaPart.description) {
		return `\n-> ${schemaPart.description}`;
	}
	return "";
};

const filterChildren = children => {
	return children.filter(
		err =>
			err.keyword !== "anyOf" &&
			err.keyword !== "allOf" &&
			err.keyword !== "oneOf"
	);
};

const indent = (str, prefix, firstLine) => {
	if (firstLine) {
		return prefix + str.replace(/\n(?!$)/g, "\n" + prefix);
	} else {
		return str.replace(/\n(?!$)/g, `\n${prefix}`);
	}
};

class WebpackOptionsValidationError extends WebpackError {
	constructor(validationErrors) {
		super(
			"Invalid configuration object. " +
				"Webpack has been initialised using a configuration object that does not match the API schema.\n" +
				validationErrors
					.map(
						err =>
							" - " +
							indent(
								WebpackOptionsValidationError.formatValidationError(err),
								"   ",
								false
							)
					)
					.join("\n")
		);

		this.name = "WebpackOptionsValidationError";
		this.validationErrors = validationErrors;

		Error.captureStackTrace(this, this.constructor);
	}

	static formatSchema(schema, prevSchemas) {
		prevSchemas = prevSchemas || [];

		const formatInnerSchema = (innerSchema, addSelf) => {
			if (!addSelf) {
				return WebpackOptionsValidationError.formatSchema(
					innerSchema,
					prevSchemas
				);
			}
			if (prevSchemas.includes(innerSchema)) {
				return "(recursive)";
			}
			return WebpackOptionsValidationError.formatSchema(
				innerSchema,
				prevSchemas.concat(schema)
			);
		};

		if (schema.type === "string") {
			if (schema.minLength === 1) {
				return "non-empty string";
			}
			if (schema.minLength > 1) {
				return `string (min length ${schema.minLength})`;
			}
			return "string";
		}
		if (schema.type === "boolean") {
			return "boolean";
		}
		if (schema.type === "number") {
			return "number";
		}
		if (schema.type === "object") {
			if (schema.properties) {
				const required = schema.required || [];
				return `object { ${Object.keys(schema.properties)
					.map(property => {
						if (!required.includes(property)) return property + "?";
						return property;
					})
					.concat(schema.additionalProperties ? ["…"] : [])
					.join(", ")} }`;
			}
			if (schema.additionalProperties) {
				return `object { <key>: ${formatInnerSchema(
					schema.additionalProperties
				)} }`;
			}
			return "object";
		}
		if (schema.type === "array") {
			return `[${formatInnerSchema(schema.items)}]`;
		}

		switch (schema.instanceof) {
			case "Function":
				return "function";
			case "RegExp":
				return "RegExp";
		}

		if (schema.$ref) {
			return formatInnerSchema(getSchemaPart(schema.$ref), true);
		}
		if (schema.allOf) {
			return schema.allOf.map(formatInnerSchema).join(" & ");
		}
		if (schema.oneOf) {
			return schema.oneOf.map(formatInnerSchema).join(" | ");
		}
		if (schema.anyOf) {
			return schema.anyOf.map(formatInnerSchema).join(" | ");
		}
		if (schema.enum) {
			return schema.enum.map(item => JSON.stringify(item)).join(" | ");
		}
		return JSON.stringify(schema, null, 2);
	}

	static formatValidationError(err) {
		const dataPath = `configuration${err.dataPath}`;
		if (err.keyword === "additionalProperties") {
			const baseMessage = `${dataPath} has an unknown property '${
				err.params.additionalProperty
			}'. These properties are valid:\n${getSchemaPartText(err.parentSchema)}`;
			if (!err.dataPath) {
				switch (err.params.additionalProperty) {
					case "debug":
						return (
							`${baseMessage}\n` +
							"The 'debug' property was removed in webpack 2.0.0.\n" +
							"Loaders should be updated to allow passing this option via loader options in module.rules.\n" +
							"Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\n" +
							"plugins: [\n" +
							"  new webpack.LoaderOptionsPlugin({\n" +
							"    debug: true\n" +
							"  })\n" +
							"]"
						);
				}
				return (
					`${baseMessage}\n` +
					"For typos: please correct them.\n" +
					"For loader options: webpack >= v2.0.0 no longer allows custom properties in configuration.\n" +
					"  Loaders should be updated to allow passing options via loader options in module.rules.\n" +
					"  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\n" +
					"  plugins: [\n" +
					"    new webpack.LoaderOptionsPlugin({\n" +
					"      // test: /\\.xxx$/, // may apply this only for some modules\n" +
					"      options: {\n" +
					`        ${err.params.additionalProperty}: …\n` +
					"      }\n" +
					"    })\n" +
					"  ]"
				);
			}
			return baseMessage;
		} else if (err.keyword === "oneOf" || err.keyword === "anyOf") {
			if (err.children && err.children.length > 0) {
				if (err.schema.length === 1) {
					const lastChild = err.children[err.children.length - 1];
					const remainingChildren = err.children.slice(
						0,
						err.children.length - 1
					);
					return WebpackOptionsValidationError.formatValidationError(
						Object.assign({}, lastChild, {
							children: remainingChildren,
							parentSchema: Object.assign(
								{},
								err.parentSchema,
								lastChild.parentSchema
							)
						})
					);
				}
				return (
					`${dataPath} should be one of these:\n${getSchemaPartText(
						err.parentSchema
					)}\n` +
					`Details:\n${filterChildren(err.children)
						.map(
							err =>
								" * " +
								indent(
									WebpackOptionsValidationError.formatValidationError(err),
									"   ",
									false
								)
						)
						.join("\n")}`
				);
			}
			return `${dataPath} should be one of these:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === "enum") {
			if (
				err.parentSchema &&
				err.parentSchema.enum &&
				err.parentSchema.enum.length === 1
			) {
				return `${dataPath} should be ${getSchemaPartText(err.parentSchema)}`;
			}
			return `${dataPath} should be one of these:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === "allOf") {
			return `${dataPath} should be:\n${getSchemaPartText(err.parentSchema)}`;
		} else if (err.keyword === "type") {
			switch (err.params.type) {
				case "object":
					return `${dataPath} should be an object.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case "string":
					return `${dataPath} should be a string.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case "boolean":
					return `${dataPath} should be a boolean.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case "number":
					return `${dataPath} should be a number.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case "array":
					return `${dataPath} should be an array:\n${getSchemaPartText(
						err.parentSchema
					)}`;
			}
			return `${dataPath} should be ${err.params.type}:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === "instanceof") {
			return `${dataPath} should be an instance of ${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === "required") {
			const missingProperty = err.params.missingProperty.replace(/^\./, "");
			return `${dataPath} misses the property '${missingProperty}'.\n${getSchemaPartText(
				err.parentSchema,
				["properties", missingProperty]
			)}`;
		} else if (err.keyword === "minimum") {
			return `${dataPath} ${err.message}.${getSchemaPartDescription(
				err.parentSchema
			)}`;
		} else if (err.keyword === "uniqueItems") {
			return `${dataPath} should not contain the item '${
				err.data[err.params.i]
			}' twice.${getSchemaPartDescription(err.parentSchema)}`;
		} else if (
			err.keyword === "minLength" ||
			err.keyword === "minItems" ||
			err.keyword === "minProperties"
		) {
			if (err.params.limit === 1) {
				return `${dataPath} should not be empty.${getSchemaPartDescription(
					err.parentSchema
				)}`;
			} else {
				return `${dataPath} ${err.message}${getSchemaPartDescription(
					err.parentSchema
				)}`;
			}
		} else if (err.keyword === "absolutePath") {
			const baseMessage = `${dataPath}: ${
				err.message
			}${getSchemaPartDescription(err.parentSchema)}`;
			if (dataPath === "configuration.output.filename") {
				return (
					`${baseMessage}\n` +
					"Please use output.path to specify absolute path and output.filename for the file name."
				);
			}
			return baseMessage;
		} else {
			return `${dataPath} ${err.message} (${JSON.stringify(
				err,
				null,
				2
			)}).\n${getSchemaPartText(err.parentSchema)}`;
		}
	}
}

module.exports = WebpackOptionsValidationError;


/***/ }),

/***/ "./node_modules/webpack/lib/compareLocations.js":
/*!*****************************************!*\
  !*** (webpack)/lib/compareLocations.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */

// TODO webpack 5 remove string type from a and b
/**
 * Compare two locations
 * @param {string|DependencyLocation} a A location node
 * @param {string|DependencyLocation} b A location node
 * @returns {-1|0|1} sorting comparator value
 */
module.exports = (a, b) => {
	if (typeof a === "string") {
		if (typeof b === "string") {
			if (a < b) return -1;
			if (a > b) return 1;
			return 0;
		} else if (typeof b === "object") {
			return 1;
		} else {
			return 0;
		}
	} else if (typeof a === "object") {
		if (typeof b === "string") {
			return -1;
		} else if (typeof b === "object") {
			if ("start" in a && "start" in b) {
				const ap = a.start;
				const bp = b.start;
				if (ap.line < bp.line) return -1;
				if (ap.line > bp.line) return 1;
				if (ap.column < bp.column) return -1;
				if (ap.column > bp.column) return 1;
			}
			if ("name" in a && "name" in b) {
				if (a.name < b.name) return -1;
				if (a.name > b.name) return 1;
			}
			if ("index" in a && "index" in b) {
				if (a.index < b.index) return -1;
				if (a.index > b.index) return 1;
			}
			return 0;
		} else {
			return 0;
		}
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/debug/ProfilingPlugin.js":
/*!**********************************************!*\
  !*** (webpack)/lib/debug/ProfilingPlugin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const mkdirp = __webpack_require__(/*! mkdirp */ "mkdirp");
const { Tracer } = __webpack_require__(/*! chrome-trace-event */ "chrome-trace-event");
const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../../schemas/plugins/debug/ProfilingPlugin.json */ "./node_modules/webpack/schemas/plugins/debug/ProfilingPlugin.json");

/** @typedef {import("../../declarations/plugins/debug/ProfilingPlugin").ProfilingPluginOptions} ProfilingPluginOptions */

let inspector = undefined;

try {
	// eslint-disable-next-line node/no-unsupported-features/node-builtins
	inspector = __webpack_require__(/*! inspector */ "inspector");
} catch (e) {
	console.log("Unable to CPU profile in < node 8.0");
}

class Profiler {
	constructor(inspector) {
		this.session = undefined;
		this.inspector = inspector;
	}

	hasSession() {
		return this.session !== undefined;
	}

	startProfiling() {
		if (this.inspector === undefined) {
			return Promise.resolve();
		}

		try {
			this.session = new inspector.Session();
			this.session.connect();
		} catch (_) {
			this.session = undefined;
			return Promise.resolve();
		}

		return Promise.all([
			this.sendCommand("Profiler.setSamplingInterval", {
				interval: 100
			}),
			this.sendCommand("Profiler.enable"),
			this.sendCommand("Profiler.start")
		]);
	}

	sendCommand(method, params) {
		if (this.hasSession()) {
			return new Promise((res, rej) => {
				return this.session.post(method, params, (err, params) => {
					if (err !== null) {
						rej(err);
					} else {
						res(params);
					}
				});
			});
		} else {
			return Promise.resolve();
		}
	}

	destroy() {
		if (this.hasSession()) {
			this.session.disconnect();
		}

		return Promise.resolve();
	}

	stopProfiling() {
		return this.sendCommand("Profiler.stop");
	}
}

/**
 * @typedef {Object} Trace
 * @description an object that wraps Tracer and Profiler with a counter
 * @property {Tracer} trace instance of Tracer
 * @property {number} counter Counter
 * @property {Profiler} profiler instance of Profiler
 * @property {Function} end the end function
 */

/**
 * @param {string} outputPath The location where to write the log.
 * @returns {Trace} The trace object
 */
const createTrace = outputPath => {
	const trace = new Tracer({
		noStream: true
	});
	const profiler = new Profiler(inspector);
	if (/\/|\\/.test(outputPath)) {
		const dirPath = path.dirname(outputPath);
		mkdirp.sync(dirPath);
	}
	const fsStream = fs.createWriteStream(outputPath);

	let counter = 0;

	trace.pipe(fsStream);
	// These are critical events that need to be inserted so that tools like
	// chrome dev tools can load the profile.
	trace.instantEvent({
		name: "TracingStartedInPage",
		id: ++counter,
		cat: ["disabled-by-default-devtools.timeline"],
		args: {
			data: {
				sessionId: "-1",
				page: "0xfff",
				frames: [
					{
						frame: "0xfff",
						url: "webpack",
						name: ""
					}
				]
			}
		}
	});

	trace.instantEvent({
		name: "TracingStartedInBrowser",
		id: ++counter,
		cat: ["disabled-by-default-devtools.timeline"],
		args: {
			data: {
				sessionId: "-1"
			}
		}
	});

	return {
		trace,
		counter,
		profiler,
		end: callback => {
			// Wait until the write stream finishes.
			fsStream.on("finish", () => {
				callback();
			});
			// Tear down the readable trace stream.
			trace.push(null);
		}
	};
};

const pluginName = "ProfilingPlugin";

class ProfilingPlugin {
	/**
	 * @param {ProfilingPluginOptions=} opts options object
	 */
	constructor(opts) {
		validateOptions(schema, opts || {}, "Profiling plugin");
		opts = opts || {};
		this.outputPath = opts.outputPath || "events.json";
	}

	apply(compiler) {
		const tracer = createTrace(this.outputPath);
		tracer.profiler.startProfiling();

		// Compiler Hooks
		Object.keys(compiler.hooks).forEach(hookName => {
			compiler.hooks[hookName].intercept(
				makeInterceptorFor("Compiler", tracer)(hookName)
			);
		});

		Object.keys(compiler.resolverFactory.hooks).forEach(hookName => {
			compiler.resolverFactory.hooks[hookName].intercept(
				makeInterceptorFor("Resolver", tracer)(hookName)
			);
		});

		compiler.hooks.compilation.tap(
			pluginName,
			(compilation, { normalModuleFactory, contextModuleFactory }) => {
				interceptAllHooksFor(compilation, tracer, "Compilation");
				interceptAllHooksFor(
					normalModuleFactory,
					tracer,
					"Normal Module Factory"
				);
				interceptAllHooksFor(
					contextModuleFactory,
					tracer,
					"Context Module Factory"
				);
				interceptAllParserHooks(normalModuleFactory, tracer);
				interceptTemplateInstancesFrom(compilation, tracer);
			}
		);

		// We need to write out the CPU profile when we are all done.
		compiler.hooks.done.tapAsync(
			{
				name: pluginName,
				stage: Infinity
			},
			(stats, callback) => {
				tracer.profiler.stopProfiling().then(parsedResults => {
					if (parsedResults === undefined) {
						tracer.profiler.destroy();
						tracer.trace.flush();
						tracer.end(callback);
						return;
					}

					const cpuStartTime = parsedResults.profile.startTime;
					const cpuEndTime = parsedResults.profile.endTime;

					tracer.trace.completeEvent({
						name: "TaskQueueManager::ProcessTaskFromWorkQueue",
						id: ++tracer.counter,
						cat: ["toplevel"],
						ts: cpuStartTime,
						args: {
							src_file: "../../ipc/ipc_moji_bootstrap.cc",
							src_func: "Accept"
						}
					});

					tracer.trace.completeEvent({
						name: "EvaluateScript",
						id: ++tracer.counter,
						cat: ["devtools.timeline"],
						ts: cpuStartTime,
						dur: cpuEndTime - cpuStartTime,
						args: {
							data: {
								url: "webpack",
								lineNumber: 1,
								columnNumber: 1,
								frame: "0xFFF"
							}
						}
					});

					tracer.trace.instantEvent({
						name: "CpuProfile",
						id: ++tracer.counter,
						cat: ["disabled-by-default-devtools.timeline"],
						ts: cpuEndTime,
						args: {
							data: {
								cpuProfile: parsedResults.profile
							}
						}
					});

					tracer.profiler.destroy();
					tracer.trace.flush();
					tracer.end(callback);
				});
			}
		);
	}
}

const interceptTemplateInstancesFrom = (compilation, tracer) => {
	const {
		mainTemplate,
		chunkTemplate,
		hotUpdateChunkTemplate,
		moduleTemplates
	} = compilation;

	const { javascript, webassembly } = moduleTemplates;

	[
		{
			instance: mainTemplate,
			name: "MainTemplate"
		},
		{
			instance: chunkTemplate,
			name: "ChunkTemplate"
		},
		{
			instance: hotUpdateChunkTemplate,
			name: "HotUpdateChunkTemplate"
		},
		{
			instance: javascript,
			name: "JavaScriptModuleTemplate"
		},
		{
			instance: webassembly,
			name: "WebAssemblyModuleTemplate"
		}
	].forEach(templateObject => {
		Object.keys(templateObject.instance.hooks).forEach(hookName => {
			templateObject.instance.hooks[hookName].intercept(
				makeInterceptorFor(templateObject.name, tracer)(hookName)
			);
		});
	});
};

const interceptAllHooksFor = (instance, tracer, logLabel) => {
	if (Reflect.has(instance, "hooks")) {
		Object.keys(instance.hooks).forEach(hookName => {
			instance.hooks[hookName].intercept(
				makeInterceptorFor(logLabel, tracer)(hookName)
			);
		});
	}
};

const interceptAllParserHooks = (moduleFactory, tracer) => {
	const moduleTypes = [
		"javascript/auto",
		"javascript/dynamic",
		"javascript/esm",
		"json",
		"webassembly/experimental"
	];

	moduleTypes.forEach(moduleType => {
		moduleFactory.hooks.parser
			.for(moduleType)
			.tap("ProfilingPlugin", (parser, parserOpts) => {
				interceptAllHooksFor(parser, tracer, "Parser");
			});
	});
};

const makeInterceptorFor = (instance, tracer) => hookName => ({
	register: ({ name, type, context, fn }) => {
		const newFn = makeNewProfiledTapFn(hookName, tracer, {
			name,
			type,
			fn
		});
		return {
			name,
			type,
			context,
			fn: newFn
		};
	}
});

// TODO improve typing
/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */

/**
 * @param {string} hookName Name of the hook to profile.
 * @param {Trace} tracer The trace object.
 * @param {object} options Options for the profiled fn.
 * @param {string} options.name Plugin name
 * @param {string} options.type Plugin type (sync | async | promise)
 * @param {PluginFunction} options.fn Plugin function
 * @returns {PluginFunction} Chainable hooked function.
 */
const makeNewProfiledTapFn = (hookName, tracer, { name, type, fn }) => {
	const defaultCategory = ["blink.user_timing"];

	switch (type) {
		case "promise":
			return (...args) => {
				const id = ++tracer.counter;
				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				});
				const promise = /** @type {Promise<*>} */ (fn(...args));
				return promise.then(r => {
					tracer.trace.end({
						name,
						id,
						cat: defaultCategory
					});
					return r;
				});
			};
		case "async":
			return (...args) => {
				const id = ++tracer.counter;
				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				});
				fn(...args, (...r) => {
					const callback = args.pop();
					tracer.trace.end({
						name,
						id,
						cat: defaultCategory
					});
					callback(...r);
				});
			};
		case "sync":
			return (...args) => {
				const id = ++tracer.counter;
				// Do not instrument ourself due to the CPU
				// profile needing to be the last event in the trace.
				if (name === pluginName) {
					return fn(...args);
				}

				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				});
				let r;
				try {
					r = fn(...args);
				} catch (error) {
					tracer.trace.end({
						name,
						id,
						cat: defaultCategory
					});
					throw error;
				}
				tracer.trace.end({
					name,
					id,
					cat: defaultCategory
				});
				return r;
			};
		default:
			break;
	}
};

module.exports = ProfilingPlugin;
module.exports.Profiler = Profiler;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDDefineDependency.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/dependencies/AMDDefineDependency.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class AMDDefineDependency extends NullDependency {
	constructor(range, arrayRange, functionRange, objectRange, namedModule) {
		super();
		this.range = range;
		this.arrayRange = arrayRange;
		this.functionRange = functionRange;
		this.objectRange = objectRange;
		this.namedModule = namedModule;
		this.localModule = null;
	}

	get type() {
		return "amd define";
	}
}

AMDDefineDependency.Template = class AMDDefineDependencyTemplate {
	get definitions() {
		return {
			f: [
				"var __WEBPACK_AMD_DEFINE_RESULT__;",
				`!(__WEBPACK_AMD_DEFINE_RESULT__ = (#).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`
			],
			o: ["", "!(module.exports = #)"],
			of: [
				"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;",
				`!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`
			],
			af: [
				"var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;",
				`!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_RESULT__ = (#).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`
			],
			ao: ["", "!(#, module.exports = #)"],
			aof: [
				"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;",
				`!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`
			],
			lf: [
				"var XXX, XXXmodule;",
				"!(XXXmodule = { id: YYY, exports: {}, loaded: false }, XXX = #.call(XXXmodule.exports, __webpack_require__, XXXmodule.exports, XXXmodule), XXXmodule.loaded = true, XXX === undefined && (XXX = XXXmodule.exports))"
			],
			lo: ["var XXX;", "!(XXX = #)"],
			lof: [
				"var XXX, XXXfactory, XXXmodule;",
				"!(XXXfactory = (#), (XXXmodule = { id: YYY, exports: {}, loaded: false }), XXX = (typeof XXXfactory === 'function' ? (XXXfactory.call(XXXmodule.exports, __webpack_require__, XXXmodule.exports, XXXmodule)) : XXXfactory), (XXXmodule.loaded = true), XXX === undefined && (XXX = XXXmodule.exports))"
			],
			laf: [
				"var __WEBPACK_AMD_DEFINE_ARRAY__, XXX;",
				"!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, XXX = ((#).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))"
			],
			lao: ["var XXX;", "!(#, XXX = #)"],
			laof: [
				"var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, XXX;",
				`!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#),
				XXX = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__))`
			]
		};
	}

	apply(dependency, source) {
		const branch = this.branch(dependency);
		const defAndText = this.definitions[branch];
		const definitions = defAndText[0];
		const text = defAndText[1];
		this.replace(dependency, source, definitions, text);
	}

	localModuleVar(dependency) {
		return (
			dependency.localModule &&
			dependency.localModule.used &&
			dependency.localModule.variableName()
		);
	}

	branch(dependency) {
		const localModuleVar = this.localModuleVar(dependency) ? "l" : "";
		const arrayRange = dependency.arrayRange ? "a" : "";
		const objectRange = dependency.objectRange ? "o" : "";
		const functionRange = dependency.functionRange ? "f" : "";
		return localModuleVar + arrayRange + objectRange + functionRange;
	}

	replace(dependency, source, definition, text) {
		const localModuleVar = this.localModuleVar(dependency);
		if (localModuleVar) {
			text = text.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$"));
			definition = definition.replace(
				/XXX/g,
				localModuleVar.replace(/\$/g, "$$$$")
			);
		}

		if (dependency.namedModule) {
			text = text.replace(/YYY/g, JSON.stringify(dependency.namedModule));
		}

		const texts = text.split("#");

		if (definition) source.insert(0, definition);

		let current = dependency.range[0];
		if (dependency.arrayRange) {
			source.replace(current, dependency.arrayRange[0] - 1, texts.shift());
			current = dependency.arrayRange[1];
		}

		if (dependency.objectRange) {
			source.replace(current, dependency.objectRange[0] - 1, texts.shift());
			current = dependency.objectRange[1];
		} else if (dependency.functionRange) {
			source.replace(current, dependency.functionRange[0] - 1, texts.shift());
			current = dependency.functionRange[1];
		}
		source.replace(current, dependency.range[1] - 1, texts.shift());
		if (texts.length > 0) throw new Error("Implementation error");
	}
};

module.exports = AMDDefineDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDDefineDependencyParserPlugin.js":
/*!*********************************************************************!*\
  !*** (webpack)/lib/dependencies/AMDDefineDependencyParserPlugin.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const AMDRequireItemDependency = __webpack_require__(/*! ./AMDRequireItemDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireItemDependency.js");
const AMDRequireContextDependency = __webpack_require__(/*! ./AMDRequireContextDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireContextDependency.js");
const ConstDependency = __webpack_require__(/*! ./ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const AMDDefineDependency = __webpack_require__(/*! ./AMDDefineDependency */ "./node_modules/webpack/lib/dependencies/AMDDefineDependency.js");
const AMDRequireArrayDependency = __webpack_require__(/*! ./AMDRequireArrayDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireArrayDependency.js");
const LocalModuleDependency = __webpack_require__(/*! ./LocalModuleDependency */ "./node_modules/webpack/lib/dependencies/LocalModuleDependency.js");
const ContextDependencyHelpers = __webpack_require__(/*! ./ContextDependencyHelpers */ "./node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js");
const LocalModulesHelpers = __webpack_require__(/*! ./LocalModulesHelpers */ "./node_modules/webpack/lib/dependencies/LocalModulesHelpers.js");

const isBoundFunctionExpression = expr => {
	if (expr.type !== "CallExpression") return false;
	if (expr.callee.type !== "MemberExpression") return false;
	if (expr.callee.computed) return false;
	if (expr.callee.object.type !== "FunctionExpression") return false;
	if (expr.callee.property.type !== "Identifier") return false;
	if (expr.callee.property.name !== "bind") return false;
	return true;
};

const isUnboundFunctionExpression = expr => {
	if (expr.type === "FunctionExpression") return true;
	if (expr.type === "ArrowFunctionExpression") return true;
	return false;
};

const isCallable = expr => {
	if (isUnboundFunctionExpression(expr)) return true;
	if (isBoundFunctionExpression(expr)) return true;
	return false;
};

class AMDDefineDependencyParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		parser.hooks.call
			.for("define")
			.tap(
				"AMDDefineDependencyParserPlugin",
				this.processCallDefine.bind(this, parser)
			);
	}

	processArray(parser, expr, param, identifiers, namedModule) {
		if (param.isArray()) {
			param.items.forEach((param, idx) => {
				if (
					param.isString() &&
					["require", "module", "exports"].includes(param.string)
				)
					identifiers[idx] = param.string;
				const result = this.processItem(parser, expr, param, namedModule);
				if (result === undefined) {
					this.processContext(parser, expr, param);
				}
			});
			return true;
		} else if (param.isConstArray()) {
			const deps = [];
			param.array.forEach((request, idx) => {
				let dep;
				let localModule;
				if (request === "require") {
					identifiers[idx] = request;
					dep = "__webpack_require__";
				} else if (["exports", "module"].includes(request)) {
					identifiers[idx] = request;
					dep = request;
				} else if (
					(localModule = LocalModulesHelpers.getLocalModule(
						parser.state,
						request
					))
				) {
					dep = new LocalModuleDependency(localModule, undefined, false);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
				} else {
					dep = this.newRequireItemDependency(request);
					dep.loc = expr.loc;
					dep.optional = !!parser.scope.inTry;
					parser.state.current.addDependency(dep);
				}
				deps.push(dep);
			});
			const dep = this.newRequireArrayDependency(deps, param.range);
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		}
	}
	processItem(parser, expr, param, namedModule) {
		if (param.isConditional()) {
			param.options.forEach(param => {
				const result = this.processItem(parser, expr, param);
				if (result === undefined) {
					this.processContext(parser, expr, param);
				}
			});
			return true;
		} else if (param.isString()) {
			let dep, localModule;
			if (param.string === "require") {
				dep = new ConstDependency("__webpack_require__", param.range);
			} else if (["require", "exports", "module"].includes(param.string)) {
				dep = new ConstDependency(param.string, param.range);
			} else if (
				(localModule = LocalModulesHelpers.getLocalModule(
					parser.state,
					param.string,
					namedModule
				))
			) {
				dep = new LocalModuleDependency(localModule, param.range, false);
			} else {
				dep = this.newRequireItemDependency(param.string, param.range);
			}
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		}
	}
	processContext(parser, expr, param) {
		const dep = ContextDependencyHelpers.create(
			AMDRequireContextDependency,
			param.range,
			param,
			expr,
			this.options,
			{},
			parser
		);
		if (!dep) return;
		dep.loc = expr.loc;
		dep.optional = !!parser.scope.inTry;
		parser.state.current.addDependency(dep);
		return true;
	}

	processCallDefine(parser, expr) {
		let array, fn, obj, namedModule;
		switch (expr.arguments.length) {
			case 1:
				if (isCallable(expr.arguments[0])) {
					// define(f() {…})
					fn = expr.arguments[0];
				} else if (expr.arguments[0].type === "ObjectExpression") {
					// define({…})
					obj = expr.arguments[0];
				} else {
					// define(expr)
					// unclear if function or object
					obj = fn = expr.arguments[0];
				}
				break;
			case 2:
				if (expr.arguments[0].type === "Literal") {
					namedModule = expr.arguments[0].value;
					// define("…", …)
					if (isCallable(expr.arguments[1])) {
						// define("…", f() {…})
						fn = expr.arguments[1];
					} else if (expr.arguments[1].type === "ObjectExpression") {
						// define("…", {…})
						obj = expr.arguments[1];
					} else {
						// define("…", expr)
						// unclear if function or object
						obj = fn = expr.arguments[1];
					}
				} else {
					array = expr.arguments[0];
					if (isCallable(expr.arguments[1])) {
						// define([…], f() {})
						fn = expr.arguments[1];
					} else if (expr.arguments[1].type === "ObjectExpression") {
						// define([…], {…})
						obj = expr.arguments[1];
					} else {
						// define([…], expr)
						// unclear if function or object
						obj = fn = expr.arguments[1];
					}
				}
				break;
			case 3:
				// define("…", […], f() {…})
				namedModule = expr.arguments[0].value;
				array = expr.arguments[1];
				if (isCallable(expr.arguments[2])) {
					// define("…", […], f() {})
					fn = expr.arguments[2];
				} else if (expr.arguments[2].type === "ObjectExpression") {
					// define("…", […], {…})
					obj = expr.arguments[2];
				} else {
					// define("…", […], expr)
					// unclear if function or object
					obj = fn = expr.arguments[2];
				}
				break;
			default:
				return;
		}
		let fnParams = null;
		let fnParamsOffset = 0;
		if (fn) {
			if (isUnboundFunctionExpression(fn)) {
				fnParams = fn.params;
			} else if (isBoundFunctionExpression(fn)) {
				fnParams = fn.callee.object.params;
				fnParamsOffset = fn.arguments.length - 1;
				if (fnParamsOffset < 0) {
					fnParamsOffset = 0;
				}
			}
		}
		let fnRenames = parser.scope.renames.createChild();
		if (array) {
			const identifiers = {};
			const param = parser.evaluateExpression(array);
			const result = this.processArray(
				parser,
				expr,
				param,
				identifiers,
				namedModule
			);
			if (!result) return;
			if (fnParams) {
				fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {
					if (identifiers[idx]) {
						fnRenames.set(param.name, identifiers[idx]);
						return false;
					}
					return true;
				});
			}
		} else {
			const identifiers = ["require", "exports", "module"];
			if (fnParams) {
				fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {
					if (identifiers[idx]) {
						fnRenames.set(param.name, identifiers[idx]);
						return false;
					}
					return true;
				});
			}
		}
		let inTry;
		if (fn && isUnboundFunctionExpression(fn)) {
			inTry = parser.scope.inTry;
			parser.inScope(fnParams, () => {
				parser.scope.renames = fnRenames;
				parser.scope.inTry = inTry;
				if (fn.body.type === "BlockStatement") {
					parser.walkStatement(fn.body);
				} else {
					parser.walkExpression(fn.body);
				}
			});
		} else if (fn && isBoundFunctionExpression(fn)) {
			inTry = parser.scope.inTry;
			parser.inScope(
				fn.callee.object.params.filter(
					i => !["require", "module", "exports"].includes(i.name)
				),
				() => {
					parser.scope.renames = fnRenames;
					parser.scope.inTry = inTry;
					if (fn.callee.object.body.type === "BlockStatement") {
						parser.walkStatement(fn.callee.object.body);
					} else {
						parser.walkExpression(fn.callee.object.body);
					}
				}
			);
			if (fn.arguments) {
				parser.walkExpressions(fn.arguments);
			}
		} else if (fn || obj) {
			parser.walkExpression(fn || obj);
		}

		const dep = this.newDefineDependency(
			expr.range,
			array ? array.range : null,
			fn ? fn.range : null,
			obj ? obj.range : null,
			namedModule ? namedModule : null
		);
		dep.loc = expr.loc;
		if (namedModule) {
			dep.localModule = LocalModulesHelpers.addLocalModule(
				parser.state,
				namedModule
			);
		}
		parser.state.current.addDependency(dep);
		return true;
	}

	newDefineDependency(
		range,
		arrayRange,
		functionRange,
		objectRange,
		namedModule
	) {
		return new AMDDefineDependency(
			range,
			arrayRange,
			functionRange,
			objectRange,
			namedModule
		);
	}
	newRequireArrayDependency(depsArray, range) {
		return new AMDRequireArrayDependency(depsArray, range);
	}
	newRequireItemDependency(request, range) {
		return new AMDRequireItemDependency(request, range);
	}
}
module.exports = AMDDefineDependencyParserPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDPlugin.js":
/*!***********************************************!*\
  !*** (webpack)/lib/dependencies/AMDPlugin.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const path = __webpack_require__(/*! path */ "path");
const AMDRequireDependency = __webpack_require__(/*! ./AMDRequireDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireDependency.js");
const AMDRequireItemDependency = __webpack_require__(/*! ./AMDRequireItemDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireItemDependency.js");
const AMDRequireArrayDependency = __webpack_require__(/*! ./AMDRequireArrayDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireArrayDependency.js");
const AMDRequireContextDependency = __webpack_require__(/*! ./AMDRequireContextDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireContextDependency.js");
const AMDDefineDependency = __webpack_require__(/*! ./AMDDefineDependency */ "./node_modules/webpack/lib/dependencies/AMDDefineDependency.js");
const UnsupportedDependency = __webpack_require__(/*! ./UnsupportedDependency */ "./node_modules/webpack/lib/dependencies/UnsupportedDependency.js");
const LocalModuleDependency = __webpack_require__(/*! ./LocalModuleDependency */ "./node_modules/webpack/lib/dependencies/LocalModuleDependency.js");

const NullFactory = __webpack_require__(/*! ../NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

const AMDRequireDependenciesBlockParserPlugin = __webpack_require__(/*! ./AMDRequireDependenciesBlockParserPlugin */ "./node_modules/webpack/lib/dependencies/AMDRequireDependenciesBlockParserPlugin.js");
const AMDDefineDependencyParserPlugin = __webpack_require__(/*! ./AMDDefineDependencyParserPlugin */ "./node_modules/webpack/lib/dependencies/AMDDefineDependencyParserPlugin.js");

const AliasPlugin = __webpack_require__(/*! enhanced-resolve/lib/AliasPlugin */ "enhanced-resolve/lib/AliasPlugin");

const ParserHelpers = __webpack_require__(/*! ../ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");

class AMDPlugin {
	constructor(options, amdOptions) {
		this.amdOptions = amdOptions;
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		const amdOptions = this.amdOptions;
		compiler.hooks.compilation.tap(
			"AMDPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					AMDRequireDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					AMDRequireDependency,
					new AMDRequireDependency.Template()
				);

				compilation.dependencyFactories.set(
					AMDRequireItemDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					AMDRequireItemDependency,
					new AMDRequireItemDependency.Template()
				);

				compilation.dependencyFactories.set(
					AMDRequireArrayDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					AMDRequireArrayDependency,
					new AMDRequireArrayDependency.Template()
				);

				compilation.dependencyFactories.set(
					AMDRequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					AMDRequireContextDependency,
					new AMDRequireContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					AMDDefineDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					AMDDefineDependency,
					new AMDDefineDependency.Template()
				);

				compilation.dependencyFactories.set(
					UnsupportedDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					UnsupportedDependency,
					new UnsupportedDependency.Template()
				);

				compilation.dependencyFactories.set(
					LocalModuleDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					LocalModuleDependency,
					new LocalModuleDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.amd !== undefined && !parserOptions.amd) return;

					const setExpressionToModule = (outerExpr, module) => {
						parser.hooks.expression.for(outerExpr).tap("AMDPlugin", expr => {
							const dep = new AMDRequireItemDependency(module, expr.range);
							dep.userRequest = outerExpr;
							dep.loc = expr.loc;
							parser.state.current.addDependency(dep);
							return true;
						});
					};

					new AMDRequireDependenciesBlockParserPlugin(options).apply(parser);
					new AMDDefineDependencyParserPlugin(options).apply(parser);

					setExpressionToModule("require.amd", "!!webpack amd options");
					setExpressionToModule("define.amd", "!!webpack amd options");
					setExpressionToModule("define", "!!webpack amd define");

					parser.hooks.expression
						.for("__webpack_amd_options__")
						.tap("AMDPlugin", () =>
							parser.state.current.addVariable(
								"__webpack_amd_options__",
								JSON.stringify(amdOptions)
							)
						);
					parser.hooks.evaluateTypeof
						.for("define.amd")
						.tap(
							"AMDPlugin",
							ParserHelpers.evaluateToString(typeof amdOptions)
						);
					parser.hooks.evaluateTypeof
						.for("require.amd")
						.tap(
							"AMDPlugin",
							ParserHelpers.evaluateToString(typeof amdOptions)
						);
					parser.hooks.evaluateIdentifier
						.for("define.amd")
						.tap(
							"AMDPlugin",
							ParserHelpers.evaluateToIdentifier("define.amd", true)
						);
					parser.hooks.evaluateIdentifier
						.for("require.amd")
						.tap(
							"AMDPlugin",
							ParserHelpers.evaluateToIdentifier("require.amd", true)
						);
					parser.hooks.typeof
						.for("define")
						.tap(
							"AMDPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
					parser.hooks.evaluateTypeof
						.for("define")
						.tap("AMDPlugin", ParserHelpers.evaluateToString("function"));
					parser.hooks.canRename
						.for("define")
						.tap("AMDPlugin", ParserHelpers.approve);
					parser.hooks.rename.for("define").tap("AMDPlugin", expr => {
						const dep = new AMDRequireItemDependency(
							"!!webpack amd define",
							expr.range
						);
						dep.userRequest = "define";
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
						return false;
					});
					parser.hooks.typeof
						.for("require")
						.tap(
							"AMDPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
					parser.hooks.evaluateTypeof
						.for("require")
						.tap("AMDPlugin", ParserHelpers.evaluateToString("function"));
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("AMDPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("AMDPlugin", handler);
			}
		);
		compiler.hooks.afterResolvers.tap("AMDPlugin", () => {
			compiler.resolverFactory.hooks.resolver
				.for("normal")
				.tap("AMDPlugin", resolver => {
					new AliasPlugin(
						"described-resolve",
						{
							name: "amdefine",
							alias: path.join(
								__dirname,
								"..",
								"..",
								"buildin",
								"amd-define.js"
							)
						},
						"resolve"
					).apply(resolver);
					new AliasPlugin(
						"described-resolve",
						{
							name: "webpack amd options",
							alias: path.join(
								__dirname,
								"..",
								"..",
								"buildin",
								"amd-options.js"
							)
						},
						"resolve"
					).apply(resolver);
					new AliasPlugin(
						"described-resolve",
						{
							name: "webpack amd define",
							alias: path.join(
								__dirname,
								"..",
								"..",
								"buildin",
								"amd-define.js"
							)
						},
						"resolve"
					).apply(resolver);
				});
		});
	}
}
module.exports = AMDPlugin;

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDRequireArrayDependency.js":
/*!***************************************************************!*\
  !*** (webpack)/lib/dependencies/AMDRequireArrayDependency.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Dependency = __webpack_require__(/*! ../Dependency */ "./node_modules/webpack/lib/Dependency.js");

class AMDRequireArrayDependency extends Dependency {
	constructor(depsArray, range) {
		super();
		this.depsArray = depsArray;
		this.range = range;
	}

	get type() {
		return "amd require array";
	}
}

AMDRequireArrayDependency.Template = class AMDRequireArrayDependencyTemplate {
	apply(dep, source, runtime) {
		const content = this.getContent(dep, runtime);
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}

	getContent(dep, runtime) {
		const requires = dep.depsArray.map(dependency => {
			return this.contentForDependency(dependency, runtime);
		});
		return `[${requires.join(", ")}]`;
	}

	contentForDependency(dep, runtime) {
		if (typeof dep === "string") {
			return dep;
		}

		if (dep.localModule) {
			return dep.localModule.variableName();
		} else {
			return runtime.moduleExports({
				module: dep.module,
				request: dep.request
			});
		}
	}
};

module.exports = AMDRequireArrayDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDRequireContextDependency.js":
/*!*****************************************************************!*\
  !*** (webpack)/lib/dependencies/AMDRequireContextDependency.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ContextDependency = __webpack_require__(/*! ./ContextDependency */ "./node_modules/webpack/lib/dependencies/ContextDependency.js");
class AMDRequireContextDependency extends ContextDependency {
	constructor(options, range, valueRange) {
		super(options);
		this.range = range;
		this.valueRange = valueRange;
	}

	get type() {
		return "amd require context";
	}
}
AMDRequireContextDependency.Template = __webpack_require__(/*! ./ContextDependencyTemplateAsRequireCall */ "./node_modules/webpack/lib/dependencies/ContextDependencyTemplateAsRequireCall.js");
module.exports = AMDRequireContextDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDRequireDependenciesBlock.js":
/*!*****************************************************************!*\
  !*** (webpack)/lib/dependencies/AMDRequireDependenciesBlock.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const AsyncDependenciesBlock = __webpack_require__(/*! ../AsyncDependenciesBlock */ "./node_modules/webpack/lib/AsyncDependenciesBlock.js");
const AMDRequireDependency = __webpack_require__(/*! ./AMDRequireDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireDependency.js");

module.exports = class AMDRequireDependenciesBlock extends AsyncDependenciesBlock {
	constructor(
		expr,
		arrayRange,
		functionRange,
		errorCallbackRange,
		module,
		loc,
		request
	) {
		super(null, module, loc, request);
		this.expr = expr;
		this.outerRange = expr.range;
		this.arrayRange = arrayRange;
		this.functionBindThis = false;
		this.functionRange = functionRange;
		this.errorCallbackBindThis = false;
		this.errorCallbackRange = errorCallbackRange;
		this.bindThis = true;
		if (arrayRange && functionRange && errorCallbackRange) {
			this.range = [arrayRange[0], errorCallbackRange[1]];
		} else if (arrayRange && functionRange) {
			this.range = [arrayRange[0], functionRange[1]];
		} else if (arrayRange) {
			this.range = arrayRange;
		} else if (functionRange) {
			this.range = functionRange;
		} else {
			this.range = expr.range;
		}
		const dep = this.newRequireDependency();
		dep.loc = loc;
		this.addDependency(dep);
	}

	newRequireDependency() {
		return new AMDRequireDependency(this);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDRequireDependenciesBlockParserPlugin.js":
/*!*****************************************************************************!*\
  !*** (webpack)/lib/dependencies/AMDRequireDependenciesBlockParserPlugin.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const AMDRequireItemDependency = __webpack_require__(/*! ./AMDRequireItemDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireItemDependency.js");
const AMDRequireArrayDependency = __webpack_require__(/*! ./AMDRequireArrayDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireArrayDependency.js");
const AMDRequireContextDependency = __webpack_require__(/*! ./AMDRequireContextDependency */ "./node_modules/webpack/lib/dependencies/AMDRequireContextDependency.js");
const AMDRequireDependenciesBlock = __webpack_require__(/*! ./AMDRequireDependenciesBlock */ "./node_modules/webpack/lib/dependencies/AMDRequireDependenciesBlock.js");
const UnsupportedDependency = __webpack_require__(/*! ./UnsupportedDependency */ "./node_modules/webpack/lib/dependencies/UnsupportedDependency.js");
const LocalModuleDependency = __webpack_require__(/*! ./LocalModuleDependency */ "./node_modules/webpack/lib/dependencies/LocalModuleDependency.js");
const ContextDependencyHelpers = __webpack_require__(/*! ./ContextDependencyHelpers */ "./node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js");
const LocalModulesHelpers = __webpack_require__(/*! ./LocalModulesHelpers */ "./node_modules/webpack/lib/dependencies/LocalModulesHelpers.js");
const ConstDependency = __webpack_require__(/*! ./ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const getFunctionExpression = __webpack_require__(/*! ./getFunctionExpression */ "./node_modules/webpack/lib/dependencies/getFunctionExpression.js");
const UnsupportedFeatureWarning = __webpack_require__(/*! ../UnsupportedFeatureWarning */ "./node_modules/webpack/lib/UnsupportedFeatureWarning.js");

class AMDRequireDependenciesBlockParserPlugin {
	constructor(options) {
		this.options = options;
	}

	processFunctionArgument(parser, expression) {
		let bindThis = true;
		const fnData = getFunctionExpression(expression);
		if (fnData) {
			parser.inScope(
				fnData.fn.params.filter(i => {
					return !["require", "module", "exports"].includes(i.name);
				}),
				() => {
					if (fnData.fn.body.type === "BlockStatement") {
						parser.walkStatement(fnData.fn.body);
					} else {
						parser.walkExpression(fnData.fn.body);
					}
				}
			);
			parser.walkExpressions(fnData.expressions);
			if (fnData.needThis === false) {
				bindThis = false;
			}
		} else {
			parser.walkExpression(expression);
		}
		return bindThis;
	}

	apply(parser) {
		parser.hooks.call
			.for("require")
			.tap(
				"AMDRequireDependenciesBlockParserPlugin",
				this.processCallRequire.bind(this, parser)
			);
	}

	processArray(parser, expr, param) {
		if (param.isArray()) {
			for (const p of param.items) {
				const result = this.processItem(parser, expr, p);
				if (result === undefined) {
					this.processContext(parser, expr, p);
				}
			}
			return true;
		} else if (param.isConstArray()) {
			const deps = [];
			for (const request of param.array) {
				let dep, localModule;
				if (request === "require") {
					dep = "__webpack_require__";
				} else if (["exports", "module"].includes(request)) {
					dep = request;
				} else if (
					(localModule = LocalModulesHelpers.getLocalModule(
						parser.state,
						request
					))
				) {
					dep = new LocalModuleDependency(localModule, undefined, false);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
				} else {
					dep = this.newRequireItemDependency(request);
					dep.loc = expr.loc;
					dep.optional = !!parser.scope.inTry;
					parser.state.current.addDependency(dep);
				}
				deps.push(dep);
			}
			const dep = this.newRequireArrayDependency(deps, param.range);
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		}
	}
	processItem(parser, expr, param) {
		if (param.isConditional()) {
			for (const p of param.options) {
				const result = this.processItem(parser, expr, p);
				if (result === undefined) {
					this.processContext(parser, expr, p);
				}
			}
			return true;
		} else if (param.isString()) {
			let dep, localModule;
			if (param.string === "require") {
				dep = new ConstDependency("__webpack_require__", param.string);
			} else if (param.string === "module") {
				dep = new ConstDependency(
					parser.state.module.buildInfo.moduleArgument,
					param.range
				);
			} else if (param.string === "exports") {
				dep = new ConstDependency(
					parser.state.module.buildInfo.exportsArgument,
					param.range
				);
			} else if (
				(localModule = LocalModulesHelpers.getLocalModule(
					parser.state,
					param.string
				))
			) {
				dep = new LocalModuleDependency(localModule, param.range, false);
			} else {
				dep = this.newRequireItemDependency(param.string, param.range);
			}
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		}
	}
	processContext(parser, expr, param) {
		const dep = ContextDependencyHelpers.create(
			AMDRequireContextDependency,
			param.range,
			param,
			expr,
			this.options,
			{},
			parser
		);
		if (!dep) return;
		dep.loc = expr.loc;
		dep.optional = !!parser.scope.inTry;
		parser.state.current.addDependency(dep);
		return true;
	}

	processArrayForRequestString(param) {
		if (param.isArray()) {
			const result = param.items.map(item =>
				this.processItemForRequestString(item)
			);
			if (result.every(Boolean)) return result.join(" ");
		} else if (param.isConstArray()) {
			return param.array.join(" ");
		}
	}

	processItemForRequestString(param) {
		if (param.isConditional()) {
			const result = param.options.map(item =>
				this.processItemForRequestString(item)
			);
			if (result.every(Boolean)) return result.join("|");
		} else if (param.isString()) {
			return param.string;
		}
	}

	processCallRequire(parser, expr) {
		let param;
		let dep;
		let result;

		const old = parser.state.current;

		if (expr.arguments.length >= 1) {
			param = parser.evaluateExpression(expr.arguments[0]);
			dep = this.newRequireDependenciesBlock(
				expr,
				param.range,
				expr.arguments.length > 1 ? expr.arguments[1].range : null,
				expr.arguments.length > 2 ? expr.arguments[2].range : null,
				parser.state.module,
				expr.loc,
				this.processArrayForRequestString(param)
			);
			parser.state.current = dep;
		}

		if (expr.arguments.length === 1) {
			parser.inScope([], () => {
				result = this.processArray(parser, expr, param);
			});
			parser.state.current = old;
			if (!result) return;
			parser.state.current.addBlock(dep);
			return true;
		}

		if (expr.arguments.length === 2 || expr.arguments.length === 3) {
			try {
				parser.inScope([], () => {
					result = this.processArray(parser, expr, param);
				});
				if (!result) {
					dep = new UnsupportedDependency("unsupported", expr.range);
					old.addDependency(dep);
					if (parser.state.module) {
						parser.state.module.errors.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								"Cannot statically analyse 'require(…, …)' in line " +
									expr.loc.start.line,
								expr.loc
							)
						);
					}
					dep = null;
					return true;
				}
				dep.functionBindThis = this.processFunctionArgument(
					parser,
					expr.arguments[1]
				);
				if (expr.arguments.length === 3) {
					dep.errorCallbackBindThis = this.processFunctionArgument(
						parser,
						expr.arguments[2]
					);
				}
			} finally {
				parser.state.current = old;
				if (dep) parser.state.current.addBlock(dep);
			}
			return true;
		}
	}

	newRequireDependenciesBlock(
		expr,
		arrayRange,
		functionRange,
		errorCallbackRange,
		module,
		loc,
		request
	) {
		return new AMDRequireDependenciesBlock(
			expr,
			arrayRange,
			functionRange,
			errorCallbackRange,
			module,
			loc,
			request
		);
	}
	newRequireItemDependency(request, range) {
		return new AMDRequireItemDependency(request, range);
	}
	newRequireArrayDependency(depsArray, range) {
		return new AMDRequireArrayDependency(depsArray, range);
	}
}
module.exports = AMDRequireDependenciesBlockParserPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDRequireDependency.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/dependencies/AMDRequireDependency.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class AMDRequireDependency extends NullDependency {
	constructor(block) {
		super();
		this.block = block;
	}
}

AMDRequireDependency.Template = class AMDRequireDependencyTemplate {
	apply(dep, source, runtime) {
		const depBlock = dep.block;
		const promise = runtime.blockPromise({
			block: depBlock,
			message: "AMD require"
		});

		// has array range but no function range
		if (depBlock.arrayRange && !depBlock.functionRange) {
			const startBlock = `${promise}.then(function() {`;
			const endBlock = `;}).catch(${runtime.onError()})`;
			source.replace(
				depBlock.outerRange[0],
				depBlock.arrayRange[0] - 1,
				startBlock
			);
			source.replace(
				depBlock.arrayRange[1],
				depBlock.outerRange[1] - 1,
				endBlock
			);
			return;
		}

		// has function range but no array range
		if (depBlock.functionRange && !depBlock.arrayRange) {
			const startBlock = `${promise}.then((`;
			const endBlock = `).bind(exports, __webpack_require__, exports, module)).catch(${runtime.onError()})`;
			source.replace(
				depBlock.outerRange[0],
				depBlock.functionRange[0] - 1,
				startBlock
			);
			source.replace(
				depBlock.functionRange[1],
				depBlock.outerRange[1] - 1,
				endBlock
			);
			return;
		}

		// has array range, function range, and errorCallbackRange
		if (
			depBlock.arrayRange &&
			depBlock.functionRange &&
			depBlock.errorCallbackRange
		) {
			const startBlock = `${promise}.then(function() { `;
			const errorRangeBlock = `}${
				depBlock.functionBindThis ? ".bind(this)" : ""
			}).catch(`;
			const endBlock = `${
				depBlock.errorCallbackBindThis ? ".bind(this)" : ""
			})`;

			source.replace(
				depBlock.outerRange[0],
				depBlock.arrayRange[0] - 1,
				startBlock
			);
			source.insert(
				depBlock.arrayRange[0] + 0.9,
				"var __WEBPACK_AMD_REQUIRE_ARRAY__ = "
			);
			source.replace(
				depBlock.arrayRange[1],
				depBlock.functionRange[0] - 1,
				"; ("
			);
			source.insert(
				depBlock.functionRange[1],
				").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);"
			);
			source.replace(
				depBlock.functionRange[1],
				depBlock.errorCallbackRange[0] - 1,
				errorRangeBlock
			);
			source.replace(
				depBlock.errorCallbackRange[1],
				depBlock.outerRange[1] - 1,
				endBlock
			);
			return;
		}

		// has array range, function range, but no errorCallbackRange
		if (depBlock.arrayRange && depBlock.functionRange) {
			const startBlock = `${promise}.then(function() { `;
			const endBlock = `}${
				depBlock.functionBindThis ? ".bind(this)" : ""
			}).catch(${runtime.onError()})`;
			source.replace(
				depBlock.outerRange[0],
				depBlock.arrayRange[0] - 1,
				startBlock
			);
			source.insert(
				depBlock.arrayRange[0] + 0.9,
				"var __WEBPACK_AMD_REQUIRE_ARRAY__ = "
			);
			source.replace(
				depBlock.arrayRange[1],
				depBlock.functionRange[0] - 1,
				"; ("
			);
			source.insert(
				depBlock.functionRange[1],
				").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);"
			);
			source.replace(
				depBlock.functionRange[1],
				depBlock.outerRange[1] - 1,
				endBlock
			);
		}
	}
};

module.exports = AMDRequireDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/AMDRequireItemDependency.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/dependencies/AMDRequireItemDependency.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const ModuleDependencyTemplateAsRequireId = __webpack_require__(/*! ./ModuleDependencyTemplateAsRequireId */ "./node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsRequireId.js");

class AMDRequireItemDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
	}

	get type() {
		return "amd require";
	}
}

AMDRequireItemDependency.Template = ModuleDependencyTemplateAsRequireId;

module.exports = AMDRequireItemDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/CommonJsPlugin.js":
/*!****************************************************!*\
  !*** (webpack)/lib/dependencies/CommonJsPlugin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ConstDependency = __webpack_require__(/*! ./ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");
const CommonJsRequireDependency = __webpack_require__(/*! ./CommonJsRequireDependency */ "./node_modules/webpack/lib/dependencies/CommonJsRequireDependency.js");
const CommonJsRequireContextDependency = __webpack_require__(/*! ./CommonJsRequireContextDependency */ "./node_modules/webpack/lib/dependencies/CommonJsRequireContextDependency.js");
const RequireResolveDependency = __webpack_require__(/*! ./RequireResolveDependency */ "./node_modules/webpack/lib/dependencies/RequireResolveDependency.js");
const RequireResolveContextDependency = __webpack_require__(/*! ./RequireResolveContextDependency */ "./node_modules/webpack/lib/dependencies/RequireResolveContextDependency.js");
const RequireResolveHeaderDependency = __webpack_require__(/*! ./RequireResolveHeaderDependency */ "./node_modules/webpack/lib/dependencies/RequireResolveHeaderDependency.js");
const RequireHeaderDependency = __webpack_require__(/*! ./RequireHeaderDependency */ "./node_modules/webpack/lib/dependencies/RequireHeaderDependency.js");

const NullFactory = __webpack_require__(/*! ../NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

const RequireResolveDependencyParserPlugin = __webpack_require__(/*! ./RequireResolveDependencyParserPlugin */ "./node_modules/webpack/lib/dependencies/RequireResolveDependencyParserPlugin.js");
const CommonJsRequireDependencyParserPlugin = __webpack_require__(/*! ./CommonJsRequireDependencyParserPlugin */ "./node_modules/webpack/lib/dependencies/CommonJsRequireDependencyParserPlugin.js");

const ParserHelpers = __webpack_require__(/*! ../ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");

class CommonJsPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"CommonJsPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					CommonJsRequireDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsRequireDependency,
					new CommonJsRequireDependency.Template()
				);

				compilation.dependencyFactories.set(
					CommonJsRequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsRequireContextDependency,
					new CommonJsRequireContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireResolveDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireResolveDependency,
					new RequireResolveDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireResolveContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireResolveContextDependency,
					new RequireResolveContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireResolveHeaderDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					RequireResolveHeaderDependency,
					new RequireResolveHeaderDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireHeaderDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					RequireHeaderDependency,
					new RequireHeaderDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.commonjs !== undefined && !parserOptions.commonjs)
						return;

					const requireExpressions = [
						"require",
						"require.resolve",
						"require.resolveWeak"
					];
					for (let expression of requireExpressions) {
						parser.hooks.typeof
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.toConstantDependency(
									parser,
									JSON.stringify("function")
								)
							);
						parser.hooks.evaluateTypeof
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.evaluateToString("function")
							);
						parser.hooks.evaluateIdentifier
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.evaluateToIdentifier(expression, true)
							);
					}

					parser.hooks.evaluateTypeof
						.for("module")
						.tap("CommonJsPlugin", ParserHelpers.evaluateToString("object"));
					parser.hooks.assign.for("require").tap("CommonJsPlugin", expr => {
						// to not leak to global "require", we need to define a local require here.
						const dep = new ConstDependency("var require;", 0);
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
						parser.scope.definitions.add("require");
						return true;
					});
					parser.hooks.canRename
						.for("require")
						.tap("CommonJsPlugin", () => true);
					parser.hooks.rename.for("require").tap("CommonJsPlugin", expr => {
						// define the require variable. It's still undefined, but not "not defined".
						const dep = new ConstDependency("var require;", 0);
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
						return false;
					});
					parser.hooks.typeof.for("module").tap("CommonJsPlugin", () => true);
					parser.hooks.evaluateTypeof
						.for("exports")
						.tap("CommonJsPlugin", ParserHelpers.evaluateToString("object"));

					new CommonJsRequireDependencyParserPlugin(options).apply(parser);
					new RequireResolveDependencyParserPlugin(options).apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("CommonJsPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("CommonJsPlugin", handler);
			}
		);
	}
}
module.exports = CommonJsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/CommonJsRequireContextDependency.js":
/*!**********************************************************************!*\
  !*** (webpack)/lib/dependencies/CommonJsRequireContextDependency.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ContextDependency = __webpack_require__(/*! ./ContextDependency */ "./node_modules/webpack/lib/dependencies/ContextDependency.js");
const ContextDependencyTemplateAsRequireCall = __webpack_require__(/*! ./ContextDependencyTemplateAsRequireCall */ "./node_modules/webpack/lib/dependencies/ContextDependencyTemplateAsRequireCall.js");

class CommonJsRequireContextDependency extends ContextDependency {
	constructor(options, range, valueRange) {
		super(options);
		this.range = range;
		this.valueRange = valueRange;
	}

	get type() {
		return "cjs require context";
	}
}

CommonJsRequireContextDependency.Template = ContextDependencyTemplateAsRequireCall;

module.exports = CommonJsRequireContextDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/CommonJsRequireDependency.js":
/*!***************************************************************!*\
  !*** (webpack)/lib/dependencies/CommonJsRequireDependency.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const ModuleDependencyTemplateAsId = __webpack_require__(/*! ./ModuleDependencyTemplateAsId */ "./node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsId.js");

class CommonJsRequireDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
	}

	get type() {
		return "cjs require";
	}
}

CommonJsRequireDependency.Template = ModuleDependencyTemplateAsId;

module.exports = CommonJsRequireDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/CommonJsRequireDependencyParserPlugin.js":
/*!***************************************************************************!*\
  !*** (webpack)/lib/dependencies/CommonJsRequireDependencyParserPlugin.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const CommonJsRequireDependency = __webpack_require__(/*! ./CommonJsRequireDependency */ "./node_modules/webpack/lib/dependencies/CommonJsRequireDependency.js");
const CommonJsRequireContextDependency = __webpack_require__(/*! ./CommonJsRequireContextDependency */ "./node_modules/webpack/lib/dependencies/CommonJsRequireContextDependency.js");
const RequireHeaderDependency = __webpack_require__(/*! ./RequireHeaderDependency */ "./node_modules/webpack/lib/dependencies/RequireHeaderDependency.js");
const LocalModuleDependency = __webpack_require__(/*! ./LocalModuleDependency */ "./node_modules/webpack/lib/dependencies/LocalModuleDependency.js");
const ContextDependencyHelpers = __webpack_require__(/*! ./ContextDependencyHelpers */ "./node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js");
const LocalModulesHelpers = __webpack_require__(/*! ./LocalModulesHelpers */ "./node_modules/webpack/lib/dependencies/LocalModulesHelpers.js");
const ParserHelpers = __webpack_require__(/*! ../ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");

class CommonJsRequireDependencyParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		const options = this.options;

		const processItem = (expr, param) => {
			if (param.isString()) {
				const dep = new CommonJsRequireDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		const processContext = (expr, param) => {
			const dep = ContextDependencyHelpers.create(
				CommonJsRequireContextDependency,
				expr.range,
				param,
				expr,
				options,
				{},
				parser
			);
			if (!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		};

		parser.hooks.expression
			.for("require.cache")
			.tap(
				"CommonJsRequireDependencyParserPlugin",
				ParserHelpers.toConstantDependencyWithWebpackRequire(
					parser,
					"__webpack_require__.c"
				)
			);
		parser.hooks.expression
			.for("require")
			.tap("CommonJsRequireDependencyParserPlugin", expr => {
				const dep = new CommonJsRequireContextDependency(
					{
						request: options.unknownContextRequest,
						recursive: options.unknownContextRecursive,
						regExp: options.unknownContextRegExp,
						mode: "sync"
					},
					expr.range
				);
				dep.critical =
					options.unknownContextCritical &&
					"require function is used in a way in which dependencies cannot be statically extracted";
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			});

		const createHandler = callNew => expr => {
			if (expr.arguments.length !== 1) return;
			let localModule;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
				let isExpression = false;
				const prevLength = parser.state.current.dependencies.length;
				const dep = new RequireHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				for (const p of param.options) {
					const result = processItem(expr, p);
					if (result === undefined) {
						isExpression = true;
					}
				}
				if (isExpression) {
					parser.state.current.dependencies.length = prevLength;
				} else {
					return true;
				}
			}
			if (
				param.isString() &&
				(localModule = LocalModulesHelpers.getLocalModule(
					parser.state,
					param.string
				))
			) {
				const dep = new LocalModuleDependency(localModule, expr.range, callNew);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			} else {
				const result = processItem(expr, param);
				if (result === undefined) {
					processContext(expr, param);
				} else {
					const dep = new RequireHeaderDependency(expr.callee.range);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
				}
				return true;
			}
		};
		parser.hooks.call
			.for("require")
			.tap("CommonJsRequireDependencyParserPlugin", createHandler(false));
		parser.hooks.new
			.for("require")
			.tap("CommonJsRequireDependencyParserPlugin", createHandler(true));
		parser.hooks.call
			.for("module.require")
			.tap("CommonJsRequireDependencyParserPlugin", createHandler(false));
		parser.hooks.new
			.for("module.require")
			.tap("CommonJsRequireDependencyParserPlugin", createHandler(true));
	}
}
module.exports = CommonJsRequireDependencyParserPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ConstDependency.js":
/*!*****************************************************!*\
  !*** (webpack)/lib/dependencies/ConstDependency.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class ConstDependency extends NullDependency {
	constructor(expression, range, requireWebpackRequire) {
		super();
		this.expression = expression;
		this.range = range;
		this.requireWebpackRequire = requireWebpackRequire;
	}

	updateHash(hash) {
		hash.update(this.range + "");
		hash.update(this.expression + "");
	}
}

ConstDependency.Template = class ConstDependencyTemplate {
	apply(dep, source) {
		if (typeof dep.range === "number") {
			source.insert(dep.range, dep.expression);
			return;
		}

		source.replace(dep.range[0], dep.range[1] - 1, dep.expression);
	}
};

module.exports = ConstDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ContextDependency.js":
/*!*******************************************************!*\
  !*** (webpack)/lib/dependencies/ContextDependency.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Dependency = __webpack_require__(/*! ../Dependency */ "./node_modules/webpack/lib/Dependency.js");
const CriticalDependencyWarning = __webpack_require__(/*! ./CriticalDependencyWarning */ "./node_modules/webpack/lib/dependencies/CriticalDependencyWarning.js");

const regExpToString = r => (r ? r + "" : "");

class ContextDependency extends Dependency {
	// options: { request, recursive, regExp, include, exclude, mode, chunkName, groupOptions }
	constructor(options) {
		super();
		this.options = options;
		this.userRequest = this.options.request;
		/** @type {false | string} */
		this.critical = false;
		this.hadGlobalOrStickyRegExp = false;
		if (this.options.regExp.global || this.options.regExp.sticky) {
			this.options.regExp = null;
			this.hadGlobalOrStickyRegExp = true;
		}
	}

	getResourceIdentifier() {
		return (
			`context${this.options.request} ${this.options.recursive} ` +
			`${regExpToString(this.options.regExp)} ${regExpToString(
				this.options.include
			)} ${regExpToString(this.options.exclude)} ` +
			`${this.options.mode} ${this.options.chunkName} ` +
			`${JSON.stringify(this.options.groupOptions)}`
		);
	}

	getWarnings() {
		let warnings = super.getWarnings() || [];
		if (this.critical) {
			warnings.push(new CriticalDependencyWarning(this.critical));
		}
		if (this.hadGlobalOrStickyRegExp) {
			warnings.push(
				new CriticalDependencyWarning(
					"Contexts can't use RegExps with the 'g' or 'y' flags."
				)
			);
		}
		return warnings;
	}
}

// TODO remove in webpack 5
Object.defineProperty(ContextDependency.prototype, "async", {
	configurable: false,
	get() {
		throw new Error(
			"ContextDependency.async was removed. Use ContextDependency.options.mode instead."
		);
	},
	set() {
		throw new Error(
			"ContextDependency.async was removed. Pass options.mode to constructor instead"
		);
	}
});

module.exports = ContextDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/dependencies/ContextDependencyHelpers.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ContextDependencyHelpers = exports;

/**
 * Escapes regular expression metacharacters
 * @param {string} str String to quote
 * @returns {string} Escaped string
 */
const quotemeta = str => {
	return str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
};

const splitContextFromPrefix = prefix => {
	const idx = prefix.lastIndexOf("/");
	let context = ".";
	if (idx >= 0) {
		context = prefix.substr(0, idx);
		prefix = `.${prefix.substr(idx)}`;
	}
	return {
		context,
		prefix
	};
};

const splitQueryFromPostfix = postfix => {
	const idx = postfix.indexOf("?");
	let query = "";
	if (idx >= 0) {
		query = postfix.substr(idx);
		postfix = postfix.substr(0, idx);
	}
	return {
		postfix,
		query
	};
};

ContextDependencyHelpers.create = (
	Dep,
	range,
	param,
	expr,
	options,
	contextOptions,
	// when parser is not passed in, expressions won't be walked
	parser = null
) => {
	if (param.isTemplateString()) {
		let prefixRaw = param.quasis[0].string;
		let postfixRaw =
			param.quasis.length > 1
				? param.quasis[param.quasis.length - 1].string
				: "";

		const valueRange = param.range;
		const { context, prefix } = splitContextFromPrefix(prefixRaw);
		const { postfix, query } = splitQueryFromPostfix(postfixRaw);

		// When there are more than two quasis, the generated RegExp can be more precise
		// We join the quasis with the expression regexp
		const innerQuasis = param.quasis.slice(1, param.quasis.length - 1);
		const innerRegExp =
			options.wrappedContextRegExp.source +
			innerQuasis
				.map(q => quotemeta(q.string) + options.wrappedContextRegExp.source)
				.join("");

		// Example: `./context/pre${e}inner${e}inner2${e}post?query`
		// context: "./context"
		// prefix: "./pre"
		// innerQuasis: [BEE("inner"), BEE("inner2")]
		// (BEE = BasicEvaluatedExpression)
		// postfix: "post"
		// query: "?query"
		// regExp: /^\.\/pre.*inner.*inner2.*post$/
		const regExp = new RegExp(
			`^${quotemeta(prefix)}${innerRegExp}${quotemeta(postfix)}$`
		);
		const dep = new Dep(
			Object.assign(
				{
					request: context + query,
					recursive: options.wrappedContextRecursive,
					regExp,
					mode: "sync"
				},
				contextOptions
			),
			range,
			valueRange
		);
		dep.loc = expr.loc;
		const replaces = [];

		param.parts.forEach((part, i) => {
			if (i % 2 === 0) {
				// Quasis or merged quasi
				let range = part.range;
				let value = part.string;
				if (param.templateStringKind === "cooked") {
					value = JSON.stringify(value);
					value = value.slice(1, value.length - 1);
				}
				if (i === 0) {
					// prefix
					value = prefix;
					range = [param.range[0], part.range[1]];
					value =
						(param.templateStringKind === "cooked" ? "`" : "String.raw`") +
						value;
				} else if (i === param.parts.length - 1) {
					// postfix
					value = postfix;
					range = [part.range[0], param.range[1]];
					value = value + "`";
				} else if (
					part.expression &&
					part.expression.type === "TemplateElement" &&
					part.expression.value.raw === value
				) {
					// Shortcut when it's a single quasi and doesn't need to be replaced
					return;
				}
				replaces.push({
					range,
					value
				});
			} else {
				// Expression
				if (parser) {
					parser.walkExpression(part.expression);
				}
			}
		});

		dep.replaces = replaces;
		dep.critical =
			options.wrappedContextCritical &&
			"a part of the request of a dependency is an expression";
		return dep;
	} else if (
		param.isWrapped() &&
		((param.prefix && param.prefix.isString()) ||
			(param.postfix && param.postfix.isString()))
	) {
		let prefixRaw =
			param.prefix && param.prefix.isString() ? param.prefix.string : "";
		let postfixRaw =
			param.postfix && param.postfix.isString() ? param.postfix.string : "";
		const prefixRange =
			param.prefix && param.prefix.isString() ? param.prefix.range : null;
		const postfixRange =
			param.postfix && param.postfix.isString() ? param.postfix.range : null;
		const valueRange = param.range;
		const { context, prefix } = splitContextFromPrefix(prefixRaw);
		const { postfix, query } = splitQueryFromPostfix(postfixRaw);
		const regExp = new RegExp(
			`^${quotemeta(prefix)}${options.wrappedContextRegExp.source}${quotemeta(
				postfix
			)}$`
		);
		const dep = new Dep(
			Object.assign(
				{
					request: context + query,
					recursive: options.wrappedContextRecursive,
					regExp,
					mode: "sync"
				},
				contextOptions
			),
			range,
			valueRange
		);
		dep.loc = expr.loc;
		const replaces = [];
		if (prefixRange) {
			replaces.push({
				range: prefixRange,
				value: JSON.stringify(prefix)
			});
		}
		if (postfixRange) {
			replaces.push({
				range: postfixRange,
				value: JSON.stringify(postfix)
			});
		}
		dep.replaces = replaces;
		dep.critical =
			options.wrappedContextCritical &&
			"a part of the request of a dependency is an expression";

		if (parser && param.wrappedInnerExpressions) {
			for (const part of param.wrappedInnerExpressions) {
				if (part.expression) parser.walkExpression(part.expression);
			}
		}

		return dep;
	} else {
		const dep = new Dep(
			Object.assign(
				{
					request: options.exprContextRequest,
					recursive: options.exprContextRecursive,
					regExp: options.exprContextRegExp,
					mode: "sync"
				},
				contextOptions
			),
			range,
			param.range
		);
		dep.loc = expr.loc;
		dep.critical =
			options.exprContextCritical &&
			"the request of a dependency is an expression";

		if (parser) {
			parser.walkExpression(param.expression);
		}

		return dep;
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ContextDependencyTemplateAsId.js":
/*!*******************************************************************!*\
  !*** (webpack)/lib/dependencies/ContextDependencyTemplateAsId.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class ContextDependencyTemplateAsId {
	apply(dep, source, runtime) {
		const moduleExports = runtime.moduleExports({
			module: dep.module,
			request: dep.request
		});

		if (dep.module) {
			if (dep.valueRange) {
				if (Array.isArray(dep.replaces)) {
					for (let i = 0; i < dep.replaces.length; i++) {
						const rep = dep.replaces[i];
						source.replace(rep.range[0], rep.range[1] - 1, rep.value);
					}
				}
				source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
				// TODO webpack 5 remove `prepend` it's no longer used
				source.replace(
					dep.range[0],
					dep.valueRange[0] - 1,
					`${moduleExports}.resolve(${
						typeof dep.prepend === "string" ? JSON.stringify(dep.prepend) : ""
					}`
				);
			} else {
				source.replace(
					dep.range[0],
					dep.range[1] - 1,
					`${moduleExports}.resolve`
				);
			}
		} else {
			source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
		}
	}
}
module.exports = ContextDependencyTemplateAsId;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ContextDependencyTemplateAsRequireCall.js":
/*!****************************************************************************!*\
  !*** (webpack)/lib/dependencies/ContextDependencyTemplateAsRequireCall.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class ContextDependencyTemplateAsRequireCall {
	apply(dep, source, runtime) {
		const moduleExports = runtime.moduleExports({
			module: dep.module,
			request: dep.request
		});

		if (dep.module) {
			if (dep.valueRange) {
				if (Array.isArray(dep.replaces)) {
					for (let i = 0; i < dep.replaces.length; i++) {
						const rep = dep.replaces[i];
						source.replace(rep.range[0], rep.range[1] - 1, rep.value);
					}
				}
				source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
				// TODO webpack 5 remove `prepend` it's no longer used
				source.replace(
					dep.range[0],
					dep.valueRange[0] - 1,
					`${moduleExports}(${
						typeof dep.prepend === "string" ? JSON.stringify(dep.prepend) : ""
					}`
				);
			} else {
				source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
			}
		} else {
			source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
		}
	}
}
module.exports = ContextDependencyTemplateAsRequireCall;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ContextElementDependency.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/dependencies/ContextElementDependency.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class ContextElementDependency extends ModuleDependency {
	constructor(request, userRequest) {
		super(request);
		if (userRequest) {
			this.userRequest = userRequest;
		}
	}

	get type() {
		return "context element";
	}
}

module.exports = ContextElementDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/CriticalDependencyWarning.js":
/*!***************************************************************!*\
  !*** (webpack)/lib/dependencies/CriticalDependencyWarning.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ../WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

class CriticalDependencyWarning extends WebpackError {
	constructor(message) {
		super();

		this.name = "CriticalDependencyWarning";
		this.message = "Critical dependency: " + message;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = CriticalDependencyWarning;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/DelegatedExportsDependency.js":
/*!****************************************************************!*\
  !*** (webpack)/lib/dependencies/DelegatedExportsDependency.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DependencyReference = __webpack_require__(/*! ./DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");
const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class DelegatedExportsDependency extends NullDependency {
	constructor(originModule, exports) {
		super();
		this.originModule = originModule;
		this.exports = exports;
	}

	get type() {
		return "delegated exports";
	}

	getReference() {
		return new DependencyReference(this.originModule, true, false);
	}

	getExports() {
		return {
			exports: this.exports,
			dependencies: undefined
		};
	}
}

module.exports = DelegatedExportsDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/DelegatedSourceDependency.js":
/*!***************************************************************!*\
  !*** (webpack)/lib/dependencies/DelegatedSourceDependency.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class DelegatedSourceDependency extends ModuleDependency {
	constructor(request) {
		super(request);
	}

	get type() {
		return "delegated source";
	}
}

module.exports = DelegatedSourceDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/DependencyReference.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/dependencies/DependencyReference.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Florent Cailhol @ooflorent
*/


/** @typedef {import("../Module")} Module */

class DependencyReference {
	// TODO webpack 5: module must be dynamic, you must pass a function returning a module
	// This is needed to remove the hack in ConcatenatedModule
	// The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting
	/**
	 *
	 * @param {Module} module the referenced module
	 * @param {string[] | boolean} importedNames imported named from the module
	 * @param {boolean=} weak if this is a weak reference
	 * @param {number} order the order information or NaN if don't care
	 */
	constructor(module, importedNames, weak = false, order = NaN) {
		// TODO webpack 5: make it a getter
		this.module = module;
		// true: full object
		// false: only sideeffects/no export
		// array of strings: the exports with this names
		this.importedNames = importedNames;
		this.weak = !!weak;
		this.order = order;
	}

	/**
	 * @param {DependencyReference[]} array an array (will be modified)
	 * @returns {DependencyReference[]} the array again
	 */
	static sort(array) {
		/** @type {WeakMap<DependencyReference, number>} */
		const originalOrder = new WeakMap();
		let i = 0;
		for (const ref of array) {
			originalOrder.set(ref, i++);
		}
		return array.sort((a, b) => {
			const aOrder = a.order;
			const bOrder = b.order;
			if (isNaN(aOrder)) {
				if (!isNaN(bOrder)) {
					return 1;
				}
			} else {
				if (isNaN(bOrder)) {
					return -1;
				}
				if (aOrder !== bOrder) {
					return aOrder - bOrder;
				}
			}
			const aOrg = originalOrder.get(a);
			const bOrg = originalOrder.get(b);
			return aOrg - bOrg;
		});
	}
}

module.exports = DependencyReference;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/DllEntryDependency.js":
/*!********************************************************!*\
  !*** (webpack)/lib/dependencies/DllEntryDependency.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Dependency = __webpack_require__(/*! ../Dependency */ "./node_modules/webpack/lib/Dependency.js");

class DllEntryDependency extends Dependency {
	constructor(dependencies, name) {
		super();
		this.dependencies = dependencies;
		this.name = name;
	}

	get type() {
		return "dll entry";
	}
}

module.exports = DllEntryDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyAcceptDependency.js":
/*!*************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyAcceptDependency.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");
const HarmonyImportDependency = __webpack_require__(/*! ./HarmonyImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportDependency.js");

class HarmonyAcceptDependency extends NullDependency {
	constructor(range, dependencies, hasCallback) {
		super();
		this.range = range;
		this.dependencies = dependencies;
		this.hasCallback = hasCallback;
	}

	get type() {
		return "accepted harmony modules";
	}
}

HarmonyAcceptDependency.Template = class HarmonyAcceptDependencyTemplate {
	apply(dep, source, runtime) {
		const content = dep.dependencies
			.filter(dependency =>
				HarmonyImportDependency.Template.isImportEmitted(dependency, source)
			)
			.map(dependency => dependency.getImportStatement(true, runtime))
			.join("");

		if (dep.hasCallback) {
			source.insert(
				dep.range[0],
				`function(__WEBPACK_OUTDATED_DEPENDENCIES__) { ${content}(`
			);
			source.insert(dep.range[1], ")(__WEBPACK_OUTDATED_DEPENDENCIES__); }");
			return;
		}

		source.insert(dep.range[1] - 0.5, `, function() { ${content} }`);
	}
};

module.exports = HarmonyAcceptDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyAcceptImportDependency.js":
/*!*******************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyAcceptImportDependency.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const HarmonyImportDependency = __webpack_require__(/*! ./HarmonyImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportDependency.js");

class HarmonyAcceptImportDependency extends HarmonyImportDependency {
	constructor(request, originModule, parserScope) {
		super(request, originModule, NaN, parserScope);
		this.weak = true;
	}

	get type() {
		return "harmony accept";
	}
}

HarmonyAcceptImportDependency.Template = class HarmonyAcceptImportDependencyTemplate extends HarmonyImportDependency.Template {
	apply(dep, source, runtime) {}
};

module.exports = HarmonyAcceptImportDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyCompatibilityDependency.js":
/*!********************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyCompatibilityDependency.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class HarmonyCompatibilityDependency extends NullDependency {
	constructor(originModule) {
		super();
		this.originModule = originModule;
	}

	get type() {
		return "harmony export header";
	}
}

HarmonyCompatibilityDependency.Template = class HarmonyExportDependencyTemplate {
	apply(dep, source, runtime) {
		const usedExports = dep.originModule.usedExports;
		if (usedExports !== false && !Array.isArray(usedExports)) {
			const content = runtime.defineEsModuleFlagStatement({
				exportsArgument: dep.originModule.exportsArgument
			});
			source.insert(-10, content);
		}
	}
};

module.exports = HarmonyCompatibilityDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyDetectionParserPlugin.js":
/*!******************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyDetectionParserPlugin.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const HarmonyCompatibilityDependency = __webpack_require__(/*! ./HarmonyCompatibilityDependency */ "./node_modules/webpack/lib/dependencies/HarmonyCompatibilityDependency.js");
const HarmonyInitDependency = __webpack_require__(/*! ./HarmonyInitDependency */ "./node_modules/webpack/lib/dependencies/HarmonyInitDependency.js");

module.exports = class HarmonyDetectionParserPlugin {
	apply(parser) {
		parser.hooks.program.tap("HarmonyDetectionParserPlugin", ast => {
			const isStrictHarmony = parser.state.module.type === "javascript/esm";
			const isHarmony =
				isStrictHarmony ||
				ast.body.some(
					statement =>
						statement.type === "ImportDeclaration" ||
						statement.type === "ExportDefaultDeclaration" ||
						statement.type === "ExportNamedDeclaration" ||
						statement.type === "ExportAllDeclaration"
				);
			if (isHarmony) {
				const module = parser.state.module;
				const compatDep = new HarmonyCompatibilityDependency(module);
				compatDep.loc = {
					start: {
						line: -1,
						column: 0
					},
					end: {
						line: -1,
						column: 0
					},
					index: -3
				};
				module.addDependency(compatDep);
				const initDep = new HarmonyInitDependency(module);
				initDep.loc = {
					start: {
						line: -1,
						column: 0
					},
					end: {
						line: -1,
						column: 0
					},
					index: -2
				};
				module.addDependency(initDep);
				parser.state.harmonyParserScope = parser.state.harmonyParserScope || {};
				parser.scope.isStrict = true;
				module.buildMeta.exportsType = "namespace";
				module.buildInfo.strict = true;
				module.buildInfo.exportsArgument = "__webpack_exports__";
				if (isStrictHarmony) {
					module.buildMeta.strictHarmonyModule = true;
					module.buildInfo.moduleArgument = "__webpack_module__";
				}
			}
		});

		const skipInHarmony = () => {
			const module = parser.state.module;
			if (module && module.buildMeta && module.buildMeta.exportsType) {
				return true;
			}
		};

		const nullInHarmony = () => {
			const module = parser.state.module;
			if (module && module.buildMeta && module.buildMeta.exportsType) {
				return null;
			}
		};

		const nonHarmonyIdentifiers = ["define", "exports"];
		for (const identifer of nonHarmonyIdentifiers) {
			parser.hooks.evaluateTypeof
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", nullInHarmony);
			parser.hooks.typeof
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", skipInHarmony);
			parser.hooks.evaluate
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", nullInHarmony);
			parser.hooks.expression
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", skipInHarmony);
			parser.hooks.call
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", skipInHarmony);
		}
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyExportDependencyParserPlugin.js":
/*!*************************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyExportDependencyParserPlugin.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const HarmonyExportExpressionDependency = __webpack_require__(/*! ./HarmonyExportExpressionDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportExpressionDependency.js");
const HarmonyImportSideEffectDependency = __webpack_require__(/*! ./HarmonyImportSideEffectDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSideEffectDependency.js");
const HarmonyExportHeaderDependency = __webpack_require__(/*! ./HarmonyExportHeaderDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportHeaderDependency.js");
const HarmonyExportSpecifierDependency = __webpack_require__(/*! ./HarmonyExportSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportSpecifierDependency.js");
const HarmonyExportImportedSpecifierDependency = __webpack_require__(/*! ./HarmonyExportImportedSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency.js");
const ConstDependency = __webpack_require__(/*! ./ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");

module.exports = class HarmonyExportDependencyParserPlugin {
	constructor(moduleOptions) {
		this.strictExportPresence = moduleOptions.strictExportPresence;
	}

	apply(parser) {
		parser.hooks.export.tap(
			"HarmonyExportDependencyParserPlugin",
			statement => {
				const dep = new HarmonyExportHeaderDependency(
					statement.declaration && statement.declaration.range,
					statement.range
				);
				dep.loc = Object.create(statement.loc);
				dep.loc.index = -1;
				parser.state.current.addDependency(dep);
				return true;
			}
		);
		parser.hooks.exportImport.tap(
			"HarmonyExportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency("", statement.range);
				clearDep.loc = Object.create(statement.loc);
				clearDep.loc.index = -1;
				parser.state.current.addDependency(clearDep);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.module,
					parser.state.lastHarmonyImportOrder,
					parser.state.harmonyParserScope
				);
				sideEffectDep.loc = Object.create(statement.loc);
				sideEffectDep.loc.index = -1;
				parser.state.current.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.exportExpression.tap(
			"HarmonyExportDependencyParserPlugin",
			(statement, expr) => {
				const comments = parser.getComments([
					statement.range[0],
					expr.range[0]
				]);
				const dep = new HarmonyExportExpressionDependency(
					parser.state.module,
					expr.range,
					statement.range,
					comments
						.map(c => {
							switch (c.type) {
								case "Block":
									return `/*${c.value}*/`;
								case "Line":
									return `//${c.value}\n`;
							}
							return "";
						})
						.join("")
				);
				dep.loc = Object.create(statement.loc);
				dep.loc.index = -1;
				parser.state.current.addDependency(dep);
				return true;
			}
		);
		parser.hooks.exportDeclaration.tap(
			"HarmonyExportDependencyParserPlugin",
			statement => {}
		);
		parser.hooks.exportSpecifier.tap(
			"HarmonyExportDependencyParserPlugin",
			(statement, id, name, idx) => {
				const rename = parser.scope.renames.get(id);
				let dep;
				const harmonyNamedExports = (parser.state.harmonyNamedExports =
					parser.state.harmonyNamedExports || new Set());
				harmonyNamedExports.add(name);
				if (rename === "imported var") {
					const settings = parser.state.harmonySpecifier.get(id);
					dep = new HarmonyExportImportedSpecifierDependency(
						settings.source,
						parser.state.module,
						settings.sourceOrder,
						parser.state.harmonyParserScope,
						settings.id,
						name,
						harmonyNamedExports,
						null,
						this.strictExportPresence
					);
				} else {
					dep = new HarmonyExportSpecifierDependency(
						parser.state.module,
						id,
						name
					);
				}
				dep.loc = Object.create(statement.loc);
				dep.loc.index = idx;
				parser.state.current.addDependency(dep);
				return true;
			}
		);
		parser.hooks.exportImportSpecifier.tap(
			"HarmonyExportDependencyParserPlugin",
			(statement, source, id, name, idx) => {
				const harmonyNamedExports = (parser.state.harmonyNamedExports =
					parser.state.harmonyNamedExports || new Set());
				let harmonyStarExports = null;
				if (name) {
					harmonyNamedExports.add(name);
				} else {
					harmonyStarExports = parser.state.harmonyStarExports =
						parser.state.harmonyStarExports || [];
				}
				const dep = new HarmonyExportImportedSpecifierDependency(
					source,
					parser.state.module,
					parser.state.lastHarmonyImportOrder,
					parser.state.harmonyParserScope,
					id,
					name,
					harmonyNamedExports,
					harmonyStarExports && harmonyStarExports.slice(),
					this.strictExportPresence
				);
				if (harmonyStarExports) {
					harmonyStarExports.push(dep);
				}
				dep.loc = Object.create(statement.loc);
				dep.loc.index = idx;
				parser.state.current.addDependency(dep);
				return true;
			}
		);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyExportExpressionDependency.js":
/*!***********************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyExportExpressionDependency.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class HarmonyExportExpressionDependency extends NullDependency {
	constructor(originModule, range, rangeStatement, prefix) {
		super();
		this.originModule = originModule;
		this.range = range;
		this.rangeStatement = rangeStatement;
		this.prefix = prefix;
	}

	get type() {
		return "harmony export expression";
	}

	getExports() {
		return {
			exports: ["default"],
			dependencies: undefined
		};
	}
}

HarmonyExportExpressionDependency.Template = class HarmonyExportDependencyTemplate {
	apply(dep, source) {
		const used = dep.originModule.isUsed("default");
		const content = this.getContent(dep.originModule, used);

		if (dep.range) {
			source.replace(
				dep.rangeStatement[0],
				dep.range[0] - 1,
				content + "(" + dep.prefix
			);
			source.replace(dep.range[1], dep.rangeStatement[1] - 1, ");");
			return;
		}

		source.replace(dep.rangeStatement[0], dep.rangeStatement[1] - 1, content);
	}

	getContent(module, used) {
		const exportsName = module.exportsArgument;
		if (used) {
			return `/* harmony default export */ ${exportsName}[${JSON.stringify(
				used
			)}] = `;
		}
		return "/* unused harmony default export */ var _unused_webpack_default_export = ";
	}
};

module.exports = HarmonyExportExpressionDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyExportHeaderDependency.js":
/*!*******************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyExportHeaderDependency.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class HarmonyExportHeaderDependency extends NullDependency {
	constructor(range, rangeStatement) {
		super();
		this.range = range;
		this.rangeStatement = rangeStatement;
	}

	get type() {
		return "harmony export header";
	}
}

HarmonyExportHeaderDependency.Template = class HarmonyExportDependencyTemplate {
	apply(dep, source) {
		const content = "";
		const replaceUntil = dep.range
			? dep.range[0] - 1
			: dep.rangeStatement[1] - 1;
		source.replace(dep.rangeStatement[0], replaceUntil, content);
	}
};

module.exports = HarmonyExportHeaderDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency.js":
/*!******************************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyExportImportedSpecifierDependency.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DependencyReference = __webpack_require__(/*! ./DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");
const HarmonyImportDependency = __webpack_require__(/*! ./HarmonyImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportDependency.js");
const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");
const HarmonyLinkingError = __webpack_require__(/*! ../HarmonyLinkingError */ "./node_modules/webpack/lib/HarmonyLinkingError.js");

/** @typedef {import("../Module")} Module */

/** @typedef {"missing"|"unused"|"empty-star"|"reexport-non-harmony-default"|"reexport-named-default"|"reexport-namespace-object"|"reexport-non-harmony-default-strict"|"reexport-fake-namespace-object"|"rexport-non-harmony-undefined"|"safe-reexport"|"checked-reexport"|"dynamic-reexport"} ExportModeType */

/** @type {Map<string, string>} */
const EMPTY_MAP = new Map();

class ExportMode {
	/**
	 * @param {ExportModeType} type type of the mode
	 */
	constructor(type) {
		/** @type {ExportModeType} */
		this.type = type;
		/** @type {string|null} */
		this.name = null;
		/** @type {Map<string, string>} */
		this.map = EMPTY_MAP;
		/** @type {Module|null} */
		this.module = null;
		/** @type {string|null} */
		this.userRequest = null;
	}
}

const EMPTY_STAR_MODE = new ExportMode("empty-star");

class HarmonyExportImportedSpecifierDependency extends HarmonyImportDependency {
	constructor(
		request,
		originModule,
		sourceOrder,
		parserScope,
		id,
		name,
		activeExports,
		otherStarExports,
		strictExportPresence
	) {
		super(request, originModule, sourceOrder, parserScope);
		this.id = id;
		this.name = name;
		this.activeExports = activeExports;
		this.otherStarExports = otherStarExports;
		this.strictExportPresence = strictExportPresence;
	}

	get type() {
		return "harmony export imported specifier";
	}

	getMode(ignoreUnused) {
		const name = this.name;
		const id = this.id;
		const used = this.originModule.isUsed(name);
		const importedModule = this._module;

		if (!importedModule) {
			const mode = new ExportMode("missing");
			mode.userRequest = this.userRequest;
			return mode;
		}

		if (
			!ignoreUnused &&
			(name ? !used : this.originModule.usedExports === false)
		) {
			const mode = new ExportMode("unused");
			mode.name = name || "*";
			return mode;
		}

		const strictHarmonyModule = this.originModule.buildMeta.strictHarmonyModule;
		if (name && id === "default" && importedModule.buildMeta) {
			if (!importedModule.buildMeta.exportsType) {
				const mode = new ExportMode(
					strictHarmonyModule
						? "reexport-non-harmony-default-strict"
						: "reexport-non-harmony-default"
				);
				mode.name = name;
				mode.module = importedModule;
				return mode;
			} else if (importedModule.buildMeta.exportsType === "named") {
				const mode = new ExportMode("reexport-named-default");
				mode.name = name;
				mode.module = importedModule;
				return mode;
			}
		}

		const isNotAHarmonyModule =
			importedModule.buildMeta && !importedModule.buildMeta.exportsType;
		if (name) {
			let mode;
			if (id) {
				// export { name as name }
				if (isNotAHarmonyModule && strictHarmonyModule) {
					mode = new ExportMode("rexport-non-harmony-undefined");
					mode.name = name;
				} else {
					mode = new ExportMode("safe-reexport");
					mode.map = new Map([[name, id]]);
				}
			} else {
				// export { * as name }
				if (isNotAHarmonyModule && strictHarmonyModule) {
					mode = new ExportMode("reexport-fake-namespace-object");
					mode.name = name;
				} else {
					mode = new ExportMode("reexport-namespace-object");
					mode.name = name;
				}
			}
			mode.module = importedModule;
			return mode;
		}

		const hasUsedExports = Array.isArray(this.originModule.usedExports);
		const hasProvidedExports = Array.isArray(
			importedModule.buildMeta.providedExports
		);
		const activeFromOtherStarExports = this._discoverActiveExportsFromOtherStartExports();

		// export *
		if (hasUsedExports) {
			// reexport * with known used exports
			if (hasProvidedExports) {
				const map = new Map(
					this.originModule.usedExports
						.filter(id => {
							if (id === "default") return false;
							if (this.activeExports.has(id)) return false;
							if (activeFromOtherStarExports.has(id)) return false;
							if (!importedModule.buildMeta.providedExports.includes(id))
								return false;
							return true;
						})
						.map(item => [item, item])
				);

				if (map.size === 0) {
					return EMPTY_STAR_MODE;
				}

				const mode = new ExportMode("safe-reexport");
				mode.module = importedModule;
				mode.map = map;
				return mode;
			}

			const map = new Map(
				this.originModule.usedExports
					.filter(id => {
						if (id === "default") return false;
						if (this.activeExports.has(id)) return false;
						if (activeFromOtherStarExports.has(id)) return false;

						return true;
					})
					.map(item => [item, item])
			);

			if (map.size === 0) {
				return EMPTY_STAR_MODE;
			}

			const mode = new ExportMode("checked-reexport");
			mode.module = importedModule;
			mode.map = map;
			return mode;
		}

		if (hasProvidedExports) {
			const map = new Map(
				importedModule.buildMeta.providedExports
					.filter(id => {
						if (id === "default") return false;
						if (this.activeExports.has(id)) return false;
						if (activeFromOtherStarExports.has(id)) return false;

						return true;
					})
					.map(item => [item, item])
			);

			if (map.size === 0) {
				return EMPTY_STAR_MODE;
			}

			const mode = new ExportMode("safe-reexport");
			mode.module = importedModule;
			mode.map = map;
			return mode;
		}

		const mode = new ExportMode("dynamic-reexport");
		mode.module = importedModule;
		return mode;
	}

	getReference() {
		const mode = this.getMode(false);

		switch (mode.type) {
			case "missing":
			case "unused":
			case "empty-star":
				return null;

			case "reexport-non-harmony-default":
			case "reexport-named-default":
				return new DependencyReference(
					mode.module,
					["default"],
					false,
					this.sourceOrder
				);

			case "reexport-namespace-object":
			case "reexport-non-harmony-default-strict":
			case "reexport-fake-namespace-object":
			case "rexport-non-harmony-undefined":
				return new DependencyReference(
					mode.module,
					true,
					false,
					this.sourceOrder
				);

			case "safe-reexport":
			case "checked-reexport":
				return new DependencyReference(
					mode.module,
					Array.from(mode.map.values()),
					false,
					this.sourceOrder
				);

			case "dynamic-reexport":
				return new DependencyReference(
					mode.module,
					true,
					false,
					this.sourceOrder
				);

			default:
				throw new Error(`Unknown mode ${mode.type}`);
		}
	}

	_discoverActiveExportsFromOtherStartExports() {
		if (!this.otherStarExports) return new Set();
		const result = new Set();
		// try to learn impossible exports from other star exports with provided exports
		for (const otherStarExport of this.otherStarExports) {
			const otherImportedModule = otherStarExport._module;
			if (
				otherImportedModule &&
				Array.isArray(otherImportedModule.buildMeta.providedExports)
			) {
				for (const exportName of otherImportedModule.buildMeta
					.providedExports) {
					result.add(exportName);
				}
			}
		}
		return result;
	}

	getExports() {
		if (this.name) {
			return {
				exports: [this.name],
				dependencies: undefined
			};
		}

		const importedModule = this.module;

		if (!importedModule) {
			// no imported module available
			return {
				exports: null,
				dependencies: undefined
			};
		}

		if (Array.isArray(importedModule.buildMeta.providedExports)) {
			return {
				exports: importedModule.buildMeta.providedExports.filter(
					id => id !== "default"
				),
				dependencies: [importedModule]
			};
		}

		if (importedModule.buildMeta.providedExports) {
			return {
				exports: true,
				dependencies: undefined
			};
		}

		return {
			exports: null,
			dependencies: [importedModule]
		};
	}

	getWarnings() {
		if (
			this.strictExportPresence ||
			this.originModule.buildMeta.strictHarmonyModule
		) {
			return [];
		}
		return this._getErrors();
	}

	getErrors() {
		if (
			this.strictExportPresence ||
			this.originModule.buildMeta.strictHarmonyModule
		) {
			return this._getErrors();
		}
		return [];
	}

	_getErrors() {
		const importedModule = this._module;
		if (!importedModule) {
			return;
		}

		if (!importedModule.buildMeta || !importedModule.buildMeta.exportsType) {
			// It's not an harmony module
			if (
				this.originModule.buildMeta.strictHarmonyModule &&
				this.id !== "default"
			) {
				// In strict harmony modules we only support the default export
				const exportName = this.id
					? `the named export '${this.id}'`
					: "the namespace object";
				return [
					new HarmonyLinkingError(
						`Can't reexport ${exportName} from non EcmaScript module (only default export is available)`
					)
				];
			}
			return;
		}

		if (!this.id) {
			return;
		}

		if (importedModule.isProvided(this.id) !== false) {
			// It's provided or we are not sure
			return;
		}

		// We are sure that it's not provided
		const idIsNotNameMessage =
			this.id !== this.name ? ` (reexported as '${this.name}')` : "";
		const errorMessage = `"export '${
			this.id
		}'${idIsNotNameMessage} was not found in '${this.userRequest}'`;
		return [new HarmonyLinkingError(errorMessage)];
	}

	updateHash(hash) {
		super.updateHash(hash);
		const hashValue = this.getHashValue(this._module);
		hash.update(hashValue);
	}

	getHashValue(importedModule) {
		if (!importedModule) {
			return "";
		}

		const stringifiedUsedExport = JSON.stringify(importedModule.usedExports);
		const stringifiedProvidedExport = JSON.stringify(
			importedModule.buildMeta.providedExports
		);
		return (
			importedModule.used + stringifiedUsedExport + stringifiedProvidedExport
		);
	}
}

module.exports = HarmonyExportImportedSpecifierDependency;

HarmonyExportImportedSpecifierDependency.Template = class HarmonyExportImportedSpecifierDependencyTemplate extends HarmonyImportDependency.Template {
	harmonyInit(dep, source, runtime, dependencyTemplates) {
		super.harmonyInit(dep, source, runtime, dependencyTemplates);
		const content = this.getContent(dep);
		source.insert(-1, content);
	}

	getHarmonyInitOrder(dep) {
		if (dep.name) {
			const used = dep.originModule.isUsed(dep.name);
			if (!used) return NaN;
		} else {
			const importedModule = dep._module;

			const activeFromOtherStarExports = dep._discoverActiveExportsFromOtherStartExports();

			if (Array.isArray(dep.originModule.usedExports)) {
				// we know which exports are used

				const unused = dep.originModule.usedExports.every(id => {
					if (id === "default") return true;
					if (dep.activeExports.has(id)) return true;
					if (importedModule.isProvided(id) === false) return true;
					if (activeFromOtherStarExports.has(id)) return true;
					return false;
				});
				if (unused) return NaN;
			} else if (
				dep.originModule.usedExports &&
				importedModule &&
				Array.isArray(importedModule.buildMeta.providedExports)
			) {
				// not sure which exports are used, but we know which are provided

				const unused = importedModule.buildMeta.providedExports.every(id => {
					if (id === "default") return true;
					if (dep.activeExports.has(id)) return true;
					if (activeFromOtherStarExports.has(id)) return true;
					return false;
				});
				if (unused) return NaN;
			}
		}
		return super.getHarmonyInitOrder(dep);
	}

	getContent(dep) {
		const mode = dep.getMode(false);
		const module = dep.originModule;
		const importedModule = dep._module;
		const importVar = dep.getImportVar();

		switch (mode.type) {
			case "missing":
				return `throw new Error(${JSON.stringify(
					`Cannot find module '${mode.userRequest}'`
				)});\n`;

			case "unused":
				return `${Template.toNormalComment(
					`unused harmony reexport ${mode.name}`
				)}\n`;

			case "reexport-non-harmony-default":
				return (
					"/* harmony reexport (default from non-harmony) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						importVar,
						null
					)
				);

			case "reexport-named-default":
				return (
					"/* harmony reexport (default from named exports) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						importVar,
						""
					)
				);

			case "reexport-fake-namespace-object":
				return (
					"/* harmony reexport (fake namespace object from non-harmony) */ " +
					this.getReexportFakeNamespaceObjectStatement(
						module,
						module.isUsed(mode.name),
						importVar
					)
				);

			case "rexport-non-harmony-undefined":
				return (
					"/* harmony reexport (non default export from non-harmony) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						"undefined",
						""
					)
				);

			case "reexport-non-harmony-default-strict":
				return (
					"/* harmony reexport (default from non-harmony) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						importVar,
						""
					)
				);

			case "reexport-namespace-object":
				return (
					"/* harmony reexport (module object) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						importVar,
						""
					)
				);

			case "empty-star":
				return "/* empty/unused harmony star reexport */";

			case "safe-reexport":
				return Array.from(mode.map.entries())
					.map(item => {
						return (
							"/* harmony reexport (safe) */ " +
							this.getReexportStatement(
								module,
								module.isUsed(item[0]),
								importVar,
								importedModule.isUsed(item[1])
							) +
							"\n"
						);
					})
					.join("");

			case "checked-reexport":
				return Array.from(mode.map.entries())
					.map(item => {
						return (
							"/* harmony reexport (checked) */ " +
							this.getConditionalReexportStatement(
								module,
								item[0],
								importVar,
								item[1]
							) +
							"\n"
						);
					})
					.join("");

			case "dynamic-reexport": {
				const activeExports = new Set([
					...dep.activeExports,
					...dep._discoverActiveExportsFromOtherStartExports()
				]);
				let content =
					"/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in " +
					importVar +
					") ";

				// Filter out exports which are defined by other exports
				// and filter out default export because it cannot be reexported with *
				if (activeExports.size > 0) {
					content +=
						"if(" +
						JSON.stringify(Array.from(activeExports).concat("default")) +
						".indexOf(__WEBPACK_IMPORT_KEY__) < 0) ";
				} else {
					content += "if(__WEBPACK_IMPORT_KEY__ !== 'default') ";
				}
				const exportsName = dep.originModule.exportsArgument;
				return (
					content +
					`(function(key) { __webpack_require__.d(${exportsName}, key, function() { return ${importVar}[key]; }) }(__WEBPACK_IMPORT_KEY__));\n`
				);
			}

			default:
				throw new Error(`Unknown mode ${mode.type}`);
		}
	}

	getReexportStatement(module, key, name, valueKey) {
		const exportsName = module.exportsArgument;
		const returnValue = this.getReturnValue(name, valueKey);
		return `__webpack_require__.d(${exportsName}, ${JSON.stringify(
			key
		)}, function() { return ${returnValue}; });\n`;
	}

	getReexportFakeNamespaceObjectStatement(module, key, name) {
		const exportsName = module.exportsArgument;
		return `__webpack_require__.d(${exportsName}, ${JSON.stringify(
			key
		)}, function() { return __webpack_require__.t(${name}); });\n`;
	}

	getConditionalReexportStatement(module, key, name, valueKey) {
		if (valueKey === false) {
			return "/* unused export */\n";
		}
		const exportsName = module.exportsArgument;
		const returnValue = this.getReturnValue(name, valueKey);
		return `if(__webpack_require__.o(${name}, ${JSON.stringify(
			valueKey
		)})) __webpack_require__.d(${exportsName}, ${JSON.stringify(
			key
		)}, function() { return ${returnValue}; });\n`;
	}

	getReturnValue(name, valueKey) {
		if (valueKey === null) {
			return `${name}_default.a`;
		}
		if (valueKey === "") {
			return name;
		}
		if (valueKey === false) {
			return "/* unused export */ undefined";
		}

		return `${name}[${JSON.stringify(valueKey)}]`;
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyExportSpecifierDependency.js":
/*!**********************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyExportSpecifierDependency.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class HarmonyExportSpecifierDependency extends NullDependency {
	constructor(originModule, id, name) {
		super();
		this.originModule = originModule;
		this.id = id;
		this.name = name;
	}

	get type() {
		return "harmony export specifier";
	}

	getExports() {
		return {
			exports: [this.name],
			dependencies: undefined
		};
	}
}

HarmonyExportSpecifierDependency.Template = class HarmonyExportSpecifierDependencyTemplate {
	apply(dep, source) {}

	getHarmonyInitOrder(dep) {
		return 0;
	}

	harmonyInit(dep, source, runtime) {
		const content = this.getContent(dep);
		source.insert(-1, content);
	}

	getContent(dep) {
		const used = dep.originModule.isUsed(dep.name);
		if (!used) {
			return `/* unused harmony export ${dep.name || "namespace"} */\n`;
		}

		const exportsName = dep.originModule.exportsArgument;

		return `/* harmony export (binding) */ __webpack_require__.d(${exportsName}, ${JSON.stringify(
			used
		)}, function() { return ${dep.id}; });\n`;
	}
};

module.exports = HarmonyExportSpecifierDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyImportDependency.js":
/*!*************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyImportDependency.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DependencyReference = __webpack_require__(/*! ./DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");
const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");

class HarmonyImportDependency extends ModuleDependency {
	constructor(request, originModule, sourceOrder, parserScope) {
		super(request);
		this.redirectedModule = undefined;
		this.originModule = originModule;
		this.sourceOrder = sourceOrder;
		this.parserScope = parserScope;
	}

	get _module() {
		return this.redirectedModule || this.module;
	}

	getReference() {
		if (!this._module) return null;
		return new DependencyReference(
			this._module,
			false,
			this.weak,
			this.sourceOrder
		);
	}

	getImportVar() {
		let importVarMap = this.parserScope.importVarMap;
		if (!importVarMap) this.parserScope.importVarMap = importVarMap = new Map();
		let importVar = importVarMap.get(this._module);
		if (importVar) return importVar;
		importVar = `${Template.toIdentifier(
			`${this.userRequest}`
		)}__WEBPACK_IMPORTED_MODULE_${importVarMap.size}__`;
		importVarMap.set(this._module, importVar);
		return importVar;
	}

	getImportStatement(update, runtime) {
		return runtime.importStatement({
			update,
			module: this._module,
			importVar: this.getImportVar(),
			request: this.request,
			originModule: this.originModule
		});
	}

	updateHash(hash) {
		super.updateHash(hash);
		const importedModule = this._module;
		hash.update(
			(importedModule &&
				(!importedModule.buildMeta || importedModule.buildMeta.exportsType)) +
				""
		);
		hash.update((importedModule && importedModule.id) + "");
	}

	disconnect() {
		super.disconnect();
		this.redirectedModule = undefined;
	}
}

module.exports = HarmonyImportDependency;

const importEmittedMap = new WeakMap();

HarmonyImportDependency.Template = class HarmonyImportDependencyTemplate {
	apply(dep, source, runtime) {
		// no-op
	}

	getHarmonyInitOrder(dep) {
		return dep.sourceOrder;
	}

	static isImportEmitted(dep, source) {
		let sourceInfo = importEmittedMap.get(source);
		if (!sourceInfo) return false;
		const key = dep._module || dep.request;
		return key && sourceInfo.emittedImports.get(key);
	}

	harmonyInit(dep, source, runtime, dependencyTemplates) {
		let sourceInfo = importEmittedMap.get(source);
		if (!sourceInfo) {
			importEmittedMap.set(
				source,
				(sourceInfo = {
					emittedImports: new Map()
				})
			);
		}
		const key = dep._module || dep.request;
		if (key && sourceInfo.emittedImports.get(key)) return;
		sourceInfo.emittedImports.set(key, true);
		const content = dep.getImportStatement(false, runtime);
		source.insert(-1, content);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyImportDependencyParserPlugin.js":
/*!*************************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyImportDependencyParserPlugin.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { SyncBailHook } = __webpack_require__(/*! tapable */ "tapable");
const HarmonyImportSideEffectDependency = __webpack_require__(/*! ./HarmonyImportSideEffectDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSideEffectDependency.js");
const HarmonyImportSpecifierDependency = __webpack_require__(/*! ./HarmonyImportSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSpecifierDependency.js");
const HarmonyAcceptImportDependency = __webpack_require__(/*! ./HarmonyAcceptImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyAcceptImportDependency.js");
const HarmonyAcceptDependency = __webpack_require__(/*! ./HarmonyAcceptDependency */ "./node_modules/webpack/lib/dependencies/HarmonyAcceptDependency.js");
const ConstDependency = __webpack_require__(/*! ./ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");

module.exports = class HarmonyImportDependencyParserPlugin {
	constructor(moduleOptions) {
		this.strictExportPresence = moduleOptions.strictExportPresence;
		this.strictThisContextOnImports = moduleOptions.strictThisContextOnImports;
	}

	apply(parser) {
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency("", statement.range);
				clearDep.loc = statement.loc;
				parser.state.module.addDependency(clearDep);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.module,
					parser.state.lastHarmonyImportOrder,
					parser.state.harmonyParserScope
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				parser.scope.definitions.delete(name);
				parser.scope.renames.set(name, "imported var");
				if (!parser.state.harmonySpecifier) {
					parser.state.harmonySpecifier = new Map();
				}
				parser.state.harmonySpecifier.set(name, {
					source,
					id,
					sourceOrder: parser.state.lastHarmonyImportOrder
				});
				return true;
			}
		);
		parser.hooks.expression
			.for("imported var")
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const name = expr.name;
				const settings = parser.state.harmonySpecifier.get(name);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					parser.state.module,
					settings.sourceOrder,
					parser.state.harmonyParserScope,
					settings.id,
					name,
					expr.range,
					this.strictExportPresence
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				return true;
			});
		parser.hooks.expressionAnyMember
			.for("imported var")
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const name = expr.object.name;
				const settings = parser.state.harmonySpecifier.get(name);
				if (settings.id !== null) return false;
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					parser.state.module,
					settings.sourceOrder,
					parser.state.harmonyParserScope,
					expr.property.name || expr.property.value,
					name,
					expr.range,
					this.strictExportPresence
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = false;
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				return true;
			});
		if (this.strictThisContextOnImports) {
			// only in case when we strictly follow the spec we need a special case here
			parser.hooks.callAnyMember
				.for("imported var")
				.tap("HarmonyImportDependencyParserPlugin", expr => {
					if (expr.callee.type !== "MemberExpression") return;
					if (expr.callee.object.type !== "Identifier") return;
					const name = expr.callee.object.name;
					const settings = parser.state.harmonySpecifier.get(name);
					if (settings.id !== null) return false;
					const dep = new HarmonyImportSpecifierDependency(
						settings.source,
						parser.state.module,
						settings.sourceOrder,
						parser.state.harmonyParserScope,
						expr.callee.property.name || expr.callee.property.value,
						name,
						expr.callee.range,
						this.strictExportPresence
					);
					dep.shorthand = parser.scope.inShorthand;
					dep.directImport = false;
					dep.namespaceObjectAsContext = true;
					dep.loc = expr.callee.loc;
					parser.state.module.addDependency(dep);
					if (expr.arguments) parser.walkExpressions(expr.arguments);
					return true;
				});
		}
		parser.hooks.call
			.for("imported var")
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const args = expr.arguments;
				const fullExpr = expr;
				expr = expr.callee;
				if (expr.type !== "Identifier") return;
				const name = expr.name;
				const settings = parser.state.harmonySpecifier.get(name);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					parser.state.module,
					settings.sourceOrder,
					parser.state.harmonyParserScope,
					settings.id,
					name,
					expr.range,
					this.strictExportPresence
				);
				dep.directImport = true;
				dep.callArgs = args;
				dep.call = fullExpr;
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				if (args) parser.walkExpressions(args);
				return true;
			});
		// TODO webpack 5: refactor this, no custom hooks
		if (!parser.hooks.hotAcceptCallback) {
			parser.hooks.hotAcceptCallback = new SyncBailHook([
				"expression",
				"requests"
			]);
		}
		if (!parser.hooks.hotAcceptWithoutCallback) {
			parser.hooks.hotAcceptWithoutCallback = new SyncBailHook([
				"expression",
				"requests"
			]);
		}
		parser.hooks.hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
			(expr, requests) => {
				const harmonyParserScope = parser.state.harmonyParserScope;
				if (!harmonyParserScope) {
					// This is not a harmony module, skip it
					return;
				}
				const dependencies = requests.map(request => {
					const dep = new HarmonyAcceptImportDependency(
						request,
						parser.state.module,
						harmonyParserScope
					);
					dep.loc = expr.loc;
					parser.state.module.addDependency(dep);
					return dep;
				});
				if (dependencies.length > 0) {
					const dep = new HarmonyAcceptDependency(
						expr.range,
						dependencies,
						true
					);
					dep.loc = expr.loc;
					parser.state.module.addDependency(dep);
				}
			}
		);
		parser.hooks.hotAcceptWithoutCallback.tap(
			"HarmonyImportDependencyParserPlugin",
			(expr, requests) => {
				const dependencies = requests.map(request => {
					const dep = new HarmonyAcceptImportDependency(
						request,
						parser.state.module,
						parser.state.harmonyParserScope
					);
					dep.loc = expr.loc;
					parser.state.module.addDependency(dep);
					return dep;
				});
				if (dependencies.length > 0) {
					const dep = new HarmonyAcceptDependency(
						expr.range,
						dependencies,
						false
					);
					dep.loc = expr.loc;
					parser.state.module.addDependency(dep);
				}
			}
		);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyImportSideEffectDependency.js":
/*!***********************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyImportSideEffectDependency.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const HarmonyImportDependency = __webpack_require__(/*! ./HarmonyImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportDependency.js");

class HarmonyImportSideEffectDependency extends HarmonyImportDependency {
	constructor(request, originModule, sourceOrder, parserScope) {
		super(request, originModule, sourceOrder, parserScope);
	}

	getReference() {
		if (this._module && this._module.factoryMeta.sideEffectFree) return null;

		return super.getReference();
	}

	get type() {
		return "harmony side effect evaluation";
	}
}

HarmonyImportSideEffectDependency.Template = class HarmonyImportSideEffectDependencyTemplate extends HarmonyImportDependency.Template {
	getHarmonyInitOrder(dep) {
		if (dep._module && dep._module.factoryMeta.sideEffectFree) return NaN;
		return super.getHarmonyInitOrder(dep);
	}
};

module.exports = HarmonyImportSideEffectDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyImportSpecifierDependency.js":
/*!**********************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyImportSpecifierDependency.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DependencyReference = __webpack_require__(/*! ./DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");
const HarmonyImportDependency = __webpack_require__(/*! ./HarmonyImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportDependency.js");
const HarmonyLinkingError = __webpack_require__(/*! ../HarmonyLinkingError */ "./node_modules/webpack/lib/HarmonyLinkingError.js");

class HarmonyImportSpecifierDependency extends HarmonyImportDependency {
	constructor(
		request,
		originModule,
		sourceOrder,
		parserScope,
		id,
		name,
		range,
		strictExportPresence
	) {
		super(request, originModule, sourceOrder, parserScope);
		this.id = id === null ? null : `${id}`;
		this.redirectedId = undefined;
		this.name = name;
		this.range = range;
		this.strictExportPresence = strictExportPresence;
		this.namespaceObjectAsContext = false;
		this.callArgs = undefined;
		this.call = undefined;
		this.directImport = undefined;
		this.shorthand = undefined;
	}

	get type() {
		return "harmony import specifier";
	}

	get _id() {
		return this.redirectedId || this.id;
	}

	getReference() {
		if (!this._module) return null;
		return new DependencyReference(
			this._module,
			this._id && !this.namespaceObjectAsContext ? [this._id] : true,
			false,
			this.sourceOrder
		);
	}

	getWarnings() {
		if (
			this.strictExportPresence ||
			this.originModule.buildMeta.strictHarmonyModule
		) {
			return [];
		}
		return this._getErrors();
	}

	getErrors() {
		if (
			this.strictExportPresence ||
			this.originModule.buildMeta.strictHarmonyModule
		) {
			return this._getErrors();
		}
		return [];
	}

	_getErrors() {
		const importedModule = this._module;
		if (!importedModule) {
			return;
		}

		if (!importedModule.buildMeta || !importedModule.buildMeta.exportsType) {
			// It's not an harmony module
			if (
				this.originModule.buildMeta.strictHarmonyModule &&
				this._id !== "default"
			) {
				// In strict harmony modules we only support the default export
				const exportName = this._id
					? `the named export '${this._id}'`
					: "the namespace object";
				return [
					new HarmonyLinkingError(
						`Can't import ${exportName} from non EcmaScript module (only default export is available)`
					)
				];
			}
			return;
		}

		if (!this._id) {
			return;
		}

		if (importedModule.isProvided(this._id) !== false) {
			// It's provided or we are not sure
			return;
		}

		// We are sure that it's not provided
		const idIsNotNameMessage =
			this._id !== this.name ? ` (imported as '${this.name}')` : "";
		const errorMessage = `"export '${
			this._id
		}'${idIsNotNameMessage} was not found in '${this.userRequest}'`;
		return [new HarmonyLinkingError(errorMessage)];
	}

	// implement this method to allow the occurrence order plugin to count correctly
	getNumberOfIdOccurrences() {
		return 0;
	}

	updateHash(hash) {
		super.updateHash(hash);
		const importedModule = this._module;
		hash.update((importedModule && this._id) + "");
		hash.update(
			(importedModule && this._id && importedModule.isUsed(this._id)) + ""
		);
		hash.update(
			(importedModule &&
				(!importedModule.buildMeta || importedModule.buildMeta.exportsType)) +
				""
		);
		hash.update(
			(importedModule &&
				importedModule.used + JSON.stringify(importedModule.usedExports)) + ""
		);
	}

	disconnect() {
		super.disconnect();
		this.redirectedId = undefined;
	}
}

HarmonyImportSpecifierDependency.Template = class HarmonyImportSpecifierDependencyTemplate extends HarmonyImportDependency.Template {
	apply(dep, source, runtime) {
		super.apply(dep, source, runtime);
		const content = this.getContent(dep, runtime);
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}

	getContent(dep, runtime) {
		const exportExpr = runtime.exportFromImport({
			module: dep._module,
			request: dep.request,
			exportName: dep._id,
			originModule: dep.originModule,
			asiSafe: dep.shorthand,
			isCall: dep.call,
			callContext: !dep.directImport,
			importVar: dep.getImportVar()
		});
		return dep.shorthand ? `${dep.name}: ${exportExpr}` : exportExpr;
	}
};

module.exports = HarmonyImportSpecifierDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyInitDependency.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyInitDependency.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class HarmonyInitDependency extends NullDependency {
	constructor(originModule) {
		super();
		this.originModule = originModule;
	}

	get type() {
		return "harmony init";
	}
}

module.exports = HarmonyInitDependency;

HarmonyInitDependency.Template = class HarmonyInitDependencyTemplate {
	apply(dep, source, runtime, dependencyTemplates) {
		const module = dep.originModule;
		const list = [];
		for (const dependency of module.dependencies) {
			const template = dependencyTemplates.get(dependency.constructor);
			if (
				template &&
				typeof template.harmonyInit === "function" &&
				typeof template.getHarmonyInitOrder === "function"
			) {
				const order = template.getHarmonyInitOrder(dependency);
				if (!isNaN(order)) {
					list.push({
						order,
						listOrder: list.length,
						dependency,
						template
					});
				}
			}
		}

		list.sort((a, b) => {
			const x = a.order - b.order;
			if (x) return x;
			return a.listOrder - b.listOrder;
		});

		for (const item of list) {
			item.template.harmonyInit(
				item.dependency,
				source,
				runtime,
				dependencyTemplates
			);
		}
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyModulesPlugin.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyModulesPlugin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const HarmonyCompatibilityDependency = __webpack_require__(/*! ./HarmonyCompatibilityDependency */ "./node_modules/webpack/lib/dependencies/HarmonyCompatibilityDependency.js");
const HarmonyInitDependency = __webpack_require__(/*! ./HarmonyInitDependency */ "./node_modules/webpack/lib/dependencies/HarmonyInitDependency.js");
const HarmonyImportSpecifierDependency = __webpack_require__(/*! ./HarmonyImportSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSpecifierDependency.js");
const HarmonyImportSideEffectDependency = __webpack_require__(/*! ./HarmonyImportSideEffectDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSideEffectDependency.js");
const HarmonyExportHeaderDependency = __webpack_require__(/*! ./HarmonyExportHeaderDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportHeaderDependency.js");
const HarmonyExportExpressionDependency = __webpack_require__(/*! ./HarmonyExportExpressionDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportExpressionDependency.js");
const HarmonyExportSpecifierDependency = __webpack_require__(/*! ./HarmonyExportSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportSpecifierDependency.js");
const HarmonyExportImportedSpecifierDependency = __webpack_require__(/*! ./HarmonyExportImportedSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency.js");
const HarmonyAcceptDependency = __webpack_require__(/*! ./HarmonyAcceptDependency */ "./node_modules/webpack/lib/dependencies/HarmonyAcceptDependency.js");
const HarmonyAcceptImportDependency = __webpack_require__(/*! ./HarmonyAcceptImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyAcceptImportDependency.js");

const NullFactory = __webpack_require__(/*! ../NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

const HarmonyDetectionParserPlugin = __webpack_require__(/*! ./HarmonyDetectionParserPlugin */ "./node_modules/webpack/lib/dependencies/HarmonyDetectionParserPlugin.js");
const HarmonyImportDependencyParserPlugin = __webpack_require__(/*! ./HarmonyImportDependencyParserPlugin */ "./node_modules/webpack/lib/dependencies/HarmonyImportDependencyParserPlugin.js");
const HarmonyExportDependencyParserPlugin = __webpack_require__(/*! ./HarmonyExportDependencyParserPlugin */ "./node_modules/webpack/lib/dependencies/HarmonyExportDependencyParserPlugin.js");
const HarmonyTopLevelThisParserPlugin = __webpack_require__(/*! ./HarmonyTopLevelThisParserPlugin */ "./node_modules/webpack/lib/dependencies/HarmonyTopLevelThisParserPlugin.js");

class HarmonyModulesPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"HarmonyModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					HarmonyCompatibilityDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyCompatibilityDependency,
					new HarmonyCompatibilityDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyInitDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyInitDependency,
					new HarmonyInitDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyImportSideEffectDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyImportSideEffectDependency,
					new HarmonyImportSideEffectDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyImportSpecifierDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyImportSpecifierDependency,
					new HarmonyImportSpecifierDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyExportHeaderDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyExportHeaderDependency,
					new HarmonyExportHeaderDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyExportExpressionDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyExportExpressionDependency,
					new HarmonyExportExpressionDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyExportSpecifierDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyExportSpecifierDependency,
					new HarmonyExportSpecifierDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyExportImportedSpecifierDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyExportImportedSpecifierDependency,
					new HarmonyExportImportedSpecifierDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyAcceptDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyAcceptDependency,
					new HarmonyAcceptDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyAcceptImportDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyAcceptImportDependency,
					new HarmonyAcceptImportDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.harmony !== undefined && !parserOptions.harmony)
						return;

					new HarmonyDetectionParserPlugin().apply(parser);
					new HarmonyImportDependencyParserPlugin(this.options).apply(parser);
					new HarmonyExportDependencyParserPlugin(this.options).apply(parser);
					new HarmonyTopLevelThisParserPlugin().apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("HarmonyModulesPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("HarmonyModulesPlugin", handler);
			}
		);
	}
}
module.exports = HarmonyModulesPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/HarmonyTopLevelThisParserPlugin.js":
/*!*********************************************************************!*\
  !*** (webpack)/lib/dependencies/HarmonyTopLevelThisParserPlugin.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Florent Cailhol @ooflorent
*/


const ConstDependency = __webpack_require__(/*! ./ConstDependency */ "./node_modules/webpack/lib/dependencies/ConstDependency.js");

class HarmonyTopLevelThisParserPlugin {
	apply(parser) {
		parser.hooks.expression
			.for("this")
			.tap("HarmonyTopLevelThisParserPlugin", node => {
				if (!parser.scope.topLevelScope) return;
				const module = parser.state.module;
				const isHarmony = !!(module.buildMeta && module.buildMeta.exportsType);
				if (isHarmony) {
					const dep = new ConstDependency("undefined", node.range, false);
					dep.loc = node.loc;
					parser.state.current.addDependency(dep);
				}
			});
	}
}

module.exports = HarmonyTopLevelThisParserPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ImportContextDependency.js":
/*!*************************************************************!*\
  !*** (webpack)/lib/dependencies/ImportContextDependency.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ContextDependency = __webpack_require__(/*! ./ContextDependency */ "./node_modules/webpack/lib/dependencies/ContextDependency.js");
const ContextDependencyTemplateAsRequireCall = __webpack_require__(/*! ./ContextDependencyTemplateAsRequireCall */ "./node_modules/webpack/lib/dependencies/ContextDependencyTemplateAsRequireCall.js");

class ImportContextDependency extends ContextDependency {
	constructor(options, range, valueRange) {
		super(options);
		this.range = range;
		this.valueRange = valueRange;
	}

	get type() {
		return `import() context ${this.options.mode}`;
	}
}

ImportContextDependency.Template = ContextDependencyTemplateAsRequireCall;

module.exports = ImportContextDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ImportDependenciesBlock.js":
/*!*************************************************************!*\
  !*** (webpack)/lib/dependencies/ImportDependenciesBlock.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const AsyncDependenciesBlock = __webpack_require__(/*! ../AsyncDependenciesBlock */ "./node_modules/webpack/lib/AsyncDependenciesBlock.js");
const ImportDependency = __webpack_require__(/*! ./ImportDependency */ "./node_modules/webpack/lib/dependencies/ImportDependency.js");

module.exports = class ImportDependenciesBlock extends AsyncDependenciesBlock {
	// TODO webpack 5 reorganize arguments
	constructor(request, range, groupOptions, module, loc, originModule) {
		super(groupOptions, module, loc, request);
		this.range = range;
		const dep = new ImportDependency(request, originModule, this);
		dep.loc = loc;
		this.addDependency(dep);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ImportDependency.js":
/*!******************************************************!*\
  !*** (webpack)/lib/dependencies/ImportDependency.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class ImportDependency extends ModuleDependency {
	constructor(request, originModule, block) {
		super(request);
		this.originModule = originModule;
		this.block = block;
	}

	get type() {
		return "import()";
	}
}

ImportDependency.Template = class ImportDependencyTemplate {
	apply(dep, source, runtime) {
		const content = runtime.moduleNamespacePromise({
			block: dep.block,
			module: dep.module,
			request: dep.request,
			strict: dep.originModule.buildMeta.strictHarmonyModule,
			message: "import()"
		});

		source.replace(dep.block.range[0], dep.block.range[1] - 1, content);
	}
};

module.exports = ImportDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ImportEagerDependency.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/dependencies/ImportEagerDependency.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class ImportEagerDependency extends ModuleDependency {
	constructor(request, originModule, range) {
		super(request);
		this.originModule = originModule;
		this.range = range;
	}

	get type() {
		return "import() eager";
	}
}

ImportEagerDependency.Template = class ImportEagerDependencyTemplate {
	apply(dep, source, runtime) {
		const content = runtime.moduleNamespacePromise({
			module: dep.module,
			request: dep.request,
			strict: dep.originModule.buildMeta.strictHarmonyModule,
			message: "import() eager"
		});
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
};

module.exports = ImportEagerDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ImportParserPlugin.js":
/*!********************************************************!*\
  !*** (webpack)/lib/dependencies/ImportParserPlugin.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ImportContextDependency = __webpack_require__(/*! ./ImportContextDependency */ "./node_modules/webpack/lib/dependencies/ImportContextDependency.js");
const ImportWeakDependency = __webpack_require__(/*! ./ImportWeakDependency */ "./node_modules/webpack/lib/dependencies/ImportWeakDependency.js");
const ImportDependenciesBlock = __webpack_require__(/*! ./ImportDependenciesBlock */ "./node_modules/webpack/lib/dependencies/ImportDependenciesBlock.js");
const ImportEagerDependency = __webpack_require__(/*! ./ImportEagerDependency */ "./node_modules/webpack/lib/dependencies/ImportEagerDependency.js");
const ContextDependencyHelpers = __webpack_require__(/*! ./ContextDependencyHelpers */ "./node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js");
const UnsupportedFeatureWarning = __webpack_require__(/*! ../UnsupportedFeatureWarning */ "./node_modules/webpack/lib/UnsupportedFeatureWarning.js");
const CommentCompilationWarning = __webpack_require__(/*! ../CommentCompilationWarning */ "./node_modules/webpack/lib/CommentCompilationWarning.js");

class ImportParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		parser.hooks.importCall.tap("ImportParserPlugin", expr => {
			if (expr.arguments.length !== 1) {
				throw new Error(
					"Incorrect number of arguments provided to 'import(module: string) -> Promise'."
				);
			}

			const param = parser.evaluateExpression(expr.arguments[0]);

			let chunkName = null;
			let mode = "lazy";
			let include = null;
			let exclude = null;
			const groupOptions = {};

			const {
				options: importOptions,
				errors: commentErrors
			} = parser.parseCommentOptions(expr.range);

			if (commentErrors) {
				for (const e of commentErrors) {
					const { comment } = e;
					parser.state.module.warnings.push(
						new CommentCompilationWarning(
							`Compilation error while processing magic comment(-s): /*${
								comment.value
							}*/: ${e.message}`,
							parser.state.module,
							comment.loc
						)
					);
				}
			}

			if (importOptions) {
				if (importOptions.webpackIgnore !== undefined) {
					if (typeof importOptions.webpackIgnore !== "boolean") {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackIgnore\` expected a boolean, but received: ${
									importOptions.webpackIgnore
								}.`,
								expr.loc
							)
						);
					} else {
						// Do not instrument `import()` if `webpackIgnore` is `true`
						if (importOptions.webpackIgnore) {
							return false;
						}
					}
				}
				if (importOptions.webpackChunkName !== undefined) {
					if (typeof importOptions.webpackChunkName !== "string") {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackChunkName\` expected a string, but received: ${
									importOptions.webpackChunkName
								}.`,
								expr.loc
							)
						);
					} else {
						chunkName = importOptions.webpackChunkName;
					}
				}
				if (importOptions.webpackMode !== undefined) {
					if (typeof importOptions.webpackMode !== "string") {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackMode\` expected a string, but received: ${
									importOptions.webpackMode
								}.`,
								expr.loc
							)
						);
					} else {
						mode = importOptions.webpackMode;
					}
				}
				if (importOptions.webpackPrefetch !== undefined) {
					if (importOptions.webpackPrefetch === true) {
						groupOptions.prefetchOrder = 0;
					} else if (typeof importOptions.webpackPrefetch === "number") {
						groupOptions.prefetchOrder = importOptions.webpackPrefetch;
					} else {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackPrefetch\` expected true or a number, but received: ${
									importOptions.webpackPrefetch
								}.`,
								expr.loc
							)
						);
					}
				}
				if (importOptions.webpackPreload !== undefined) {
					if (importOptions.webpackPreload === true) {
						groupOptions.preloadOrder = 0;
					} else if (typeof importOptions.webpackPreload === "number") {
						groupOptions.preloadOrder = importOptions.webpackPreload;
					} else {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackPreload\` expected true or a number, but received: ${
									importOptions.webpackPreload
								}.`,
								expr.loc
							)
						);
					}
				}
				if (importOptions.webpackInclude !== undefined) {
					if (
						!importOptions.webpackInclude ||
						importOptions.webpackInclude.constructor.name !== "RegExp"
					) {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackInclude\` expected a regular expression, but received: ${
									importOptions.webpackInclude
								}.`,
								expr.loc
							)
						);
					} else {
						include = new RegExp(importOptions.webpackInclude);
					}
				}
				if (importOptions.webpackExclude !== undefined) {
					if (
						!importOptions.webpackExclude ||
						importOptions.webpackExclude.constructor.name !== "RegExp"
					) {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackExclude\` expected a regular expression, but received: ${
									importOptions.webpackExclude
								}.`,
								expr.loc
							)
						);
					} else {
						exclude = new RegExp(importOptions.webpackExclude);
					}
				}
			}

			if (param.isString()) {
				if (mode !== "lazy" && mode !== "eager" && mode !== "weak") {
					parser.state.module.warnings.push(
						new UnsupportedFeatureWarning(
							parser.state.module,
							`\`webpackMode\` expected 'lazy', 'eager' or 'weak', but received: ${mode}.`,
							expr.loc
						)
					);
				}

				if (mode === "eager") {
					const dep = new ImportEagerDependency(
						param.string,
						parser.state.module,
						expr.range
					);
					parser.state.current.addDependency(dep);
				} else if (mode === "weak") {
					const dep = new ImportWeakDependency(
						param.string,
						parser.state.module,
						expr.range
					);
					parser.state.current.addDependency(dep);
				} else {
					const depBlock = new ImportDependenciesBlock(
						param.string,
						expr.range,
						Object.assign(groupOptions, {
							name: chunkName
						}),
						parser.state.module,
						expr.loc,
						parser.state.module
					);
					parser.state.current.addBlock(depBlock);
				}
				return true;
			} else {
				if (
					mode !== "lazy" &&
					mode !== "lazy-once" &&
					mode !== "eager" &&
					mode !== "weak"
				) {
					parser.state.module.warnings.push(
						new UnsupportedFeatureWarning(
							parser.state.module,
							`\`webpackMode\` expected 'lazy', 'lazy-once', 'eager' or 'weak', but received: ${mode}.`,
							expr.loc
						)
					);
					mode = "lazy";
				}

				if (mode === "weak") {
					mode = "async-weak";
				}
				const dep = ContextDependencyHelpers.create(
					ImportContextDependency,
					expr.range,
					param,
					expr,
					this.options,
					{
						chunkName,
						groupOptions,
						include,
						exclude,
						mode,
						namespaceObject: parser.state.module.buildMeta.strictHarmonyModule
							? "strict"
							: true
					},
					parser
				);
				if (!dep) return;
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			}
		});
	}
}

module.exports = ImportParserPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ImportPlugin.js":
/*!**************************************************!*\
  !*** (webpack)/lib/dependencies/ImportPlugin.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ImportDependency = __webpack_require__(/*! ./ImportDependency */ "./node_modules/webpack/lib/dependencies/ImportDependency.js");
const ImportEagerDependency = __webpack_require__(/*! ./ImportEagerDependency */ "./node_modules/webpack/lib/dependencies/ImportEagerDependency.js");
const ImportWeakDependency = __webpack_require__(/*! ./ImportWeakDependency */ "./node_modules/webpack/lib/dependencies/ImportWeakDependency.js");
const ImportContextDependency = __webpack_require__(/*! ./ImportContextDependency */ "./node_modules/webpack/lib/dependencies/ImportContextDependency.js");
const ImportParserPlugin = __webpack_require__(/*! ./ImportParserPlugin */ "./node_modules/webpack/lib/dependencies/ImportParserPlugin.js");

class ImportPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"ImportPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					ImportDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportDependency,
					new ImportDependency.Template()
				);

				compilation.dependencyFactories.set(
					ImportEagerDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportEagerDependency,
					new ImportEagerDependency.Template()
				);

				compilation.dependencyFactories.set(
					ImportWeakDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportWeakDependency,
					new ImportWeakDependency.Template()
				);

				compilation.dependencyFactories.set(
					ImportContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportContextDependency,
					new ImportContextDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.import !== undefined && !parserOptions.import)
						return;

					new ImportParserPlugin(options).apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ImportPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ImportPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("ImportPlugin", handler);
			}
		);
	}
}
module.exports = ImportPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ImportWeakDependency.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/dependencies/ImportWeakDependency.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class ImportWeakDependency extends ModuleDependency {
	constructor(request, originModule, range) {
		super(request);
		this.originModule = originModule;
		this.range = range;
		this.weak = true;
	}

	get type() {
		return "import() weak";
	}
}

ImportWeakDependency.Template = class ImportDependencyTemplate {
	apply(dep, source, runtime) {
		const content = runtime.moduleNamespacePromise({
			module: dep.module,
			request: dep.request,
			strict: dep.originModule.buildMeta.strictHarmonyModule,
			message: "import() weak",
			weak: true
		});
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
};

module.exports = ImportWeakDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/JsonExportsDependency.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/dependencies/JsonExportsDependency.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class JsonExportsDependency extends NullDependency {
	constructor(exports) {
		super();
		this.exports = exports;
	}

	get type() {
		return "json exports";
	}

	getExports() {
		return {
			exports: this.exports,
			dependencies: undefined
		};
	}
}

module.exports = JsonExportsDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/LoaderDependency.js":
/*!******************************************************!*\
  !*** (webpack)/lib/dependencies/LoaderDependency.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class LoaderDependency extends ModuleDependency {
	/**
	 * @param {string} request request string
	 */
	constructor(request) {
		super(request);
	}

	get type() {
		return "loader";
	}
}

module.exports = LoaderDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/LoaderPlugin.js":
/*!**************************************************!*\
  !*** (webpack)/lib/dependencies/LoaderPlugin.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const LoaderDependency = __webpack_require__(/*! ./LoaderDependency */ "./node_modules/webpack/lib/dependencies/LoaderDependency.js");
const NormalModule = __webpack_require__(/*! ../NormalModule */ "./node_modules/webpack/lib/NormalModule.js");

/** @typedef {import("../Module")} Module */

/**
 * @callback LoadModuleCallback
 * @param {Error=} err error object
 * @param {string=} source source code
 * @param {object=} map source map
 * @param {Module=} module loaded module if successful
 */

class LoaderPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"LoaderPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					LoaderDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.compilation.tap("LoaderPlugin", compilation => {
			compilation.hooks.normalModuleLoader.tap(
				"LoaderPlugin",
				(loaderContext, module) => {
					/**
					 * @param {string} request the request string to load the module from
					 * @param {LoadModuleCallback} callback callback returning the loaded module or error
					 * @returns {void}
					 */
					loaderContext.loadModule = (request, callback) => {
						const dep = new LoaderDependency(request);
						dep.loc = {
							name: request
						};
						const factory = compilation.dependencyFactories.get(
							dep.constructor
						);
						if (factory === undefined) {
							return callback(
								new Error(
									`No module factory available for dependency type: ${
										dep.constructor.name
									}`
								)
							);
						}
						compilation.semaphore.release();
						compilation.addModuleDependencies(
							module,
							[
								{
									factory,
									dependencies: [dep]
								}
							],
							true,
							"lm",
							true,
							err => {
								compilation.semaphore.acquire(() => {
									if (err) {
										return callback(err);
									}
									if (!dep.module) {
										return callback(new Error("Cannot load the module"));
									}
									// TODO consider removing this in webpack 5
									if (dep.module instanceof NormalModule && dep.module.error) {
										return callback(dep.module.error);
									}
									if (!dep.module._source) {
										throw new Error(
											"The module created for a LoaderDependency must have a property _source"
										);
									}
									let source, map;
									const moduleSource = dep.module._source;
									if (moduleSource.sourceAndMap) {
										const sourceAndMap = moduleSource.sourceAndMap();
										map = sourceAndMap.map;
										source = sourceAndMap.source;
									} else {
										map = moduleSource.map();
										source = moduleSource.source();
									}
									if (dep.module.buildInfo.fileDependencies) {
										for (const d of dep.module.buildInfo.fileDependencies) {
											loaderContext.addDependency(d);
										}
									}
									if (dep.module.buildInfo.contextDependencies) {
										for (const d of dep.module.buildInfo.contextDependencies) {
											loaderContext.addContextDependency(d);
										}
									}
									return callback(null, source, map, dep.module);
								});
							}
						);
					};
				}
			);
		});
	}
}
module.exports = LoaderPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/LocalModule.js":
/*!*************************************************!*\
  !*** (webpack)/lib/dependencies/LocalModule.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class LocalModule {
	constructor(module, name, idx) {
		this.module = module;
		this.name = name;
		this.idx = idx;
		this.used = false;
	}

	flagUsed() {
		this.used = true;
	}

	variableName() {
		return "__WEBPACK_LOCAL_MODULE_" + this.idx + "__";
	}
}
module.exports = LocalModule;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/LocalModuleDependency.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/dependencies/LocalModuleDependency.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class LocalModuleDependency extends NullDependency {
	constructor(localModule, range, callNew) {
		super();
		localModule.flagUsed();
		this.localModule = localModule;
		this.range = range;
		this.callNew = callNew;
	}
}

LocalModuleDependency.Template = class LocalModuleDependencyTemplate {
	apply(dep, source) {
		if (!dep.range) return;
		const moduleInstance = dep.callNew
			? `new (function () { return ${dep.localModule.variableName()}; })()`
			: dep.localModule.variableName();
		source.replace(dep.range[0], dep.range[1] - 1, moduleInstance);
	}
};

module.exports = LocalModuleDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/LocalModulesHelpers.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/dependencies/LocalModulesHelpers.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const LocalModule = __webpack_require__(/*! ./LocalModule */ "./node_modules/webpack/lib/dependencies/LocalModule.js");
const LocalModulesHelpers = exports;

const lookup = (parent, mod) => {
	if (mod.charAt(0) !== ".") return mod;

	var path = parent.split("/");
	var segs = mod.split("/");
	path.pop();

	for (let i = 0; i < segs.length; i++) {
		const seg = segs[i];
		if (seg === "..") {
			path.pop();
		} else if (seg !== ".") {
			path.push(seg);
		}
	}

	return path.join("/");
};

LocalModulesHelpers.addLocalModule = (state, name) => {
	if (!state.localModules) {
		state.localModules = [];
	}
	const m = new LocalModule(state.module, name, state.localModules.length);
	state.localModules.push(m);
	return m;
};

LocalModulesHelpers.getLocalModule = (state, name, namedModule) => {
	if (!state.localModules) return null;
	if (namedModule) {
		// resolve dependency name relative to the defining named module
		name = lookup(namedModule, name);
	}
	for (let i = 0; i < state.localModules.length; i++) {
		if (state.localModules[i].name === name) {
			return state.localModules[i];
		}
	}
	return null;
};

module.exports = LocalModulesHelpers;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ModuleDependency.js":
/*!******************************************************!*\
  !*** (webpack)/lib/dependencies/ModuleDependency.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Dependency = __webpack_require__(/*! ../Dependency */ "./node_modules/webpack/lib/Dependency.js");

class ModuleDependency extends Dependency {
	/**
	 * @param {string} request request path which needs resolving
	 */
	constructor(request) {
		super();
		this.request = request;
		this.userRequest = request;
	}

	getResourceIdentifier() {
		return `module${this.request}`;
	}
}

module.exports = ModuleDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsId.js":
/*!******************************************************************!*\
  !*** (webpack)/lib/dependencies/ModuleDependencyTemplateAsId.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class ModuleDependencyTemplateAsId {
	apply(dep, source, runtime) {
		if (!dep.range) return;
		const content = runtime.moduleId({
			module: dep.module,
			request: dep.request
		});
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
}
module.exports = ModuleDependencyTemplateAsId;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsRequireId.js":
/*!*************************************************************************!*\
  !*** (webpack)/lib/dependencies/ModuleDependencyTemplateAsRequireId.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class ModuleDependencyTemplateAsRequireId {
	apply(dep, source, runtime) {
		if (!dep.range) return;
		const content = runtime.moduleExports({
			module: dep.module,
			request: dep.request
		});
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
}
module.exports = ModuleDependencyTemplateAsRequireId;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ModuleHotAcceptDependency.js":
/*!***************************************************************!*\
  !*** (webpack)/lib/dependencies/ModuleHotAcceptDependency.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const ModuleDependencyTemplateAsId = __webpack_require__(/*! ./ModuleDependencyTemplateAsId */ "./node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsId.js");

class ModuleHotAcceptDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
		this.weak = true;
	}

	get type() {
		return "module.hot.accept";
	}
}

ModuleHotAcceptDependency.Template = ModuleDependencyTemplateAsId;

module.exports = ModuleHotAcceptDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/ModuleHotDeclineDependency.js":
/*!****************************************************************!*\
  !*** (webpack)/lib/dependencies/ModuleHotDeclineDependency.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const ModuleDependencyTemplateAsId = __webpack_require__(/*! ./ModuleDependencyTemplateAsId */ "./node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsId.js");

class ModuleHotDeclineDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
		this.weak = true;
	}

	get type() {
		return "module.hot.decline";
	}
}

ModuleHotDeclineDependency.Template = ModuleDependencyTemplateAsId;

module.exports = ModuleHotDeclineDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/MultiEntryDependency.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/dependencies/MultiEntryDependency.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

/** @typedef {import("./SingleEntryDependency")} SingleEntryDependency */
const Dependency = __webpack_require__(/*! ../Dependency */ "./node_modules/webpack/lib/Dependency.js");

class MultiEntryDependency extends Dependency {
	/**
	 * @param {SingleEntryDependency[]} dependencies an array of SingleEntryDependencies
	 * @param {string} name entry name
	 */
	constructor(dependencies, name) {
		super();
		this.dependencies = dependencies;
		this.name = name;
	}

	get type() {
		return "multi entry";
	}
}

module.exports = MultiEntryDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/NullDependency.js":
/*!****************************************************!*\
  !*** (webpack)/lib/dependencies/NullDependency.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Dependency = __webpack_require__(/*! ../Dependency */ "./node_modules/webpack/lib/Dependency.js");

class NullDependency extends Dependency {
	get type() {
		return "null";
	}

	updateHash() {}
}

NullDependency.Template = class NullDependencyTemplate {
	apply() {}
};

module.exports = NullDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/PrefetchDependency.js":
/*!********************************************************!*\
  !*** (webpack)/lib/dependencies/PrefetchDependency.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class PrefetchDependency extends ModuleDependency {
	constructor(request) {
		super(request);
	}

	get type() {
		return "prefetch";
	}
}

module.exports = PrefetchDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireContextDependency.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireContextDependency.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ContextDependency = __webpack_require__(/*! ./ContextDependency */ "./node_modules/webpack/lib/dependencies/ContextDependency.js");
const ModuleDependencyTemplateAsRequireId = __webpack_require__(/*! ./ModuleDependencyTemplateAsRequireId */ "./node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsRequireId.js");

class RequireContextDependency extends ContextDependency {
	constructor(options, range) {
		super(options);
		this.range = range;
	}

	get type() {
		return "require.context";
	}
}

RequireContextDependency.Template = ModuleDependencyTemplateAsRequireId;

module.exports = RequireContextDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireContextDependencyParserPlugin.js":
/*!**************************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireContextDependencyParserPlugin.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const RequireContextDependency = __webpack_require__(/*! ./RequireContextDependency */ "./node_modules/webpack/lib/dependencies/RequireContextDependency.js");

module.exports = class RequireContextDependencyParserPlugin {
	apply(parser) {
		parser.hooks.call
			.for("require.context")
			.tap("RequireContextDependencyParserPlugin", expr => {
				let regExp = /^\.\/.*$/;
				let recursive = true;
				let mode = "sync";
				switch (expr.arguments.length) {
					case 4: {
						const modeExpr = parser.evaluateExpression(expr.arguments[3]);
						if (!modeExpr.isString()) return;
						mode = modeExpr.string;
					}
					// falls through
					case 3: {
						const regExpExpr = parser.evaluateExpression(expr.arguments[2]);
						if (!regExpExpr.isRegExp()) return;
						regExp = regExpExpr.regExp;
					}
					// falls through
					case 2: {
						const recursiveExpr = parser.evaluateExpression(expr.arguments[1]);
						if (!recursiveExpr.isBoolean()) return;
						recursive = recursiveExpr.bool;
					}
					// falls through
					case 1: {
						const requestExpr = parser.evaluateExpression(expr.arguments[0]);
						if (!requestExpr.isString()) return;
						const dep = new RequireContextDependency(
							{
								request: requestExpr.string,
								recursive,
								regExp,
								mode
							},
							expr.range
						);
						dep.loc = expr.loc;
						dep.optional = parser.scope.inTry;
						parser.state.current.addDependency(dep);
						return true;
					}
				}
			});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireContextPlugin.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/dependencies/RequireContextPlugin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const RequireContextDependency = __webpack_require__(/*! ./RequireContextDependency */ "./node_modules/webpack/lib/dependencies/RequireContextDependency.js");
const ContextElementDependency = __webpack_require__(/*! ./ContextElementDependency */ "./node_modules/webpack/lib/dependencies/ContextElementDependency.js");

const RequireContextDependencyParserPlugin = __webpack_require__(/*! ./RequireContextDependencyParserPlugin */ "./node_modules/webpack/lib/dependencies/RequireContextDependencyParserPlugin.js");

class RequireContextPlugin {
	constructor(modulesDirectories, extensions, mainFiles) {
		if (!Array.isArray(modulesDirectories)) {
			throw new Error("modulesDirectories must be an array");
		}
		if (!Array.isArray(extensions)) {
			throw new Error("extensions must be an array");
		}
		this.modulesDirectories = modulesDirectories;
		this.extensions = extensions;
		this.mainFiles = mainFiles;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireContextPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireContextDependency,
					new RequireContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					ContextElementDependency,
					normalModuleFactory
				);

				const handler = (parser, parserOptions) => {
					if (
						parserOptions.requireContext !== undefined &&
						!parserOptions.requireContext
					)
						return;

					new RequireContextDependencyParserPlugin().apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireContextPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("RequireContextPlugin", handler);

				contextModuleFactory.hooks.alternatives.tap(
					"RequireContextPlugin",
					items => {
						if (items.length === 0) return items;
						return items
							.map(obj => {
								return this.extensions
									.filter(ext => {
										const l = obj.request.length;
										return (
											l > ext.length &&
											obj.request.substr(l - ext.length, l) === ext
										);
									})
									.map(ext => {
										const l = obj.request.length;
										return {
											context: obj.context,
											request: obj.request.substr(0, l - ext.length)
										};
									})
									.concat(obj);
							})
							.reduce((a, b) => a.concat(b), []);
					}
				);

				contextModuleFactory.hooks.alternatives.tap(
					"RequireContextPlugin",
					items => {
						if (items.length === 0) return items;
						return items
							.map(obj => {
								return this.mainFiles
									.filter(mainFile => {
										const l = obj.request.length;
										return (
											l > mainFile.length + 1 &&
											obj.request.substr(l - mainFile.length - 1, l) ===
												"/" + mainFile
										);
									})
									.map(mainFile => {
										const l = obj.request.length;
										return [
											{
												context: obj.context,
												request: obj.request.substr(0, l - mainFile.length)
											},
											{
												context: obj.context,
												request: obj.request.substr(0, l - mainFile.length - 1)
											}
										];
									})
									.reduce((a, b) => a.concat(b), [])
									.concat(obj);
							})
							.reduce((a, b) => a.concat(b), []);
					}
				);

				contextModuleFactory.hooks.alternatives.tap(
					"RequireContextPlugin",
					items => {
						if (items.length === 0) return items;
						return items.map(obj => {
							for (let i = 0; i < this.modulesDirectories.length; i++) {
								const dir = this.modulesDirectories[i];
								const idx = obj.request.indexOf("./" + dir + "/");
								if (idx === 0) {
									obj.request = obj.request.slice(dir.length + 3);
									break;
								}
							}
							return obj;
						});
					}
				);
			}
		);
	}
}
module.exports = RequireContextPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlock.js":
/*!********************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireEnsureDependenciesBlock.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const AsyncDependenciesBlock = __webpack_require__(/*! ../AsyncDependenciesBlock */ "./node_modules/webpack/lib/AsyncDependenciesBlock.js");
const RequireEnsureDependency = __webpack_require__(/*! ./RequireEnsureDependency */ "./node_modules/webpack/lib/dependencies/RequireEnsureDependency.js");

module.exports = class RequireEnsureDependenciesBlock extends AsyncDependenciesBlock {
	constructor(
		expr,
		successExpression,
		errorExpression,
		chunkName,
		chunkNameRange,
		module,
		loc
	) {
		super(chunkName, module, loc, null);
		this.expr = expr;
		const successBodyRange =
			successExpression &&
			successExpression.body &&
			successExpression.body.range;
		if (successBodyRange) {
			this.range = [successBodyRange[0] + 1, successBodyRange[1] - 1];
		}
		this.chunkNameRange = chunkNameRange;
		const dep = new RequireEnsureDependency(this);
		dep.loc = loc;
		this.addDependency(dep);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlockParserPlugin.js":
/*!********************************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireEnsureDependenciesBlockParserPlugin.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const RequireEnsureDependenciesBlock = __webpack_require__(/*! ./RequireEnsureDependenciesBlock */ "./node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlock.js");
const RequireEnsureItemDependency = __webpack_require__(/*! ./RequireEnsureItemDependency */ "./node_modules/webpack/lib/dependencies/RequireEnsureItemDependency.js");
const getFunctionExpression = __webpack_require__(/*! ./getFunctionExpression */ "./node_modules/webpack/lib/dependencies/getFunctionExpression.js");

module.exports = class RequireEnsureDependenciesBlockParserPlugin {
	apply(parser) {
		parser.hooks.call
			.for("require.ensure")
			.tap("RequireEnsureDependenciesBlockParserPlugin", expr => {
				let chunkName = null;
				let chunkNameRange = null;
				let errorExpressionArg = null;
				let errorExpression = null;
				switch (expr.arguments.length) {
					case 4: {
						const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
						if (!chunkNameExpr.isString()) return;
						chunkNameRange = chunkNameExpr.range;
						chunkName = chunkNameExpr.string;
					}
					// falls through
					case 3: {
						errorExpressionArg = expr.arguments[2];
						errorExpression = getFunctionExpression(errorExpressionArg);

						if (!errorExpression && !chunkName) {
							const chunkNameExpr = parser.evaluateExpression(
								expr.arguments[2]
							);
							if (!chunkNameExpr.isString()) return;
							chunkNameRange = chunkNameExpr.range;
							chunkName = chunkNameExpr.string;
						}
					}
					// falls through
					case 2: {
						const dependenciesExpr = parser.evaluateExpression(
							expr.arguments[0]
						);
						const dependenciesItems = dependenciesExpr.isArray()
							? dependenciesExpr.items
							: [dependenciesExpr];
						const successExpressionArg = expr.arguments[1];
						const successExpression = getFunctionExpression(
							successExpressionArg
						);

						if (successExpression) {
							parser.walkExpressions(successExpression.expressions);
						}
						if (errorExpression) {
							parser.walkExpressions(errorExpression.expressions);
						}

						const dep = new RequireEnsureDependenciesBlock(
							expr,
							successExpression ? successExpression.fn : successExpressionArg,
							errorExpression ? errorExpression.fn : errorExpressionArg,
							chunkName,
							chunkNameRange,
							parser.state.module,
							expr.loc
						);
						const old = parser.state.current;
						parser.state.current = dep;
						try {
							let failed = false;
							parser.inScope([], () => {
								for (const ee of dependenciesItems) {
									if (ee.isString()) {
										const edep = new RequireEnsureItemDependency(ee.string);
										edep.loc = dep.loc;
										dep.addDependency(edep);
									} else {
										failed = true;
									}
								}
							});
							if (failed) {
								return;
							}
							if (successExpression) {
								if (successExpression.fn.body.type === "BlockStatement") {
									parser.walkStatement(successExpression.fn.body);
								} else {
									parser.walkExpression(successExpression.fn.body);
								}
							}
							old.addBlock(dep);
						} finally {
							parser.state.current = old;
						}
						if (!successExpression) {
							parser.walkExpression(successExpressionArg);
						}
						if (errorExpression) {
							if (errorExpression.fn.body.type === "BlockStatement") {
								parser.walkStatement(errorExpression.fn.body);
							} else {
								parser.walkExpression(errorExpression.fn.body);
							}
						} else if (errorExpressionArg) {
							parser.walkExpression(errorExpressionArg);
						}
						return true;
					}
				}
			});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireEnsureDependency.js":
/*!*************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireEnsureDependency.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class RequireEnsureDependency extends NullDependency {
	constructor(block) {
		super();
		this.block = block;
	}

	get type() {
		return "require.ensure";
	}
}

RequireEnsureDependency.Template = class RequireEnsureDependencyTemplate {
	apply(dep, source, runtime) {
		const depBlock = dep.block;
		const promise = runtime.blockPromise({
			block: depBlock,
			message: "require.ensure"
		});
		const errorCallbackExists =
			depBlock.expr.arguments.length === 4 ||
			(!depBlock.chunkName && depBlock.expr.arguments.length === 3);
		const startBlock = `${promise}.then((`;
		const middleBlock = ").bind(null, __webpack_require__)).catch(";
		const endBlock = `).bind(null, __webpack_require__)).catch(${runtime.onError()})`;
		source.replace(
			depBlock.expr.range[0],
			depBlock.expr.arguments[1].range[0] - 1,
			startBlock
		);
		if (errorCallbackExists) {
			source.replace(
				depBlock.expr.arguments[1].range[1],
				depBlock.expr.arguments[2].range[0] - 1,
				middleBlock
			);
			source.replace(
				depBlock.expr.arguments[2].range[1],
				depBlock.expr.range[1] - 1,
				")"
			);
		} else {
			source.replace(
				depBlock.expr.arguments[1].range[1],
				depBlock.expr.range[1] - 1,
				endBlock
			);
		}
	}
};

module.exports = RequireEnsureDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireEnsureItemDependency.js":
/*!*****************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireEnsureItemDependency.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class RequireEnsureItemDependency extends ModuleDependency {
	constructor(request) {
		super(request);
	}

	get type() {
		return "require.ensure item";
	}
}

RequireEnsureItemDependency.Template = NullDependency.Template;

module.exports = RequireEnsureItemDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireEnsurePlugin.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/dependencies/RequireEnsurePlugin.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const RequireEnsureItemDependency = __webpack_require__(/*! ./RequireEnsureItemDependency */ "./node_modules/webpack/lib/dependencies/RequireEnsureItemDependency.js");
const RequireEnsureDependency = __webpack_require__(/*! ./RequireEnsureDependency */ "./node_modules/webpack/lib/dependencies/RequireEnsureDependency.js");

const NullFactory = __webpack_require__(/*! ../NullFactory */ "./node_modules/webpack/lib/NullFactory.js");

const RequireEnsureDependenciesBlockParserPlugin = __webpack_require__(/*! ./RequireEnsureDependenciesBlockParserPlugin */ "./node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlockParserPlugin.js");

const ParserHelpers = __webpack_require__(/*! ../ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");

class RequireEnsurePlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireEnsurePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireEnsureItemDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireEnsureItemDependency,
					new RequireEnsureItemDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireEnsureDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					RequireEnsureDependency,
					new RequireEnsureDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (
						parserOptions.requireEnsure !== undefined &&
						!parserOptions.requireEnsure
					)
						return;

					new RequireEnsureDependenciesBlockParserPlugin().apply(parser);
					parser.hooks.evaluateTypeof
						.for("require.ensure")
						.tap(
							"RequireEnsurePlugin",
							ParserHelpers.evaluateToString("function")
						);
					parser.hooks.typeof
						.for("require.ensure")
						.tap(
							"RequireEnsurePlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireEnsurePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("RequireEnsurePlugin", handler);
			}
		);
	}
}
module.exports = RequireEnsurePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireHeaderDependency.js":
/*!*************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireHeaderDependency.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class RequireHeaderDependency extends NullDependency {
	constructor(range) {
		super();
		if (!Array.isArray(range)) throw new Error("range must be valid");
		this.range = range;
	}
}

RequireHeaderDependency.Template = class RequireHeaderDependencyTemplate {
	apply(dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__");
	}

	applyAsTemplateArgument(name, dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "require");
	}
};

module.exports = RequireHeaderDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireIncludeDependency.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireIncludeDependency.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DependencyReference = __webpack_require__(/*! ./DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");
const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");

class RequireIncludeDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
	}

	getReference() {
		if (!this.module) return null;
		// This doesn't use any export
		return new DependencyReference(this.module, [], false);
	}

	get type() {
		return "require.include";
	}
}

RequireIncludeDependency.Template = class RequireIncludeDependencyTemplate {
	apply(dep, source, runtime) {
		const comment = runtime.outputOptions.pathinfo
			? Template.toComment(
					`require.include ${runtime.requestShortener.shorten(dep.request)}`
			  )
			: "";
		source.replace(dep.range[0], dep.range[1] - 1, `undefined${comment}`);
	}
};

module.exports = RequireIncludeDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireIncludeDependencyParserPlugin.js":
/*!**************************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireIncludeDependencyParserPlugin.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const RequireIncludeDependency = __webpack_require__(/*! ./RequireIncludeDependency */ "./node_modules/webpack/lib/dependencies/RequireIncludeDependency.js");

module.exports = class RequireIncludeDependencyParserPlugin {
	apply(parser) {
		parser.hooks.call
			.for("require.include")
			.tap("RequireIncludeDependencyParserPlugin", expr => {
				if (expr.arguments.length !== 1) return;
				const param = parser.evaluateExpression(expr.arguments[0]);
				if (!param.isString()) return;
				const dep = new RequireIncludeDependency(param.string, expr.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireIncludePlugin.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/dependencies/RequireIncludePlugin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const RequireIncludeDependency = __webpack_require__(/*! ./RequireIncludeDependency */ "./node_modules/webpack/lib/dependencies/RequireIncludeDependency.js");
const RequireIncludeDependencyParserPlugin = __webpack_require__(/*! ./RequireIncludeDependencyParserPlugin */ "./node_modules/webpack/lib/dependencies/RequireIncludeDependencyParserPlugin.js");

const ParserHelpers = __webpack_require__(/*! ../ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");

class RequireIncludePlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireIncludePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireIncludeDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireIncludeDependency,
					new RequireIncludeDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (
						parserOptions.requireInclude !== undefined &&
						!parserOptions.requireInclude
					)
						return;

					new RequireIncludeDependencyParserPlugin().apply(parser);
					parser.hooks.evaluateTypeof
						.for("require.include")
						.tap(
							"RequireIncludePlugin",
							ParserHelpers.evaluateToString("function")
						);
					parser.hooks.typeof
						.for("require.include")
						.tap(
							"RequireIncludePlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireIncludePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("RequireIncludePlugin", handler);
			}
		);
	}
}
module.exports = RequireIncludePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireResolveContextDependency.js":
/*!*********************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireResolveContextDependency.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ContextDependency = __webpack_require__(/*! ./ContextDependency */ "./node_modules/webpack/lib/dependencies/ContextDependency.js");
const ContextDependencyTemplateAsId = __webpack_require__(/*! ./ContextDependencyTemplateAsId */ "./node_modules/webpack/lib/dependencies/ContextDependencyTemplateAsId.js");

class RequireResolveContextDependency extends ContextDependency {
	constructor(options, range, valueRange) {
		super(options);
		this.range = range;
		this.valueRange = valueRange;
	}

	get type() {
		return "amd require context";
	}
}

RequireResolveContextDependency.Template = ContextDependencyTemplateAsId;

module.exports = RequireResolveContextDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireResolveDependency.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireResolveDependency.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const ModuleDependencyAsId = __webpack_require__(/*! ./ModuleDependencyTemplateAsId */ "./node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsId.js");

class RequireResolveDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
	}

	get type() {
		return "require.resolve";
	}
}

RequireResolveDependency.Template = ModuleDependencyAsId;

module.exports = RequireResolveDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireResolveDependencyParserPlugin.js":
/*!**************************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireResolveDependencyParserPlugin.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const RequireResolveDependency = __webpack_require__(/*! ./RequireResolveDependency */ "./node_modules/webpack/lib/dependencies/RequireResolveDependency.js");
const RequireResolveContextDependency = __webpack_require__(/*! ./RequireResolveContextDependency */ "./node_modules/webpack/lib/dependencies/RequireResolveContextDependency.js");
const RequireResolveHeaderDependency = __webpack_require__(/*! ./RequireResolveHeaderDependency */ "./node_modules/webpack/lib/dependencies/RequireResolveHeaderDependency.js");
const ContextDependencyHelpers = __webpack_require__(/*! ./ContextDependencyHelpers */ "./node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js");

class RequireResolveDependencyParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		const options = this.options;

		const process = (expr, weak) => {
			if (expr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
				for (const option of param.options) {
					const result = processItem(expr, option, weak);
					if (result === undefined) {
						processContext(expr, option, weak);
					}
				}
				const dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			} else {
				const result = processItem(expr, param, weak);
				if (result === undefined) {
					processContext(expr, param, weak);
				}
				const dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		const processItem = (expr, param, weak) => {
			if (param.isString()) {
				const dep = new RequireResolveDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				dep.weak = weak;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		const processContext = (expr, param, weak) => {
			const dep = ContextDependencyHelpers.create(
				RequireResolveContextDependency,
				param.range,
				param,
				expr,
				options,
				{
					mode: weak ? "weak" : "sync"
				},
				parser
			);
			if (!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		};

		parser.hooks.call
			.for("require.resolve")
			.tap("RequireResolveDependencyParserPlugin", expr => {
				return process(expr, false);
			});
		parser.hooks.call
			.for("require.resolveWeak")
			.tap("RequireResolveDependencyParserPlugin", expr => {
				return process(expr, true);
			});
	}
}
module.exports = RequireResolveDependencyParserPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/RequireResolveHeaderDependency.js":
/*!********************************************************************!*\
  !*** (webpack)/lib/dependencies/RequireResolveHeaderDependency.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");

class RequireResolveHeaderDependency extends NullDependency {
	constructor(range) {
		super();
		if (!Array.isArray(range)) throw new Error("range must be valid");
		this.range = range;
	}
}

RequireResolveHeaderDependency.Template = class RequireResolveHeaderDependencyTemplate {
	apply(dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
	}

	applyAsTemplateArgument(name, dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
	}
};

module.exports = RequireResolveHeaderDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/SingleEntryDependency.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/dependencies/SingleEntryDependency.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class SingleEntryDependency extends ModuleDependency {
	/**
	 * @param {string} request request path for entry
	 */
	constructor(request) {
		super(request);
	}

	get type() {
		return "single entry";
	}
}

module.exports = SingleEntryDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/SystemPlugin.js":
/*!**************************************************!*\
  !*** (webpack)/lib/dependencies/SystemPlugin.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ParserHelpers = __webpack_require__(/*! ../ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");
const WebpackError = __webpack_require__(/*! ../WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

class SystemPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"SystemPlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = (parser, parserOptions) => {
					if (parserOptions.system !== undefined && !parserOptions.system)
						return;

					const shouldWarn = parserOptions.system === undefined;

					const setNotSupported = name => {
						parser.hooks.evaluateTypeof
							.for(name)
							.tap("SystemPlugin", ParserHelpers.evaluateToString("undefined"));
						parser.hooks.expression
							.for(name)
							.tap(
								"SystemPlugin",
								ParserHelpers.expressionIsUnsupported(
									parser,
									name + " is not supported by webpack."
								)
							);
					};

					parser.hooks.typeof
						.for("System.import")
						.tap(
							"SystemPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
					parser.hooks.evaluateTypeof
						.for("System.import")
						.tap("SystemPlugin", ParserHelpers.evaluateToString("function"));
					parser.hooks.typeof
						.for("System")
						.tap(
							"SystemPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("object")
							)
						);
					parser.hooks.evaluateTypeof
						.for("System")
						.tap("SystemPlugin", ParserHelpers.evaluateToString("object"));

					setNotSupported("System.set");
					setNotSupported("System.get");
					setNotSupported("System.register");

					parser.hooks.expression.for("System").tap("SystemPlugin", () => {
						const systemPolyfillRequire = ParserHelpers.requireFileAsExpression(
							parser.state.module.context,
							/*require.resolve*/(/*! ../../buildin/system */ "./node_modules/webpack/buildin/system.js")
						);
						return ParserHelpers.addParsedVariableToModule(
							parser,
							"System",
							systemPolyfillRequire
						);
					});

					parser.hooks.call.for("System.import").tap("SystemPlugin", expr => {
						if (shouldWarn) {
							parser.state.module.warnings.push(
								new SystemImportDeprecationWarning(
									parser.state.module,
									expr.loc
								)
							);
						}

						return parser.hooks.importCall.call(expr);
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("SystemPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("SystemPlugin", handler);
			}
		);
	}
}

class SystemImportDeprecationWarning extends WebpackError {
	constructor(module, loc) {
		super(
			"System.import() is deprecated and will be removed soon. Use import() instead.\n" +
				"For more info visit https://webpack.js.org/guides/code-splitting/"
		);

		this.name = "SystemImportDeprecationWarning";

		this.module = module;
		this.loc = loc;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = SystemPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/UnsupportedDependency.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/dependencies/UnsupportedDependency.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const NullDependency = __webpack_require__(/*! ./NullDependency */ "./node_modules/webpack/lib/dependencies/NullDependency.js");
const webpackMissingModule = __webpack_require__(/*! ./WebpackMissingModule */ "./node_modules/webpack/lib/dependencies/WebpackMissingModule.js").module;

class UnsupportedDependency extends NullDependency {
	constructor(request, range) {
		super();
		this.request = request;
		this.range = range;
	}
}

UnsupportedDependency.Template = class UnsupportedDependencyTemplate {
	apply(dep, source, runtime) {
		source.replace(
			dep.range[0],
			dep.range[1],
			webpackMissingModule(dep.request)
		);
	}
};

module.exports = UnsupportedDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/WebAssemblyExportImportedDependency.js":
/*!*************************************************************************!*\
  !*** (webpack)/lib/dependencies/WebAssemblyExportImportedDependency.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DependencyReference = __webpack_require__(/*! ./DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");
const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");

class WebAssemblyExportImportedDependency extends ModuleDependency {
	constructor(exportName, request, name, valueType) {
		super(request);
		/** @type {string} */
		this.exportName = exportName;
		/** @type {string} */
		this.name = name;
		/** @type {string} */
		this.valueType = valueType;
	}

	getReference() {
		if (!this.module) return null;
		return new DependencyReference(this.module, [this.name], false);
	}

	get type() {
		return "wasm export import";
	}
}

module.exports = WebAssemblyExportImportedDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/WebAssemblyImportDependency.js":
/*!*****************************************************************!*\
  !*** (webpack)/lib/dependencies/WebAssemblyImportDependency.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const DependencyReference = __webpack_require__(/*! ./DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");
const ModuleDependency = __webpack_require__(/*! ./ModuleDependency */ "./node_modules/webpack/lib/dependencies/ModuleDependency.js");
const UnsupportedWebAssemblyFeatureError = __webpack_require__(/*! ../wasm/UnsupportedWebAssemblyFeatureError */ "./node_modules/webpack/lib/wasm/UnsupportedWebAssemblyFeatureError.js");

/** @typedef {import("@webassemblyjs/ast").ModuleImportDescription} ModuleImportDescription */

class WebAssemblyImportDependency extends ModuleDependency {
	/**
	 * @param {string} request the request
	 * @param {string} name the imported name
	 * @param {ModuleImportDescription} description the WASM ast node
	 * @param {false | string} onlyDirectImport if only direct imports are allowed
	 */
	constructor(request, name, description, onlyDirectImport) {
		super(request);
		/** @type {string} */
		this.name = name;
		/** @type {ModuleImportDescription} */
		this.description = description;
		/** @type {false | string} */
		this.onlyDirectImport = onlyDirectImport;
	}

	getReference() {
		if (!this.module) return null;
		return new DependencyReference(this.module, [this.name], false);
	}

	getErrors() {
		if (
			this.onlyDirectImport &&
			this.module &&
			!this.module.type.startsWith("webassembly")
		) {
			return [
				new UnsupportedWebAssemblyFeatureError(
					`Import "${this.name}" from "${this.request}" with ${
						this.onlyDirectImport
					} can only be used for direct wasm to wasm dependencies`
				)
			];
		}
	}

	get type() {
		return "wasm import";
	}
}

module.exports = WebAssemblyImportDependency;


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/WebpackMissingModule.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/dependencies/WebpackMissingModule.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const toErrorCode = err =>
	`var e = new Error(${JSON.stringify(err)}); e.code = 'MODULE_NOT_FOUND';`;

exports.module = request =>
	`!(function webpackMissingModule() { ${exports.moduleCode(request)} }())`;

exports.promise = request => {
	const errorCode = toErrorCode(`Cannot find module '${request}'`);
	return `Promise.reject(function webpackMissingModule() { ${errorCode} return e; }())`;
};

exports.moduleCode = request => {
	const errorCode = toErrorCode(`Cannot find module '${request}'`);
	return `${errorCode} throw e;`;
};


/***/ }),

/***/ "./node_modules/webpack/lib/dependencies/getFunctionExpression.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/dependencies/getFunctionExpression.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = expr => {
	// <FunctionExpression>
	if (
		expr.type === "FunctionExpression" ||
		expr.type === "ArrowFunctionExpression"
	) {
		return {
			fn: expr,
			expressions: [],
			needThis: false
		};
	}

	// <FunctionExpression>.bind(<Expression>)
	if (
		expr.type === "CallExpression" &&
		expr.callee.type === "MemberExpression" &&
		expr.callee.object.type === "FunctionExpression" &&
		expr.callee.property.type === "Identifier" &&
		expr.callee.property.name === "bind" &&
		expr.arguments.length === 1
	) {
		return {
			fn: expr.callee.object,
			expressions: [expr.arguments[0]],
			needThis: undefined
		};
	}
	// (function(_this) {return <FunctionExpression>})(this) (Coffeescript)
	if (
		expr.type === "CallExpression" &&
		expr.callee.type === "FunctionExpression" &&
		expr.callee.body.type === "BlockStatement" &&
		expr.arguments.length === 1 &&
		expr.arguments[0].type === "ThisExpression" &&
		expr.callee.body.body &&
		expr.callee.body.body.length === 1 &&
		expr.callee.body.body[0].type === "ReturnStatement" &&
		expr.callee.body.body[0].argument &&
		expr.callee.body.body[0].argument.type === "FunctionExpression"
	) {
		return {
			fn: expr.callee.body.body[0].argument,
			expressions: [],
			needThis: true
		};
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/formatLocation.js":
/*!***************************************!*\
  !*** (webpack)/lib/formatLocation.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Dependency").SourcePosition} SourcePosition */

// TODO webpack 5: pos must be SourcePosition
/**
 * @param {SourcePosition|DependencyLocation|string} pos position
 * @returns {string} formatted position
 */
const formatPosition = pos => {
	if (pos === null) return "";
	// TODO webpack 5: Simplify this
	if (typeof pos === "string") return pos;
	if (typeof pos === "number") return `${pos}`;
	if (typeof pos === "object") {
		if ("line" in pos && "column" in pos) {
			return `${pos.line}:${pos.column}`;
		} else if ("line" in pos) {
			return `${pos.line}:?`;
		} else if ("index" in pos) {
			// TODO webpack 5 remove this case
			return `+${pos.index}`;
		} else {
			return "";
		}
	}
	return "";
};

// TODO webpack 5: loc must be DependencyLocation
/**
 * @param {DependencyLocation|SourcePosition|string} loc location
 * @returns {string} formatted location
 */
const formatLocation = loc => {
	if (loc === null) return "";
	// TODO webpack 5: Simplify this
	if (typeof loc === "string") return loc;
	if (typeof loc === "number") return `${loc}`;
	if (typeof loc === "object") {
		if ("start" in loc && loc.start && "end" in loc && loc.end) {
			if (
				typeof loc.start === "object" &&
				typeof loc.start.line === "number" &&
				typeof loc.end === "object" &&
				typeof loc.end.line === "number" &&
				typeof loc.end.column === "number" &&
				loc.start.line === loc.end.line
			) {
				return `${formatPosition(loc.start)}-${loc.end.column}`;
			} else {
				return `${formatPosition(loc.start)}-${formatPosition(loc.end)}`;
			}
		}
		if ("start" in loc && loc.start) {
			return formatPosition(loc.start);
		}
		if ("name" in loc && "index" in loc) {
			return `${loc.name}[${loc.index}]`;
		}
		if ("name" in loc) {
			return loc.name;
		}
		return formatPosition(loc);
	}
	return "";
};

module.exports = formatLocation;


/***/ }),

/***/ "./node_modules/webpack/lib/node sync recursive ^\\.\\/.*$":
/*!****************************************!*\
  !*** (webpack)/lib/node sync ^\.\/.*$ ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./NodeChunkTemplatePlugin": "./node_modules/webpack/lib/node/NodeChunkTemplatePlugin.js",
	"./NodeChunkTemplatePlugin.js": "./node_modules/webpack/lib/node/NodeChunkTemplatePlugin.js",
	"./NodeEnvironmentPlugin": "./node_modules/webpack/lib/node/NodeEnvironmentPlugin.js",
	"./NodeEnvironmentPlugin.js": "./node_modules/webpack/lib/node/NodeEnvironmentPlugin.js",
	"./NodeHotUpdateChunkTemplatePlugin": "./node_modules/webpack/lib/node/NodeHotUpdateChunkTemplatePlugin.js",
	"./NodeHotUpdateChunkTemplatePlugin.js": "./node_modules/webpack/lib/node/NodeHotUpdateChunkTemplatePlugin.js",
	"./NodeMainTemplate.runtime": "./node_modules/webpack/lib/node/NodeMainTemplate.runtime.js",
	"./NodeMainTemplate.runtime.js": "./node_modules/webpack/lib/node/NodeMainTemplate.runtime.js",
	"./NodeMainTemplateAsync.runtime": "./node_modules/webpack/lib/node/NodeMainTemplateAsync.runtime.js",
	"./NodeMainTemplateAsync.runtime.js": "./node_modules/webpack/lib/node/NodeMainTemplateAsync.runtime.js",
	"./NodeMainTemplatePlugin": "./node_modules/webpack/lib/node/NodeMainTemplatePlugin.js",
	"./NodeMainTemplatePlugin.js": "./node_modules/webpack/lib/node/NodeMainTemplatePlugin.js",
	"./NodeOutputFileSystem": "./node_modules/webpack/lib/node/NodeOutputFileSystem.js",
	"./NodeOutputFileSystem.js": "./node_modules/webpack/lib/node/NodeOutputFileSystem.js",
	"./NodeSourcePlugin": "./node_modules/webpack/lib/node/NodeSourcePlugin.js",
	"./NodeSourcePlugin.js": "./node_modules/webpack/lib/node/NodeSourcePlugin.js",
	"./NodeTargetPlugin": "./node_modules/webpack/lib/node/NodeTargetPlugin.js",
	"./NodeTargetPlugin.js": "./node_modules/webpack/lib/node/NodeTargetPlugin.js",
	"./NodeTemplatePlugin": "./node_modules/webpack/lib/node/NodeTemplatePlugin.js",
	"./NodeTemplatePlugin.js": "./node_modules/webpack/lib/node/NodeTemplatePlugin.js",
	"./NodeWatchFileSystem": "./node_modules/webpack/lib/node/NodeWatchFileSystem.js",
	"./NodeWatchFileSystem.js": "./node_modules/webpack/lib/node/NodeWatchFileSystem.js",
	"./ReadFileCompileWasmTemplatePlugin": "./node_modules/webpack/lib/node/ReadFileCompileWasmTemplatePlugin.js",
	"./ReadFileCompileWasmTemplatePlugin.js": "./node_modules/webpack/lib/node/ReadFileCompileWasmTemplatePlugin.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/webpack/lib/node sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeChunkTemplatePlugin.js":
/*!*****************************************************!*\
  !*** (webpack)/lib/node/NodeChunkTemplatePlugin.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

class NodeChunkTemplatePlugin {
	apply(chunkTemplate) {
		chunkTemplate.hooks.render.tap(
			"NodeChunkTemplatePlugin",
			(modules, chunk) => {
				const source = new ConcatSource();
				source.add(
					`exports.ids = ${JSON.stringify(chunk.ids)};\nexports.modules = `
				);
				source.add(modules);
				source.add(";");
				return source;
			}
		);
		chunkTemplate.hooks.hash.tap("NodeChunkTemplatePlugin", hash => {
			hash.update("node");
			hash.update("3");
		});
	}
}

module.exports = NodeChunkTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeEnvironmentPlugin.js":
/*!***************************************************!*\
  !*** (webpack)/lib/node/NodeEnvironmentPlugin.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const NodeWatchFileSystem = __webpack_require__(/*! ./NodeWatchFileSystem */ "./node_modules/webpack/lib/node/NodeWatchFileSystem.js");
const NodeOutputFileSystem = __webpack_require__(/*! ./NodeOutputFileSystem */ "./node_modules/webpack/lib/node/NodeOutputFileSystem.js");
const NodeJsInputFileSystem = __webpack_require__(/*! enhanced-resolve/lib/NodeJsInputFileSystem */ "enhanced-resolve/lib/NodeJsInputFileSystem");
const CachedInputFileSystem = __webpack_require__(/*! enhanced-resolve/lib/CachedInputFileSystem */ "enhanced-resolve/lib/CachedInputFileSystem");

class NodeEnvironmentPlugin {
	apply(compiler) {
		compiler.inputFileSystem = new CachedInputFileSystem(
			new NodeJsInputFileSystem(),
			60000
		);
		const inputFileSystem = compiler.inputFileSystem;
		compiler.outputFileSystem = new NodeOutputFileSystem();
		compiler.watchFileSystem = new NodeWatchFileSystem(
			compiler.inputFileSystem
		);
		compiler.hooks.beforeRun.tap("NodeEnvironmentPlugin", compiler => {
			if (compiler.inputFileSystem === inputFileSystem) inputFileSystem.purge();
		});
	}
}
module.exports = NodeEnvironmentPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeHotUpdateChunkTemplatePlugin.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/node/NodeHotUpdateChunkTemplatePlugin.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

class NodeHotUpdateChunkTemplatePlugin {
	apply(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.hooks.render.tap(
			"NodeHotUpdateChunkTemplatePlugin",
			(modulesSource, modules, removedModules, hash, id) => {
				const source = new ConcatSource();
				source.add(
					"exports.id = " + JSON.stringify(id) + ";\nexports.modules = "
				);
				source.add(modulesSource);
				source.add(";");
				return source;
			}
		);
		hotUpdateChunkTemplate.hooks.hash.tap(
			"NodeHotUpdateChunkTemplatePlugin",
			hash => {
				hash.update("NodeHotUpdateChunkTemplatePlugin");
				hash.update("3");
				hash.update(
					hotUpdateChunkTemplate.outputOptions.hotUpdateFunction + ""
				);
				hash.update(hotUpdateChunkTemplate.outputOptions.library + "");
			}
		);
	}
}
module.exports = NodeHotUpdateChunkTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeMainTemplate.runtime.js":
/*!******************************************************!*\
  !*** (webpack)/lib/node/NodeMainTemplate.runtime.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*global installedChunks $hotChunkFilename$ hotAddUpdateChunk $hotMainFilename$ */
module.exports = function() {
	// eslint-disable-next-line no-unused-vars
	function hotDownloadUpdateChunk(chunkId) {
		var chunk = __webpack_require__("./node_modules/webpack/lib/node sync recursive ^\\.\\/.*$")("./" + $hotChunkFilename$);
		hotAddUpdateChunk(chunk.id, chunk.modules);
	}

	// eslint-disable-next-line no-unused-vars
	function hotDownloadManifest() {
		try {
			var update = __webpack_require__("./node_modules/webpack/lib/node sync recursive ^\\.\\/.*$")("./" + $hotMainFilename$);
		} catch (e) {
			return Promise.resolve();
		}
		return Promise.resolve(update);
	}

	//eslint-disable-next-line no-unused-vars
	function hotDisposeChunk(chunkId) {
		delete installedChunks[chunkId];
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeMainTemplateAsync.runtime.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/node/NodeMainTemplateAsync.runtime.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname) {/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*global installedChunks $hotChunkFilename$ $require$ hotAddUpdateChunk $hotMainFilename$ */
module.exports = function() {
	// eslint-disable-next-line no-unused-vars
	function hotDownloadUpdateChunk(chunkId) {
		var filename = __webpack_require__(/*! path */ "path").join(__dirname, $hotChunkFilename$);
		__webpack_require__(/*! fs */ "fs").readFile(filename, "utf-8", function(err, content) {
			if (err) {
				if ($require$.onError) return $require$.oe(err);
				throw err;
			}
			var chunk = {};
			__webpack_require__(/*! vm */ "vm").runInThisContext(
				"(function(exports) {" + content + "\n})",
				{ filename: filename }
			)(chunk);
			hotAddUpdateChunk(chunk.id, chunk.modules);
		});
	}

	// eslint-disable-next-line no-unused-vars
	function hotDownloadManifest() {
		var filename = __webpack_require__(/*! path */ "path").join(__dirname, $hotMainFilename$);
		return new Promise(function(resolve, reject) {
			__webpack_require__(/*! fs */ "fs").readFile(filename, "utf-8", function(err, content) {
				if (err) return resolve();
				try {
					var update = JSON.parse(content);
				} catch (e) {
					return reject(e);
				}
				resolve(update);
			});
		});
	}

	// eslint-disable-next-line no-unused-vars
	function hotDisposeChunk(chunkId) {
		delete installedChunks[chunkId];
	}
};

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeMainTemplatePlugin.js":
/*!****************************************************!*\
  !*** (webpack)/lib/node/NodeMainTemplatePlugin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");

module.exports = class NodeMainTemplatePlugin {
	constructor(asyncChunkLoading) {
		this.asyncChunkLoading = asyncChunkLoading;
	}

	apply(mainTemplate) {
		const needChunkOnDemandLoadingCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.getNumberOfChildren() > 0) return true;
			}
			return false;
		};
		const asyncChunkLoading = this.asyncChunkLoading;
		mainTemplate.hooks.localVars.tap(
			"NodeMainTemplatePlugin",
			(source, chunk) => {
				if (needChunkOnDemandLoadingCode(chunk)) {
					return Template.asString([
						source,
						"",
						"// object to store loaded chunks",
						'// "0" means "already loaded"',
						"var installedChunks = {",
						Template.indent(
							chunk.ids.map(id => `${JSON.stringify(id)}: 0`).join(",\n")
						),
						"};"
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.requireExtensions.tap(
			"NodeMainTemplatePlugin",
			(source, chunk) => {
				if (needChunkOnDemandLoadingCode(chunk)) {
					return Template.asString([
						source,
						"",
						"// uncaught error handler for webpack runtime",
						`${mainTemplate.requireFn}.oe = function(err) {`,
						Template.indent([
							"process.nextTick(function() {",
							Template.indent(
								"throw err; // catch this error by using import().catch()"
							),
							"});"
						]),
						"};"
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			"NodeMainTemplatePlugin",
			(source, chunk, hash) => {
				const chunkFilename = mainTemplate.outputOptions.chunkFilename;
				const chunkMaps = chunk.getChunkMaps();
				const insertMoreModules = [
					"var moreModules = chunk.modules, chunkIds = chunk.ids;",
					"for(var moduleId in moreModules) {",
					Template.indent(
						mainTemplate.renderAddModule(
							hash,
							chunk,
							"moduleId",
							"moreModules[moduleId]"
						)
					),
					"}"
				];
				if (asyncChunkLoading) {
					return Template.asString([
						source,
						"",
						"// ReadFile + VM.run chunk loading for javascript",
						"",
						"var installedChunkData = installedChunks[chunkId];",
						'if(installedChunkData !== 0) { // 0 means "already installed".',
						Template.indent([
							'// array of [resolve, reject, promise] means "currently loading"',
							"if(installedChunkData) {",
							Template.indent(["promises.push(installedChunkData[2]);"]),
							"} else {",
							Template.indent([
								"// load the chunk and return promise to it",
								"var promise = new Promise(function(resolve, reject) {",
								Template.indent([
									"installedChunkData = installedChunks[chunkId] = [resolve, reject];",
									"var filename = require('path').join(__dirname, " +
										mainTemplate.getAssetPath(
											JSON.stringify(`/${chunkFilename}`),
											{
												hash: `" + ${mainTemplate.renderCurrentHashCode(
													hash
												)} + "`,
												hashWithLength: length =>
													`" + ${mainTemplate.renderCurrentHashCode(
														hash,
														length
													)} + "`,
												chunk: {
													id: '" + chunkId + "',
													hash: `" + ${JSON.stringify(
														chunkMaps.hash
													)}[chunkId] + "`,
													hashWithLength: length => {
														const shortChunkHashMap = {};
														for (const chunkId of Object.keys(chunkMaps.hash)) {
															if (typeof chunkMaps.hash[chunkId] === "string") {
																shortChunkHashMap[chunkId] = chunkMaps.hash[
																	chunkId
																].substr(0, length);
															}
														}
														return `" + ${JSON.stringify(
															shortChunkHashMap
														)}[chunkId] + "`;
													},
													contentHash: {
														javascript: `" + ${JSON.stringify(
															chunkMaps.contentHash.javascript
														)}[chunkId] + "`
													},
													contentHashWithLength: {
														javascript: length => {
															const shortContentHashMap = {};
															const contentHash =
																chunkMaps.contentHash.javascript;
															for (const chunkId of Object.keys(contentHash)) {
																if (typeof contentHash[chunkId] === "string") {
																	shortContentHashMap[chunkId] = contentHash[
																		chunkId
																	].substr(0, length);
																}
															}
															return `" + ${JSON.stringify(
																shortContentHashMap
															)}[chunkId] + "`;
														}
													},
													name: `" + (${JSON.stringify(
														chunkMaps.name
													)}[chunkId]||chunkId) + "`
												},
												contentHashType: "javascript"
											}
										) +
										");",
									"require('fs').readFile(filename, 'utf-8',  function(err, content) {",
									Template.indent(
										[
											"if(err) return reject(err);",
											"var chunk = {};",
											"require('vm').runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\\n})', filename)" +
												"(chunk, require, require('path').dirname(filename), filename);"
										]
											.concat(insertMoreModules)
											.concat([
												"var callbacks = [];",
												"for(var i = 0; i < chunkIds.length; i++) {",
												Template.indent([
													"if(installedChunks[chunkIds[i]])",
													Template.indent([
														"callbacks = callbacks.concat(installedChunks[chunkIds[i]][0]);"
													]),
													"installedChunks[chunkIds[i]] = 0;"
												]),
												"}",
												"for(i = 0; i < callbacks.length; i++)",
												Template.indent("callbacks[i]();")
											])
									),
									"});"
								]),
								"});",
								"promises.push(installedChunkData[2] = promise);"
							]),
							"}"
						]),
						"}"
					]);
				} else {
					const request = mainTemplate.getAssetPath(
						JSON.stringify(`./${chunkFilename}`),
						{
							hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
							hashWithLength: length =>
								`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
							chunk: {
								id: '" + chunkId + "',
								hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
								hashWithLength: length => {
									const shortChunkHashMap = {};
									for (const chunkId of Object.keys(chunkMaps.hash)) {
										if (typeof chunkMaps.hash[chunkId] === "string") {
											shortChunkHashMap[chunkId] = chunkMaps.hash[
												chunkId
											].substr(0, length);
										}
									}
									return `" + ${JSON.stringify(
										shortChunkHashMap
									)}[chunkId] + "`;
								},
								contentHash: {
									javascript: `" + ${JSON.stringify(
										chunkMaps.contentHash.javascript
									)}[chunkId] + "`
								},
								contentHashWithLength: {
									javascript: length => {
										const shortContentHashMap = {};
										const contentHash = chunkMaps.contentHash.javascript;
										for (const chunkId of Object.keys(contentHash)) {
											if (typeof contentHash[chunkId] === "string") {
												shortContentHashMap[chunkId] = contentHash[
													chunkId
												].substr(0, length);
											}
										}
										return `" + ${JSON.stringify(
											shortContentHashMap
										)}[chunkId] + "`;
									}
								},
								name: `" + (${JSON.stringify(
									chunkMaps.name
								)}[chunkId]||chunkId) + "`
							},
							contentHashType: "javascript"
						}
					);
					return Template.asString([
						source,
						"",
						"// require() chunk loading for javascript",
						"",
						'// "0" is the signal for "already loaded"',
						"if(installedChunks[chunkId] !== 0) {",
						Template.indent(
							[`var chunk = require(${request});`]
								.concat(insertMoreModules)
								.concat([
									"for(var i = 0; i < chunkIds.length; i++)",
									Template.indent("installedChunks[chunkIds[i]] = 0;")
								])
						),
						"}"
					]);
				}
			}
		);
		mainTemplate.hooks.hotBootstrap.tap(
			"NodeMainTemplatePlugin",
			(source, chunk, hash) => {
				const hotUpdateChunkFilename =
					mainTemplate.outputOptions.hotUpdateChunkFilename;
				const hotUpdateMainFilename =
					mainTemplate.outputOptions.hotUpdateMainFilename;
				const chunkMaps = chunk.getChunkMaps();
				const currentHotUpdateChunkFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateChunkFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
						chunk: {
							id: '" + chunkId + "',
							hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
							hashWithLength: length => {
								const shortChunkHashMap = {};
								for (const chunkId of Object.keys(chunkMaps.hash)) {
									if (typeof chunkMaps.hash[chunkId] === "string") {
										shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(
											0,
											length
										);
									}
								}
								return `" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + "`;
							},
							name: `" + (${JSON.stringify(
								chunkMaps.name
							)}[chunkId]||chunkId) + "`
						}
					}
				);
				const currentHotUpdateMainFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateMainFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
					}
				);
				return Template.getFunctionContent(
					asyncChunkLoading
						? __webpack_require__(/*! ./NodeMainTemplateAsync.runtime */ "./node_modules/webpack/lib/node/NodeMainTemplateAsync.runtime.js")
						: __webpack_require__(/*! ./NodeMainTemplate.runtime */ "./node_modules/webpack/lib/node/NodeMainTemplate.runtime.js")
				)
					.replace(/\$require\$/g, mainTemplate.requireFn)
					.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
					.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename);
			}
		);
		mainTemplate.hooks.hash.tap("NodeMainTemplatePlugin", hash => {
			hash.update("node");
			hash.update("4");
		});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeOutputFileSystem.js":
/*!**************************************************!*\
  !*** (webpack)/lib/node/NodeOutputFileSystem.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const mkdirp = __webpack_require__(/*! mkdirp */ "mkdirp");

class NodeOutputFileSystem {
	constructor() {
		this.mkdirp = mkdirp;
		this.mkdir = fs.mkdir.bind(fs);
		this.rmdir = fs.rmdir.bind(fs);
		this.unlink = fs.unlink.bind(fs);
		this.writeFile = fs.writeFile.bind(fs);
		this.join = path.join.bind(path);
	}
}

module.exports = NodeOutputFileSystem;


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeSourcePlugin.js":
/*!**********************************************!*\
  !*** (webpack)/lib/node/NodeSourcePlugin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const AliasPlugin = __webpack_require__(/*! enhanced-resolve/lib/AliasPlugin */ "enhanced-resolve/lib/AliasPlugin");
const ParserHelpers = __webpack_require__(/*! ../ParserHelpers */ "./node_modules/webpack/lib/ParserHelpers.js");
const nodeLibsBrowser = __webpack_require__(/*! node-libs-browser */ "node-libs-browser");

module.exports = class NodeSourcePlugin {
	constructor(options) {
		this.options = options;
	}
	apply(compiler) {
		const options = this.options;
		if (options === false) {
			// allow single kill switch to turn off this plugin
			return;
		}

		const getPathToModule = (module, type) => {
			if (type === true || (type === undefined && nodeLibsBrowser[module])) {
				if (!nodeLibsBrowser[module]) {
					throw new Error(
						`No browser version for node.js core module ${module} available`
					);
				}
				return nodeLibsBrowser[module];
			} else if (type === "mock") {
				return /*require.resolve*/(__webpack_require__("./node_modules/node-libs-browser/mock sync recursive ^\\.\\/.*$").resolve(`./${module}`));
			} else if (type === "empty") {
				return /*require.resolve*/(/*! node-libs-browser/mock/empty */ "node-libs-browser/mock/empty");
			} else {
				return module;
			}
		};

		const addExpression = (parser, name, module, type, suffix) => {
			suffix = suffix || "";
			parser.hooks.expression.for(name).tap("NodeSourcePlugin", () => {
				if (
					parser.state.module &&
					parser.state.module.resource === getPathToModule(module, type)
				)
					return;
				const mockModule = ParserHelpers.requireFileAsExpression(
					parser.state.module.context,
					getPathToModule(module, type)
				);
				return ParserHelpers.addParsedVariableToModule(
					parser,
					name,
					mockModule + suffix
				);
			});
		};

		compiler.hooks.compilation.tap(
			"NodeSourcePlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = (parser, parserOptions) => {
					if (parserOptions.node === false) return;

					let localOptions = options;
					if (parserOptions.node) {
						localOptions = Object.assign({}, localOptions, parserOptions.node);
					}
					if (localOptions.global) {
						parser.hooks.expression
							.for("global")
							.tap("NodeSourcePlugin", () => {
								const retrieveGlobalModule = ParserHelpers.requireFileAsExpression(
									parser.state.module.context,
									/*require.resolve*/(/*! ../../buildin/global */ "./node_modules/webpack/buildin/global.js")
								);
								return ParserHelpers.addParsedVariableToModule(
									parser,
									"global",
									retrieveGlobalModule
								);
							});
					}
					if (localOptions.process) {
						const processType = localOptions.process;
						addExpression(parser, "process", "process", processType);
					}
					if (localOptions.console) {
						const consoleType = localOptions.console;
						addExpression(parser, "console", "console", consoleType);
					}
					const bufferType = localOptions.Buffer;
					if (bufferType) {
						addExpression(parser, "Buffer", "buffer", bufferType, ".Buffer");
					}
					if (localOptions.setImmediate) {
						const setImmediateType = localOptions.setImmediate;
						addExpression(
							parser,
							"setImmediate",
							"timers",
							setImmediateType,
							".setImmediate"
						);
						addExpression(
							parser,
							"clearImmediate",
							"timers",
							setImmediateType,
							".clearImmediate"
						);
					}
				};
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("NodeSourcePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("NodeSourcePlugin", handler);
			}
		);
		compiler.hooks.afterResolvers.tap("NodeSourcePlugin", compiler => {
			for (const lib of Object.keys(nodeLibsBrowser)) {
				if (options[lib] !== false) {
					compiler.resolverFactory.hooks.resolver
						.for("normal")
						.tap("NodeSourcePlugin", resolver => {
							new AliasPlugin(
								"described-resolve",
								{
									name: lib,
									onlyModule: true,
									alias: getPathToModule(lib, options[lib])
								},
								"resolve"
							).apply(resolver);
						});
				}
			}
		});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeTargetPlugin.js":
/*!**********************************************!*\
  !*** (webpack)/lib/node/NodeTargetPlugin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const ExternalsPlugin = __webpack_require__(/*! ../ExternalsPlugin */ "./node_modules/webpack/lib/ExternalsPlugin.js");

const builtins =
	// eslint-disable-next-line node/no-unsupported-features/node-builtins,node/no-deprecated-api
	__webpack_require__(/*! module */ "module").builtinModules || Object.keys(process.binding("natives"));

class NodeTargetPlugin {
	apply(compiler) {
		new ExternalsPlugin("commonjs", builtins).apply(compiler);
	}
}

module.exports = NodeTargetPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeTemplatePlugin.js":
/*!************************************************!*\
  !*** (webpack)/lib/node/NodeTemplatePlugin.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



const NodeMainTemplatePlugin = __webpack_require__(/*! ./NodeMainTemplatePlugin */ "./node_modules/webpack/lib/node/NodeMainTemplatePlugin.js");
const NodeChunkTemplatePlugin = __webpack_require__(/*! ./NodeChunkTemplatePlugin */ "./node_modules/webpack/lib/node/NodeChunkTemplatePlugin.js");
const NodeHotUpdateChunkTemplatePlugin = __webpack_require__(/*! ./NodeHotUpdateChunkTemplatePlugin */ "./node_modules/webpack/lib/node/NodeHotUpdateChunkTemplatePlugin.js");

class NodeTemplatePlugin {
	constructor(options) {
		options = options || {};
		this.asyncChunkLoading = options.asyncChunkLoading;
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap("NodeTemplatePlugin", compilation => {
			new NodeMainTemplatePlugin(this.asyncChunkLoading).apply(
				compilation.mainTemplate
			);
			new NodeChunkTemplatePlugin().apply(compilation.chunkTemplate);
			new NodeHotUpdateChunkTemplatePlugin().apply(
				compilation.hotUpdateChunkTemplate
			);
		});
	}
}

module.exports = NodeTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/node/NodeWatchFileSystem.js":
/*!*************************************************!*\
  !*** (webpack)/lib/node/NodeWatchFileSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Watchpack = __webpack_require__(/*! watchpack */ "watchpack");
const objectToMap = __webpack_require__(/*! ../util/objectToMap */ "./node_modules/webpack/lib/util/objectToMap.js");

class NodeWatchFileSystem {
	constructor(inputFileSystem) {
		this.inputFileSystem = inputFileSystem;
		this.watcherOptions = {
			aggregateTimeout: 0
		};
		this.watcher = new Watchpack(this.watcherOptions);
	}

	watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
		if (!Array.isArray(files)) {
			throw new Error("Invalid arguments: 'files'");
		}
		if (!Array.isArray(dirs)) {
			throw new Error("Invalid arguments: 'dirs'");
		}
		if (!Array.isArray(missing)) {
			throw new Error("Invalid arguments: 'missing'");
		}
		if (typeof callback !== "function") {
			throw new Error("Invalid arguments: 'callback'");
		}
		if (typeof startTime !== "number" && startTime) {
			throw new Error("Invalid arguments: 'startTime'");
		}
		if (typeof options !== "object") {
			throw new Error("Invalid arguments: 'options'");
		}
		if (typeof callbackUndelayed !== "function" && callbackUndelayed) {
			throw new Error("Invalid arguments: 'callbackUndelayed'");
		}
		const oldWatcher = this.watcher;
		this.watcher = new Watchpack(options);

		if (callbackUndelayed) {
			this.watcher.once("change", callbackUndelayed);
		}
		const cachedFiles = files;
		const cachedDirs = dirs;
		this.watcher.once("aggregated", (changes, removals) => {
			changes = changes.concat(removals);
			if (this.inputFileSystem && this.inputFileSystem.purge) {
				this.inputFileSystem.purge(changes);
			}
			const times = objectToMap(this.watcher.getTimes());
			files = new Set(files);
			dirs = new Set(dirs);
			missing = new Set(missing);
			removals = new Set(removals.filter(file => files.has(file)));
			callback(
				null,
				changes.filter(file => files.has(file)).sort(),
				changes.filter(file => dirs.has(file)).sort(),
				changes.filter(file => missing.has(file)).sort(),
				times,
				times,
				removals
			);
		});

		this.watcher.watch(
			cachedFiles.concat(missing),
			cachedDirs.concat(missing),
			startTime
		);

		if (oldWatcher) {
			oldWatcher.close();
		}
		return {
			close: () => {
				if (this.watcher) {
					this.watcher.close();
					this.watcher = null;
				}
			},
			pause: () => {
				if (this.watcher) {
					this.watcher.pause();
				}
			},
			getFileTimestamps: () => {
				if (this.watcher) {
					return objectToMap(this.watcher.getTimes());
				} else {
					return new Map();
				}
			},
			getContextTimestamps: () => {
				if (this.watcher) {
					return objectToMap(this.watcher.getTimes());
				} else {
					return new Map();
				}
			}
		};
	}
}

module.exports = NodeWatchFileSystem;


/***/ }),

/***/ "./node_modules/webpack/lib/node/ReadFileCompileWasmTemplatePlugin.js":
/*!***************************************************************!*\
  !*** (webpack)/lib/node/ReadFileCompileWasmTemplatePlugin.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");
const WasmMainTemplatePlugin = __webpack_require__(/*! ../wasm/WasmMainTemplatePlugin */ "./node_modules/webpack/lib/wasm/WasmMainTemplatePlugin.js");

class ReadFileCompileWasmTemplatePlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"ReadFileCompileWasmTemplatePlugin",
			compilation => {
				const generateLoadBinaryCode = path =>
					Template.asString([
						"new Promise(function (resolve, reject) {",
						Template.indent([
							"var { readFile } = require('fs');",
							"var { join } = require('path');",
							"",
							"try {",
							Template.indent([
								`readFile(join(__dirname, ${path}), function(err, buffer){`,
								Template.indent([
									"if (err) return reject(err);",
									"",
									"// Fake fetch response",
									"resolve({",
									Template.indent([
										"arrayBuffer() { return Promise.resolve(buffer); }"
									]),
									"});"
								]),
								"});"
							]),
							"} catch (err) { reject(err); }"
						]),
						"})"
					]);

				const plugin = new WasmMainTemplatePlugin(
					Object.assign(
						{
							generateLoadBinaryCode,
							supportsStreaming: false
						},
						this.options
					)
				);
				plugin.apply(compilation.mainTemplate);
			}
		);
	}
}

module.exports = ReadFileCompileWasmTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/AggressiveMergingPlugin.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/optimize/AggressiveMergingPlugin.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class AggressiveMergingPlugin {
	constructor(options) {
		if (
			(options !== undefined && typeof options !== "object") ||
			Array.isArray(options)
		) {
			throw new Error(
				"Argument should be an options object. To use defaults, pass in nothing.\nFor more info on options, see https://webpack.js.org/plugins/"
			);
		}
		this.options = options || {};
	}

	apply(compiler) {
		const options = this.options;
		const minSizeReduce = options.minSizeReduce || 1.5;

		compiler.hooks.thisCompilation.tap(
			"AggressiveMergingPlugin",
			compilation => {
				compilation.hooks.optimizeChunksAdvanced.tap(
					"AggressiveMergingPlugin",
					chunks => {
						let combinations = [];
						chunks.forEach((a, idx) => {
							if (a.canBeInitial()) return;
							for (let i = 0; i < idx; i++) {
								const b = chunks[i];
								if (b.canBeInitial()) continue;
								combinations.push({
									a,
									b,
									improvement: undefined
								});
							}
						});

						for (const pair of combinations) {
							const a = pair.b.size({
								chunkOverhead: 0
							});
							const b = pair.a.size({
								chunkOverhead: 0
							});
							const ab = pair.b.integratedSize(pair.a, {
								chunkOverhead: 0
							});
							let newSize;
							if (ab === false) {
								pair.improvement = false;
								return;
							} else {
								newSize = ab;
							}

							pair.improvement = (a + b) / newSize;
						}
						combinations = combinations.filter(pair => {
							return pair.improvement !== false;
						});
						combinations.sort((a, b) => {
							return b.improvement - a.improvement;
						});

						const pair = combinations[0];

						if (!pair) return;
						if (pair.improvement < minSizeReduce) return;

						if (pair.b.integrate(pair.a, "aggressive-merge")) {
							chunks.splice(chunks.indexOf(pair.a), 1);
							return true;
						}
					}
				);
			}
		);
	}
}

module.exports = AggressiveMergingPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/optimize/AggressiveSplittingPlugin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const identifierUtils = __webpack_require__(/*! ../util/identifier */ "./node_modules/webpack/lib/util/identifier.js");
const { intersect } = __webpack_require__(/*! ../util/SetHelpers */ "./node_modules/webpack/lib/util/SetHelpers.js");
const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../../schemas/plugins/optimize/AggressiveSplittingPlugin.json */ "./node_modules/webpack/schemas/plugins/optimize/AggressiveSplittingPlugin.json");

/** @typedef {import("../../declarations/plugins/optimize/AggressiveSplittingPlugin").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */

const moveModuleBetween = (oldChunk, newChunk) => {
	return module => {
		oldChunk.moveModule(module, newChunk);
	};
};

const isNotAEntryModule = entryModule => {
	return module => {
		return entryModule !== module;
	};
};

class AggressiveSplittingPlugin {
	/**
	 * @param {AggressiveSplittingPluginOptions=} options options object
	 */
	constructor(options) {
		if (!options) options = {};

		validateOptions(schema, options, "Aggressive Splitting Plugin");

		this.options = options;
		if (typeof this.options.minSize !== "number") {
			this.options.minSize = 30 * 1024;
		}
		if (typeof this.options.maxSize !== "number") {
			this.options.maxSize = 50 * 1024;
		}
		if (typeof this.options.chunkOverhead !== "number") {
			this.options.chunkOverhead = 0;
		}
		if (typeof this.options.entryChunkMultiplicator !== "number") {
			this.options.entryChunkMultiplicator = 1;
		}
	}
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"AggressiveSplittingPlugin",
			compilation => {
				let needAdditionalSeal = false;
				let newSplits;
				let fromAggressiveSplittingSet;
				let chunkSplitDataMap;
				compilation.hooks.optimize.tap("AggressiveSplittingPlugin", () => {
					newSplits = [];
					fromAggressiveSplittingSet = new Set();
					chunkSplitDataMap = new Map();
				});
				compilation.hooks.optimizeChunksAdvanced.tap(
					"AggressiveSplittingPlugin",
					chunks => {
						// Precompute stuff
						const nameToModuleMap = new Map();
						const moduleToNameMap = new Map();
						for (const m of compilation.modules) {
							const name = identifierUtils.makePathsRelative(
								compiler.context,
								m.identifier(),
								compilation.cache
							);
							nameToModuleMap.set(name, m);
							moduleToNameMap.set(m, name);
						}

						// Check used chunk ids
						const usedIds = new Set();
						for (const chunk of chunks) {
							usedIds.add(chunk.id);
						}

						const recordedSplits =
							(compilation.records && compilation.records.aggressiveSplits) ||
							[];
						const usedSplits = newSplits
							? recordedSplits.concat(newSplits)
							: recordedSplits;

						const minSize = this.options.minSize;
						const maxSize = this.options.maxSize;

						const applySplit = splitData => {
							// Cannot split if id is already taken
							if (splitData.id !== undefined && usedIds.has(splitData.id)) {
								return false;
							}

							// Get module objects from names
							const selectedModules = splitData.modules.map(name =>
								nameToModuleMap.get(name)
							);

							// Does the modules exist at all?
							if (!selectedModules.every(Boolean)) return false;

							// Check if size matches (faster than waiting for hash)
							const size = selectedModules.reduce(
								(sum, m) => sum + m.size(),
								0
							);
							if (size !== splitData.size) return false;

							// get chunks with all modules
							const selectedChunks = intersect(
								selectedModules.map(m => new Set(m.chunksIterable))
							);

							// No relevant chunks found
							if (selectedChunks.size === 0) return false;

							// The found chunk is already the split or similar
							if (
								selectedChunks.size === 1 &&
								Array.from(selectedChunks)[0].getNumberOfModules() ===
									selectedModules.length
							) {
								const chunk = Array.from(selectedChunks)[0];
								if (fromAggressiveSplittingSet.has(chunk)) return false;
								fromAggressiveSplittingSet.add(chunk);
								chunkSplitDataMap.set(chunk, splitData);
								return true;
							}

							// split the chunk into two parts
							const newChunk = compilation.addChunk();
							newChunk.chunkReason = "aggressive splitted";
							for (const chunk of selectedChunks) {
								selectedModules.forEach(moveModuleBetween(chunk, newChunk));
								chunk.split(newChunk);
								chunk.name = null;
							}
							fromAggressiveSplittingSet.add(newChunk);
							chunkSplitDataMap.set(newChunk, splitData);

							if (splitData.id !== null && splitData.id !== undefined) {
								newChunk.id = splitData.id;
							}
							return true;
						};

						// try to restore to recorded splitting
						let changed = false;
						for (let j = 0; j < usedSplits.length; j++) {
							const splitData = usedSplits[j];
							if (applySplit(splitData)) changed = true;
						}

						// for any chunk which isn't splitted yet, split it and create a new entry
						// start with the biggest chunk
						const sortedChunks = chunks.slice().sort((a, b) => {
							const diff1 = b.modulesSize() - a.modulesSize();
							if (diff1) return diff1;
							const diff2 = a.getNumberOfModules() - b.getNumberOfModules();
							if (diff2) return diff2;
							const modulesA = Array.from(a.modulesIterable);
							const modulesB = Array.from(b.modulesIterable);
							modulesA.sort();
							modulesB.sort();
							const aI = modulesA[Symbol.iterator]();
							const bI = modulesB[Symbol.iterator]();
							// eslint-disable-next-line no-constant-condition
							while (true) {
								const aItem = aI.next();
								const bItem = bI.next();
								if (aItem.done) return 0;
								const aModuleIdentifier = aItem.value.identifier();
								const bModuleIdentifier = bItem.value.identifier();
								if (aModuleIdentifier > bModuleIdentifier) return -1;
								if (aModuleIdentifier < bModuleIdentifier) return 1;
							}
						});
						for (const chunk of sortedChunks) {
							if (fromAggressiveSplittingSet.has(chunk)) continue;
							const size = chunk.modulesSize();
							if (size > maxSize && chunk.getNumberOfModules() > 1) {
								const modules = chunk
									.getModules()
									.filter(isNotAEntryModule(chunk.entryModule))
									.sort((a, b) => {
										a = a.identifier();
										b = b.identifier();
										if (a > b) return 1;
										if (a < b) return -1;
										return 0;
									});
								const selectedModules = [];
								let selectedModulesSize = 0;
								for (let k = 0; k < modules.length; k++) {
									const module = modules[k];
									const newSize = selectedModulesSize + module.size();
									if (newSize > maxSize && selectedModulesSize >= minSize) {
										break;
									}
									selectedModulesSize = newSize;
									selectedModules.push(module);
								}
								if (selectedModules.length === 0) continue;
								const splitData = {
									modules: selectedModules
										.map(m => moduleToNameMap.get(m))
										.sort(),
									size: selectedModulesSize
								};

								if (applySplit(splitData)) {
									newSplits = (newSplits || []).concat(splitData);
									changed = true;
								}
							}
						}
						if (changed) return true;
					}
				);
				compilation.hooks.recordHash.tap(
					"AggressiveSplittingPlugin",
					records => {
						// 4. save made splittings to records
						const allSplits = new Set();
						const invalidSplits = new Set();

						// Check if some splittings are invalid
						// We remove invalid splittings and try again
						for (const chunk of compilation.chunks) {
							const splitData = chunkSplitDataMap.get(chunk);
							if (splitData !== undefined) {
								if (splitData.hash && chunk.hash !== splitData.hash) {
									// Split was successful, but hash doesn't equal
									// We can throw away the split since it's useless now
									invalidSplits.add(splitData);
								}
							}
						}

						if (invalidSplits.size > 0) {
							records.aggressiveSplits = records.aggressiveSplits.filter(
								splitData => !invalidSplits.has(splitData)
							);
							needAdditionalSeal = true;
						} else {
							// set hash and id values on all (new) splittings
							for (const chunk of compilation.chunks) {
								const splitData = chunkSplitDataMap.get(chunk);
								if (splitData !== undefined) {
									splitData.hash = chunk.hash;
									splitData.id = chunk.id;
									allSplits.add(splitData);
									// set flag for stats
									chunk.recorded = true;
								}
							}

							// Also add all unused historial splits (after the used ones)
							// They can still be used in some future compilation
							const recordedSplits =
								compilation.records && compilation.records.aggressiveSplits;
							if (recordedSplits) {
								for (const splitData of recordedSplits) {
									if (!invalidSplits.has(splitData)) allSplits.add(splitData);
								}
							}

							// record all splits
							records.aggressiveSplits = Array.from(allSplits);

							needAdditionalSeal = false;
						}
					}
				);
				compilation.hooks.needAdditionalSeal.tap(
					"AggressiveSplittingPlugin",
					() => {
						if (needAdditionalSeal) {
							needAdditionalSeal = false;
							return true;
						}
					}
				);
			}
		);
	}
}
module.exports = AggressiveSplittingPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/ChunkModuleIdRangePlugin.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/optimize/ChunkModuleIdRangePlugin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const sortByIndex = (a, b) => {
	return a.index - b.index;
};

const sortByIndex2 = (a, b) => {
	return a.index2 - b.index2;
};

class ChunkModuleIdRangePlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("ChunkModuleIdRangePlugin", compilation => {
			compilation.hooks.moduleIds.tap("ChunkModuleIdRangePlugin", modules => {
				const chunk = compilation.chunks.find(
					chunk => chunk.name === options.name
				);
				if (!chunk) {
					throw new Error(
						`ChunkModuleIdRangePlugin: Chunk with name '${
							options.name
						}"' was not found`
					);
				}

				let chunkModules;
				if (options.order) {
					chunkModules = Array.from(chunk.modulesIterable);
					switch (options.order) {
						case "index":
							chunkModules.sort(sortByIndex);
							break;
						case "index2":
							chunkModules.sort(sortByIndex2);
							break;
						default:
							throw new Error(
								"ChunkModuleIdRangePlugin: unexpected value of order"
							);
					}
				} else {
					chunkModules = modules.filter(m => {
						return m.chunksIterable.has(chunk);
					});
				}

				let currentId = options.start || 0;
				for (let i = 0; i < chunkModules.length; i++) {
					const m = chunkModules[i];
					if (m.id === null) {
						m.id = currentId++;
					}
					if (options.end && currentId > options.end) break;
				}
			});
		});
	}
}
module.exports = ChunkModuleIdRangePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/ConcatenatedModule.js":
/*!****************************************************!*\
  !*** (webpack)/lib/optimize/ConcatenatedModule.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Module = __webpack_require__(/*! ../Module */ "./node_modules/webpack/lib/Module.js");
const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");
const Parser = __webpack_require__(/*! ../Parser */ "./node_modules/webpack/lib/Parser.js");
const eslintScope = __webpack_require__(/*! eslint-scope */ "eslint-scope");
const { ConcatSource, ReplaceSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const DependencyReference = __webpack_require__(/*! ../dependencies/DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js");
const HarmonyImportDependency = __webpack_require__(/*! ../dependencies/HarmonyImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportDependency.js");
const HarmonyImportSideEffectDependency = __webpack_require__(/*! ../dependencies/HarmonyImportSideEffectDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSideEffectDependency.js");
const HarmonyImportSpecifierDependency = __webpack_require__(/*! ../dependencies/HarmonyImportSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSpecifierDependency.js");
const HarmonyExportSpecifierDependency = __webpack_require__(/*! ../dependencies/HarmonyExportSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportSpecifierDependency.js");
const HarmonyExportExpressionDependency = __webpack_require__(/*! ../dependencies/HarmonyExportExpressionDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportExpressionDependency.js");
const HarmonyExportImportedSpecifierDependency = __webpack_require__(/*! ../dependencies/HarmonyExportImportedSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency.js");
const HarmonyCompatibilityDependency = __webpack_require__(/*! ../dependencies/HarmonyCompatibilityDependency */ "./node_modules/webpack/lib/dependencies/HarmonyCompatibilityDependency.js");
const createHash = __webpack_require__(/*! ../util/createHash */ "./node_modules/webpack/lib/util/createHash.js");

/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../util/createHash").Hash} Hash */

/**
 * @typedef {Object} ConcatenationEntry
 * @property {"concatenated" | "external"} type
 * @property {Module} module
 */

const ensureNsObjSource = (
	info,
	moduleToInfoMap,
	requestShortener,
	strictHarmonyModule
) => {
	if (!info.hasNamespaceObject) {
		info.hasNamespaceObject = true;
		const name = info.exportMap.get(true);
		const nsObj = [`var ${name} = {};`, `__webpack_require__.r(${name});`];
		for (const exportName of info.module.buildMeta.providedExports) {
			const finalName = getFinalName(
				info,
				exportName,
				moduleToInfoMap,
				requestShortener,
				false,
				strictHarmonyModule
			);
			nsObj.push(
				`__webpack_require__.d(${name}, ${JSON.stringify(
					exportName
				)}, function() { return ${finalName}; });`
			);
		}
		info.namespaceObjectSource = nsObj.join("\n") + "\n";
	}
};

const getExternalImport = (
	importedModule,
	info,
	exportName,
	asCall,
	strictHarmonyModule
) => {
	const used = importedModule.isUsed(exportName);
	if (!used) return "/* unused reexport */undefined";
	const comment =
		used !== exportName ? ` ${Template.toNormalComment(exportName)}` : "";
	switch (importedModule.buildMeta.exportsType) {
		case "named":
			if (exportName === "default") {
				return info.name;
			} else if (exportName === true) {
				info.interopNamespaceObjectUsed = true;
				return info.interopNamespaceObjectName;
			} else {
				break;
			}
		case "namespace":
			if (exportName === true) {
				return info.name;
			} else {
				break;
			}
		default:
			if (strictHarmonyModule) {
				if (exportName === "default") {
					return info.name;
				} else if (exportName === true) {
					info.interopNamespaceObjectUsed = true;
					return info.interopNamespaceObjectName;
				} else {
					return "/* non-default import from non-esm module */undefined";
				}
			} else {
				if (exportName === "default") {
					info.interopDefaultAccessUsed = true;
					return asCall
						? `${info.interopDefaultAccessName}()`
						: `${info.interopDefaultAccessName}.a`;
				} else if (exportName === true) {
					return info.name;
				} else {
					break;
				}
			}
	}
	const reference = `${info.name}[${JSON.stringify(used)}${comment}]`;
	if (asCall) return `Object(${reference})`;
	return reference;
};

const getFinalName = (
	info,
	exportName,
	moduleToInfoMap,
	requestShortener,
	asCall,
	strictHarmonyModule,
	alreadyVisited = new Set()
) => {
	switch (info.type) {
		case "concatenated": {
			const directExport = info.exportMap.get(exportName);
			if (directExport) {
				if (exportName === true) {
					ensureNsObjSource(
						info,
						moduleToInfoMap,
						requestShortener,
						strictHarmonyModule
					);
				} else if (!info.module.isUsed(exportName)) {
					return "/* unused export */ undefined";
				}
				if (info.globalExports.has(directExport)) {
					return directExport;
				}
				const name = info.internalNames.get(directExport);
				if (!name) {
					throw new Error(
						`The export "${directExport}" in "${info.module.readableIdentifier(
							requestShortener
						)}" has no internal name`
					);
				}
				return name;
			}
			const reexport = info.reexportMap.get(exportName);
			if (reexport) {
				if (alreadyVisited.has(reexport)) {
					throw new Error(
						`Circular reexports ${Array.from(
							alreadyVisited,
							e =>
								`"${e.module.readableIdentifier(requestShortener)}".${
									e.exportName
								}`
						).join(
							" --> "
						)} -(circular)-> "${reexport.module.readableIdentifier(
							requestShortener
						)}".${reexport.exportName}`
					);
				}
				alreadyVisited.add(reexport);
				const refInfo = moduleToInfoMap.get(reexport.module);
				if (refInfo) {
					// module is in the concatenation
					return getFinalName(
						refInfo,
						reexport.exportName,
						moduleToInfoMap,
						requestShortener,
						asCall,
						strictHarmonyModule,
						alreadyVisited
					);
				}
			}
			const problem =
				`Cannot get final name for export "${exportName}" in "${info.module.readableIdentifier(
					requestShortener
				)}"` +
				` (known exports: ${Array.from(info.exportMap.keys())
					.filter(name => name !== true)
					.join(" ")}, ` +
				`known reexports: ${Array.from(info.reexportMap.keys()).join(" ")})`;
			return `${Template.toNormalComment(problem)} undefined`;
		}
		case "external": {
			const importedModule = info.module;
			return getExternalImport(
				importedModule,
				info,
				exportName,
				asCall,
				strictHarmonyModule
			);
		}
	}
};

const addScopeSymbols1 = (s, nameSet, scopeSet) => {
	let scope = s;
	while (scope) {
		if (scopeSet.has(scope)) break;
		scopeSet.add(scope);
		for (const variable of scope.variables) {
			nameSet.add(variable.name);
		}
		scope = scope.upper;
	}
};

const addScopeSymbols2 = (s, nameSet, scopeSet1, scopeSet2) => {
	let scope = s;
	while (scope) {
		if (scopeSet1.has(scope)) break;
		if (scopeSet2.has(scope)) break;
		scopeSet1.add(scope);
		for (const variable of scope.variables) {
			nameSet.add(variable.name);
		}
		scope = scope.upper;
	}
};

const getAllReferences = variable => {
	let set = variable.references;
	// Look for inner scope variables too (like in class Foo { t() { Foo } })
	const identifiers = new Set(variable.identifiers);
	for (const scope of variable.scope.childScopes) {
		for (const innerVar of scope.variables) {
			if (innerVar.identifiers.some(id => identifiers.has(id))) {
				set = set.concat(innerVar.references);
				break;
			}
		}
	}
	return set;
};

const getPathInAst = (ast, node) => {
	if (ast === node) {
		return [];
	}

	const nr = node.range;

	const enterNode = n => {
		if (!n) return undefined;
		const r = n.range;
		if (r) {
			if (r[0] <= nr[0] && r[1] >= nr[1]) {
				const path = getPathInAst(n, node);
				if (path) {
					path.push(n);
					return path;
				}
			}
		}
		return undefined;
	};

	var i;
	if (Array.isArray(ast)) {
		for (i = 0; i < ast.length; i++) {
			const enterResult = enterNode(ast[i]);
			if (enterResult !== undefined) return enterResult;
		}
	} else if (ast && typeof ast === "object") {
		const keys = Object.keys(ast);
		for (i = 0; i < keys.length; i++) {
			const value = ast[keys[i]];
			if (Array.isArray(value)) {
				const pathResult = getPathInAst(value, node);
				if (pathResult !== undefined) return pathResult;
			} else if (value && typeof value === "object") {
				const enterResult = enterNode(value);
				if (enterResult !== undefined) return enterResult;
			}
		}
	}
};

class ConcatenatedModule extends Module {
	constructor(rootModule, modules, concatenationList) {
		super("javascript/esm", null);
		super.setChunks(rootModule._chunks);

		// Info from Factory
		this.rootModule = rootModule;
		this.factoryMeta = rootModule.factoryMeta;

		// Info from Compilation
		this.index = rootModule.index;
		this.index2 = rootModule.index2;
		this.depth = rootModule.depth;

		// Info from Optimization
		this.used = rootModule.used;
		this.usedExports = rootModule.usedExports;

		// Info from Build
		this.buildInfo = {
			strict: true,
			cacheable: modules.every(m => m.buildInfo.cacheable),
			moduleArgument: rootModule.buildInfo.moduleArgument,
			exportsArgument: rootModule.buildInfo.exportsArgument,
			fileDependencies: new Set(),
			contextDependencies: new Set(),
			assets: undefined
		};
		this.built = modules.some(m => m.built);
		this.buildMeta = rootModule.buildMeta;

		// Caching
		this._numberOfConcatenatedModules = modules.length;

		// Graph
		const modulesSet = new Set(modules);
		this.reasons = rootModule.reasons.filter(
			reason =>
				!(reason.dependency instanceof HarmonyImportDependency) ||
				!modulesSet.has(reason.module)
		);

		this.dependencies = [];

		this.warnings = [];
		this.errors = [];
		this._orderedConcatenationList =
			concatenationList ||
			ConcatenatedModule.createConcatenationList(rootModule, modulesSet, null);
		for (const info of this._orderedConcatenationList) {
			if (info.type === "concatenated") {
				const m = info.module;

				// populate dependencies
				for (const d of m.dependencies.filter(
					dep =>
						!(dep instanceof HarmonyImportDependency) ||
						!modulesSet.has(dep._module)
				)) {
					this.dependencies.push(d);
				}
				// populate file dependencies
				if (m.buildInfo.fileDependencies) {
					for (const file of m.buildInfo.fileDependencies) {
						this.buildInfo.fileDependencies.add(file);
					}
				}
				// populate context dependencies
				if (m.buildInfo.contextDependencies) {
					for (const context of m.buildInfo.contextDependencies) {
						this.buildInfo.contextDependencies.add(context);
					}
				}
				// populate warnings
				for (const warning of m.warnings) {
					this.warnings.push(warning);
				}
				// populate errors
				for (const error of m.errors) {
					this.errors.push(error);
				}

				if (m.buildInfo.assets) {
					if (this.buildInfo.assets === undefined) {
						this.buildInfo.assets = Object.create(null);
					}
					Object.assign(this.buildInfo.assets, m.buildInfo.assets);
				}
			}
		}
		this._identifier = this._createIdentifier();
	}

	get modules() {
		return this._orderedConcatenationList
			.filter(info => info.type === "concatenated")
			.map(info => info.module);
	}

	identifier() {
		return this._identifier;
	}

	readableIdentifier(requestShortener) {
		return (
			this.rootModule.readableIdentifier(requestShortener) +
			` + ${this._numberOfConcatenatedModules - 1} modules`
		);
	}

	libIdent(options) {
		return this.rootModule.libIdent(options);
	}

	nameForCondition() {
		return this.rootModule.nameForCondition();
	}

	build(options, compilation, resolver, fs, callback) {
		throw new Error("Cannot build this module. It should be already built.");
	}

	size() {
		// Guess size from embedded modules
		return this._orderedConcatenationList.reduce((sum, info) => {
			switch (info.type) {
				case "concatenated":
					return sum + info.module.size();
				case "external":
					return sum + 5;
			}
			return sum;
		}, 0);
	}

	/**
	 * @param {Module} rootModule the root of the concatenation
	 * @param {Set<Module>} modulesSet a set of modules which should be concatenated
	 * @param {Compilation} compilation the compilation context
	 * @returns {ConcatenationEntry[]} concatenation list
	 */
	static createConcatenationList(rootModule, modulesSet, compilation) {
		const list = [];
		const set = new Set();

		/**
		 * @param {Module} module a module
		 * @returns {(function(): Module)[]} imported modules in order
		 */
		const getConcatenatedImports = module => {
			/** @type {WeakMap<DependencyReference, Dependency>} */
			const map = new WeakMap();
			const references = module.dependencies
				.filter(dep => dep instanceof HarmonyImportDependency)
				.map(dep => {
					const ref = compilation.getDependencyReference(module, dep);
					if (ref) map.set(ref, dep);
					return ref;
				})
				.filter(ref => ref);
			DependencyReference.sort(references);
			// TODO webpack 5: remove this hack, see also DependencyReference
			return references.map(ref => {
				const dep = map.get(ref);
				return () => compilation.getDependencyReference(module, dep).module;
			});
		};

		const enterModule = getModule => {
			const module = getModule();
			if (!module) return;
			if (set.has(module)) return;
			set.add(module);
			if (modulesSet.has(module)) {
				const imports = getConcatenatedImports(module);
				imports.forEach(enterModule);
				list.push({
					type: "concatenated",
					module
				});
			} else {
				list.push({
					type: "external",
					get module() {
						// We need to use a getter here, because the module in the dependency
						// could be replaced by some other process (i. e. also replaced with a
						// concatenated module)
						return getModule();
					}
				});
			}
		};

		enterModule(() => rootModule);

		return list;
	}

	_createIdentifier() {
		let orderedConcatenationListIdentifiers = "";
		for (let i = 0; i < this._orderedConcatenationList.length; i++) {
			if (this._orderedConcatenationList[i].type === "concatenated") {
				orderedConcatenationListIdentifiers += this._orderedConcatenationList[
					i
				].module.identifier();
				orderedConcatenationListIdentifiers += " ";
			}
		}
		const hash = createHash("md4");
		hash.update(orderedConcatenationListIdentifiers);
		return this.rootModule.identifier() + " " + hash.digest("hex");
	}

	source(dependencyTemplates, runtimeTemplate) {
		const requestShortener = runtimeTemplate.requestShortener;
		// Metainfo for each module
		const modulesWithInfo = this._orderedConcatenationList.map((info, idx) => {
			switch (info.type) {
				case "concatenated": {
					const exportMap = new Map();
					const reexportMap = new Map();
					for (const dep of info.module.dependencies) {
						if (dep instanceof HarmonyExportSpecifierDependency) {
							if (!exportMap.has(dep.name)) {
								exportMap.set(dep.name, dep.id);
							}
						} else if (dep instanceof HarmonyExportExpressionDependency) {
							if (!exportMap.has("default")) {
								exportMap.set("default", "__WEBPACK_MODULE_DEFAULT_EXPORT__");
							}
						} else if (
							dep instanceof HarmonyExportImportedSpecifierDependency
						) {
							const exportName = dep.name;
							const importName = dep.id;
							const importedModule = dep._module;
							if (exportName && importName) {
								if (!reexportMap.has(exportName)) {
									reexportMap.set(exportName, {
										module: importedModule,
										exportName: importName,
										dependency: dep
									});
								}
							} else if (exportName) {
								if (!reexportMap.has(exportName)) {
									reexportMap.set(exportName, {
										module: importedModule,
										exportName: true,
										dependency: dep
									});
								}
							} else if (importedModule) {
								for (const name of importedModule.buildMeta.providedExports) {
									if (dep.activeExports.has(name) || name === "default") {
										continue;
									}
									if (!reexportMap.has(name)) {
										reexportMap.set(name, {
											module: importedModule,
											exportName: name,
											dependency: dep
										});
									}
								}
							}
						}
					}
					return {
						type: "concatenated",
						module: info.module,
						index: idx,
						ast: undefined,
						internalSource: undefined,
						source: undefined,
						globalScope: undefined,
						moduleScope: undefined,
						internalNames: new Map(),
						globalExports: new Set(),
						exportMap: exportMap,
						reexportMap: reexportMap,
						hasNamespaceObject: false,
						namespaceObjectSource: null
					};
				}
				case "external":
					return {
						type: "external",
						module: info.module,
						index: idx,
						name: undefined,
						interopNamespaceObjectUsed: false,
						interopNamespaceObjectName: undefined,
						interopDefaultAccessUsed: false,
						interopDefaultAccessName: undefined
					};
				default:
					throw new Error(`Unsupported concatenation entry type ${info.type}`);
			}
		});

		// Create mapping from module to info
		const moduleToInfoMap = new Map();
		for (const m of modulesWithInfo) {
			moduleToInfoMap.set(m.module, m);
		}

		// Configure template decorators for dependencies
		const innerDependencyTemplates = new Map(dependencyTemplates);

		innerDependencyTemplates.set(
			HarmonyImportSpecifierDependency,
			new HarmonyImportSpecifierDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyImportSpecifierDependency),
				moduleToInfoMap
			)
		);
		innerDependencyTemplates.set(
			HarmonyImportSideEffectDependency,
			new HarmonyImportSideEffectDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyImportSideEffectDependency),
				moduleToInfoMap
			)
		);
		innerDependencyTemplates.set(
			HarmonyExportSpecifierDependency,
			new HarmonyExportSpecifierDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyExportSpecifierDependency),
				this.rootModule
			)
		);
		innerDependencyTemplates.set(
			HarmonyExportExpressionDependency,
			new HarmonyExportExpressionDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyExportExpressionDependency),
				this.rootModule
			)
		);
		innerDependencyTemplates.set(
			HarmonyExportImportedSpecifierDependency,
			new HarmonyExportImportedSpecifierDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyExportImportedSpecifierDependency),
				this.rootModule,
				moduleToInfoMap
			)
		);
		innerDependencyTemplates.set(
			HarmonyCompatibilityDependency,
			new HarmonyCompatibilityDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyCompatibilityDependency),
				this.rootModule,
				moduleToInfoMap
			)
		);

		// Must use full identifier in our cache here to ensure that the source
		// is updated should our dependencies list change.
		// TODO webpack 5 refactor
		innerDependencyTemplates.set(
			"hash",
			innerDependencyTemplates.get("hash") + this.identifier()
		);

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				const m = info.module;
				const source = m.source(innerDependencyTemplates, runtimeTemplate);
				const code = source.source();
				let ast;
				try {
					ast = Parser.parse(code, {
						sourceType: "module"
					});
				} catch (err) {
					if (
						err.loc &&
						typeof err.loc === "object" &&
						typeof err.loc.line === "number"
					) {
						const lineNumber = err.loc.line;
						const lines = code.split("\n");
						err.message +=
							"\n| " +
							lines
								.slice(Math.max(0, lineNumber - 3), lineNumber + 2)
								.join("\n| ");
					}
					throw err;
				}
				const scopeManager = eslintScope.analyze(ast, {
					ecmaVersion: 6,
					sourceType: "module",
					optimistic: true,
					ignoreEval: true,
					impliedStrict: true
				});
				const globalScope = scopeManager.acquire(ast);
				const moduleScope = globalScope.childScopes[0];
				const resultSource = new ReplaceSource(source);
				info.ast = ast;
				info.internalSource = source;
				info.source = resultSource;
				info.globalScope = globalScope;
				info.moduleScope = moduleScope;
			}
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set([
			"__WEBPACK_MODULE_DEFAULT_EXPORT__", // avoid using this internal name

			"abstract",
			"arguments",
			"async",
			"await",
			"boolean",
			"break",
			"byte",
			"case",
			"catch",
			"char",
			"class",
			"const",
			"continue",
			"debugger",
			"default",
			"delete",
			"do",
			"double",
			"else",
			"enum",
			"eval",
			"export",
			"extends",
			"false",
			"final",
			"finally",
			"float",
			"for",
			"function",
			"goto",
			"if",
			"implements",
			"import",
			"in",
			"instanceof",
			"int",
			"interface",
			"let",
			"long",
			"native",
			"new",
			"null",
			"package",
			"private",
			"protected",
			"public",
			"return",
			"short",
			"static",
			"super",
			"switch",
			"synchronized",
			"this",
			"throw",
			"throws",
			"transient",
			"true",
			"try",
			"typeof",
			"var",
			"void",
			"volatile",
			"while",
			"with",
			"yield",

			"module",
			"__dirname",
			"__filename",
			"exports",

			"Array",
			"Date",
			"eval",
			"function",
			"hasOwnProperty",
			"Infinity",
			"isFinite",
			"isNaN",
			"isPrototypeOf",
			"length",
			"Math",
			"NaN",
			"name",
			"Number",
			"Object",
			"prototype",
			"String",
			"toString",
			"undefined",
			"valueOf",

			"alert",
			"all",
			"anchor",
			"anchors",
			"area",
			"assign",
			"blur",
			"button",
			"checkbox",
			"clearInterval",
			"clearTimeout",
			"clientInformation",
			"close",
			"closed",
			"confirm",
			"constructor",
			"crypto",
			"decodeURI",
			"decodeURIComponent",
			"defaultStatus",
			"document",
			"element",
			"elements",
			"embed",
			"embeds",
			"encodeURI",
			"encodeURIComponent",
			"escape",
			"event",
			"fileUpload",
			"focus",
			"form",
			"forms",
			"frame",
			"innerHeight",
			"innerWidth",
			"layer",
			"layers",
			"link",
			"location",
			"mimeTypes",
			"navigate",
			"navigator",
			"frames",
			"frameRate",
			"hidden",
			"history",
			"image",
			"images",
			"offscreenBuffering",
			"open",
			"opener",
			"option",
			"outerHeight",
			"outerWidth",
			"packages",
			"pageXOffset",
			"pageYOffset",
			"parent",
			"parseFloat",
			"parseInt",
			"password",
			"pkcs11",
			"plugin",
			"prompt",
			"propertyIsEnum",
			"radio",
			"reset",
			"screenX",
			"screenY",
			"scroll",
			"secure",
			"select",
			"self",
			"setInterval",
			"setTimeout",
			"status",
			"submit",
			"taint",
			"text",
			"textarea",
			"top",
			"unescape",
			"untaint",
			"window",

			"onblur",
			"onclick",
			"onerror",
			"onfocus",
			"onkeydown",
			"onkeypress",
			"onkeyup",
			"onmouseover",
			"onload",
			"onmouseup",
			"onmousedown",
			"onsubmit"
		]);

		// Set of already checked scopes
		const alreadyCheckedScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			const superClassExpressions = [];

			// ignore symbols from moduleScope
			if (info.moduleScope) {
				alreadyCheckedScopes.add(info.moduleScope);

				// The super class expression in class scopes behaves weird
				// We store ranges of all super class expressions to make
				// renaming to work correctly
				for (const childScope of info.moduleScope.childScopes) {
					if (childScope.type !== "class") continue;
					if (!childScope.block.superClass) continue;
					superClassExpressions.push({
						range: childScope.block.superClass.range,
						variables: childScope.variables
					});
				}
			}

			// add global symbols
			if (info.globalScope) {
				for (const reference of info.globalScope.through) {
					const name = reference.identifier.name;
					if (
						/^__WEBPACK_MODULE_REFERENCE__\d+_([\da-f]+|ns)(_call)?(_strict)?__$/.test(
							name
						)
					) {
						for (const expr of superClassExpressions) {
							if (
								expr.range[0] <= reference.identifier.range[0] &&
								expr.range[1] >= reference.identifier.range[1]
							) {
								for (const variable of expr.variables) {
									allUsedNames.add(variable.name);
								}
							}
						}
						addScopeSymbols1(
							reference.from,
							allUsedNames,
							alreadyCheckedScopes
						);
					} else {
						allUsedNames.add(name);
					}
				}
			}

			// add exported globals
			if (info.type === "concatenated") {
				const variables = new Set();
				for (const variable of info.moduleScope.variables) {
					variables.add(variable.name);
				}
				for (const [, variable] of info.exportMap) {
					if (!variables.has(variable)) {
						info.globalExports.add(variable);
					}
				}
			}
		}

		// generate names for symbols
		for (const info of modulesWithInfo) {
			switch (info.type) {
				case "concatenated": {
					const namespaceObjectName = this.findNewName(
						"namespaceObject",
						allUsedNames,
						null,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(namespaceObjectName);
					info.internalNames.set(namespaceObjectName, namespaceObjectName);
					info.exportMap.set(true, namespaceObjectName);
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						if (allUsedNames.has(name)) {
							const references = getAllReferences(variable);
							const symbolsInReferences = new Set();
							const alreadyCheckedInnerScopes = new Set();
							for (const ref of references) {
								addScopeSymbols2(
									ref.from,
									symbolsInReferences,
									alreadyCheckedInnerScopes,
									alreadyCheckedScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								symbolsInReferences,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (
									path &&
									path.length > 1 &&
									path[1].type === "Property" &&
									path[1].shorthand
								) {
									source.insert(r[1], `: ${newName}`);
								} else {
									source.replace(r[0], r[1] - 1, newName);
								}
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					break;
				}
				case "external": {
					const externalName = this.findNewName(
						"",
						allUsedNames,
						null,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(externalName);
					info.name = externalName;
					if (
						info.module.buildMeta.exportsType === "named" ||
						!info.module.buildMeta.exportsType
					) {
						const externalNameInterop = this.findNewName(
							"namespaceObject",
							allUsedNames,
							null,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(externalNameInterop);
						info.interopNamespaceObjectName = externalNameInterop;
					}
					if (!info.module.buildMeta.exportsType) {
						const externalNameInterop = this.findNewName(
							"default",
							allUsedNames,
							null,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(externalNameInterop);
						info.interopDefaultAccessName = externalNameInterop;
					}
					break;
				}
			}
		}

		// Find and replace referenced to modules
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				for (const reference of info.globalScope.through) {
					const name = reference.identifier.name;
					const match = /^__WEBPACK_MODULE_REFERENCE__(\d+)_([\da-f]+|ns)(_call)?(_strict)?__$/.exec(
						name
					);
					if (match) {
						const referencedModule = modulesWithInfo[+match[1]];
						let exportName;
						if (match[2] === "ns") {
							exportName = true;
						} else {
							const exportData = match[2];
							exportName = Buffer.from(exportData, "hex").toString("utf-8");
						}
						const asCall = !!match[3];
						const strictHarmonyModule = !!match[4];
						const finalName = getFinalName(
							referencedModule,
							exportName,
							moduleToInfoMap,
							requestShortener,
							asCall,
							strictHarmonyModule
						);
						const r = reference.identifier.range;
						const source = info.source;
						source.replace(r[0], r[1] - 1, finalName);
					}
				}
			}
		}

		const result = new ConcatSource();

		// add harmony compatibility flag (must be first because of possible circular dependencies)
		const usedExports = this.rootModule.usedExports;
		if (usedExports === true) {
			result.add(
				runtimeTemplate.defineEsModuleFlagStatement({
					exportsArgument: this.exportsArgument
				})
			);
		}

		// define required namespace objects (must be before evaluation modules)
		for (const info of modulesWithInfo) {
			if (info.namespaceObjectSource) {
				result.add(info.namespaceObjectSource);
			}
		}

		// evaluate modules in order
		for (const info of modulesWithInfo) {
			switch (info.type) {
				case "concatenated":
					result.add(
						`\n// CONCATENATED MODULE: ${info.module.readableIdentifier(
							requestShortener
						)}\n`
					);
					result.add(info.source);
					break;
				case "external":
					result.add(
						`\n// EXTERNAL MODULE: ${info.module.readableIdentifier(
							requestShortener
						)}\n`
					);
					result.add(
						`var ${info.name} = __webpack_require__(${JSON.stringify(
							info.module.id
						)});\n`
					);
					if (info.interopNamespaceObjectUsed) {
						if (info.module.buildMeta.exportsType === "named") {
							result.add(
								`var ${
									info.interopNamespaceObjectName
								} = /*#__PURE__*/__webpack_require__.t(${info.name}, 2);\n`
							);
						} else if (!info.module.buildMeta.exportsType) {
							result.add(
								`var ${
									info.interopNamespaceObjectName
								} = /*#__PURE__*/__webpack_require__.t(${info.name});\n`
							);
						}
					}
					if (info.interopDefaultAccessUsed) {
						result.add(
							`var ${
								info.interopDefaultAccessName
							} = /*#__PURE__*/__webpack_require__.n(${info.name});\n`
						);
					}
					break;
				default:
					throw new Error(`Unsupported concatenation entry type ${info.type}`);
			}
		}

		return result;
	}

	findNewName(oldName, usedNamed1, usedNamed2, extraInfo) {
		let name = oldName;

		if (name === "__WEBPACK_MODULE_DEFAULT_EXPORT__") name = "";

		// Remove uncool stuff
		extraInfo = extraInfo.replace(
			/\.+\/|(\/index)?\.([a-zA-Z0-9]{1,4})($|\s|\?)|\s*\+\s*\d+\s*modules/g,
			""
		);

		const splittedInfo = extraInfo.split("/");
		while (splittedInfo.length) {
			name = splittedInfo.pop() + (name ? "_" + name : "");
			const nameIdent = Template.toIdentifier(name);
			if (
				!usedNamed1.has(nameIdent) &&
				(!usedNamed2 || !usedNamed2.has(nameIdent))
			)
				return nameIdent;
		}

		let i = 0;
		let nameWithNumber = Template.toIdentifier(`${name}_${i}`);
		while (
			usedNamed1.has(nameWithNumber) ||
			(usedNamed2 && usedNamed2.has(nameWithNumber))
		) {
			i++;
			nameWithNumber = Template.toIdentifier(`${name}_${i}`);
		}
		return nameWithNumber;
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @returns {void}
	 */
	updateHash(hash) {
		for (const info of this._orderedConcatenationList) {
			switch (info.type) {
				case "concatenated":
					info.module.updateHash(hash);
					break;
				case "external":
					hash.update(`${info.module.id}`);
					break;
			}
		}
		super.updateHash(hash);
	}
}

class HarmonyImportSpecifierDependencyConcatenatedTemplate {
	constructor(originalTemplate, modulesMap) {
		this.originalTemplate = originalTemplate;
		this.modulesMap = modulesMap;
	}

	getHarmonyInitOrder(dep) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			return this.originalTemplate.getHarmonyInitOrder(dep);
		}
		return NaN;
	}

	harmonyInit(dep, source, runtimeTemplate, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.harmonyInit(
				dep,
				source,
				runtimeTemplate,
				dependencyTemplates
			);
			return;
		}
	}

	apply(dep, source, runtime, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.apply(dep, source, runtime, dependencyTemplates);
			return;
		}
		let content;
		const callFlag = dep.call ? "_call" : "";
		const strictFlag = dep.originModule.buildMeta.strictHarmonyModule
			? "_strict"
			: "";
		if (dep._id === null) {
			content = `__WEBPACK_MODULE_REFERENCE__${info.index}_ns${strictFlag}__`;
		} else if (dep.namespaceObjectAsContext) {
			content = `__WEBPACK_MODULE_REFERENCE__${
				info.index
			}_ns${strictFlag}__[${JSON.stringify(dep._id)}]`;
		} else {
			const exportData = Buffer.from(dep._id, "utf-8").toString("hex");
			content = `__WEBPACK_MODULE_REFERENCE__${
				info.index
			}_${exportData}${callFlag}${strictFlag}__`;
		}
		if (dep.shorthand) {
			content = dep.name + ": " + content;
		}
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
}

class HarmonyImportSideEffectDependencyConcatenatedTemplate {
	constructor(originalTemplate, modulesMap) {
		this.originalTemplate = originalTemplate;
		this.modulesMap = modulesMap;
	}

	getHarmonyInitOrder(dep) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			return this.originalTemplate.getHarmonyInitOrder(dep);
		}
		return NaN;
	}

	harmonyInit(dep, source, runtime, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.harmonyInit(
				dep,
				source,
				runtime,
				dependencyTemplates
			);
			return;
		}
	}

	apply(dep, source, runtime, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.apply(dep, source, runtime, dependencyTemplates);
			return;
		}
	}
}

class HarmonyExportSpecifierDependencyConcatenatedTemplate {
	constructor(originalTemplate, rootModule) {
		this.originalTemplate = originalTemplate;
		this.rootModule = rootModule;
	}

	getHarmonyInitOrder(dep) {
		if (dep.originModule === this.rootModule) {
			return this.originalTemplate.getHarmonyInitOrder(dep);
		}
		return NaN;
	}

	harmonyInit(dep, source, runtime, dependencyTemplates) {
		if (dep.originModule === this.rootModule) {
			this.originalTemplate.harmonyInit(
				dep,
				source,
				runtime,
				dependencyTemplates
			);
			return;
		}
	}

	apply(dep, source, runtime, dependencyTemplates) {
		if (dep.originModule === this.rootModule) {
			this.originalTemplate.apply(dep, source, runtime, dependencyTemplates);
		}
	}
}

class HarmonyExportExpressionDependencyConcatenatedTemplate {
	constructor(originalTemplate, rootModule) {
		this.originalTemplate = originalTemplate;
		this.rootModule = rootModule;
	}

	apply(dep, source, runtime, dependencyTemplates) {
		let content =
			"/* harmony default export */ var __WEBPACK_MODULE_DEFAULT_EXPORT__ = ";
		if (dep.originModule === this.rootModule) {
			const used = dep.originModule.isUsed("default");
			const exportsName = dep.originModule.exportsArgument;
			if (used) content += `${exportsName}[${JSON.stringify(used)}] = `;
		}

		if (dep.range) {
			source.replace(
				dep.rangeStatement[0],
				dep.range[0] - 1,
				content + "(" + dep.prefix
			);
			source.replace(dep.range[1], dep.rangeStatement[1] - 1, ");");
			return;
		}

		source.replace(
			dep.rangeStatement[0],
			dep.rangeStatement[1] - 1,
			content + dep.prefix
		);
	}
}

class HarmonyExportImportedSpecifierDependencyConcatenatedTemplate {
	constructor(originalTemplate, rootModule, modulesMap) {
		this.originalTemplate = originalTemplate;
		this.rootModule = rootModule;
		this.modulesMap = modulesMap;
	}

	getExports(dep) {
		const importModule = dep._module;
		if (dep.id) {
			// export { named } from "module"
			return [
				{
					name: dep.name,
					id: dep.id,
					module: importModule
				}
			];
		}
		if (dep.name) {
			// export * as abc from "module"
			return [
				{
					name: dep.name,
					id: true,
					module: importModule
				}
			];
		}
		// export * from "module"
		return importModule.buildMeta.providedExports
			.filter(exp => exp !== "default" && !dep.activeExports.has(exp))
			.map(exp => {
				return {
					name: exp,
					id: exp,
					module: importModule
				};
			});
	}

	getHarmonyInitOrder(dep) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			return this.originalTemplate.getHarmonyInitOrder(dep);
		}
		return NaN;
	}

	harmonyInit(dep, source, runtime, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.harmonyInit(
				dep,
				source,
				runtime,
				dependencyTemplates
			);
			return;
		}
	}

	apply(dep, source, runtime, dependencyTemplates) {
		if (dep.originModule === this.rootModule) {
			if (this.modulesMap.get(dep._module)) {
				const exportDefs = this.getExports(dep);
				for (const def of exportDefs) {
					const info = this.modulesMap.get(def.module);
					const used = dep.originModule.isUsed(def.name);
					if (!used) {
						source.insert(
							-1,
							`/* unused concated harmony import ${def.name} */\n`
						);
						continue;
					}
					let finalName;
					const strictFlag = dep.originModule.buildMeta.strictHarmonyModule
						? "_strict"
						: "";
					if (def.id === true) {
						finalName = `__WEBPACK_MODULE_REFERENCE__${
							info.index
						}_ns${strictFlag}__`;
					} else {
						const exportData = Buffer.from(def.id, "utf-8").toString("hex");
						finalName = `__WEBPACK_MODULE_REFERENCE__${
							info.index
						}_${exportData}${strictFlag}__`;
					}
					const exportsName = this.rootModule.exportsArgument;
					const content =
						`/* concated harmony reexport ${def.name} */` +
						`__webpack_require__.d(${exportsName}, ` +
						`${JSON.stringify(used)}, ` +
						`function() { return ${finalName}; });\n`;
					source.insert(-1, content);
				}
			} else {
				this.originalTemplate.apply(dep, source, runtime, dependencyTemplates);
			}
		}
	}
}

class HarmonyCompatibilityDependencyConcatenatedTemplate {
	constructor(originalTemplate, rootModule, modulesMap) {
		this.originalTemplate = originalTemplate;
		this.rootModule = rootModule;
		this.modulesMap = modulesMap;
	}

	apply(dep, source, runtime, dependencyTemplates) {
		// do nothing
	}
}

module.exports = ConcatenatedModule;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/EnsureChunkConditionsPlugin.js":
/*!*************************************************************!*\
  !*** (webpack)/lib/optimize/EnsureChunkConditionsPlugin.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const GraphHelpers = __webpack_require__(/*! ../GraphHelpers */ "./node_modules/webpack/lib/GraphHelpers.js");

class EnsureChunkConditionsPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"EnsureChunkConditionsPlugin",
			compilation => {
				const handler = chunks => {
					let changed = false;
					for (const module of compilation.modules) {
						if (!module.chunkCondition) continue;
						const sourceChunks = new Set();
						const chunkGroups = new Set();
						for (const chunk of module.chunksIterable) {
							if (!module.chunkCondition(chunk)) {
								sourceChunks.add(chunk);
								for (const group of chunk.groupsIterable) {
									chunkGroups.add(group);
								}
							}
						}
						if (sourceChunks.size === 0) continue;
						const targetChunks = new Set();
						chunkGroupLoop: for (const chunkGroup of chunkGroups) {
							// Can module be placed in a chunk of this group?
							for (const chunk of chunkGroup.chunks) {
								if (module.chunkCondition(chunk)) {
									targetChunks.add(chunk);
									continue chunkGroupLoop;
								}
							}
							// We reached the entrypoint: fail
							if (chunkGroup.isInitial()) {
								throw new Error(
									"Cannot fullfil chunk condition of " + module.identifier()
								);
							}
							// Try placing in all parents
							for (const group of chunkGroup.parentsIterable) {
								chunkGroups.add(group);
							}
						}
						for (const sourceChunk of sourceChunks) {
							GraphHelpers.disconnectChunkAndModule(sourceChunk, module);
						}
						for (const targetChunk of targetChunks) {
							GraphHelpers.connectChunkAndModule(targetChunk, module);
						}
					}
					if (changed) return true;
				};
				compilation.hooks.optimizeChunksBasic.tap(
					"EnsureChunkConditionsPlugin",
					handler
				);
				compilation.hooks.optimizeExtractedChunksBasic.tap(
					"EnsureChunkConditionsPlugin",
					handler
				);
			}
		);
	}
}
module.exports = EnsureChunkConditionsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/FlagIncludedChunksPlugin.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/optimize/FlagIncludedChunksPlugin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class FlagIncludedChunksPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("FlagIncludedChunksPlugin", compilation => {
			compilation.hooks.optimizeChunkIds.tap(
				"FlagIncludedChunksPlugin",
				chunks => {
					// prepare two bit integers for each module
					// 2^31 is the max number represented as SMI in v8
					// we want the bits distributed this way:
					// the bit 2^31 is pretty rar and only one module should get it
					// so it has a probability of 1 / modulesCount
					// the first bit (2^0) is the easiest and every module could get it
					// if it doesn't get a better bit
					// from bit 2^n to 2^(n+1) there is a probability of p
					// so 1 / modulesCount == p^31
					// <=> p = sqrt31(1 / modulesCount)
					// so we use a modulo of 1 / sqrt31(1 / modulesCount)
					const moduleBits = new WeakMap();
					const modulesCount = compilation.modules.length;

					// precalculate the modulo values for each bit
					const modulo = 1 / Math.pow(1 / modulesCount, 1 / 31);
					const modulos = Array.from(
						{ length: 31 },
						(x, i) => Math.pow(modulo, i) | 0
					);

					// iterate all modules to generate bit values
					let i = 0;
					for (const module of compilation.modules) {
						let bit = 30;
						while (i % modulos[bit] !== 0) {
							bit--;
						}
						moduleBits.set(module, 1 << bit);
						i++;
					}

					// interate all chunks to generate bitmaps
					const chunkModulesHash = new WeakMap();
					for (const chunk of chunks) {
						let hash = 0;
						for (const module of chunk.modulesIterable) {
							hash |= moduleBits.get(module);
						}
						chunkModulesHash.set(chunk, hash);
					}

					for (const chunkA of chunks) {
						const chunkAHash = chunkModulesHash.get(chunkA);
						const chunkAModulesCount = chunkA.getNumberOfModules();
						if (chunkAModulesCount === 0) continue;
						let bestModule = undefined;
						for (const module of chunkA.modulesIterable) {
							if (
								bestModule === undefined ||
								bestModule.getNumberOfChunks() > module.getNumberOfChunks()
							)
								bestModule = module;
						}
						loopB: for (const chunkB of bestModule.chunksIterable) {
							// as we iterate the same iterables twice
							// skip if we find ourselves
							if (chunkA === chunkB) continue;

							const chunkBModulesCount = chunkB.getNumberOfModules();

							// ids for empty chunks are not included
							if (chunkBModulesCount === 0) continue;

							// instead of swapping A and B just bail
							// as we loop twice the current A will be B and B then A
							if (chunkAModulesCount > chunkBModulesCount) continue;

							// is chunkA in chunkB?

							// we do a cheap check for the hash value
							const chunkBHash = chunkModulesHash.get(chunkB);
							if ((chunkBHash & chunkAHash) !== chunkAHash) continue;

							// compare all modules
							for (const m of chunkA.modulesIterable) {
								if (!chunkB.containsModule(m)) continue loopB;
							}
							chunkB.ids.push(chunkA.id);
						}
					}
				}
			);
		});
	}
}
module.exports = FlagIncludedChunksPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js":
/*!*******************************************************!*\
  !*** (webpack)/lib/optimize/LimitChunkCountPlugin.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../../schemas/plugins/optimize/LimitChunkCountPlugin.json */ "./node_modules/webpack/schemas/plugins/optimize/LimitChunkCountPlugin.json");

/** @typedef {import("../../declarations/plugins/optimize/LimitChunkCountPlugin").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */

class LimitChunkCountPlugin {
	/**
	 * @param {LimitChunkCountPluginOptions=} options options object
	 */
	constructor(options) {
		if (!options) options = {};

		validateOptions(schema, options, "Limit Chunk Count Plugin");
		this.options = options;
	}
	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("LimitChunkCountPlugin", compilation => {
			compilation.hooks.optimizeChunksAdvanced.tap(
				"LimitChunkCountPlugin",
				chunks => {
					const maxChunks = options.maxChunks;
					if (!maxChunks) return;
					if (maxChunks < 1) return;
					if (chunks.length <= maxChunks) return;

					const orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));

					const sortedExtendedPairCombinations = orderedChunks
						.reduce((combinations, a, idx) => {
							// create combination pairs
							for (let i = 0; i < idx; i++) {
								const b = orderedChunks[i];
								combinations.push([b, a]);
							}
							return combinations;
						}, [])
						.map(pair => {
							// extend combination pairs with size and integrated size
							const a = pair[0].size(options);
							const b = pair[1].size(options);
							const ab = pair[0].integratedSize(pair[1], options);
							return [a + b - ab, ab, pair[0], pair[1], a, b];
						})
						.filter(extendedPair => {
							// filter pairs that do not have an integratedSize
							// meaning they can NOT be integrated!
							return extendedPair[1] !== false;
						})
						.sort((a, b) => {
							// sadly javascript does an inplace sort here
							// sort them by size
							const diff1 = b[0] - a[0];
							if (diff1 !== 0) return diff1;
							const diff2 = a[1] - b[1];
							if (diff2 !== 0) return diff2;
							const diff3 = a[2].compareTo(b[2]);
							if (diff3 !== 0) return diff3;
							return a[3].compareTo(b[3]);
						});

					const pair = sortedExtendedPairCombinations[0];

					if (pair && pair[2].integrate(pair[3], "limit")) {
						chunks.splice(chunks.indexOf(pair[3]), 1);
						return true;
					}
				}
			);
		});
	}
}
module.exports = LimitChunkCountPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/MergeDuplicateChunksPlugin.js":
/*!************************************************************!*\
  !*** (webpack)/lib/optimize/MergeDuplicateChunksPlugin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class MergeDuplicateChunksPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"MergeDuplicateChunksPlugin",
			compilation => {
				compilation.hooks.optimizeChunksBasic.tap(
					"MergeDuplicateChunksPlugin",
					chunks => {
						// remember already tested chunks for performance
						const notDuplicates = new Set();

						// for each chunk
						for (const chunk of chunks) {
							// track a Set of all chunk that could be duplicates
							let possibleDuplicates;
							for (const module of chunk.modulesIterable) {
								if (possibleDuplicates === undefined) {
									// when possibleDuplicates is not yet set,
									// create a new Set from chunks of the current module
									// including only chunks with the same number of modules
									for (const dup of module.chunksIterable) {
										if (
											dup !== chunk &&
											chunk.getNumberOfModules() === dup.getNumberOfModules() &&
											!notDuplicates.has(dup)
										) {
											// delay allocating the new Set until here, reduce memory pressure
											if (possibleDuplicates === undefined) {
												possibleDuplicates = new Set();
											}
											possibleDuplicates.add(dup);
										}
									}
									// when no chunk is possible we can break here
									if (possibleDuplicates === undefined) break;
								} else {
									// validate existing possible duplicates
									for (const dup of possibleDuplicates) {
										// remove possible duplicate when module is not contained
										if (!dup.containsModule(module)) {
											possibleDuplicates.delete(dup);
										}
									}
									// when all chunks has been removed we can break here
									if (possibleDuplicates.size === 0) break;
								}
							}

							// when we found duplicates
							if (
								possibleDuplicates !== undefined &&
								possibleDuplicates.size > 0
							) {
								for (const otherChunk of possibleDuplicates) {
									if (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;
									// merge them
									if (chunk.integrate(otherChunk, "duplicate")) {
										chunks.splice(chunks.indexOf(otherChunk), 1);
									}
								}
							}

							// don't check already processed chunks twice
							notDuplicates.add(chunk);
						}
					}
				);
			}
		);
	}
}
module.exports = MergeDuplicateChunksPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/MinChunkSizePlugin.js":
/*!****************************************************!*\
  !*** (webpack)/lib/optimize/MinChunkSizePlugin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../../schemas/plugins/optimize/MinChunkSizePlugin.json */ "./node_modules/webpack/schemas/plugins/optimize/MinChunkSizePlugin.json");

/** @typedef {import("../../declarations/plugins/optimize/MinChunkSizePlugin").MinChunkSizePluginOptions} MinChunkSizePluginOptions */

class MinChunkSizePlugin {
	/**
	 * @param {MinChunkSizePluginOptions} options options object
	 */
	constructor(options) {
		validateOptions(schema, options, "Min Chunk Size Plugin");
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		const minChunkSize = options.minChunkSize;
		compiler.hooks.compilation.tap("MinChunkSizePlugin", compilation => {
			compilation.hooks.optimizeChunksAdvanced.tap(
				"MinChunkSizePlugin",
				chunks => {
					const equalOptions = {
						chunkOverhead: 1,
						entryChunkMultiplicator: 1
					};

					const sortedSizeFilteredExtendedPairCombinations = chunks
						.reduce((combinations, a, idx) => {
							// create combination pairs
							for (let i = 0; i < idx; i++) {
								const b = chunks[i];
								combinations.push([b, a]);
							}
							return combinations;
						}, [])
						.filter(pair => {
							// check if one of the chunks sizes is smaller than the minChunkSize
							const p0SmallerThanMinChunkSize =
								pair[0].size(equalOptions) < minChunkSize;
							const p1SmallerThanMinChunkSize =
								pair[1].size(equalOptions) < minChunkSize;
							return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;
						})
						.map(pair => {
							// extend combination pairs with size and integrated size
							const a = pair[0].size(options);
							const b = pair[1].size(options);
							const ab = pair[0].integratedSize(pair[1], options);
							return [a + b - ab, ab, pair[0], pair[1]];
						})
						.filter(pair => {
							// filter pairs that do not have an integratedSize
							// meaning they can NOT be integrated!
							return pair[1] !== false;
						})
						.sort((a, b) => {
							// sadly javascript does an inplace sort here
							// sort by size
							const diff = b[0] - a[0];
							if (diff !== 0) return diff;
							return a[1] - b[1];
						});

					if (sortedSizeFilteredExtendedPairCombinations.length === 0) return;

					const pair = sortedSizeFilteredExtendedPairCombinations[0];

					pair[2].integrate(pair[3], "min-size");
					chunks.splice(chunks.indexOf(pair[3]), 1);
					return true;
				}
			);
		});
	}
}
module.exports = MinChunkSizePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/MinMaxSizeWarning.js":
/*!***************************************************!*\
  !*** (webpack)/lib/optimize/MinMaxSizeWarning.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebpackError = __webpack_require__(/*! ../WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const SizeFormatHelpers = __webpack_require__(/*! ../SizeFormatHelpers */ "./node_modules/webpack/lib/SizeFormatHelpers.js");

class MinMaxSizeWarning extends WebpackError {
	constructor(keys, minSize, maxSize) {
		let keysMessage = "Fallback cache group";
		if (keys) {
			keysMessage =
				keys.length > 1
					? `Cache groups ${keys.sort().join(", ")}`
					: `Cache group ${keys[0]}`;
		}
		super(
			`SplitChunksPlugin\n` +
				`${keysMessage}\n` +
				`Configured minSize (${SizeFormatHelpers.formatSize(minSize)}) is ` +
				`bigger than maxSize (${SizeFormatHelpers.formatSize(maxSize)}).\n` +
				"This seem to be a invalid optimiziation.splitChunks configuration."
		);
	}
}

module.exports = MinMaxSizeWarning;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/optimize/ModuleConcatenationPlugin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const HarmonyImportDependency = __webpack_require__(/*! ../dependencies/HarmonyImportDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportDependency.js");
const ModuleHotAcceptDependency = __webpack_require__(/*! ../dependencies/ModuleHotAcceptDependency */ "./node_modules/webpack/lib/dependencies/ModuleHotAcceptDependency.js");
const ModuleHotDeclineDependency = __webpack_require__(/*! ../dependencies/ModuleHotDeclineDependency */ "./node_modules/webpack/lib/dependencies/ModuleHotDeclineDependency.js");
const ConcatenatedModule = __webpack_require__(/*! ./ConcatenatedModule */ "./node_modules/webpack/lib/optimize/ConcatenatedModule.js");
const HarmonyCompatibilityDependency = __webpack_require__(/*! ../dependencies/HarmonyCompatibilityDependency */ "./node_modules/webpack/lib/dependencies/HarmonyCompatibilityDependency.js");
const StackedSetMap = __webpack_require__(/*! ../util/StackedSetMap */ "./node_modules/webpack/lib/util/StackedSetMap.js");

const formatBailoutReason = msg => {
	return "ModuleConcatenation bailout: " + msg;
};

class ModuleConcatenationPlugin {
	constructor(options) {
		if (typeof options !== "object") options = {};
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"ModuleConcatenationPlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = (parser, parserOptions) => {
					parser.hooks.call.for("eval").tap("ModuleConcatenationPlugin", () => {
						// Because of variable renaming we can't use modules with eval.
						parser.state.module.buildMeta.moduleConcatenationBailout = "eval()";
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ModuleConcatenationPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ModuleConcatenationPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("ModuleConcatenationPlugin", handler);

				const bailoutReasonMap = new Map();

				const setBailoutReason = (module, reason) => {
					bailoutReasonMap.set(module, reason);
					module.optimizationBailout.push(
						typeof reason === "function"
							? rs => formatBailoutReason(reason(rs))
							: formatBailoutReason(reason)
					);
				};

				const getBailoutReason = (module, requestShortener) => {
					const reason = bailoutReasonMap.get(module);
					if (typeof reason === "function") return reason(requestShortener);
					return reason;
				};

				compilation.hooks.optimizeChunkModules.tap(
					"ModuleConcatenationPlugin",
					(chunks, modules) => {
						const relevantModules = [];
						const possibleInners = new Set();
						for (const module of modules) {
							// Only harmony modules are valid for optimization
							if (
								!module.buildMeta ||
								module.buildMeta.exportsType !== "namespace" ||
								!module.dependencies.some(
									d => d instanceof HarmonyCompatibilityDependency
								)
							) {
								setBailoutReason(module, "Module is not an ECMAScript module");
								continue;
							}

							// Some expressions are not compatible with module concatenation
							// because they may produce unexpected results. The plugin bails out
							// if some were detected upfront.
							if (
								module.buildMeta &&
								module.buildMeta.moduleConcatenationBailout
							) {
								setBailoutReason(
									module,
									`Module uses ${module.buildMeta.moduleConcatenationBailout}`
								);
								continue;
							}

							// Exports must be known (and not dynamic)
							if (!Array.isArray(module.buildMeta.providedExports)) {
								setBailoutReason(module, "Module exports are unknown");
								continue;
							}

							// Using dependency variables is not possible as this wraps the code in a function
							if (module.variables.length > 0) {
								setBailoutReason(
									module,
									`Module uses injected variables (${module.variables
										.map(v => v.name)
										.join(", ")})`
								);
								continue;
							}

							// Hot Module Replacement need it's own module to work correctly
							if (
								module.dependencies.some(
									dep =>
										dep instanceof ModuleHotAcceptDependency ||
										dep instanceof ModuleHotDeclineDependency
								)
							) {
								setBailoutReason(module, "Module uses Hot Module Replacement");
								continue;
							}

							relevantModules.push(module);

							// Module must not be the entry points
							if (module.isEntryModule()) {
								setBailoutReason(module, "Module is an entry point");
								continue;
							}

							// Module must be in any chunk (we don't want to do useless work)
							if (module.getNumberOfChunks() === 0) {
								setBailoutReason(module, "Module is not in any chunk");
								continue;
							}

							// Module must only be used by Harmony Imports
							const nonHarmonyReasons = module.reasons.filter(
								reason =>
									!reason.dependency ||
									!(reason.dependency instanceof HarmonyImportDependency)
							);
							if (nonHarmonyReasons.length > 0) {
								const importingModules = new Set(
									nonHarmonyReasons.map(r => r.module).filter(Boolean)
								);
								const importingExplanations = new Set(
									nonHarmonyReasons.map(r => r.explanation).filter(Boolean)
								);
								const importingModuleTypes = new Map(
									Array.from(importingModules).map(
										m => /** @type {[string, Set]} */ ([
											m,
											new Set(
												nonHarmonyReasons
													.filter(r => r.module === m)
													.map(r => r.dependency.type)
													.sort()
											)
										])
									)
								);
								setBailoutReason(module, requestShortener => {
									const names = Array.from(importingModules)
										.map(
											m =>
												`${m.readableIdentifier(
													requestShortener
												)} (referenced with ${Array.from(
													importingModuleTypes.get(m)
												).join(", ")})`
										)
										.sort();
									const explanations = Array.from(importingExplanations).sort();
									if (names.length > 0 && explanations.length === 0) {
										return `Module is referenced from these modules with unsupported syntax: ${names.join(
											", "
										)}`;
									} else if (names.length === 0 && explanations.length > 0) {
										return `Module is referenced by: ${explanations.join(
											", "
										)}`;
									} else if (names.length > 0 && explanations.length > 0) {
										return `Module is referenced from these modules with unsupported syntax: ${names.join(
											", "
										)} and by: ${explanations.join(", ")}`;
									} else {
										return "Module is referenced in a unsupported way";
									}
								});
								continue;
							}

							possibleInners.add(module);
						}
						// sort by depth
						// modules with lower depth are more likely suited as roots
						// this improves performance, because modules already selected as inner are skipped
						relevantModules.sort((a, b) => {
							return a.depth - b.depth;
						});
						const concatConfigurations = [];
						const usedAsInner = new Set();
						for (const currentRoot of relevantModules) {
							// when used by another configuration as inner:
							// the other configuration is better and we can skip this one
							if (usedAsInner.has(currentRoot)) continue;

							// create a configuration with the root
							const currentConfiguration = new ConcatConfiguration(currentRoot);

							// cache failures to add modules
							const failureCache = new Map();

							// try to add all imports
							for (const imp of this._getImports(compilation, currentRoot)) {
								const problem = this._tryToAdd(
									compilation,
									currentConfiguration,
									imp,
									possibleInners,
									failureCache
								);
								if (problem) {
									failureCache.set(imp, problem);
									currentConfiguration.addWarning(imp, problem);
								}
							}
							if (!currentConfiguration.isEmpty()) {
								concatConfigurations.push(currentConfiguration);
								for (const module of currentConfiguration.getModules()) {
									if (module !== currentConfiguration.rootModule) {
										usedAsInner.add(module);
									}
								}
							}
						}
						// HACK: Sort configurations by length and start with the longest one
						// to get the biggers groups possible. Used modules are marked with usedModules
						// TODO: Allow to reuse existing configuration while trying to add dependencies.
						// This would improve performance. O(n^2) -> O(n)
						concatConfigurations.sort((a, b) => {
							return b.modules.size - a.modules.size;
						});
						const usedModules = new Set();
						for (const concatConfiguration of concatConfigurations) {
							if (usedModules.has(concatConfiguration.rootModule)) continue;
							const modules = concatConfiguration.getModules();
							const rootModule = concatConfiguration.rootModule;
							const newModule = new ConcatenatedModule(
								rootModule,
								Array.from(modules),
								ConcatenatedModule.createConcatenationList(
									rootModule,
									modules,
									compilation
								)
							);
							for (const warning of concatConfiguration.getWarningsSorted()) {
								newModule.optimizationBailout.push(requestShortener => {
									const reason = getBailoutReason(warning[0], requestShortener);
									const reasonWithPrefix = reason ? ` (<- ${reason})` : "";
									if (warning[0] === warning[1]) {
										return formatBailoutReason(
											`Cannot concat with ${warning[0].readableIdentifier(
												requestShortener
											)}${reasonWithPrefix}`
										);
									} else {
										return formatBailoutReason(
											`Cannot concat with ${warning[0].readableIdentifier(
												requestShortener
											)} because of ${warning[1].readableIdentifier(
												requestShortener
											)}${reasonWithPrefix}`
										);
									}
								});
							}
							const chunks = concatConfiguration.rootModule.getChunks();
							for (const m of modules) {
								usedModules.add(m);
								for (const chunk of chunks) {
									chunk.removeModule(m);
								}
							}
							for (const chunk of chunks) {
								chunk.addModule(newModule);
								newModule.addChunk(chunk);
								if (chunk.entryModule === concatConfiguration.rootModule) {
									chunk.entryModule = newModule;
								}
							}
							compilation.modules.push(newModule);
							for (const reason of newModule.reasons) {
								if (reason.dependency.module === concatConfiguration.rootModule)
									reason.dependency.module = newModule;
								if (
									reason.dependency.redirectedModule ===
									concatConfiguration.rootModule
								)
									reason.dependency.redirectedModule = newModule;
							}
							// TODO: remove when LTS node version contains fixed v8 version
							// @see https://github.com/webpack/webpack/pull/6613
							// Turbofan does not correctly inline for-of loops with polymorphic input arrays.
							// Work around issue by using a standard for loop and assigning dep.module.reasons
							for (let i = 0; i < newModule.dependencies.length; i++) {
								let dep = newModule.dependencies[i];
								if (dep.module) {
									let reasons = dep.module.reasons;
									for (let j = 0; j < reasons.length; j++) {
										let reason = reasons[j];
										if (reason.dependency === dep) {
											reason.module = newModule;
										}
									}
								}
							}
						}
						compilation.modules = compilation.modules.filter(
							m => !usedModules.has(m)
						);
					}
				);
			}
		);
	}

	_getImports(compilation, module) {
		return new Set(
			module.dependencies

				// Get reference info only for harmony Dependencies
				.map(dep => {
					if (!(dep instanceof HarmonyImportDependency)) return null;
					if (!compilation) return dep.getReference();
					return compilation.getDependencyReference(module, dep);
				})

				// Reference is valid and has a module
				// Dependencies are simple enough to concat them
				.filter(
					ref =>
						ref &&
						ref.module &&
						(Array.isArray(ref.importedNames) ||
							Array.isArray(ref.module.buildMeta.providedExports))
				)

				// Take the imported module
				.map(ref => ref.module)
		);
	}

	_tryToAdd(compilation, config, module, possibleModules, failureCache) {
		const cacheEntry = failureCache.get(module);
		if (cacheEntry) {
			return cacheEntry;
		}

		// Already added?
		if (config.has(module)) {
			return null;
		}

		// Not possible to add?
		if (!possibleModules.has(module)) {
			failureCache.set(module, module); // cache failures for performance
			return module;
		}

		// module must be in the same chunks
		if (!config.rootModule.hasEqualsChunks(module)) {
			failureCache.set(module, module); // cache failures for performance
			return module;
		}

		// Clone config to make experimental changes
		const testConfig = config.clone();

		// Add the module
		testConfig.add(module);

		// Every module which depends on the added module must be in the configuration too.
		for (const reason of module.reasons) {
			// Modules that are not used can be ignored
			if (
				reason.module.factoryMeta.sideEffectFree &&
				reason.module.used === false
			)
				continue;

			const problem = this._tryToAdd(
				compilation,
				testConfig,
				reason.module,
				possibleModules,
				failureCache
			);
			if (problem) {
				failureCache.set(module, problem); // cache failures for performance
				return problem;
			}
		}

		// Commit experimental changes
		config.set(testConfig);

		// Eagerly try to add imports too if possible
		for (const imp of this._getImports(compilation, module)) {
			const problem = this._tryToAdd(
				compilation,
				config,
				imp,
				possibleModules,
				failureCache
			);
			if (problem) {
				config.addWarning(imp, problem);
			}
		}
		return null;
	}
}

class ConcatConfiguration {
	constructor(rootModule, cloneFrom) {
		this.rootModule = rootModule;
		if (cloneFrom) {
			this.modules = cloneFrom.modules.createChild(5);
			this.warnings = cloneFrom.warnings.createChild(5);
		} else {
			this.modules = new StackedSetMap();
			this.modules.add(rootModule);
			this.warnings = new StackedSetMap();
		}
	}

	add(module) {
		this.modules.add(module);
	}

	has(module) {
		return this.modules.has(module);
	}

	isEmpty() {
		return this.modules.size === 1;
	}

	addWarning(module, problem) {
		this.warnings.set(module, problem);
	}

	getWarningsSorted() {
		return new Map(
			this.warnings.asPairArray().sort((a, b) => {
				const ai = a[0].identifier();
				const bi = b[0].identifier();
				if (ai < bi) return -1;
				if (ai > bi) return 1;
				return 0;
			})
		);
	}

	getModules() {
		return this.modules.asSet();
	}

	clone() {
		return new ConcatConfiguration(this.rootModule, this);
	}

	set(config) {
		this.rootModule = config.rootModule;
		this.modules = config.modules;
		this.warnings = config.warnings;
	}
}

module.exports = ModuleConcatenationPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/NaturalChunkOrderPlugin.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/optimize/NaturalChunkOrderPlugin.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


/** @typedef {import("../Compiler")} Compiler */

class NaturalChunkOrderPlugin {
	/**
	 * @param {Compiler} compiler webpack compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap("NaturalChunkOrderPlugin", compilation => {
			compilation.hooks.optimizeChunkOrder.tap(
				"NaturalChunkOrderPlugin",
				chunks => {
					chunks.sort((chunkA, chunkB) => {
						const a = chunkA.modulesIterable[Symbol.iterator]();
						const b = chunkB.modulesIterable[Symbol.iterator]();
						// eslint-disable-next-line no-constant-condition
						while (true) {
							const aItem = a.next();
							const bItem = b.next();
							if (aItem.done && bItem.done) return 0;
							if (aItem.done) return -1;
							if (bItem.done) return 1;
							const aModuleId = aItem.value.id;
							const bModuleId = bItem.value.id;
							if (aModuleId < bModuleId) return -1;
							if (aModuleId > bModuleId) return 1;
						}
					});
				}
			);
		});
	}
}

module.exports = NaturalChunkOrderPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/OccurrenceChunkOrderPlugin.js":
/*!************************************************************!*\
  !*** (webpack)/lib/optimize/OccurrenceChunkOrderPlugin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../../schemas/plugins/optimize/OccurrenceOrderChunkIdsPlugin.json */ "./node_modules/webpack/schemas/plugins/optimize/OccurrenceOrderChunkIdsPlugin.json");

/** @typedef {import("../../declarations/plugins/optimize/OccurrenceOrderChunkIdsPlugin").OccurrenceOrderChunkIdsPluginOptions} OccurrenceOrderChunkIdsPluginOptions */

class OccurrenceOrderChunkIdsPlugin {
	/**
	 * @param {OccurrenceOrderChunkIdsPluginOptions=} options options object
	 */
	constructor(options = {}) {
		validateOptions(schema, options, "Occurrence Order Chunk Ids Plugin");
		this.options = options;
	}

	apply(compiler) {
		const prioritiseInitial = this.options.prioritiseInitial;
		compiler.hooks.compilation.tap(
			"OccurrenceOrderChunkIdsPlugin",
			compilation => {
				compilation.hooks.optimizeChunkOrder.tap(
					"OccurrenceOrderChunkIdsPlugin",
					chunks => {
						const occursInInitialChunksMap = new Map();
						const originalOrder = new Map();

						let i = 0;
						for (const c of chunks) {
							let occurs = 0;
							for (const chunkGroup of c.groupsIterable) {
								for (const parent of chunkGroup.parentsIterable) {
									if (parent.isInitial()) occurs++;
								}
							}
							occursInInitialChunksMap.set(c, occurs);
							originalOrder.set(c, i++);
						}

						chunks.sort((a, b) => {
							if (prioritiseInitial) {
								const aEntryOccurs = occursInInitialChunksMap.get(a);
								const bEntryOccurs = occursInInitialChunksMap.get(b);
								if (aEntryOccurs > bEntryOccurs) return -1;
								if (aEntryOccurs < bEntryOccurs) return 1;
							}
							const aOccurs = a.getNumberOfGroups();
							const bOccurs = b.getNumberOfGroups();
							if (aOccurs > bOccurs) return -1;
							if (aOccurs < bOccurs) return 1;
							const orgA = originalOrder.get(a);
							const orgB = originalOrder.get(b);
							return orgA - orgB;
						});
					}
				);
			}
		);
	}
}

module.exports = OccurrenceOrderChunkIdsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/OccurrenceModuleOrderPlugin.js":
/*!*************************************************************!*\
  !*** (webpack)/lib/optimize/OccurrenceModuleOrderPlugin.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const validateOptions = __webpack_require__(/*! schema-utils */ "./node_modules/webpack/node_modules/schema-utils/src/index.js");
const schema = __webpack_require__(/*! ../../schemas/plugins/optimize/OccurrenceOrderModuleIdsPlugin.json */ "./node_modules/webpack/schemas/plugins/optimize/OccurrenceOrderModuleIdsPlugin.json");

/** @typedef {import("../../declarations/plugins/optimize/OccurrenceOrderModuleIdsPlugin").OccurrenceOrderModuleIdsPluginOptions} OccurrenceOrderModuleIdsPluginOptions */

class OccurrenceOrderModuleIdsPlugin {
	/**
	 * @param {OccurrenceOrderModuleIdsPluginOptions=} options options object
	 */
	constructor(options = {}) {
		validateOptions(schema, options, "Occurrence Order Module Ids Plugin");
		this.options = options;
	}

	apply(compiler) {
		const prioritiseInitial = this.options.prioritiseInitial;
		compiler.hooks.compilation.tap(
			"OccurrenceOrderModuleIdsPlugin",
			compilation => {
				compilation.hooks.optimizeModuleOrder.tap(
					"OccurrenceOrderModuleIdsPlugin",
					modules => {
						const occursInInitialChunksMap = new Map();
						const occursInAllChunksMap = new Map();

						const initialChunkChunkMap = new Map();
						const entryCountMap = new Map();
						for (const m of modules) {
							let initial = 0;
							let entry = 0;
							for (const c of m.chunksIterable) {
								if (c.canBeInitial()) initial++;
								if (c.entryModule === m) entry++;
							}
							initialChunkChunkMap.set(m, initial);
							entryCountMap.set(m, entry);
						}

						const countOccursInEntry = (sum, r) => {
							if (!r.module) {
								return sum;
							}
							const count = initialChunkChunkMap.get(r.module);
							if (!count) {
								return sum;
							}
							return sum + count;
						};
						const countOccurs = (sum, r) => {
							if (!r.module) {
								return sum;
							}
							let factor = 1;
							if (typeof r.dependency.getNumberOfIdOccurrences === "function") {
								factor = r.dependency.getNumberOfIdOccurrences();
							}
							if (factor === 0) {
								return sum;
							}
							return sum + factor * r.module.getNumberOfChunks();
						};

						if (prioritiseInitial) {
							for (const m of modules) {
								const result =
									m.reasons.reduce(countOccursInEntry, 0) +
									initialChunkChunkMap.get(m) +
									entryCountMap.get(m);
								occursInInitialChunksMap.set(m, result);
							}
						}

						const originalOrder = new Map();
						let i = 0;
						for (const m of modules) {
							const result =
								m.reasons.reduce(countOccurs, 0) +
								m.getNumberOfChunks() +
								entryCountMap.get(m);
							occursInAllChunksMap.set(m, result);
							originalOrder.set(m, i++);
						}

						modules.sort((a, b) => {
							if (prioritiseInitial) {
								const aEntryOccurs = occursInInitialChunksMap.get(a);
								const bEntryOccurs = occursInInitialChunksMap.get(b);
								if (aEntryOccurs > bEntryOccurs) return -1;
								if (aEntryOccurs < bEntryOccurs) return 1;
							}
							const aOccurs = occursInAllChunksMap.get(a);
							const bOccurs = occursInAllChunksMap.get(b);
							if (aOccurs > bOccurs) return -1;
							if (aOccurs < bOccurs) return 1;
							const orgA = originalOrder.get(a);
							const orgB = originalOrder.get(b);
							return orgA - orgB;
						});
					}
				);
			}
		);
	}
}

module.exports = OccurrenceOrderModuleIdsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/OccurrenceOrderPlugin.js":
/*!*******************************************************!*\
  !*** (webpack)/lib/optimize/OccurrenceOrderPlugin.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


// TODO webpack 5 remove this plugin
// It has been splitted into separate plugins for modules and chunks
class OccurrenceOrderPlugin {
	constructor(preferEntry) {
		if (preferEntry !== undefined && typeof preferEntry !== "boolean") {
			throw new Error(
				"Argument should be a boolean.\nFor more info on this plugin, see https://webpack.js.org/plugins/"
			);
		}
		this.preferEntry = preferEntry;
	}
	apply(compiler) {
		const preferEntry = this.preferEntry;
		compiler.hooks.compilation.tap("OccurrenceOrderPlugin", compilation => {
			compilation.hooks.optimizeModuleOrder.tap(
				"OccurrenceOrderPlugin",
				modules => {
					const occursInInitialChunksMap = new Map();
					const occursInAllChunksMap = new Map();

					const initialChunkChunkMap = new Map();
					const entryCountMap = new Map();
					for (const m of modules) {
						let initial = 0;
						let entry = 0;
						for (const c of m.chunksIterable) {
							if (c.canBeInitial()) initial++;
							if (c.entryModule === m) entry++;
						}
						initialChunkChunkMap.set(m, initial);
						entryCountMap.set(m, entry);
					}

					const countOccursInEntry = (sum, r) => {
						if (!r.module) {
							return sum;
						}
						return sum + initialChunkChunkMap.get(r.module);
					};
					const countOccurs = (sum, r) => {
						if (!r.module) {
							return sum;
						}
						let factor = 1;
						if (typeof r.dependency.getNumberOfIdOccurrences === "function") {
							factor = r.dependency.getNumberOfIdOccurrences();
						}
						if (factor === 0) {
							return sum;
						}
						return sum + factor * r.module.getNumberOfChunks();
					};

					if (preferEntry) {
						for (const m of modules) {
							const result =
								m.reasons.reduce(countOccursInEntry, 0) +
								initialChunkChunkMap.get(m) +
								entryCountMap.get(m);
							occursInInitialChunksMap.set(m, result);
						}
					}

					const originalOrder = new Map();
					let i = 0;
					for (const m of modules) {
						const result =
							m.reasons.reduce(countOccurs, 0) +
							m.getNumberOfChunks() +
							entryCountMap.get(m);
						occursInAllChunksMap.set(m, result);
						originalOrder.set(m, i++);
					}

					modules.sort((a, b) => {
						if (preferEntry) {
							const aEntryOccurs = occursInInitialChunksMap.get(a);
							const bEntryOccurs = occursInInitialChunksMap.get(b);
							if (aEntryOccurs > bEntryOccurs) return -1;
							if (aEntryOccurs < bEntryOccurs) return 1;
						}
						const aOccurs = occursInAllChunksMap.get(a);
						const bOccurs = occursInAllChunksMap.get(b);
						if (aOccurs > bOccurs) return -1;
						if (aOccurs < bOccurs) return 1;
						const orgA = originalOrder.get(a);
						const orgB = originalOrder.get(b);
						return orgA - orgB;
					});
				}
			);
			compilation.hooks.optimizeChunkOrder.tap(
				"OccurrenceOrderPlugin",
				chunks => {
					const occursInInitialChunksMap = new Map();
					const originalOrder = new Map();

					let i = 0;
					for (const c of chunks) {
						let occurs = 0;
						for (const chunkGroup of c.groupsIterable) {
							for (const parent of chunkGroup.parentsIterable) {
								if (parent.isInitial()) occurs++;
							}
						}
						occursInInitialChunksMap.set(c, occurs);
						originalOrder.set(c, i++);
					}

					chunks.sort((a, b) => {
						const aEntryOccurs = occursInInitialChunksMap.get(a);
						const bEntryOccurs = occursInInitialChunksMap.get(b);
						if (aEntryOccurs > bEntryOccurs) return -1;
						if (aEntryOccurs < bEntryOccurs) return 1;
						const aOccurs = a.getNumberOfGroups();
						const bOccurs = b.getNumberOfGroups();
						if (aOccurs > bOccurs) return -1;
						if (aOccurs < bOccurs) return 1;
						const orgA = originalOrder.get(a);
						const orgB = originalOrder.get(b);
						return orgA - orgB;
					});
				}
			);
		});
	}
}

module.exports = OccurrenceOrderPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/RemoveEmptyChunksPlugin.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/optimize/RemoveEmptyChunksPlugin.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class RemoveEmptyChunksPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("RemoveEmptyChunksPlugin", compilation => {
			const handler = chunks => {
				for (let i = chunks.length - 1; i >= 0; i--) {
					const chunk = chunks[i];
					if (
						chunk.isEmpty() &&
						!chunk.hasRuntime() &&
						!chunk.hasEntryModule()
					) {
						chunk.remove("empty");
						chunks.splice(i, 1);
					}
				}
			};
			compilation.hooks.optimizeChunksBasic.tap(
				"RemoveEmptyChunksPlugin",
				handler
			);
			compilation.hooks.optimizeChunksAdvanced.tap(
				"RemoveEmptyChunksPlugin",
				handler
			);
			compilation.hooks.optimizeExtractedChunksBasic.tap(
				"RemoveEmptyChunksPlugin",
				handler
			);
			compilation.hooks.optimizeExtractedChunksAdvanced.tap(
				"RemoveEmptyChunksPlugin",
				handler
			);
		});
	}
}
module.exports = RemoveEmptyChunksPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/optimize/RemoveParentModulesPlugin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Queue = __webpack_require__(/*! ../util/Queue */ "./node_modules/webpack/lib/util/Queue.js");
const { intersect } = __webpack_require__(/*! ../util/SetHelpers */ "./node_modules/webpack/lib/util/SetHelpers.js");

const getParentChunksWithModule = (currentChunk, module) => {
	const chunks = [];
	const stack = new Set(currentChunk.parentsIterable);

	for (const chunk of stack) {
		if (chunk.containsModule(module)) {
			chunks.push(chunk);
		} else {
			for (const parent of chunk.parentsIterable) {
				stack.add(parent);
			}
		}
	}

	return chunks;
};

class RemoveParentModulesPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("RemoveParentModulesPlugin", compilation => {
			const handler = (chunks, chunkGroups) => {
				const queue = new Queue();
				const availableModulesMap = new WeakMap();

				for (const chunkGroup of compilation.entrypoints.values()) {
					// initialize available modules for chunks without parents
					availableModulesMap.set(chunkGroup, new Set());
					for (const child of chunkGroup.childrenIterable) {
						queue.enqueue(child);
					}
				}

				while (queue.length > 0) {
					const chunkGroup = queue.dequeue();
					let availableModules = availableModulesMap.get(chunkGroup);
					let changed = false;
					for (const parent of chunkGroup.parentsIterable) {
						const availableModulesInParent = availableModulesMap.get(parent);
						if (availableModulesInParent !== undefined) {
							// If we know the available modules in parent: process these
							if (availableModules === undefined) {
								// if we have not own info yet: create new entry
								availableModules = new Set(availableModulesInParent);
								for (const chunk of parent.chunks) {
									for (const m of chunk.modulesIterable) {
										availableModules.add(m);
									}
								}
								availableModulesMap.set(chunkGroup, availableModules);
								changed = true;
							} else {
								for (const m of availableModules) {
									if (
										!parent.containsModule(m) &&
										!availableModulesInParent.has(m)
									) {
										availableModules.delete(m);
										changed = true;
									}
								}
							}
						}
					}
					if (changed) {
						// if something changed: enqueue our children
						for (const child of chunkGroup.childrenIterable) {
							queue.enqueue(child);
						}
					}
				}

				// now we have available modules for every chunk
				for (const chunk of chunks) {
					const availableModulesSets = Array.from(
						chunk.groupsIterable,
						chunkGroup => availableModulesMap.get(chunkGroup)
					);
					if (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group
					const availableModules =
						availableModulesSets.length === 1
							? availableModulesSets[0]
							: intersect(availableModulesSets);
					const numberOfModules = chunk.getNumberOfModules();
					const toRemove = new Set();
					if (numberOfModules < availableModules.size) {
						for (const m of chunk.modulesIterable) {
							if (availableModules.has(m)) {
								toRemove.add(m);
							}
						}
					} else {
						for (const m of availableModules) {
							if (chunk.containsModule(m)) {
								toRemove.add(m);
							}
						}
					}
					for (const module of toRemove) {
						module.rewriteChunkInReasons(
							chunk,
							getParentChunksWithModule(chunk, module)
						);
						chunk.removeModule(module);
					}
				}
			};
			compilation.hooks.optimizeChunksBasic.tap(
				"RemoveParentModulesPlugin",
				handler
			);
			compilation.hooks.optimizeExtractedChunksBasic.tap(
				"RemoveParentModulesPlugin",
				handler
			);
		});
	}
}
module.exports = RemoveParentModulesPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/RuntimeChunkPlugin.js":
/*!****************************************************!*\
  !*** (webpack)/lib/optimize/RuntimeChunkPlugin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


module.exports = class RuntimeChunkPlugin {
	constructor(options) {
		this.options = Object.assign(
			{
				name: entrypoint => `runtime~${entrypoint.name}`
			},
			options
		);
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap("RuntimeChunkPlugin", compilation => {
			compilation.hooks.optimizeChunksAdvanced.tap("RuntimeChunkPlugin", () => {
				for (const entrypoint of compilation.entrypoints.values()) {
					const chunk = entrypoint.getRuntimeChunk();
					let name = this.options.name;
					if (typeof name === "function") {
						name = name(entrypoint);
					}
					if (
						chunk.getNumberOfModules() > 0 ||
						!chunk.preventIntegration ||
						chunk.name !== name
					) {
						const newChunk = compilation.addChunk(name);
						newChunk.preventIntegration = true;
						entrypoint.unshiftChunk(newChunk);
						newChunk.addGroup(entrypoint);
						entrypoint.setRuntimeChunk(newChunk);
					}
				}
			});
		});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js":
/*!*******************************************************!*\
  !*** (webpack)/lib/optimize/SideEffectsFlagPlugin.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const mm = __webpack_require__(/*! micromatch */ "micromatch");
const HarmonyExportImportedSpecifierDependency = __webpack_require__(/*! ../dependencies/HarmonyExportImportedSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency.js");
const HarmonyImportSideEffectDependency = __webpack_require__(/*! ../dependencies/HarmonyImportSideEffectDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSideEffectDependency.js");
const HarmonyImportSpecifierDependency = __webpack_require__(/*! ../dependencies/HarmonyImportSpecifierDependency */ "./node_modules/webpack/lib/dependencies/HarmonyImportSpecifierDependency.js");

/** @typedef {import("../Module")} Module */
/** @typedef {import("../Dependency")} Dependency */

/**
 * @typedef {Object} ExportInModule
 * @property {Module} module the module
 * @property {string} exportName the name of the export
 */

class SideEffectsFlagPlugin {
	apply(compiler) {
		compiler.hooks.normalModuleFactory.tap("SideEffectsFlagPlugin", nmf => {
			nmf.hooks.module.tap("SideEffectsFlagPlugin", (module, data) => {
				const resolveData = data.resourceResolveData;
				if (
					resolveData &&
					resolveData.descriptionFileData &&
					resolveData.relativePath
				) {
					const sideEffects = resolveData.descriptionFileData.sideEffects;
					const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(
						resolveData.relativePath,
						sideEffects
					);
					if (!hasSideEffects) {
						module.factoryMeta.sideEffectFree = true;
					}
				}

				return module;
			});
			nmf.hooks.module.tap("SideEffectsFlagPlugin", (module, data) => {
				if (data.settings.sideEffects === false) {
					module.factoryMeta.sideEffectFree = true;
				} else if (data.settings.sideEffects === true) {
					module.factoryMeta.sideEffectFree = false;
				}
			});
		});
		compiler.hooks.compilation.tap("SideEffectsFlagPlugin", compilation => {
			compilation.hooks.optimizeDependencies.tap(
				"SideEffectsFlagPlugin",
				modules => {
					/** @type {Map<Module, Map<string, ExportInModule>>} */
					const reexportMaps = new Map();

					// Capture reexports of sideEffectFree modules
					for (const module of modules) {
						/** @type {Dependency[]} */
						const removeDependencies = [];
						for (const dep of module.dependencies) {
							if (dep instanceof HarmonyImportSideEffectDependency) {
								if (dep.module && dep.module.factoryMeta.sideEffectFree) {
									removeDependencies.push(dep);
								}
							} else if (
								dep instanceof HarmonyExportImportedSpecifierDependency
							) {
								if (module.factoryMeta.sideEffectFree) {
									const mode = dep.getMode(true);
									if (mode.type === "safe-reexport") {
										let map = reexportMaps.get(module);
										if (!map) {
											reexportMaps.set(module, (map = new Map()));
										}
										for (const pair of mode.map) {
											map.set(pair[0], {
												module: mode.module,
												exportName: pair[1]
											});
										}
									}
								}
							}
						}
					}

					// Flatten reexports
					for (const map of reexportMaps.values()) {
						for (const pair of map) {
							let mapping = pair[1];
							while (mapping) {
								const innerMap = reexportMaps.get(mapping.module);
								if (!innerMap) break;
								const newMapping = innerMap.get(mapping.exportName);
								if (newMapping) {
									map.set(pair[0], newMapping);
								}
								mapping = newMapping;
							}
						}
					}

					// Update imports along the reexports from sideEffectFree modules
					for (const pair of reexportMaps) {
						const module = pair[0];
						const map = pair[1];
						let newReasons = undefined;
						for (let i = 0; i < module.reasons.length; i++) {
							const reason = module.reasons[i];
							const dep = reason.dependency;
							if (
								dep instanceof HarmonyImportSpecifierDependency &&
								!dep.namespaceObjectAsContext
							) {
								const mapping = map.get(dep.id);
								if (mapping) {
									dep.redirectedModule = mapping.module;
									dep.redirectedId = mapping.exportName;
									mapping.module.addReason(
										reason.module,
										dep,
										reason.explanation
											? reason.explanation +
											  " (skipped side-effect-free modules)"
											: "(skipped side-effect-free modules)"
									);
									// removing the currect reason, by not adding it to the newReasons array
									// lazily create the newReasons array
									if (newReasons === undefined) {
										newReasons = i === 0 ? [] : module.reasons.slice(0, i);
									}
									continue;
								}
							}
							if (newReasons !== undefined) newReasons.push(reason);
						}
						if (newReasons !== undefined) {
							module.reasons = newReasons;
						}
					}
				}
			);
		});
	}

	static moduleHasSideEffects(moduleName, flagValue) {
		switch (typeof flagValue) {
			case "undefined":
				return true;
			case "boolean":
				return flagValue;
			case "string":
				if (process.platform === "win32") {
					flagValue = flagValue.replace(/\\/g, "/");
				}
				return mm.isMatch(moduleName, flagValue, {
					matchBase: true
				});
			case "object":
				return flagValue.some(glob =>
					SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob)
				);
		}
	}
}
module.exports = SideEffectsFlagPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/optimize/SplitChunksPlugin.js":
/*!***************************************************!*\
  !*** (webpack)/lib/optimize/SplitChunksPlugin.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const crypto = __webpack_require__(/*! crypto */ "crypto");
const SortableSet = __webpack_require__(/*! ../util/SortableSet */ "./node_modules/webpack/lib/util/SortableSet.js");
const GraphHelpers = __webpack_require__(/*! ../GraphHelpers */ "./node_modules/webpack/lib/GraphHelpers.js");
const { isSubset } = __webpack_require__(/*! ../util/SetHelpers */ "./node_modules/webpack/lib/util/SetHelpers.js");
const deterministicGrouping = __webpack_require__(/*! ../util/deterministicGrouping */ "./node_modules/webpack/lib/util/deterministicGrouping.js");
const MinMaxSizeWarning = __webpack_require__(/*! ./MinMaxSizeWarning */ "./node_modules/webpack/lib/optimize/MinMaxSizeWarning.js");
const contextify = __webpack_require__(/*! ../util/identifier */ "./node_modules/webpack/lib/util/identifier.js").contextify;

/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../util/deterministicGrouping").Options<Module>} DeterministicGroupingOptionsForModule */
/** @typedef {import("../util/deterministicGrouping").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */

const deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (deterministicGrouping);

const hashFilename = name => {
	return crypto
		.createHash("md4")
		.update(name)
		.digest("hex")
		.slice(0, 8);
};

const sortByIdentifier = (a, b) => {
	if (a.identifier() > b.identifier()) return 1;
	if (a.identifier() < b.identifier()) return -1;
	return 0;
};

const getRequests = chunk => {
	let requests = 0;
	for (const chunkGroup of chunk.groupsIterable) {
		requests = Math.max(requests, chunkGroup.chunks.length);
	}
	return requests;
};

const getModulesSize = modules => {
	let sum = 0;
	for (const m of modules) {
		sum += m.size();
	}
	return sum;
};

/**
 * @template T
 * @param {Set<T>} a set
 * @param {Set<T>} b other set
 * @returns {boolean} true if at least one item of a is in b
 */
const isOverlap = (a, b) => {
	for (const item of a) {
		if (b.has(item)) return true;
	}
	return false;
};

const compareEntries = (a, b) => {
	// 1. by priority
	const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;
	if (diffPriority) return diffPriority;
	// 2. by number of chunks
	const diffCount = a.chunks.size - b.chunks.size;
	if (diffCount) return diffCount;
	// 3. by size reduction
	const aSizeReduce = a.size * (a.chunks.size - 1);
	const bSizeReduce = b.size * (b.chunks.size - 1);
	const diffSizeReduce = aSizeReduce - bSizeReduce;
	if (diffSizeReduce) return diffSizeReduce;
	// 4. by number of modules (to be able to compare by identifier)
	const modulesA = a.modules;
	const modulesB = b.modules;
	const diff = modulesA.size - modulesB.size;
	if (diff) return diff;
	// 5. by module identifiers
	modulesA.sort();
	modulesB.sort();
	const aI = modulesA[Symbol.iterator]();
	const bI = modulesB[Symbol.iterator]();
	// eslint-disable-next-line no-constant-condition
	while (true) {
		const aItem = aI.next();
		const bItem = bI.next();
		if (aItem.done) return 0;
		const aModuleIdentifier = aItem.value.identifier();
		const bModuleIdentifier = bItem.value.identifier();
		if (aModuleIdentifier > bModuleIdentifier) return -1;
		if (aModuleIdentifier < bModuleIdentifier) return 1;
	}
};

const compareNumbers = (a, b) => a - b;

const INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();
const ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();
const ALL_CHUNK_FILTER = chunk => true;

module.exports = class SplitChunksPlugin {
	constructor(options) {
		this.options = SplitChunksPlugin.normalizeOptions(options);
	}

	static normalizeOptions(options = {}) {
		return {
			chunksFilter: SplitChunksPlugin.normalizeChunksFilter(
				options.chunks || "all"
			),
			minSize: options.minSize || 0,
			maxSize: options.maxSize || 0,
			minChunks: options.minChunks || 1,
			maxAsyncRequests: options.maxAsyncRequests || 1,
			maxInitialRequests: options.maxInitialRequests || 1,
			hidePathInfo: options.hidePathInfo || false,
			filename: options.filename || undefined,
			getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({
				cacheGroups: options.cacheGroups,
				name: options.name,
				automaticNameDelimiter: options.automaticNameDelimiter
			}),
			automaticNameDelimiter: options.automaticNameDelimiter,
			fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(
				options.fallbackCacheGroup || {},
				options
			)
		};
	}

	static normalizeName({ name, automaticNameDelimiter, automaticNamePrefix }) {
		if (name === true) {
			/** @type {WeakMap<Chunk[], Record<string, string>>} */
			const cache = new WeakMap();
			const fn = (module, chunks, cacheGroup) => {
				let cacheEntry = cache.get(chunks);
				if (cacheEntry === undefined) {
					cacheEntry = {};
					cache.set(chunks, cacheEntry);
				} else if (cacheGroup in cacheEntry) {
					return cacheEntry[cacheGroup];
				}
				const names = chunks.map(c => c.name);
				if (!names.every(Boolean)) {
					cacheEntry[cacheGroup] = undefined;
					return;
				}
				names.sort();
				const prefix =
					typeof automaticNamePrefix === "string"
						? automaticNamePrefix
						: cacheGroup;
				const namePrefix = prefix ? prefix + automaticNameDelimiter : "";
				let name = namePrefix + names.join(automaticNameDelimiter);
				// Filenames and paths can't be too long otherwise an
				// ENAMETOOLONG error is raised. If the generated name if too
				// long, it is truncated and a hash is appended. The limit has
				// been set to 100 to prevent `[name].[chunkhash].[ext]` from
				// generating a 256+ character string.
				if (name.length > 100) {
					name =
						name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);
				}
				cacheEntry[cacheGroup] = name;
				return name;
			};
			return fn;
		}
		if (typeof name === "string") {
			const fn = () => {
				return name;
			};
			return fn;
		}
		if (typeof name === "function") return name;
	}

	static normalizeChunksFilter(chunks) {
		if (chunks === "initial") {
			return INITIAL_CHUNK_FILTER;
		}
		if (chunks === "async") {
			return ASYNC_CHUNK_FILTER;
		}
		if (chunks === "all") {
			return ALL_CHUNK_FILTER;
		}
		if (typeof chunks === "function") return chunks;
	}

	static normalizeFallbackCacheGroup(
		{
			minSize = undefined,
			maxSize = undefined,
			automaticNameDelimiter = undefined
		},
		{
			minSize: defaultMinSize = undefined,
			maxSize: defaultMaxSize = undefined,
			automaticNameDelimiter: defaultAutomaticNameDelimiter = undefined
		}
	) {
		return {
			minSize: typeof minSize === "number" ? minSize : defaultMinSize || 0,
			maxSize: typeof maxSize === "number" ? maxSize : defaultMaxSize || 0,
			automaticNameDelimiter:
				automaticNameDelimiter || defaultAutomaticNameDelimiter || "~"
		};
	}

	static normalizeCacheGroups({ cacheGroups, name, automaticNameDelimiter }) {
		if (typeof cacheGroups === "function") {
			// TODO webpack 5 remove this
			if (cacheGroups.length !== 1) {
				return module => cacheGroups(module, module.getChunks());
			}
			return cacheGroups;
		}
		if (cacheGroups && typeof cacheGroups === "object") {
			const fn = module => {
				let results;
				for (const key of Object.keys(cacheGroups)) {
					let option = cacheGroups[key];
					if (option === false) continue;
					if (option instanceof RegExp || typeof option === "string") {
						option = {
							test: option
						};
					}
					if (typeof option === "function") {
						let result = option(module);
						if (result) {
							if (results === undefined) results = [];
							for (const r of Array.isArray(result) ? result : [result]) {
								const result = Object.assign({ key }, r);
								if (result.name) result.getName = () => result.name;
								if (result.chunks) {
									result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(
										result.chunks
									);
								}
								results.push(result);
							}
						}
					} else if (SplitChunksPlugin.checkTest(option.test, module)) {
						if (results === undefined) results = [];
						results.push({
							key: key,
							priority: option.priority,
							getName:
								SplitChunksPlugin.normalizeName({
									name: option.name || name,
									automaticNameDelimiter:
										typeof option.automaticNameDelimiter === "string"
											? option.automaticNameDelimiter
											: automaticNameDelimiter,
									automaticNamePrefix: option.automaticNamePrefix
								}) || (() => {}),
							chunksFilter: SplitChunksPlugin.normalizeChunksFilter(
								option.chunks
							),
							enforce: option.enforce,
							minSize: option.minSize,
							maxSize: option.maxSize,
							minChunks: option.minChunks,
							maxAsyncRequests: option.maxAsyncRequests,
							maxInitialRequests: option.maxInitialRequests,
							filename: option.filename,
							reuseExistingChunk: option.reuseExistingChunk
						});
					}
				}
				return results;
			};
			return fn;
		}
		const fn = () => {};
		return fn;
	}

	static checkTest(test, module) {
		if (test === undefined) return true;
		if (typeof test === "function") {
			if (test.length !== 1) {
				return test(module, module.getChunks());
			}
			return test(module);
		}
		if (typeof test === "boolean") return test;
		if (typeof test === "string") {
			if (
				module.nameForCondition &&
				module.nameForCondition().startsWith(test)
			) {
				return true;
			}
			for (const chunk of module.chunksIterable) {
				if (chunk.name && chunk.name.startsWith(test)) {
					return true;
				}
			}
			return false;
		}
		if (test instanceof RegExp) {
			if (module.nameForCondition && test.test(module.nameForCondition())) {
				return true;
			}
			for (const chunk of module.chunksIterable) {
				if (chunk.name && test.test(chunk.name)) {
					return true;
				}
			}
			return false;
		}
		return false;
	}

	/**
	 * @param {Compiler} compiler webpack compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap("SplitChunksPlugin", compilation => {
			let alreadyOptimized = false;
			compilation.hooks.unseal.tap("SplitChunksPlugin", () => {
				alreadyOptimized = false;
			});
			compilation.hooks.optimizeChunksAdvanced.tap(
				"SplitChunksPlugin",
				chunks => {
					if (alreadyOptimized) return;
					alreadyOptimized = true;
					// Give each selected chunk an index (to create strings from chunks)
					const indexMap = new Map();
					let index = 1;
					for (const chunk of chunks) {
						indexMap.set(chunk, index++);
					}
					const getKey = chunks => {
						return Array.from(chunks, c => indexMap.get(c))
							.sort(compareNumbers)
							.join();
					};
					/** @type {Map<string, Set<Chunk>>} */
					const chunkSetsInGraph = new Map();
					for (const module of compilation.modules) {
						const chunksKey = getKey(module.chunksIterable);
						if (!chunkSetsInGraph.has(chunksKey)) {
							chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));
						}
					}

					// group these set of chunks by count
					// to allow to check less sets via isSubset
					// (only smaller sets can be subset)
					/** @type {Map<number, Array<Set<Chunk>>>} */
					const chunkSetsByCount = new Map();
					for (const chunksSet of chunkSetsInGraph.values()) {
						const count = chunksSet.size;
						let array = chunkSetsByCount.get(count);
						if (array === undefined) {
							array = [];
							chunkSetsByCount.set(count, array);
						}
						array.push(chunksSet);
					}

					// Create a list of possible combinations
					const combinationsCache = new Map(); // Map<string, Set<Chunk>[]>

					const getCombinations = key => {
						const chunksSet = chunkSetsInGraph.get(key);
						var array = [chunksSet];
						if (chunksSet.size > 1) {
							for (const [count, setArray] of chunkSetsByCount) {
								// "equal" is not needed because they would have been merge in the first step
								if (count < chunksSet.size) {
									for (const set of setArray) {
										if (isSubset(chunksSet, set)) {
											array.push(set);
										}
									}
								}
							}
						}
						return array;
					};

					/**
					 * @typedef {Object} SelectedChunksResult
					 * @property {Chunk[]} chunks the list of chunks
					 * @property {string} key a key of the list
					 */

					/**
					 * @typedef {function(Chunk): boolean} ChunkFilterFunction
					 */

					/** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */
					const selectedChunksCacheByChunksSet = new WeakMap();

					/**
					 * get list and key by applying the filter function to the list
					 * It is cached for performance reasons
					 * @param {Set<Chunk>} chunks list of chunks
					 * @param {ChunkFilterFunction} chunkFilter filter function for chunks
					 * @returns {SelectedChunksResult} list and key
					 */
					const getSelectedChunks = (chunks, chunkFilter) => {
						let entry = selectedChunksCacheByChunksSet.get(chunks);
						if (entry === undefined) {
							entry = new WeakMap();
							selectedChunksCacheByChunksSet.set(chunks, entry);
						}
						/** @type {SelectedChunksResult} */
						let entry2 = entry.get(chunkFilter);
						if (entry2 === undefined) {
							/** @type {Chunk[]} */
							const selectedChunks = [];
							for (const chunk of chunks) {
								if (chunkFilter(chunk)) selectedChunks.push(chunk);
							}
							entry2 = {
								chunks: selectedChunks,
								key: getKey(selectedChunks)
							};
							entry.set(chunkFilter, entry2);
						}
						return entry2;
					};

					/**
					 * @typedef {Object} ChunksInfoItem
					 * @property {SortableSet} modules
					 * @property {TODO} cacheGroup
					 * @property {string} name
					 * @property {boolean} validateSize
					 * @property {number} size
					 * @property {Set<Chunk>} chunks
					 * @property {Set<Chunk>} reuseableChunks
					 * @property {Set<string>} chunksKeys
					 */

					// Map a list of chunks to a list of modules
					// For the key the chunk "index" is used, the value is a SortableSet of modules
					/** @type {Map<string, ChunksInfoItem>} */
					const chunksInfoMap = new Map();

					/**
					 * @param {TODO} cacheGroup the current cache group
					 * @param {Chunk[]} selectedChunks chunks selected for this module
					 * @param {string} selectedChunksKey a key of selectedChunks
					 * @param {Module} module the current module
					 * @returns {void}
					 */
					const addModuleToChunksInfoMap = (
						cacheGroup,
						selectedChunks,
						selectedChunksKey,
						module
					) => {
						// Break if minimum number of chunks is not reached
						if (selectedChunks.length < cacheGroup.minChunks) return;
						// Determine name for split chunk
						const name = cacheGroup.getName(
							module,
							selectedChunks,
							cacheGroup.key
						);
						// Create key for maps
						// When it has a name we use the name as key
						// Elsewise we create the key from chunks and cache group key
						// This automatically merges equal names
						const key =
							cacheGroup.key +
							(name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);
						// Add module to maps
						let info = chunksInfoMap.get(key);
						if (info === undefined) {
							chunksInfoMap.set(
								key,
								(info = {
									modules: new SortableSet(undefined, sortByIdentifier),
									cacheGroup,
									name,
									validateSize: cacheGroup.minSize > 0,
									size: 0,
									chunks: new Set(),
									reuseableChunks: new Set(),
									chunksKeys: new Set()
								})
							);
						}
						info.modules.add(module);
						if (info.validateSize) {
							info.size += module.size();
						}
						if (!info.chunksKeys.has(selectedChunksKey)) {
							info.chunksKeys.add(selectedChunksKey);
							for (const chunk of selectedChunks) {
								info.chunks.add(chunk);
							}
						}
					};

					// Walk through all modules
					for (const module of compilation.modules) {
						// Get cache group
						let cacheGroups = this.options.getCacheGroups(module);
						if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {
							continue;
						}

						// Prepare some values
						const chunksKey = getKey(module.chunksIterable);
						let combs = combinationsCache.get(chunksKey);
						if (combs === undefined) {
							combs = getCombinations(chunksKey);
							combinationsCache.set(chunksKey, combs);
						}

						for (const cacheGroupSource of cacheGroups) {
							const cacheGroup = {
								key: cacheGroupSource.key,
								priority: cacheGroupSource.priority || 0,
								chunksFilter:
									cacheGroupSource.chunksFilter || this.options.chunksFilter,
								minSize:
									cacheGroupSource.minSize !== undefined
										? cacheGroupSource.minSize
										: cacheGroupSource.enforce
											? 0
											: this.options.minSize,
								minSizeForMaxSize:
									cacheGroupSource.minSize !== undefined
										? cacheGroupSource.minSize
										: this.options.minSize,
								maxSize:
									cacheGroupSource.maxSize !== undefined
										? cacheGroupSource.maxSize
										: cacheGroupSource.enforce
											? 0
											: this.options.maxSize,
								minChunks:
									cacheGroupSource.minChunks !== undefined
										? cacheGroupSource.minChunks
										: cacheGroupSource.enforce
											? 1
											: this.options.minChunks,
								maxAsyncRequests:
									cacheGroupSource.maxAsyncRequests !== undefined
										? cacheGroupSource.maxAsyncRequests
										: cacheGroupSource.enforce
											? Infinity
											: this.options.maxAsyncRequests,
								maxInitialRequests:
									cacheGroupSource.maxInitialRequests !== undefined
										? cacheGroupSource.maxInitialRequests
										: cacheGroupSource.enforce
											? Infinity
											: this.options.maxInitialRequests,
								getName:
									cacheGroupSource.getName !== undefined
										? cacheGroupSource.getName
										: this.options.getName,
								filename:
									cacheGroupSource.filename !== undefined
										? cacheGroupSource.filename
										: this.options.filename,
								automaticNameDelimiter:
									cacheGroupSource.automaticNameDelimiter !== undefined
										? cacheGroupSource.automaticNameDelimiter
										: this.options.automaticNameDelimiter,
								reuseExistingChunk: cacheGroupSource.reuseExistingChunk
							};
							// For all combination of chunk selection
							for (const chunkCombination of combs) {
								// Break if minimum number of chunks is not reached
								if (chunkCombination.size < cacheGroup.minChunks) continue;
								// Select chunks by configuration
								const {
									chunks: selectedChunks,
									key: selectedChunksKey
								} = getSelectedChunks(
									chunkCombination,
									cacheGroup.chunksFilter
								);

								addModuleToChunksInfoMap(
									cacheGroup,
									selectedChunks,
									selectedChunksKey,
									module
								);
							}
						}
					}

					// Filter items were size < minSize
					for (const pair of chunksInfoMap) {
						const info = pair[1];
						if (info.validateSize && info.size < info.cacheGroup.minSize) {
							chunksInfoMap.delete(pair[0]);
						}
					}

					/** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */
					const maxSizeQueueMap = new Map();

					while (chunksInfoMap.size > 0) {
						// Find best matching entry
						let bestEntryKey;
						let bestEntry;
						for (const pair of chunksInfoMap) {
							const key = pair[0];
							const info = pair[1];
							if (bestEntry === undefined) {
								bestEntry = info;
								bestEntryKey = key;
							} else if (compareEntries(bestEntry, info) < 0) {
								bestEntry = info;
								bestEntryKey = key;
							}
						}

						const item = bestEntry;
						chunksInfoMap.delete(bestEntryKey);

						let chunkName = item.name;
						// Variable for the new chunk (lazy created)
						/** @type {Chunk} */
						let newChunk;
						// When no chunk name, check if we can reuse a chunk instead of creating a new one
						let isReused = false;
						if (item.cacheGroup.reuseExistingChunk) {
							outer: for (const chunk of item.chunks) {
								if (chunk.getNumberOfModules() !== item.modules.size) continue;
								if (chunk.hasEntryModule()) continue;
								for (const module of item.modules) {
									if (!chunk.containsModule(module)) continue outer;
								}
								if (!newChunk || !newChunk.name) {
									newChunk = chunk;
								} else if (
									chunk.name &&
									chunk.name.length < newChunk.name.length
								) {
									newChunk = chunk;
								} else if (
									chunk.name &&
									chunk.name.length === newChunk.name.length &&
									chunk.name < newChunk.name
								) {
									newChunk = chunk;
								}
								chunkName = undefined;
								isReused = true;
							}
						}
						// Check if maxRequests condition can be fulfilled

						const usedChunks = Array.from(item.chunks).filter(chunk => {
							// skip if we address ourself
							return (
								(!chunkName || chunk.name !== chunkName) && chunk !== newChunk
							);
						});

						// Skip when no chunk selected
						if (usedChunks.length === 0) continue;

						if (
							Number.isFinite(item.cacheGroup.maxInitialRequests) ||
							Number.isFinite(item.cacheGroup.maxAsyncRequests)
						) {
							const chunkInLimit = usedChunks.filter(chunk => {
								// respect max requests when not enforced
								const maxRequests = chunk.isOnlyInitial()
									? item.cacheGroup.maxInitialRequests
									: chunk.canBeInitial()
										? Math.min(
												item.cacheGroup.maxInitialRequests,
												item.cacheGroup.maxAsyncRequests
										  )
										: item.cacheGroup.maxAsyncRequests;
								return (
									!isFinite(maxRequests) || getRequests(chunk) < maxRequests
								);
							});

							if (chunkInLimit.length < usedChunks.length) {
								if (chunkInLimit.length >= item.cacheGroup.minChunks) {
									for (const module of item.modules) {
										addModuleToChunksInfoMap(
											item.cacheGroup,
											chunkInLimit,
											getKey(chunkInLimit),
											module
										);
									}
								}
								continue;
							}
						}

						// Create the new chunk if not reusing one
						if (!isReused) {
							newChunk = compilation.addChunk(chunkName);
						}
						// Walk through all chunks
						for (const chunk of usedChunks) {
							// Add graph connections for splitted chunk
							chunk.split(newChunk);
						}

						// Add a note to the chunk
						newChunk.chunkReason = isReused
							? "reused as split chunk"
							: "split chunk";
						if (item.cacheGroup.key) {
							newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;
						}
						if (chunkName) {
							newChunk.chunkReason += ` (name: ${chunkName})`;
							// If the chosen name is already an entry point we remove the entry point
							const entrypoint = compilation.entrypoints.get(chunkName);
							if (entrypoint) {
								compilation.entrypoints.delete(chunkName);
								entrypoint.remove();
								newChunk.entryModule = undefined;
							}
						}
						if (item.cacheGroup.filename) {
							if (!newChunk.isOnlyInitial()) {
								throw new Error(
									"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. " +
										"The runtime can only handle loading of chunks which match the chunkFilename schema. " +
										"Using a custom filename would fail at runtime. " +
										`(cache group: ${item.cacheGroup.key})`
								);
							}
							newChunk.filenameTemplate = item.cacheGroup.filename;
						}
						if (!isReused) {
							// Add all modules to the new chunk
							for (const module of item.modules) {
								if (typeof module.chunkCondition === "function") {
									if (!module.chunkCondition(newChunk)) continue;
								}
								// Add module to new chunk
								GraphHelpers.connectChunkAndModule(newChunk, module);
								// Remove module from used chunks
								for (const chunk of usedChunks) {
									chunk.removeModule(module);
									module.rewriteChunkInReasons(chunk, [newChunk]);
								}
							}
						} else {
							// Remove all modules from used chunks
							for (const module of item.modules) {
								for (const chunk of usedChunks) {
									chunk.removeModule(module);
									module.rewriteChunkInReasons(chunk, [newChunk]);
								}
							}
						}

						if (item.cacheGroup.maxSize > 0) {
							const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);
							maxSizeQueueMap.set(newChunk, {
								minSize: Math.max(
									oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,
									item.cacheGroup.minSizeForMaxSize
								),
								maxSize: Math.min(
									oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,
									item.cacheGroup.maxSize
								),
								automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,
								keys: oldMaxSizeSettings
									? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)
									: [item.cacheGroup.key]
							});
						}

						// remove all modules from other entries and update size
						for (const [key, info] of chunksInfoMap) {
							if (isOverlap(info.chunks, item.chunks)) {
								if (info.validateSize) {
									// update modules and total size
									// may remove it from the map when < minSize
									const oldSize = info.modules.size;
									for (const module of item.modules) {
										info.modules.delete(module);
									}
									if (info.modules.size === 0) {
										chunksInfoMap.delete(key);
										continue;
									}
									if (info.modules.size !== oldSize) {
										info.size = getModulesSize(info.modules);
										if (info.size < info.cacheGroup.minSize) {
											chunksInfoMap.delete(key);
										}
									}
								} else {
									// only update the modules
									for (const module of item.modules) {
										info.modules.delete(module);
									}
									if (info.modules.size === 0) {
										chunksInfoMap.delete(key);
									}
								}
							}
						}
					}

					const incorrectMinMaxSizeSet = new Set();

					// Make sure that maxSize is fulfilled
					for (const chunk of compilation.chunks.slice()) {
						const { minSize, maxSize, automaticNameDelimiter, keys } =
							maxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;
						if (!maxSize) continue;
						if (minSize > maxSize) {
							const warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;
							if (!incorrectMinMaxSizeSet.has(warningKey)) {
								incorrectMinMaxSizeSet.add(warningKey);
								compilation.warnings.push(
									new MinMaxSizeWarning(keys, minSize, maxSize)
								);
							}
						}
						const results = deterministicGroupingForModules({
							maxSize: Math.max(minSize, maxSize),
							minSize,
							items: chunk.modulesIterable,
							getKey(module) {
								const ident = contextify(
									compilation.options.context,
									module.identifier()
								);
								const name = module.nameForCondition
									? contextify(
											compilation.options.context,
											module.nameForCondition()
									  )
									: ident.replace(/^.*!|\?[^?!]*$/g, "");
								const fullKey =
									name + automaticNameDelimiter + hashFilename(ident);
								return fullKey.replace(/[\\/?]/g, "_");
							},
							getSize(module) {
								return module.size();
							}
						});
						results.sort((a, b) => {
							if (a.key < b.key) return -1;
							if (a.key > b.key) return 1;
							return 0;
						});
						for (let i = 0; i < results.length; i++) {
							const group = results[i];
							const key = this.options.hidePathInfo
								? hashFilename(group.key)
								: group.key;
							let name = chunk.name
								? chunk.name + automaticNameDelimiter + key
								: null;
							if (name && name.length > 100) {
								name =
									name.slice(0, 100) +
									automaticNameDelimiter +
									hashFilename(name);
							}
							let newPart;
							if (i !== results.length - 1) {
								newPart = compilation.addChunk(name);
								chunk.split(newPart);
								newPart.chunkReason = chunk.chunkReason;
								// Add all modules to the new chunk
								for (const module of group.items) {
									if (typeof module.chunkCondition === "function") {
										if (!module.chunkCondition(newPart)) continue;
									}
									// Add module to new chunk
									GraphHelpers.connectChunkAndModule(newPart, module);
									// Remove module from used chunks
									chunk.removeModule(module);
									module.rewriteChunkInReasons(chunk, [newPart]);
								}
							} else {
								// change the chunk to be a part
								newPart = chunk;
								chunk.name = name;
							}
						}
					}
				}
			);
		});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/performance/AssetsOverSizeLimitWarning.js":
/*!***************************************************************!*\
  !*** (webpack)/lib/performance/AssetsOverSizeLimitWarning.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/


const WebpackError = __webpack_require__(/*! ../WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const SizeFormatHelpers = __webpack_require__(/*! ../SizeFormatHelpers */ "./node_modules/webpack/lib/SizeFormatHelpers.js");

module.exports = class AssetsOverSizeLimitWarning extends WebpackError {
	constructor(assetsOverSizeLimit, assetLimit) {
		const assetLists = assetsOverSizeLimit
			.map(
				asset =>
					`\n  ${asset.name} (${SizeFormatHelpers.formatSize(asset.size)})`
			)
			.join("");

		super(`asset size limit: The following asset(s) exceed the recommended size limit (${SizeFormatHelpers.formatSize(
			assetLimit
		)}).
This can impact web performance.
Assets: ${assetLists}`);

		this.name = "AssetsOverSizeLimitWarning";
		this.assets = assetsOverSizeLimit;

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/performance/EntrypointsOverSizeLimitWarning.js":
/*!********************************************************************!*\
  !*** (webpack)/lib/performance/EntrypointsOverSizeLimitWarning.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/


const WebpackError = __webpack_require__(/*! ../WebpackError */ "./node_modules/webpack/lib/WebpackError.js");
const SizeFormatHelpers = __webpack_require__(/*! ../SizeFormatHelpers */ "./node_modules/webpack/lib/SizeFormatHelpers.js");

module.exports = class EntrypointsOverSizeLimitWarning extends WebpackError {
	constructor(entrypoints, entrypointLimit) {
		const entrypointList = entrypoints
			.map(
				entrypoint =>
					`\n  ${entrypoint.name} (${SizeFormatHelpers.formatSize(
						entrypoint.size
					)})\n${entrypoint.files.map(asset => `      ${asset}`).join("\n")}`
			)
			.join("");
		super(`entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (${SizeFormatHelpers.formatSize(
			entrypointLimit
		)}). This can impact web performance.
Entrypoints:${entrypointList}\n`);

		this.name = "EntrypointsOverSizeLimitWarning";
		this.entrypoints = entrypoints;

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/performance/NoAsyncChunksWarning.js":
/*!*********************************************************!*\
  !*** (webpack)/lib/performance/NoAsyncChunksWarning.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/


const WebpackError = __webpack_require__(/*! ../WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

module.exports = class NoAsyncChunksWarning extends WebpackError {
	constructor() {
		super(
			"webpack performance recommendations: \n" +
				"You can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.\n" +
				"For more info visit https://webpack.js.org/guides/code-splitting/"
		);

		this.name = "NoAsyncChunksWarning";

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/performance/SizeLimitsPlugin.js":
/*!*****************************************************!*\
  !*** (webpack)/lib/performance/SizeLimitsPlugin.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/

const EntrypointsOverSizeLimitWarning = __webpack_require__(/*! ./EntrypointsOverSizeLimitWarning */ "./node_modules/webpack/lib/performance/EntrypointsOverSizeLimitWarning.js");
const AssetsOverSizeLimitWarning = __webpack_require__(/*! ./AssetsOverSizeLimitWarning */ "./node_modules/webpack/lib/performance/AssetsOverSizeLimitWarning.js");
const NoAsyncChunksWarning = __webpack_require__(/*! ./NoAsyncChunksWarning */ "./node_modules/webpack/lib/performance/NoAsyncChunksWarning.js");

module.exports = class SizeLimitsPlugin {
	constructor(options) {
		this.hints = options.hints;
		this.maxAssetSize = options.maxAssetSize;
		this.maxEntrypointSize = options.maxEntrypointSize;
		this.assetFilter = options.assetFilter;
	}
	apply(compiler) {
		const entrypointSizeLimit = this.maxEntrypointSize;
		const assetSizeLimit = this.maxAssetSize;
		const hints = this.hints;
		const assetFilter = this.assetFilter || (asset => !asset.endsWith(".map"));

		compiler.hooks.afterEmit.tap("SizeLimitsPlugin", compilation => {
			const warnings = [];

			const getEntrypointSize = entrypoint =>
				entrypoint.getFiles().reduce((currentSize, file) => {
					if (assetFilter(file) && compilation.assets[file]) {
						return currentSize + compilation.assets[file].size();
					}

					return currentSize;
				}, 0);

			const assetsOverSizeLimit = [];
			for (const assetName of Object.keys(compilation.assets)) {
				if (!assetFilter(assetName)) {
					continue;
				}

				const asset = compilation.assets[assetName];
				const size = asset.size();
				if (size > assetSizeLimit) {
					assetsOverSizeLimit.push({
						name: assetName,
						size: size
					});
					asset.isOverSizeLimit = true;
				}
			}

			const entrypointsOverLimit = [];
			for (const pair of compilation.entrypoints) {
				const name = pair[0];
				const entry = pair[1];
				const size = getEntrypointSize(entry);

				if (size > entrypointSizeLimit) {
					entrypointsOverLimit.push({
						name: name,
						size: size,
						files: entry.getFiles().filter(assetFilter)
					});
					entry.isOverSizeLimit = true;
				}
			}

			if (hints) {
				// 1. Individual Chunk: Size < 250kb
				// 2. Collective Initial Chunks [entrypoint] (Each Set?): Size < 250kb
				// 3. No Async Chunks
				// if !1, then 2, if !2 return
				if (assetsOverSizeLimit.length > 0) {
					warnings.push(
						new AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit)
					);
				}
				if (entrypointsOverLimit.length > 0) {
					warnings.push(
						new EntrypointsOverSizeLimitWarning(
							entrypointsOverLimit,
							entrypointSizeLimit
						)
					);
				}

				if (warnings.length > 0) {
					const hasAsyncChunks =
						compilation.chunks.filter(chunk => !chunk.canBeInitial()).length >
						0;

					if (!hasAsyncChunks) {
						warnings.push(new NoAsyncChunksWarning());
					}

					if (hints === "error") {
						compilation.errors.push(...warnings);
					} else {
						compilation.warnings.push(...warnings);
					}
				}
			}
		});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/util/Queue.js":
/*!***********************************!*\
  !*** (webpack)/lib/util/Queue.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @template T
 */
class Queue {
	/**
	 * @param {Iterable<T>=} items The initial elements.
	 */
	constructor(items) {
		/** @private @type {Set<T>} */
		this.set = new Set(items);
		/** @private @type {Iterator<T>} */
		this.iterator = this.set[Symbol.iterator]();
	}

	/**
	 * Returns the number of elements in this queue.
	 * @returns {number} The number of elements in this queue.
	 */
	get length() {
		return this.set.size;
	}

	/**
	 * Appends the specified element to this queue.
	 * @param {T} item The element to add.
	 * @returns {void}
	 */
	enqueue(item) {
		this.set.add(item);
	}

	/**
	 * Retrieves and removes the head of this queue.
	 * @returns {T | undefined} The head of the queue of `undefined` if this queue is empty.
	 */
	dequeue() {
		const result = this.iterator.next();
		if (result.done) return undefined;
		this.set.delete(result.value);
		return result.value;
	}
}

module.exports = Queue;


/***/ }),

/***/ "./node_modules/webpack/lib/util/Semaphore.js":
/*!***************************************!*\
  !*** (webpack)/lib/util/Semaphore.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class Semaphore {
	/**
	 * Creates an instance of Semaphore.
	 *
	 * @param {number} available the amount available number of "tasks"
	 * in the Semaphore
	 */
	constructor(available) {
		this.available = available;
		/** @type {(function(): void)[]} */
		this.waiters = [];
		/** @private */
		this._continue = this._continue.bind(this);
	}

	/**
	 * @param {function(): void} callback function block to capture and run
	 * @returns {void}
	 */
	acquire(callback) {
		if (this.available > 0) {
			this.available--;
			callback();
		} else {
			this.waiters.push(callback);
		}
	}

	release() {
		this.available++;
		if (this.waiters.length > 0) {
			process.nextTick(this._continue);
		}
	}

	_continue() {
		if (this.available > 0) {
			if (this.waiters.length > 0) {
				this.available--;
				const callback = this.waiters.pop();
				callback();
			}
		}
	}
}

module.exports = Semaphore;


/***/ }),

/***/ "./node_modules/webpack/lib/util/SetHelpers.js":
/*!****************************************!*\
  !*** (webpack)/lib/util/SetHelpers.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * intersect creates Set containing the intersection of elements between all sets
 * @param {Set[]} sets an array of sets being checked for shared elements
 * @returns {Set<TODO>} returns a new Set containing the intersecting items
 */
const intersect = sets => {
	if (sets.length === 0) return new Set();
	if (sets.length === 1) return new Set(sets[0]);
	let minSize = Infinity;
	let minIndex = -1;
	for (let i = 0; i < sets.length; i++) {
		const size = sets[i].size;
		if (size < minSize) {
			minIndex = i;
			minSize = size;
		}
	}
	const current = new Set(sets[minIndex]);
	for (let i = 0; i < sets.length; i++) {
		if (i === minIndex) continue;
		const set = sets[i];
		for (const item of current) {
			if (!set.has(item)) {
				current.delete(item);
			}
		}
	}
	return current;
};

/**
 * Checks if a set is the subset of another set
 * @param {Set<TODO>} bigSet a Set which contains the original elements to compare against
 * @param {Set<TODO>} smallSet the set whos elements might be contained inside of bigSet
 * @returns {boolean} returns true if smallSet contains all elements inside of the bigSet
 */
const isSubset = (bigSet, smallSet) => {
	if (bigSet.size < smallSet.size) return false;
	for (const item of smallSet) {
		if (!bigSet.has(item)) return false;
	}
	return true;
};

exports.intersect = intersect;
exports.isSubset = isSubset;


/***/ }),

/***/ "./node_modules/webpack/lib/util/SortableSet.js":
/*!*****************************************!*\
  !*** (webpack)/lib/util/SortableSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A subset of Set that offers sorting functionality
 * @template T item type in set
 * @extends {Set<T>}
 */
class SortableSet extends Set {
	/**
	 * Create a new sortable set
	 * @param {Iterable<T>=} initialIterable The initial iterable value
	 * @typedef {function(T, T): number} SortFunction
	 * @param {SortFunction=} defaultSort Default sorting function
	 */
	constructor(initialIterable, defaultSort) {
		super(initialIterable);
		/** @private @type {function(T, T): number}} */
		this._sortFn = defaultSort;
		/** @private @type {function(T, T): number} | null} */
		this._lastActiveSortFn = null;
		/** @private @type {Map<Function, T[]> | undefined} */
		this._cache = undefined;
		/** @private @type {Map<Function, T[]|string|number> | undefined} */
		this._cacheOrderIndependent = undefined;
	}

	/**
	 * @param {T} value value to add to set
	 * @returns {this} returns itself
	 */
	add(value) {
		this._lastActiveSortFn = null;
		this._invalidateCache();
		this._invalidateOrderedCache();
		super.add(value);
		return this;
	}

	/**
	 * @param {T} value value to delete
	 * @returns {boolean} true if value existed in set, false otherwise
	 */
	delete(value) {
		this._invalidateCache();
		this._invalidateOrderedCache();
		return super.delete(value);
	}

	/**
	 * @returns {void}
	 */
	clear() {
		this._invalidateCache();
		this._invalidateOrderedCache();
		return super.clear();
	}

	/**
	 * Sort with a comparer function
	 * @param {SortFunction} sortFn Sorting comparer function
	 * @returns {void}
	 */
	sortWith(sortFn) {
		if (this.size <= 1 || sortFn === this._lastActiveSortFn) {
			// already sorted - nothing to do
			return;
		}

		const sortedArray = Array.from(this).sort(sortFn);
		super.clear();
		for (let i = 0; i < sortedArray.length; i += 1) {
			super.add(sortedArray[i]);
		}
		this._lastActiveSortFn = sortFn;
		this._invalidateCache();
	}

	sort() {
		this.sortWith(this._sortFn);
	}

	/**
	 * Get data from cache
	 * @param {function(SortableSet<T>): T[]} fn function to calculate value
	 * @returns {T[]} returns result of fn(this), cached until set changes
	 */
	getFromCache(fn) {
		if (this._cache === undefined) {
			this._cache = new Map();
		} else {
			const data = this._cache.get(fn);
			if (data !== undefined) {
				return data;
			}
		}
		const newData = fn(this);
		this._cache.set(fn, newData);
		return newData;
	}

	/**
	 * @param {function(SortableSet<T>): string|number|T[]} fn function to calculate value
	 * @returns {any} returns result of fn(this), cached until set changes
	 */
	getFromUnorderedCache(fn) {
		if (this._cacheOrderIndependent === undefined) {
			this._cacheOrderIndependent = new Map();
		} else {
			const data = this._cacheOrderIndependent.get(fn);
			if (data !== undefined) {
				return data;
			}
		}
		const newData = fn(this);
		this._cacheOrderIndependent.set(fn, newData);
		return newData;
	}

	/**
	 * @private
	 * @returns {void}
	 */
	_invalidateCache() {
		if (this._cache !== undefined) {
			this._cache.clear();
		}
	}

	/**
	 * @private
	 * @returns {void}
	 */
	_invalidateOrderedCache() {
		if (this._cacheOrderIndependent !== undefined) {
			this._cacheOrderIndependent.clear();
		}
	}
}

module.exports = SortableSet;


/***/ }),

/***/ "./node_modules/webpack/lib/util/StackedSetMap.js":
/*!*******************************************!*\
  !*** (webpack)/lib/util/StackedSetMap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const util = __webpack_require__(/*! util */ "util");

const TOMBSTONE = {};
const UNDEFINED_MARKER = {};

class StackedSetMap {
	constructor(parentStack) {
		this.stack = parentStack === undefined ? [] : parentStack.slice();
		this.map = new Map();
		this.stack.push(this.map);
	}

	add(item) {
		this.map.set(item, true);
	}

	set(item, value) {
		this.map.set(item, value === undefined ? UNDEFINED_MARKER : value);
	}

	delete(item) {
		if (this.stack.length > 1) {
			this.map.set(item, TOMBSTONE);
		} else {
			this.map.delete(item);
		}
	}

	has(item) {
		const topValue = this.map.get(item);
		if (topValue !== undefined) return topValue !== TOMBSTONE;
		if (this.stack.length > 1) {
			for (var i = this.stack.length - 2; i >= 0; i--) {
				const value = this.stack[i].get(item);
				if (value !== undefined) {
					this.map.set(item, value);
					return value !== TOMBSTONE;
				}
			}
			this.map.set(item, TOMBSTONE);
		}
		return false;
	}

	get(item) {
		const topValue = this.map.get(item);
		if (topValue !== undefined) {
			return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER
				? undefined
				: topValue;
		}
		if (this.stack.length > 1) {
			for (var i = this.stack.length - 2; i >= 0; i--) {
				const value = this.stack[i].get(item);
				if (value !== undefined) {
					this.map.set(item, value);
					return value === TOMBSTONE || value === UNDEFINED_MARKER
						? undefined
						: value;
				}
			}
			this.map.set(item, TOMBSTONE);
		}
		return undefined;
	}

	_compress() {
		if (this.stack.length === 1) return;
		this.map = new Map();
		for (const data of this.stack) {
			for (const pair of data) {
				if (pair[1] === TOMBSTONE) {
					this.map.delete(pair[0]);
				} else {
					this.map.set(pair[0], pair[1]);
				}
			}
		}
		this.stack = [this.map];
	}

	asArray() {
		this._compress();
		return Array.from(this.map.entries(), pair => pair[0]);
	}

	asSet() {
		return new Set(this.asArray());
	}

	asPairArray() {
		this._compress();
		return Array.from(
			this.map.entries(),
			pair =>
				/** @type {[TODO, TODO]} */ (pair[1] === UNDEFINED_MARKER
					? [pair[0], undefined]
					: pair)
		);
	}

	asMap() {
		return new Map(this.asPairArray());
	}

	get size() {
		this._compress();
		return this.map.size;
	}

	createChild() {
		return new StackedSetMap(this.stack);
	}

	get length() {
		throw new Error("This is no longer an Array");
	}

	set length(value) {
		throw new Error("This is no longer an Array");
	}
}

// TODO remove in webpack 5
StackedSetMap.prototype.push = util.deprecate(
	/**
	 * @deprecated
	 * @this {StackedSetMap}
	 * @param {any} item Item to add
	 * @returns {void}
	 */
	function(item) {
		this.add(item);
	},
	"This is no longer an Array: Use add instead."
);

module.exports = StackedSetMap;


/***/ }),

/***/ "./node_modules/webpack/lib/util/TrackingSet.js":
/*!*****************************************!*\
  !*** (webpack)/lib/util/TrackingSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


module.exports = class TrackingSet {
	constructor(set) {
		this.set = set;
		this.set2 = new Set();
		this.stack = set.stack;
	}

	add(item) {
		this.set2.add(item);
		return this.set.add(item);
	}

	delete(item) {
		this.set2.delete(item);
		return this.set.delete(item);
	}

	has(item) {
		return this.set.has(item);
	}

	createChild() {
		return this.set.createChild();
	}

	getAddedItems() {
		return this.set2;
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/util/cachedMerge.js":
/*!*****************************************!*\
  !*** (webpack)/lib/util/cachedMerge.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const mergeCache = new WeakMap();

/**
 * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.
 * @example
 * // performs Object.assign(first, second), stores the result in WeakMap and returns result
 * cachedMerge({a: 1}, {a: 2})
 * {a: 2}
 *  // when same arguments passed, gets the result from WeakMap and returns it.
 * cachedMerge({a: 1}, {a: 2})
 * {a: 2}
 * @param {object} first first object
 * @param {object} second second object
 * @returns {object} merged object of first and second object
 */
const cachedMerge = (first, second) => {
	let innerCache = mergeCache.get(first);
	if (innerCache === undefined) {
		innerCache = new WeakMap();
		mergeCache.set(first, innerCache);
	}
	const prevMerge = innerCache.get(second);
	if (prevMerge !== undefined) return prevMerge;
	const newMerge = Object.assign({}, first, second);
	innerCache.set(second, newMerge);
	return newMerge;
};

module.exports = cachedMerge;


/***/ }),

/***/ "./node_modules/webpack/lib/util/createHash.js":
/*!****************************************!*\
  !*** (webpack)/lib/util/createHash.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


/** @typedef {{new(): Hash}} HashConstructor */
/**
 * @typedef {Object} Hash
 * @property {function(string|Buffer, string=): Hash} update
 * @property {function(string): string} digest
 */

const BULK_SIZE = 1000;

/**
 * @implements {Hash}
 */
class BulkUpdateDecorator {
	constructor(hash) {
		this.hash = hash;
		this.buffer = "";
	}

	update(data, inputEncoding) {
		if (
			inputEncoding !== undefined ||
			typeof data !== "string" ||
			data.length > BULK_SIZE
		) {
			if (this.buffer.length > 0) {
				this.hash.update(this.buffer);
				this.buffer = "";
			}
			this.hash.update(data, inputEncoding);
		} else {
			this.buffer += data;
			if (this.buffer.length > BULK_SIZE) {
				this.hash.update(this.buffer);
				this.buffer = "";
			}
		}
		return this;
	}

	digest(encoding) {
		if (this.buffer.length > 0) {
			this.hash.update(this.buffer);
		}
		var digestResult = this.hash.digest(encoding);
		return typeof digestResult === "string"
			? digestResult
			: digestResult.toString();
	}
}

/* istanbul ignore next */
class DebugHash {
	constructor() {
		this.string = "";
	}

	update(data, inputEncoding) {
		if (typeof data !== "string") data = data.toString("utf-8");
		this.string += data;
		return this;
	}

	digest(encoding) {
		return this.string.replace(/[^a-z0-9]+/gi, m =>
			Buffer.from(m).toString("hex")
		);
	}
}

/**
 * Creates a hash by name or function
 * @param {string | HashConstructor} algorithm the algorithm name or a constructor creating a hash
 * @returns {Hash} the hash
 */
module.exports = algorithm => {
	if (typeof algorithm === "function") {
		return new BulkUpdateDecorator(new algorithm());
	}
	switch (algorithm) {
		// TODO add non-cryptographic algorithm here
		case "debug":
			return new DebugHash();
		default:
			return new BulkUpdateDecorator(__webpack_require__(/*! crypto */ "crypto").createHash(algorithm));
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/util/deterministicGrouping.js":
/*!***************************************************!*\
  !*** (webpack)/lib/util/deterministicGrouping.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Simulations show these probabilities for a single change
// 93.1% that one group is invalidated
// 4.8% that two groups are invalidated
// 1.1% that 3 groups are invalidated
// 0.1% that 4 or more groups are invalidated
//
// And these for removing/adding 10 lexically adjacent files
// 64.5% that one group is invalidated
// 24.8% that two groups are invalidated
// 7.8% that 3 groups are invalidated
// 2.7% that 4 or more groups are invalidated
//
// And these for removing/adding 3 random files
// 0% that one group is invalidated
// 3.7% that two groups are invalidated
// 80.8% that 3 groups are invalidated
// 12.3% that 4 groups are invalidated
// 3.2% that 5 or more groups are invalidated

/**
 *
 * @param {string} a key
 * @param {string} b key
 * @returns {number} the similarity as number
 */
const similarity = (a, b) => {
	const l = Math.min(a.length, b.length);
	let dist = 0;
	for (let i = 0; i < l; i++) {
		const ca = a.charCodeAt(i);
		const cb = b.charCodeAt(i);
		dist += Math.max(0, 10 - Math.abs(ca - cb));
	}
	return dist;
};

/**
 * @param {string} a key
 * @param {string} b key
 * @returns {string} the common part and a single char for the difference
 */
const getName = (a, b) => {
	const l = Math.min(a.length, b.length);
	let r = "";
	for (let i = 0; i < l; i++) {
		const ca = a.charAt(i);
		const cb = b.charAt(i);
		r += ca;
		if (ca === cb) {
			continue;
		}
		return r;
	}
	return a;
};

/**
 * @template T
 */
class Node {
	/**
	 * @param {T} item item
	 * @param {string} key key
	 * @param {number} size size
	 */
	constructor(item, key, size) {
		this.item = item;
		this.key = key;
		this.size = size;
	}
}

/**
 * @template T
 */
class Group {
	/**
	 * @param {Node<T>[]} nodes nodes
	 * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)
	 */
	constructor(nodes, similarities) {
		this.nodes = nodes;
		this.similarities = similarities;
		this.size = nodes.reduce((size, node) => size + node.size, 0);
		/** @type {string} */
		this.key = undefined;
	}
}

/**
 * @template T
 * @typedef {Object} GroupedItems<T>
 * @property {string} key
 * @property {T[]} items
 * @property {number} size
 */

/**
 * @template T
 * @typedef {Object} Options
 * @property {number} maxSize maximum size of a group
 * @property {number} minSize minimum size of a group (preferred over maximum size)
 * @property {Iterable<T>} items a list of items
 * @property {function(T): number} getSize function to get size of an item
 * @property {function(T): string} getKey function to get the key of an item
 */

/**
 * @template T
 * @param {Options<T>} options options object
 * @returns {GroupedItems<T>[]} grouped items
 */
module.exports = ({ maxSize, minSize, items, getSize, getKey }) => {
	/** @type {Group<T>[]} */
	const result = [];

	const nodes = Array.from(
		items,
		item => new Node(item, getKey(item), getSize(item))
	);

	/** @type {Node<T>[]} */
	const initialNodes = [];

	// lexically ordering of keys
	nodes.sort((a, b) => {
		if (a.key < b.key) return -1;
		if (a.key > b.key) return 1;
		return 0;
	});

	// return nodes bigger than maxSize directly as group
	for (const node of nodes) {
		if (node.size >= maxSize) {
			result.push(new Group([node], []));
		} else {
			initialNodes.push(node);
		}
	}

	if (initialNodes.length > 0) {
		// calculate similarities between lexically adjacent nodes
		/** @type {number[]} */
		const similarities = [];
		for (let i = 1; i < initialNodes.length; i++) {
			const a = initialNodes[i - 1];
			const b = initialNodes[i];
			similarities.push(similarity(a.key, b.key));
		}

		const initialGroup = new Group(initialNodes, similarities);

		if (initialGroup.size < minSize) {
			// We hit an edgecase where the working set is already smaller than minSize
			// We merge it with the smallest result node to keep minSize intact
			if (result.length > 0) {
				const smallestGroup = result.reduce(
					(min, group) => (min.size > group.size ? group : min)
				);
				for (const node of initialGroup.nodes) smallestGroup.nodes.push(node);
				smallestGroup.nodes.sort((a, b) => {
					if (a.key < b.key) return -1;
					if (a.key > b.key) return 1;
					return 0;
				});
			} else {
				// There are no other nodes
				// We use all nodes and have to accept that it's smaller than minSize
				result.push(initialGroup);
			}
		} else {
			const queue = [initialGroup];

			while (queue.length) {
				const group = queue.pop();
				// only groups bigger than maxSize need to be splitted
				if (group.size < maxSize) {
					result.push(group);
					continue;
				}

				// find unsplittable area from left and right
				// going minSize from left and right
				// at least one node need to be included otherwise we get stuck
				let left = 0;
				let leftSize = 0;
				while (leftSize <= minSize) {
					leftSize += group.nodes[left].size;
					left++;
				}
				let right = group.nodes.length - 1;
				let rightSize = 0;
				while (rightSize <= minSize) {
					rightSize += group.nodes[right].size;
					right--;
				}

				if (left - 1 > right) {
					// can't split group while holding minSize
					// because minSize is preferred of maxSize we return
					// the group here even while it's too big
					// To avoid this make sure maxSize > minSize * 3
					result.push(group);
					continue;
				}
				if (left <= right) {
					// when there is a area between left and right
					// we look for best split point
					// we split at the minimum similarity
					// here key space is separated the most
					let best = left - 1;
					let bestSimilarity = group.similarities[best];
					for (let i = left; i <= right; i++) {
						const similarity = group.similarities[i];
						if (similarity < bestSimilarity) {
							best = i;
							bestSimilarity = similarity;
						}
					}
					left = best + 1;
					right = best;
				}

				// create two new groups for left and right area
				// and queue them up
				const rightNodes = [group.nodes[right + 1]];
				/** @type {number[]} */
				const rightSimilaries = [];
				for (let i = right + 2; i < group.nodes.length; i++) {
					rightSimilaries.push(group.similarities[i - 1]);
					rightNodes.push(group.nodes[i]);
				}
				queue.push(new Group(rightNodes, rightSimilaries));

				const leftNodes = [group.nodes[0]];
				/** @type {number[]} */
				const leftSimilaries = [];
				for (let i = 1; i < left; i++) {
					leftSimilaries.push(group.similarities[i - 1]);
					leftNodes.push(group.nodes[i]);
				}
				queue.push(new Group(leftNodes, leftSimilaries));
			}
		}
	}

	// lexically ordering
	result.sort((a, b) => {
		if (a.nodes[0].key < b.nodes[0].key) return -1;
		if (a.nodes[0].key > b.nodes[0].key) return 1;
		return 0;
	});

	// give every group a name
	for (let i = 0; i < result.length; i++) {
		const group = result[i];
		const first = group.nodes[0];
		const last = group.nodes[group.nodes.length - 1];
		let name = getName(first.key, last.key);
		group.key = name;
	}

	// return the results
	return result.map(group => {
		/** @type {GroupedItems} */
		return {
			key: group.key,
			items: group.nodes.map(node => node.item),
			size: group.size
		};
	});
};


/***/ }),

/***/ "./node_modules/webpack/lib/util/identifier.js":
/*!****************************************!*\
  !*** (webpack)/lib/util/identifier.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(/*! path */ "path");

/**
 * @typedef {Object} MakeRelativePathsCache
 * @property {Map<string, Map<string, string>>=} relativePaths
 */

/**
 *
 * @param {string} maybeAbsolutePath path to check
 * @returns {boolean} returns true if path is "Absolute Path"-like
 */
const looksLikeAbsolutePath = maybeAbsolutePath => {
	if (/^\/.*\/$/.test(maybeAbsolutePath)) {
		// this 'path' is actually a regexp generated by dynamic requires.
		// Don't treat it as an absolute path.
		return false;
	}
	return /^(?:[a-z]:\\|\/)/i.test(maybeAbsolutePath);
};

/**
 *
 * @param {string} p path to normalize
 * @returns {string} normalized version of path
 */
const normalizePathSeparator = p => p.replace(/\\/g, "/");

/**
 *
 * @param {string} context context for relative path
 * @param {string} identifier identifier for path
 * @returns {string} a converted relative path
 */
const _makePathsRelative = (context, identifier) => {
	return identifier
		.split(/([|! ])/)
		.map(
			str =>
				looksLikeAbsolutePath(str)
					? normalizePathSeparator(path.relative(context, str))
					: str
		)
		.join("");
};

/**
 *
 * @param {string} context context used to create relative path
 * @param {string} identifier identifier used to create relative path
 * @param {MakeRelativePathsCache=} cache the cache object being set
 * @returns {string} the returned relative path
 */
exports.makePathsRelative = (context, identifier, cache) => {
	if (!cache) return _makePathsRelative(context, identifier);

	const relativePaths =
		cache.relativePaths || (cache.relativePaths = new Map());

	let cachedResult;
	let contextCache = relativePaths.get(context);
	if (contextCache === undefined) {
		relativePaths.set(context, (contextCache = new Map()));
	} else {
		cachedResult = contextCache.get(identifier);
	}

	if (cachedResult !== undefined) {
		return cachedResult;
	} else {
		const relativePath = _makePathsRelative(context, identifier);
		contextCache.set(identifier, relativePath);
		return relativePath;
	}
};

/**
 * @param {string} context absolute context path
 * @param {string} request any request string may containing absolute paths, query string, etc.
 * @returns {string} a new request string avoiding absolute paths when possible
 */
exports.contextify = (context, request) => {
	return request
		.split("!")
		.map(r => {
			const splitPath = r.split("?", 2);
			if (/^[a-zA-Z]:\\/.test(splitPath[0])) {
				splitPath[0] = path.win32.relative(context, splitPath[0]);
				if (!/^[a-zA-Z]:\\/.test(splitPath[0])) {
					splitPath[0] = splitPath[0].replace(/\\/g, "/");
				}
			}
			if (/^\//.test(splitPath[0])) {
				splitPath[0] = path.posix.relative(context, splitPath[0]);
			}
			if (!/^(\.\.\/|\/|[a-zA-Z]:\\)/.test(splitPath[0])) {
				splitPath[0] = "./" + splitPath[0];
			}
			return splitPath.join("?");
		})
		.join("!");
};


/***/ }),

/***/ "./node_modules/webpack/lib/util/objectToMap.js":
/*!*****************************************!*\
  !*** (webpack)/lib/util/objectToMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * convert an object into its 2D array equivalent to be turned
 * into an ES6 map
 *
 * @param {object} obj - any object type that works with Object.keys()
 * @returns {Map<TODO, TODO>} an ES6 Map of KV pairs
 */
module.exports = function objectToMap(obj) {
	return new Map(
		Object.keys(obj).map(key => {
			/** @type {[string, string]} */
			const pair = [key, obj[key]];
			return pair;
		})
	);
};


/***/ }),

/***/ "./node_modules/webpack/lib/validateSchema.js":
/*!***************************************!*\
  !*** (webpack)/lib/validateSchema.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Gajus Kuizinas @gajus
*/


const Ajv = __webpack_require__(/*! ajv */ "ajv");
const ajv = new Ajv({
	errorDataPath: "configuration",
	allErrors: true,
	verbose: true
});
__webpack_require__(/*! ajv-keywords */ "ajv-keywords")(ajv, ["instanceof"]);
__webpack_require__(/*! ../schemas/ajv.absolutePath */ "./node_modules/webpack/schemas/ajv.absolutePath.js")(ajv);

const validateSchema = (schema, options) => {
	if (Array.isArray(options)) {
		const errors = options.map(options => validateObject(schema, options));
		errors.forEach((list, idx) => {
			const applyPrefix = err => {
				err.dataPath = `[${idx}]${err.dataPath}`;
				if (err.children) {
					err.children.forEach(applyPrefix);
				}
			};
			list.forEach(applyPrefix);
		});
		return errors.reduce((arr, items) => {
			return arr.concat(items);
		}, []);
	} else {
		return validateObject(schema, options);
	}
};

const validateObject = (schema, options) => {
	const validate = ajv.compile(schema);
	const valid = validate(options);
	return valid ? [] : filterErrors(validate.errors);
};

const filterErrors = errors => {
	let newErrors = [];
	for (const err of errors) {
		const dataPath = err.dataPath;
		let children = [];
		newErrors = newErrors.filter(oldError => {
			if (oldError.dataPath.includes(dataPath)) {
				if (oldError.children) {
					children = children.concat(oldError.children.slice(0));
				}
				oldError.children = undefined;
				children.push(oldError);
				return false;
			}
			return true;
		});
		if (children.length) {
			err.children = children;
		}
		newErrors.push(err);
	}

	return newErrors;
};

module.exports = validateSchema;


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/UnsupportedWebAssemblyFeatureError.js":
/*!****************************************************************!*\
  !*** (webpack)/lib/wasm/UnsupportedWebAssemblyFeatureError.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/


const WebpackError = __webpack_require__(/*! ../WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

module.exports = class UnsupportedWebAssemblyFeatureError extends WebpackError {
	/** @param {string} message Error message */
	constructor(message) {
		super(message);
		this.name = "UnsupportedWebAssemblyFeatureError";
		this.hideStack = true;

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/WasmFinalizeExportsPlugin.js":
/*!*******************************************************!*\
  !*** (webpack)/lib/wasm/WasmFinalizeExportsPlugin.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
	*/


const UnsupportedWebAssemblyFeatureError = __webpack_require__(/*! ./UnsupportedWebAssemblyFeatureError */ "./node_modules/webpack/lib/wasm/UnsupportedWebAssemblyFeatureError.js");

class WasmFinalizeExportsPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("WasmFinalizeExportsPlugin", compilation => {
			compilation.hooks.finishModules.tap(
				"WasmFinalizeExportsPlugin",
				modules => {
					for (const module of modules) {
						// 1. if a WebAssembly module
						if (module.type.startsWith("webassembly") === true) {
							const jsIncompatibleExports =
								module.buildMeta.jsIncompatibleExports;

							if (jsIncompatibleExports === undefined) {
								continue;
							}

							for (const reason of module.reasons) {
								// 2. is referenced by a non-WebAssembly module
								if (reason.module.type.startsWith("webassembly") === false) {
									const ref = compilation.getDependencyReference(
										reason.module,
										reason.dependency
									);

									if (!ref) continue;

									const importedNames = ref.importedNames;

									if (Array.isArray(importedNames)) {
										importedNames.forEach(name => {
											// 3. and uses a func with an incompatible JS signature
											if (
												Object.prototype.hasOwnProperty.call(
													jsIncompatibleExports,
													name
												)
											) {
												// 4. error
												/** @type {any} */
												const error = new UnsupportedWebAssemblyFeatureError(
													`Export "${name}" with ${
														jsIncompatibleExports[name]
													} can only be used for direct wasm to wasm dependencies`
												);
												error.module = module;
												error.origin = reason.module;
												error.originLoc = reason.dependency.loc;
												error.dependencies = [reason.dependency];
												compilation.errors.push(error);
											}
										});
									}
								}
							}
						}
					}
				}
			);
		});
	}
}

module.exports = WasmFinalizeExportsPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/WasmMainTemplatePlugin.js":
/*!****************************************************!*\
  !*** (webpack)/lib/wasm/WasmMainTemplatePlugin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");
const WebAssemblyUtils = __webpack_require__(/*! ./WebAssemblyUtils */ "./node_modules/webpack/lib/wasm/WebAssemblyUtils.js");

/** @typedef {import("../Module")} Module */
/** @typedef {import("../MainTemplate")} MainTemplate */

// Get all wasm modules
const getAllWasmModules = chunk => {
	const wasmModules = chunk.getAllAsyncChunks();
	const array = [];
	for (const chunk of wasmModules) {
		for (const m of chunk.modulesIterable) {
			if (m.type.startsWith("webassembly")) {
				array.push(m);
			}
		}
	}

	return array;
};

/**
 * generates the import object function for a module
 * @param {Module} module the module
 * @param {boolean} mangle mangle imports
 * @returns {string} source code
 */
const generateImportObject = (module, mangle) => {
	const waitForInstances = new Map();
	const properties = [];
	const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(
		module,
		mangle
	);
	for (const usedDep of usedWasmDependencies) {
		const dep = usedDep.dependency;
		const importedModule = dep.module;
		const exportName = dep.name;
		const usedName = importedModule && importedModule.isUsed(exportName);
		const description = dep.description;
		const direct = dep.onlyDirectImport;

		const module = usedDep.module;
		const name = usedDep.name;

		if (direct) {
			const instanceVar = `m${waitForInstances.size}`;
			waitForInstances.set(instanceVar, importedModule.id);
			properties.push({
				module,
				name,
				value: `${instanceVar}[${JSON.stringify(usedName)}]`
			});
		} else {
			const params = description.signature.params.map(
				(param, k) => "p" + k + param.valtype
			);

			const mod = `installedModules[${JSON.stringify(importedModule.id)}]`;
			const func = `${mod}.exports[${JSON.stringify(usedName)}]`;

			properties.push({
				module,
				name,
				value: Template.asString([
					(importedModule.type.startsWith("webassembly")
						? `${mod} ? ${func} : `
						: "") + `function(${params}) {`,
					Template.indent([`return ${func}(${params});`]),
					"}"
				])
			});
		}
	}

	let importObject;
	if (mangle) {
		importObject = [
			"return {",
			Template.indent([
				properties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(",\n")
			]),
			"};"
		];
	} else {
		const propertiesByModule = new Map();
		for (const p of properties) {
			let list = propertiesByModule.get(p.module);
			if (list === undefined) {
				propertiesByModule.set(p.module, (list = []));
			}
			list.push(p);
		}
		importObject = [
			"return {",
			Template.indent([
				Array.from(propertiesByModule, ([module, list]) => {
					return Template.asString([
						`${JSON.stringify(module)}: {`,
						Template.indent([
							list.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(",\n")
						]),
						"}"
					]);
				}).join(",\n")
			]),
			"};"
		];
	}

	if (waitForInstances.size === 1) {
		const moduleId = Array.from(waitForInstances.values())[0];
		const promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;
		const variable = Array.from(waitForInstances.keys())[0];
		return Template.asString([
			`${JSON.stringify(module.id)}: function() {`,
			Template.indent([
				`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`,
				Template.indent(importObject),
				"});"
			]),
			"},"
		]);
	} else if (waitForInstances.size > 0) {
		const promises = Array.from(
			waitForInstances.values(),
			id => `installedWasmModules[${JSON.stringify(id)}]`
		).join(", ");
		const variables = Array.from(
			waitForInstances.keys(),
			(name, i) => `${name} = array[${i}]`
		).join(", ");
		return Template.asString([
			`${JSON.stringify(module.id)}: function() {`,
			Template.indent([
				`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`,
				Template.indent([`var ${variables};`, ...importObject]),
				"});"
			]),
			"},"
		]);
	} else {
		return Template.asString([
			`${JSON.stringify(module.id)}: function() {`,
			Template.indent(importObject),
			"},"
		]);
	}
};

class WasmMainTemplatePlugin {
	constructor({ generateLoadBinaryCode, supportsStreaming, mangleImports }) {
		this.generateLoadBinaryCode = generateLoadBinaryCode;
		this.supportsStreaming = supportsStreaming;
		this.mangleImports = mangleImports;
	}

	/**
	 * @param {MainTemplate} mainTemplate main template
	 * @returns {void}
	 */
	apply(mainTemplate) {
		mainTemplate.hooks.localVars.tap(
			"WasmMainTemplatePlugin",
			(source, chunk) => {
				const wasmModules = getAllWasmModules(chunk);
				if (wasmModules.length === 0) return source;
				const importObjects = wasmModules.map(module => {
					return generateImportObject(module, this.mangleImports);
				});
				return Template.asString([
					source,
					"",
					"// object to store loaded and loading wasm modules",
					"var installedWasmModules = {};",
					"",
					// This function is used to delay reading the installed wasm module promises
					// by a microtask. Sorting them doesn't help because there are egdecases where
					// sorting is not possible (modules splitted into different chunks).
					// So we not even trying and solve this by a microtask delay.
					"function promiseResolve() { return Promise.resolve(); }",
					"",
					"var wasmImportObjects = {",
					Template.indent(importObjects),
					"};"
				]);
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			"WasmMainTemplatePlugin",
			(source, chunk, hash) => {
				const webassemblyModuleFilename =
					mainTemplate.outputOptions.webassemblyModuleFilename;

				const chunkModuleMaps = chunk.getChunkModuleMaps(m =>
					m.type.startsWith("webassembly")
				);
				if (Object.keys(chunkModuleMaps.id).length === 0) return source;
				const wasmModuleSrcPath = mainTemplate.getAssetPath(
					JSON.stringify(webassemblyModuleFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
						module: {
							id: '" + wasmModuleId + "',
							hash: `" + ${JSON.stringify(
								chunkModuleMaps.hash
							)}[wasmModuleId] + "`,
							hashWithLength(length) {
								const shortChunkHashMap = Object.create(null);
								for (const wasmModuleId of Object.keys(chunkModuleMaps.hash)) {
									if (typeof chunkModuleMaps.hash[wasmModuleId] === "string") {
										shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[
											wasmModuleId
										].substr(0, length);
									}
								}
								return `" + ${JSON.stringify(
									shortChunkHashMap
								)}[wasmModuleId] + "`;
							}
						}
					}
				);
				const createImportObject = content =>
					this.mangleImports
						? `{ ${JSON.stringify(
								WebAssemblyUtils.MANGLED_MODULE
						  )}: ${content} }`
						: content;
				return Template.asString([
					source,
					"",
					"// Fetch + compile chunk loading for webassembly",
					"",
					`var wasmModules = ${JSON.stringify(
						chunkModuleMaps.id
					)}[chunkId] || [];`,
					"",
					"wasmModules.forEach(function(wasmModuleId) {",
					Template.indent([
						"var installedWasmModuleData = installedWasmModules[wasmModuleId];",
						"",
						'// a Promise means "currently loading" or "already loaded".',
						"if(installedWasmModuleData)",
						Template.indent(["promises.push(installedWasmModuleData);"]),
						"else {",
						Template.indent([
							`var importObject = wasmImportObjects[wasmModuleId]();`,
							`var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`,
							"var promise;",
							this.supportsStreaming
								? Template.asString([
										"if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {",
										Template.indent([
											"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {",
											Template.indent([
												`return WebAssembly.instantiate(items[0], ${createImportObject(
													"items[1]"
												)});`
											]),
											"});"
										]),
										"} else if(typeof WebAssembly.instantiateStreaming === 'function') {",
										Template.indent([
											`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(
												"importObject"
											)});`
										])
								  ])
								: Template.asString([
										"if(importObject instanceof Promise) {",
										Template.indent([
											"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });",
											"promise = Promise.all([",
											Template.indent([
												"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),",
												"importObject"
											]),
											"]).then(function(items) {",
											Template.indent([
												`return WebAssembly.instantiate(items[0], ${createImportObject(
													"items[1]"
												)});`
											]),
											"});"
										])
								  ]),
							"} else {",
							Template.indent([
								"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });",
								"promise = bytesPromise.then(function(bytes) {",
								Template.indent([
									`return WebAssembly.instantiate(bytes, ${createImportObject(
										"importObject"
									)});`
								]),
								"});"
							]),
							"}",
							"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {",
							Template.indent([
								`return ${
									mainTemplate.requireFn
								}.w[wasmModuleId] = (res.instance || res).exports;`
							]),
							"}));"
						]),
						"}"
					]),
					"});"
				]);
			}
		);
		mainTemplate.hooks.requireExtensions.tap(
			"WasmMainTemplatePlugin",
			(source, chunk) => {
				if (!chunk.hasModuleInGraph(m => m.type.startsWith("webassembly"))) {
					return source;
				}
				return Template.asString([
					source,
					"",
					"// object with all WebAssembly.instance exports",
					`${mainTemplate.requireFn}.w = {};`
				]);
			}
		);
		mainTemplate.hooks.hash.tap("WasmMainTemplatePlugin", hash => {
			hash.update("WasmMainTemplatePlugin");
			hash.update("2");
		});
	}
}

module.exports = WasmMainTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/WebAssemblyGenerator.js":
/*!**************************************************!*\
  !*** (webpack)/lib/wasm/WebAssemblyGenerator.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Generator = __webpack_require__(/*! ../Generator */ "./node_modules/webpack/lib/Generator.js");
const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");
const WebAssemblyUtils = __webpack_require__(/*! ./WebAssemblyUtils */ "./node_modules/webpack/lib/wasm/WebAssemblyUtils.js");
const { RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

const { editWithAST, addWithAST } = __webpack_require__(/*! @webassemblyjs/wasm-edit */ "@webassemblyjs/wasm-edit");
const { decode } = __webpack_require__(/*! @webassemblyjs/wasm-parser */ "@webassemblyjs/wasm-parser");
const t = __webpack_require__(/*! @webassemblyjs/ast */ "@webassemblyjs/ast");
const {
	moduleContextFromModuleAST
} = __webpack_require__(/*! @webassemblyjs/helper-module-context */ "@webassemblyjs/helper-module-context");

const WebAssemblyExportImportedDependency = __webpack_require__(/*! ../dependencies/WebAssemblyExportImportedDependency */ "./node_modules/webpack/lib/dependencies/WebAssemblyExportImportedDependency.js");

/** @typedef {import("../Module")} Module */
/** @typedef {import("./WebAssemblyUtils").UsedWasmDependency} UsedWasmDependency */
/** @typedef {import("../NormalModule")} NormalModule */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Dependency").DependencyTemplate} DependencyTemplate */

/**
 * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform
 */

/**
 * @template T
 * @param {Function[]} fns transforms
 * @returns {Function} composed transform
 */
const compose = (...fns) => {
	return fns.reduce(
		(prevFn, nextFn) => {
			return value => nextFn(prevFn(value));
		},
		value => value
	);
};

// TODO replace with @callback

/**
 * Removes the start instruction
 *
 * @param {Object} state - unused state
 * @returns {ArrayBufferTransform} transform
 */
const removeStartFunc = state => bin => {
	return editWithAST(state.ast, bin, {
		Start(path) {
			path.remove();
		}
	});
};

/**
 * Get imported globals
 *
 * @param {Object} ast - Module's AST
 * @returns {Array<t.ModuleImport>} - nodes
 */
const getImportedGlobals = ast => {
	const importedGlobals = [];

	t.traverse(ast, {
		ModuleImport({ node }) {
			if (t.isGlobalType(node.descr) === true) {
				importedGlobals.push(node);
			}
		}
	});

	return importedGlobals;
};

const getCountImportedFunc = ast => {
	let count = 0;

	t.traverse(ast, {
		ModuleImport({ node }) {
			if (t.isFuncImportDescr(node.descr) === true) {
				count++;
			}
		}
	});

	return count;
};

/**
 * Get next type index
 *
 * @param {Object} ast - Module's AST
 * @returns {t.Index} - index
 */
const getNextTypeIndex = ast => {
	const typeSectionMetadata = t.getSectionMetadata(ast, "type");

	if (typeSectionMetadata === undefined) {
		return t.indexLiteral(0);
	}

	return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);
};

/**
 * Get next func index
 *
 * The Func section metadata provide informations for implemented funcs
 * in order to have the correct index we shift the index by number of external
 * functions.
 *
 * @param {Object} ast - Module's AST
 * @param {Number} countImportedFunc - number of imported funcs
 * @returns {t.Index} - index
 */
const getNextFuncIndex = (ast, countImportedFunc) => {
	const funcSectionMetadata = t.getSectionMetadata(ast, "func");

	if (funcSectionMetadata === undefined) {
		return t.indexLiteral(0 + countImportedFunc);
	}

	const vectorOfSize = funcSectionMetadata.vectorOfSize.value;

	return t.indexLiteral(vectorOfSize + countImportedFunc);
};

/**
 * Create a init instruction for a global
 * @param {t.GlobalType} globalType the global type
 * @returns {t.Instruction} init expression
 */
const createDefaultInitForGlobal = globalType => {
	if (globalType.valtype[0] === "i") {
		// create NumberLiteral global initializer
		return t.objectInstruction("const", globalType.valtype, [
			t.numberLiteralFromRaw(66)
		]);
	} else if (globalType.valtype[0] === "f") {
		// create FloatLiteral global initializer
		return t.objectInstruction("const", globalType.valtype, [
			t.floatLiteral(66, false, false, "66")
		]);
	} else {
		throw new Error("unknown type: " + globalType.valtype);
	}
};

/**
 * Rewrite the import globals:
 * - removes the ModuleImport instruction
 * - injects at the same offset a mutable global of the same time
 *
 * Since the imported globals are before the other global declarations, our
 * indices will be preserved.
 *
 * Note that globals will become mutable.
 *
 * @param {Object} state - unused state
 * @returns {ArrayBufferTransform} transform
 */
const rewriteImportedGlobals = state => bin => {
	const additionalInitCode = state.additionalInitCode;
	const newGlobals = [];

	bin = editWithAST(state.ast, bin, {
		ModuleImport(path) {
			if (t.isGlobalType(path.node.descr) === true) {
				const globalType = path.node.descr;

				globalType.mutability = "var";

				const init = createDefaultInitForGlobal(globalType);

				newGlobals.push(t.global(globalType, [init]));

				path.remove();
			}
		},

		// in order to preserve non-imported global's order we need to re-inject
		// those as well
		Global(path) {
			const { node } = path;
			const [init] = node.init;

			if (init.id === "get_global") {
				node.globalType.mutability = "var";

				const initialGlobalidx = init.args[0];

				node.init = [createDefaultInitForGlobal(node.globalType)];

				additionalInitCode.push(
					/**
					 * get_global in global initilizer only work for imported globals.
					 * They have the same indices than the init params, so use the
					 * same index.
					 */
					t.instruction("get_local", [initialGlobalidx]),
					t.instruction("set_global", [t.indexLiteral(newGlobals.length)])
				);
			}

			newGlobals.push(node);

			path.remove();
		}
	});

	// Add global declaration instructions
	return addWithAST(state.ast, bin, newGlobals);
};

/**
 * Rewrite the export names
 * @param {Object} state state
 * @param {Object} state.ast Module's ast
 * @param {Module} state.module Module
 * @param {Set<string>} state.externalExports Module
 * @returns {ArrayBufferTransform} transform
 */
const rewriteExportNames = ({ ast, module, externalExports }) => bin => {
	return editWithAST(ast, bin, {
		ModuleExport(path) {
			const isExternal = externalExports.has(path.node.name);
			if (isExternal) {
				path.remove();
				return;
			}
			const usedName = module.isUsed(path.node.name);
			if (!usedName) {
				path.remove();
				return;
			}
			path.node.name = usedName;
		}
	});
};

/**
 * Mangle import names and modules
 * @param {Object} state state
 * @param {Object} state.ast Module's ast
 * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names
 * @returns {ArrayBufferTransform} transform
 */
const rewriteImports = ({ ast, usedDependencyMap }) => bin => {
	return editWithAST(ast, bin, {
		ModuleImport(path) {
			const result = usedDependencyMap.get(
				path.node.module + ":" + path.node.name
			);

			if (result !== undefined) {
				path.node.module = result.module;
				path.node.name = result.name;
			}
		}
	});
};

/**
 * Add an init function.
 *
 * The init function fills the globals given input arguments.
 *
 * @param {Object} state transformation state
 * @param {Object} state.ast - Module's ast
 * @param {t.Identifier} state.initFuncId identifier of the init function
 * @param {t.Index} state.startAtFuncOffset index of the start function
 * @param {t.ModuleImport[]} state.importedGlobals list of imported globals
 * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function
 * @param {t.Index} state.nextFuncIndex index of the next function
 * @param {t.Index} state.nextTypeIndex index of the next type
 * @returns {ArrayBufferTransform} transform
 */
const addInitFunction = ({
	ast,
	initFuncId,
	startAtFuncOffset,
	importedGlobals,
	additionalInitCode,
	nextFuncIndex,
	nextTypeIndex
}) => bin => {
	const funcParams = importedGlobals.map(importedGlobal => {
		// used for debugging
		const id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);

		return t.funcParam(importedGlobal.descr.valtype, id);
	});

	const funcBody = importedGlobals.reduce((acc, importedGlobal, index) => {
		const args = [t.indexLiteral(index)];
		const body = [
			t.instruction("get_local", args),
			t.instruction("set_global", args)
		];

		return [...acc, ...body];
	}, []);

	if (typeof startAtFuncOffset === "number") {
		funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));
	}

	for (const instr of additionalInitCode) {
		funcBody.push(instr);
	}

	const funcResults = [];

	// Code section
	const funcSignature = t.signature(funcParams, funcResults);
	const func = t.func(initFuncId, funcSignature, funcBody);

	// Type section
	const functype = t.typeInstruction(undefined, funcSignature);

	// Func section
	const funcindex = t.indexInFuncSection(nextTypeIndex);

	// Export section
	const moduleExport = t.moduleExport(
		initFuncId.value,
		t.moduleExportDescr("Func", nextFuncIndex)
	);

	return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);
};

/**
 * Extract mangle mappings from module
 * @param {Module} module current module
 * @param {boolean} mangle mangle imports
 * @returns {Map<string, UsedWasmDependency>} mappings to mangled names
 */
const getUsedDependencyMap = (module, mangle) => {
	/** @type {Map<string, UsedWasmDependency>} */
	const map = new Map();
	for (const usedDep of WebAssemblyUtils.getUsedDependencies(module, mangle)) {
		const dep = usedDep.dependency;
		const request = dep.request;
		const exportName = dep.name;
		map.set(request + ":" + exportName, usedDep);
	}
	return map;
};

class WebAssemblyGenerator extends Generator {
	constructor(options) {
		super();
		this.options = options;
	}

	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates
	 * @param {RuntimeTemplate} runtimeTemplate the runtime template
	 * @param {string} type which kind of code should be generated
	 * @returns {Source} generated code
	 */
	generate(module, dependencyTemplates, runtimeTemplate, type) {
		let bin = module.originalSource().source();

		const initFuncId = t.identifier(
			Array.isArray(module.usedExports)
				? Template.numberToIdentifer(module.usedExports.length)
				: "__webpack_init__"
		);

		// parse it
		const ast = decode(bin, {
			ignoreDataSection: true,
			ignoreCodeSection: true,
			ignoreCustomNameSection: true
		});

		const moduleContext = moduleContextFromModuleAST(ast.body[0]);

		const importedGlobals = getImportedGlobals(ast);
		const countImportedFunc = getCountImportedFunc(ast);
		const startAtFuncOffset = moduleContext.getStart();
		const nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);
		const nextTypeIndex = getNextTypeIndex(ast);

		const usedDependencyMap = getUsedDependencyMap(
			module,
			this.options.mangleImports
		);
		const externalExports = new Set(
			module.dependencies
				.filter(d => d instanceof WebAssemblyExportImportedDependency)
				.map(d => {
					const wasmDep = /** @type {WebAssemblyExportImportedDependency} */ (d);
					return wasmDep.exportName;
				})
		);

		/** @type {t.Instruction[]} */
		const additionalInitCode = [];

		const transform = compose(
			rewriteExportNames({
				ast,
				module,
				externalExports
			}),

			removeStartFunc({ ast }),

			rewriteImportedGlobals({ ast, additionalInitCode }),

			rewriteImports({
				ast,
				usedDependencyMap
			}),

			addInitFunction({
				ast,
				initFuncId,
				importedGlobals,
				additionalInitCode,
				startAtFuncOffset,
				nextFuncIndex,
				nextTypeIndex
			})
		);

		const newBin = transform(bin);

		return new RawSource(newBin);
	}
}

module.exports = WebAssemblyGenerator;


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/WebAssemblyInInitialChunkError.js":
/*!************************************************************!*\
  !*** (webpack)/lib/wasm/WebAssemblyInInitialChunkError.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/


const WebpackError = __webpack_require__(/*! ../WebpackError */ "./node_modules/webpack/lib/WebpackError.js");

/** @typedef {import("../Module")} Module */
/** @typedef {import("../RequestShortener")} RequestShortener */

/**
 * @param {Module} module module to get chains from
 * @param {RequestShortener} requestShortener to make readable identifiers
 * @returns {string[]} all chains to the module
 */
const getInitialModuleChains = (module, requestShortener) => {
	const queue = [
		{ head: module, message: module.readableIdentifier(requestShortener) }
	];
	/** @type {Set<string>} */
	const results = new Set();
	/** @type {Set<string>} */
	const incompleteResults = new Set();
	/** @type {Set<Module>} */
	const visitedModules = new Set();

	for (const chain of queue) {
		const { head, message } = chain;
		let final = true;
		/** @type {Set<Module>} */
		const alreadyReferencedModules = new Set();
		for (const reason of head.reasons) {
			const newHead = reason.module;
			if (newHead) {
				if (!newHead.getChunks().some(c => c.canBeInitial())) continue;
				final = false;
				if (alreadyReferencedModules.has(newHead)) continue;
				alreadyReferencedModules.add(newHead);
				const moduleName = newHead.readableIdentifier(requestShortener);
				const detail = reason.explanation ? ` (${reason.explanation})` : "";
				const newMessage = `${moduleName}${detail} --> ${message}`;
				if (visitedModules.has(newHead)) {
					incompleteResults.add(`... --> ${newMessage}`);
					continue;
				}
				visitedModules.add(newHead);
				queue.push({
					head: newHead,
					message: newMessage
				});
			} else {
				final = false;
				const newMessage = reason.explanation
					? `(${reason.explanation}) --> ${message}`
					: message;
				results.add(newMessage);
			}
		}
		if (final) {
			results.add(message);
		}
	}
	for (const result of incompleteResults) {
		results.add(result);
	}
	return Array.from(results);
};

module.exports = class WebAssemblyInInitialChunkError extends WebpackError {
	/**
	 * @param {Module} module WASM module
	 * @param {RequestShortener} requestShortener request shortener
	 */
	constructor(module, requestShortener) {
		const moduleChains = getInitialModuleChains(module, requestShortener);
		const message = `WebAssembly module is included in initial chunk.
This is not allowed, because WebAssembly download and compilation must happen asynchronous.
Add an async splitpoint (i. e. import()) somewhere between your entrypoint and the WebAssembly module:
${moduleChains.map(s => `* ${s}`).join("\n")}`;

		super(message);
		this.name = "WebAssemblyInInitialChunkError";
		this.hideStack = true;
		this.module = module;

		Error.captureStackTrace(this, this.constructor);
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/WebAssemblyJavascriptGenerator.js":
/*!************************************************************!*\
  !*** (webpack)/lib/wasm/WebAssemblyJavascriptGenerator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Generator = __webpack_require__(/*! ../Generator */ "./node_modules/webpack/lib/Generator.js");
const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");
const { RawSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");
const WebAssemblyImportDependency = __webpack_require__(/*! ../dependencies/WebAssemblyImportDependency */ "./node_modules/webpack/lib/dependencies/WebAssemblyImportDependency.js");
const WebAssemblyExportImportedDependency = __webpack_require__(/*! ../dependencies/WebAssemblyExportImportedDependency */ "./node_modules/webpack/lib/dependencies/WebAssemblyExportImportedDependency.js");

/** @typedef {import("../NormalModule")} NormalModule */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Dependency").DependencyTemplate} DependencyTemplate */

class WebAssemblyJavascriptGenerator extends Generator {
	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates
	 * @param {RuntimeTemplate} runtimeTemplate the runtime template
	 * @param {string} type which kind of code should be generated
	 * @returns {Source} generated code
	 */
	generate(module, dependencyTemplates, runtimeTemplate, type) {
		const initIdentifer = Array.isArray(module.usedExports)
			? Template.numberToIdentifer(module.usedExports.length)
			: "__webpack_init__";

		let needExportsCopy = false;
		const importedModules = new Map();
		const initParams = [];
		let index = 0;
		for (const dep of module.dependencies) {
			const depAsAny = /** @type {any} */ (dep);
			if (dep.module) {
				let importData = importedModules.get(dep.module);
				if (importData === undefined) {
					importedModules.set(
						dep.module,
						(importData = {
							importVar: `m${index}`,
							index,
							request:
								"userRequest" in depAsAny ? depAsAny.userRequest : undefined,
							names: new Set(),
							reexports: []
						})
					);
					index++;
				}
				if (dep instanceof WebAssemblyImportDependency) {
					importData.names.add(dep.name);
					if (dep.description.type === "GlobalType") {
						const exportName = dep.name;
						const usedName = dep.module && dep.module.isUsed(exportName);

						if (dep.module) {
							if (usedName) {
								initParams.push(
									runtimeTemplate.exportFromImport({
										module: dep.module,
										request: dep.request,
										importVar: importData.importVar,
										originModule: module,
										exportName: dep.name,
										asiSafe: true,
										isCall: false,
										callContext: null
									})
								);
							}
						}
					}
				}
				if (dep instanceof WebAssemblyExportImportedDependency) {
					importData.names.add(dep.name);
					const usedName = module.isUsed(dep.exportName);
					if (usedName) {
						const exportProp = `${module.exportsArgument}[${JSON.stringify(
							usedName
						)}]`;
						const defineStatement = Template.asString([
							`${exportProp} = ${runtimeTemplate.exportFromImport({
								module: dep.module,
								request: dep.request,
								importVar: importData.importVar,
								originModule: module,
								exportName: dep.name,
								asiSafe: true,
								isCall: false,
								callContext: null
							})};`,
							`if(WebAssembly.Global) ${exportProp} = ` +
								`new WebAssembly.Global({ value: ${JSON.stringify(
									dep.valueType
								)} }, ${exportProp});`
						]);
						importData.reexports.push(defineStatement);
						needExportsCopy = true;
					}
				}
			}
		}
		const importsCode = Template.asString(
			Array.from(
				importedModules,
				([module, { importVar, request, reexports }]) => {
					const importStatement = runtimeTemplate.importStatement({
						module,
						request,
						importVar,
						originModule: module
					});
					return importStatement + reexports.join("\n");
				}
			)
		);

		// create source
		const source = new RawSource(
			[
				'"use strict";',
				"// Instantiate WebAssembly module",
				"var wasmExports = __webpack_require__.w[module.i];",

				!Array.isArray(module.usedExports)
					? `__webpack_require__.r(${module.exportsArgument});`
					: "",

				// this must be before import for circular dependencies
				"// export exports from WebAssembly module",
				Array.isArray(module.usedExports) && !needExportsCopy
					? `${module.moduleArgument}.exports = wasmExports;`
					: "for(var name in wasmExports) " +
					  `if(name != ${JSON.stringify(initIdentifer)}) ` +
					  `${module.exportsArgument}[name] = wasmExports[name];`,
				"// exec imports from WebAssembly module (for esm order)",
				importsCode,
				"",
				"// exec wasm module",
				`wasmExports[${JSON.stringify(initIdentifer)}](${initParams.join(
					", "
				)})`
			].join("\n")
		);
		return source;
	}
}

module.exports = WebAssemblyJavascriptGenerator;


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/WebAssemblyModulesPlugin.js":
/*!******************************************************!*\
  !*** (webpack)/lib/wasm/WebAssemblyModulesPlugin.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Generator = __webpack_require__(/*! ../Generator */ "./node_modules/webpack/lib/Generator.js");
const WebAssemblyParser = __webpack_require__(/*! ./WebAssemblyParser */ "./node_modules/webpack/lib/wasm/WebAssemblyParser.js");
const WebAssemblyGenerator = __webpack_require__(/*! ./WebAssemblyGenerator */ "./node_modules/webpack/lib/wasm/WebAssemblyGenerator.js");
const WebAssemblyJavascriptGenerator = __webpack_require__(/*! ./WebAssemblyJavascriptGenerator */ "./node_modules/webpack/lib/wasm/WebAssemblyJavascriptGenerator.js");
const WebAssemblyImportDependency = __webpack_require__(/*! ../dependencies/WebAssemblyImportDependency */ "./node_modules/webpack/lib/dependencies/WebAssemblyImportDependency.js");
const WebAssemblyExportImportedDependency = __webpack_require__(/*! ../dependencies/WebAssemblyExportImportedDependency */ "./node_modules/webpack/lib/dependencies/WebAssemblyExportImportedDependency.js");
const WebAssemblyInInitialChunkError = __webpack_require__(/*! ./WebAssemblyInInitialChunkError */ "./node_modules/webpack/lib/wasm/WebAssemblyInInitialChunkError.js");

/** @typedef {import("../Compiler")} Compiler */

class WebAssemblyModulesPlugin {
	constructor(options) {
		this.options = options;
	}

	/**
	 * @param {Compiler} compiler compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"WebAssemblyModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					WebAssemblyImportDependency,
					normalModuleFactory
				);

				compilation.dependencyFactories.set(
					WebAssemblyExportImportedDependency,
					normalModuleFactory
				);

				normalModuleFactory.hooks.createParser
					.for("webassembly/experimental")
					.tap("WebAssemblyModulesPlugin", () => {
						return new WebAssemblyParser();
					});

				normalModuleFactory.hooks.createGenerator
					.for("webassembly/experimental")
					.tap("WebAssemblyModulesPlugin", () => {
						return Generator.byType({
							javascript: new WebAssemblyJavascriptGenerator(),
							webassembly: new WebAssemblyGenerator(this.options)
						});
					});

				compilation.chunkTemplate.hooks.renderManifest.tap(
					"WebAssemblyModulesPlugin",
					(result, options) => {
						const chunk = options.chunk;
						const outputOptions = options.outputOptions;
						const moduleTemplates = options.moduleTemplates;
						const dependencyTemplates = options.dependencyTemplates;

						for (const module of chunk.modulesIterable) {
							if (module.type && module.type.startsWith("webassembly")) {
								const filenameTemplate =
									outputOptions.webassemblyModuleFilename;

								result.push({
									render: () =>
										this.renderWebAssembly(
											module,
											moduleTemplates.webassembly,
											dependencyTemplates
										),
									filenameTemplate,
									pathOptions: {
										module
									},
									identifier: `webassemblyModule${module.id}`,
									hash: module.hash
								});
							}
						}

						return result;
					}
				);

				compilation.hooks.afterChunks.tap("WebAssemblyModulesPlugin", () => {
					const initialWasmModules = new Set();
					for (const chunk of compilation.chunks) {
						if (chunk.canBeInitial()) {
							for (const module of chunk.modulesIterable) {
								if (module.type.startsWith("webassembly")) {
									initialWasmModules.add(module);
								}
							}
						}
					}
					for (const module of initialWasmModules) {
						compilation.errors.push(
							new WebAssemblyInInitialChunkError(
								module,
								compilation.requestShortener
							)
						);
					}
				});
			}
		);
	}

	renderWebAssembly(module, moduleTemplate, dependencyTemplates) {
		return moduleTemplate.render(module, dependencyTemplates, {});
	}
}

module.exports = WebAssemblyModulesPlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/WebAssemblyParser.js":
/*!***********************************************!*\
  !*** (webpack)/lib/wasm/WebAssemblyParser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const t = __webpack_require__(/*! @webassemblyjs/ast */ "@webassemblyjs/ast");
const { decode } = __webpack_require__(/*! @webassemblyjs/wasm-parser */ "@webassemblyjs/wasm-parser");
const {
	moduleContextFromModuleAST
} = __webpack_require__(/*! @webassemblyjs/helper-module-context */ "@webassemblyjs/helper-module-context");

const { Tapable } = __webpack_require__(/*! tapable */ "tapable");
const WebAssemblyImportDependency = __webpack_require__(/*! ../dependencies/WebAssemblyImportDependency */ "./node_modules/webpack/lib/dependencies/WebAssemblyImportDependency.js");
const WebAssemblyExportImportedDependency = __webpack_require__(/*! ../dependencies/WebAssemblyExportImportedDependency */ "./node_modules/webpack/lib/dependencies/WebAssemblyExportImportedDependency.js");

/** @typedef {import("../Module")} Module */

const JS_COMPAT_TYPES = new Set(["i32", "f32", "f64"]);

/**
 * @param {t.Signature} signature the func signature
 * @returns {null | string} the type incompatible with js types
 */
const getJsIncompatibleType = signature => {
	for (const param of signature.params) {
		if (!JS_COMPAT_TYPES.has(param.valtype)) {
			return `${param.valtype} as parameter`;
		}
	}
	for (const type of signature.results) {
		if (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;
	}
	return null;
};

/**
 * TODO why are there two different Signature types?
 * @param {t.FuncSignature} signature the func signature
 * @returns {null | string} the type incompatible with js types
 */
const getJsIncompatibleTypeOfFuncSignature = signature => {
	for (const param of signature.args) {
		if (!JS_COMPAT_TYPES.has(param)) {
			return `${param} as parameter`;
		}
	}
	for (const type of signature.result) {
		if (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;
	}
	return null;
};

const decoderOpts = {
	ignoreCodeSection: true,
	ignoreDataSection: true,

	// this will avoid having to lookup with identifiers in the ModuleContext
	ignoreCustomNameSection: true
};

class WebAssemblyParser extends Tapable {
	constructor(options) {
		super();
		this.hooks = {};
		this.options = options;
	}

	parse(binary, state) {
		// flag it as ESM
		state.module.buildMeta.exportsType = "namespace";

		// parse it
		const program = decode(binary, decoderOpts);
		const module = program.body[0];

		const moduleContext = moduleContextFromModuleAST(module);

		// extract imports and exports
		const exports = (state.module.buildMeta.providedExports = []);
		const jsIncompatibleExports = (state.module.buildMeta.jsIncompatibleExports = []);

		const importedGlobals = [];
		t.traverse(module, {
			ModuleExport({ node }) {
				const descriptor = node.descr;

				if (descriptor.exportType === "Func") {
					const funcidx = descriptor.id.value;

					/** @type {t.FuncSignature} */
					const funcSignature = moduleContext.getFunction(funcidx);

					const incompatibleType = getJsIncompatibleTypeOfFuncSignature(
						funcSignature
					);

					if (incompatibleType) {
						jsIncompatibleExports[node.name] = incompatibleType;
					}
				}

				exports.push(node.name);

				if (node.descr && node.descr.exportType === "Global") {
					const refNode = importedGlobals[node.descr.id.value];
					if (refNode) {
						const dep = new WebAssemblyExportImportedDependency(
							node.name,
							refNode.module,
							refNode.name,
							refNode.descr.valtype
						);

						state.module.addDependency(dep);
					}
				}
			},

			Global({ node }) {
				const init = node.init[0];

				let importNode = null;

				if (init.id === "get_global") {
					const globalIdx = init.args[0].value;

					if (globalIdx < importedGlobals.length) {
						importNode = importedGlobals[globalIdx];
					}
				}

				importedGlobals.push(importNode);
			},

			ModuleImport({ node }) {
				/** @type {false | string} */
				let onlyDirectImport = false;

				if (t.isMemory(node.descr) === true) {
					onlyDirectImport = "Memory";
				} else if (t.isTable(node.descr) === true) {
					onlyDirectImport = "Table";
				} else if (t.isFuncImportDescr(node.descr) === true) {
					const incompatibleType = getJsIncompatibleType(node.descr.signature);
					if (incompatibleType) {
						onlyDirectImport = `Non-JS-compatible Func Sigurature (${incompatibleType})`;
					}
				} else if (t.isGlobalType(node.descr) === true) {
					const type = node.descr.valtype;
					if (!JS_COMPAT_TYPES.has(type)) {
						onlyDirectImport = `Non-JS-compatible Global Type (${type})`;
					}
				}

				const dep = new WebAssemblyImportDependency(
					node.module,
					node.name,
					node.descr,
					onlyDirectImport
				);

				state.module.addDependency(dep);

				if (t.isGlobalType(node.descr)) {
					importedGlobals.push(node);
				}
			}
		});

		return state;
	}
}

module.exports = WebAssemblyParser;


/***/ }),

/***/ "./node_modules/webpack/lib/wasm/WebAssemblyUtils.js":
/*!**********************************************!*\
  !*** (webpack)/lib/wasm/WebAssemblyUtils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");
const WebAssemblyImportDependency = __webpack_require__(/*! ../dependencies/WebAssemblyImportDependency */ "./node_modules/webpack/lib/dependencies/WebAssemblyImportDependency.js");

/** @typedef {import("../Module")} Module */

/** @typedef {Object} UsedWasmDependency
 * @property {WebAssemblyImportDependency} dependency the dependency
 * @property {string} name the export name
 * @property {string} module the module name
 */

const MANGLED_MODULE = "a";

/**
 * @param {Module} module the module
 * @param {boolean} mangle mangle module and export names
 * @returns {UsedWasmDependency[]} used dependencies and (mangled) name
 */
const getUsedDependencies = (module, mangle) => {
	/** @type {UsedWasmDependency[]} */
	const array = [];
	let importIndex = 0;
	for (const dep of module.dependencies) {
		if (dep instanceof WebAssemblyImportDependency) {
			if (dep.description.type === "GlobalType" || dep.module === null) {
				continue;
			}

			const exportName = dep.name;
			// TODO add the following 3 lines when removing of ModuleExport is possible
			// const importedModule = dep.module;
			// const usedName = importedModule && importedModule.isUsed(exportName);
			// if (usedName !== false) {
			if (mangle) {
				array.push({
					dependency: dep,
					name: Template.numberToIdentifer(importIndex++),
					module: MANGLED_MODULE
				});
			} else {
				array.push({
					dependency: dep,
					name: exportName,
					module: dep.request
				});
			}
		}
	}
	return array;
};

exports.getUsedDependencies = getUsedDependencies;
exports.MANGLED_MODULE = MANGLED_MODULE;


/***/ }),

/***/ "./node_modules/webpack/lib/web/FetchCompileWasmTemplatePlugin.js":
/*!***********************************************************!*\
  !*** (webpack)/lib/web/FetchCompileWasmTemplatePlugin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WasmMainTemplatePlugin = __webpack_require__(/*! ../wasm/WasmMainTemplatePlugin */ "./node_modules/webpack/lib/wasm/WasmMainTemplatePlugin.js");

class FetchCompileWasmTemplatePlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"FetchCompileWasmTemplatePlugin",
			compilation => {
				const mainTemplate = compilation.mainTemplate;
				const generateLoadBinaryCode = path =>
					`fetch(${mainTemplate.requireFn}.p + ${path})`;

				const plugin = new WasmMainTemplatePlugin(
					Object.assign(
						{
							generateLoadBinaryCode,
							supportsStreaming: true
						},
						this.options
					)
				);
				plugin.apply(mainTemplate);
			}
		);
	}
}

module.exports = FetchCompileWasmTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/web/JsonpChunkTemplatePlugin.js":
/*!*****************************************************!*\
  !*** (webpack)/lib/web/JsonpChunkTemplatePlugin.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

/** @typedef {import("../ChunkTemplate")} ChunkTemplate */

const getEntryInfo = chunk => {
	return [chunk.entryModule].filter(Boolean).map(m =>
		[m.id].concat(
			Array.from(chunk.groupsIterable)[0]
				.chunks.filter(c => c !== chunk)
				.map(c => c.id)
		)
	);
};

class JsonpChunkTemplatePlugin {
	/**
	 * @param {ChunkTemplate} chunkTemplate the chunk template
	 * @returns {void}
	 */
	apply(chunkTemplate) {
		chunkTemplate.hooks.render.tap(
			"JsonpChunkTemplatePlugin",
			(modules, chunk) => {
				const jsonpFunction = chunkTemplate.outputOptions.jsonpFunction;
				const globalObject = chunkTemplate.outputOptions.globalObject;
				const source = new ConcatSource();
				const prefetchChunks = chunk.getChildIdsByOrders().prefetch;
				source.add(
					`(${globalObject}[${JSON.stringify(
						jsonpFunction
					)}] = ${globalObject}[${JSON.stringify(
						jsonpFunction
					)}] || []).push([${JSON.stringify(chunk.ids)},`
				);
				source.add(modules);
				const entries = getEntryInfo(chunk);
				if (entries.length > 0) {
					source.add(`,${JSON.stringify(entries)}`);
				} else if (prefetchChunks && prefetchChunks.length) {
					source.add(`,0`);
				}

				if (prefetchChunks && prefetchChunks.length) {
					source.add(`,${JSON.stringify(prefetchChunks)}`);
				}
				source.add("])");
				return source;
			}
		);
		chunkTemplate.hooks.hash.tap("JsonpChunkTemplatePlugin", hash => {
			hash.update("JsonpChunkTemplatePlugin");
			hash.update("4");
			hash.update(`${chunkTemplate.outputOptions.jsonpFunction}`);
			hash.update(`${chunkTemplate.outputOptions.globalObject}`);
		});
		chunkTemplate.hooks.hashForChunk.tap(
			"JsonpChunkTemplatePlugin",
			(hash, chunk) => {
				hash.update(JSON.stringify(getEntryInfo(chunk)));
				hash.update(JSON.stringify(chunk.getChildIdsByOrders().prefetch) || "");
			}
		);
	}
}
module.exports = JsonpChunkTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/web/JsonpExportMainTemplatePlugin.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/web/JsonpExportMainTemplatePlugin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

class JsonpExportMainTemplatePlugin {
	/**
	 * @param {string} name jsonp function name
	 */
	constructor(name) {
		this.name = name;
	}

	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const name = mainTemplate.getAssetPath(this.name || "", {
				hash,
				chunk
			});
			return new ConcatSource(`${name}(`, source, ");");
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"JsonpExportMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap(
			"JsonpExportMainTemplatePlugin",
			paths => {
				if (this.name) paths.push(this.name);
				return paths;
			}
		);

		mainTemplate.hooks.hash.tap("JsonpExportMainTemplatePlugin", hash => {
			hash.update("jsonp export");
			hash.update(`${this.name}`);
		});
	}
}

module.exports = JsonpExportMainTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/web/JsonpHotUpdateChunkTemplatePlugin.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/web/JsonpHotUpdateChunkTemplatePlugin.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

class JsonpHotUpdateChunkTemplatePlugin {
	apply(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.hooks.render.tap(
			"JsonpHotUpdateChunkTemplatePlugin",
			(modulesSource, modules, removedModules, hash, id) => {
				const source = new ConcatSource();
				source.add(
					`${
						hotUpdateChunkTemplate.outputOptions.hotUpdateFunction
					}(${JSON.stringify(id)},`
				);
				source.add(modulesSource);
				source.add(")");
				return source;
			}
		);
		hotUpdateChunkTemplate.hooks.hash.tap(
			"JsonpHotUpdateChunkTemplatePlugin",
			hash => {
				hash.update("JsonpHotUpdateChunkTemplatePlugin");
				hash.update("3");
				hash.update(
					`${hotUpdateChunkTemplate.outputOptions.hotUpdateFunction}`
				);
				hash.update(`${hotUpdateChunkTemplate.outputOptions.library}`);
			}
		);
	}
}

module.exports = JsonpHotUpdateChunkTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/web/JsonpMainTemplate.runtime.js":
/*!******************************************************!*\
  !*** (webpack)/lib/web/JsonpMainTemplate.runtime.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*globals hotAddUpdateChunk parentHotUpdateCallback document XMLHttpRequest $require$ $hotChunkFilename$ $hotMainFilename$ $crossOriginLoading$ */
module.exports = function() {
	// eslint-disable-next-line no-unused-vars
	function webpackHotUpdateCallback(chunkId, moreModules) {
		hotAddUpdateChunk(chunkId, moreModules);
		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
	} //$semicolon

	// eslint-disable-next-line no-unused-vars
	function hotDownloadUpdateChunk(chunkId) {
		var script = document.createElement("script");
		script.charset = "utf-8";
		script.src = $require$.p + $hotChunkFilename$;
		if ($crossOriginLoading$) script.crossOrigin = $crossOriginLoading$;
		document.head.appendChild(script);
	}

	// eslint-disable-next-line no-unused-vars
	function hotDownloadManifest(requestTimeout) {
		requestTimeout = requestTimeout || 10000;
		return new Promise(function(resolve, reject) {
			if (typeof XMLHttpRequest === "undefined") {
				return reject(new Error("No browser support"));
			}
			try {
				var request = new XMLHttpRequest();
				var requestPath = $require$.p + $hotMainFilename$;
				request.open("GET", requestPath, true);
				request.timeout = requestTimeout;
				request.send(null);
			} catch (err) {
				return reject(err);
			}
			request.onreadystatechange = function() {
				if (request.readyState !== 4) return;
				if (request.status === 0) {
					// timeout
					reject(
						new Error("Manifest request to " + requestPath + " timed out.")
					);
				} else if (request.status === 404) {
					// no update available
					resolve();
				} else if (request.status !== 200 && request.status !== 304) {
					// other failure
					reject(new Error("Manifest request to " + requestPath + " failed."));
				} else {
					// success
					try {
						var update = JSON.parse(request.responseText);
					} catch (e) {
						reject(e);
						return;
					}
					resolve(update);
				}
			};
		});
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/web/JsonpMainTemplatePlugin.js":
/*!****************************************************!*\
  !*** (webpack)/lib/web/JsonpMainTemplatePlugin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { SyncWaterfallHook } = __webpack_require__(/*! tapable */ "tapable");
const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");

class JsonpMainTemplatePlugin {
	apply(mainTemplate) {
		const needChunkOnDemandLoadingCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.getNumberOfChildren() > 0) return true;
			}
			return false;
		};
		const needChunkLoadingCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.chunks.length > 1) return true;
				if (chunkGroup.getNumberOfChildren() > 0) return true;
			}
			return false;
		};
		const needEntryDeferringCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.chunks.length > 1) return true;
			}
			return false;
		};
		const needPrefetchingCode = chunk => {
			const allPrefetchChunks = chunk.getChildIdsByOrdersMap(true).prefetch;
			return allPrefetchChunks && Object.keys(allPrefetchChunks).length;
		};

		// TODO webpack 5, no adding to .hooks, use WeakMap and static methods
		["jsonpScript", "linkPreload", "linkPrefetch"].forEach(hook => {
			if (!mainTemplate.hooks[hook]) {
				mainTemplate.hooks[hook] = new SyncWaterfallHook([
					"source",
					"chunk",
					"hash"
				]);
			}
		});

		const getScriptSrcPath = (hash, chunk, chunkIdExpression) => {
			const chunkFilename = mainTemplate.outputOptions.chunkFilename;
			const chunkMaps = chunk.getChunkMaps();
			return mainTemplate.getAssetPath(JSON.stringify(chunkFilename), {
				hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
				hashWithLength: length =>
					`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
				chunk: {
					id: `" + ${chunkIdExpression} + "`,
					hash: `" + ${JSON.stringify(
						chunkMaps.hash
					)}[${chunkIdExpression}] + "`,
					hashWithLength(length) {
						const shortChunkHashMap = Object.create(null);
						for (const chunkId of Object.keys(chunkMaps.hash)) {
							if (typeof chunkMaps.hash[chunkId] === "string") {
								shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(
									0,
									length
								);
							}
						}
						return `" + ${JSON.stringify(
							shortChunkHashMap
						)}[${chunkIdExpression}] + "`;
					},
					name: `" + (${JSON.stringify(
						chunkMaps.name
					)}[${chunkIdExpression}]||${chunkIdExpression}) + "`,
					contentHash: {
						javascript: `" + ${JSON.stringify(
							chunkMaps.contentHash.javascript
						)}[${chunkIdExpression}] + "`
					},
					contentHashWithLength: {
						javascript: length => {
							const shortContentHashMap = {};
							const contentHash = chunkMaps.contentHash.javascript;
							for (const chunkId of Object.keys(contentHash)) {
								if (typeof contentHash[chunkId] === "string") {
									shortContentHashMap[chunkId] = contentHash[chunkId].substr(
										0,
										length
									);
								}
							}
							return `" + ${JSON.stringify(
								shortContentHashMap
							)}[${chunkIdExpression}] + "`;
						}
					}
				},
				contentHashType: "javascript"
			});
		};
		mainTemplate.hooks.localVars.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				const extraCode = [];
				if (needChunkLoadingCode(chunk)) {
					extraCode.push(
						"",
						"// object to store loaded and loading chunks",
						"// undefined = chunk not loaded, null = chunk preloaded/prefetched",
						"// Promise = chunk loading, 0 = chunk loaded",
						"var installedChunks = {",
						Template.indent(
							chunk.ids.map(id => `${JSON.stringify(id)}: 0`).join(",\n")
						),
						"};",
						"",
						needEntryDeferringCode(chunk) ? "var deferredModules = [];" : ""
					);
				}
				if (needChunkOnDemandLoadingCode(chunk)) {
					extraCode.push(
						"",
						"// script path function",
						"function jsonpScriptSrc(chunkId) {",
						Template.indent([
							`return ${mainTemplate.requireFn}.p + ${getScriptSrcPath(
								hash,
								chunk,
								"chunkId"
							)}`
						]),
						"}"
					);
				}
				if (extraCode.length === 0) return source;
				return Template.asString([source, ...extraCode]);
			}
		);

		mainTemplate.hooks.jsonpScript.tap(
			"JsonpMainTemplatePlugin",
			(_, chunk, hash) => {
				const crossOriginLoading =
					mainTemplate.outputOptions.crossOriginLoading;
				const chunkLoadTimeout = mainTemplate.outputOptions.chunkLoadTimeout;
				const jsonpScriptType = mainTemplate.outputOptions.jsonpScriptType;

				return Template.asString([
					"var script = document.createElement('script');",
					"var onScriptComplete;",
					jsonpScriptType
						? `script.type = ${JSON.stringify(jsonpScriptType)};`
						: "",
					"script.charset = 'utf-8';",
					`script.timeout = ${chunkLoadTimeout / 1000};`,
					`if (${mainTemplate.requireFn}.nc) {`,
					Template.indent(
						`script.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`
					),
					"}",
					"script.src = jsonpScriptSrc(chunkId);",
					crossOriginLoading
						? Template.asString([
								"if (script.src.indexOf(window.location.origin + '/') !== 0) {",
								Template.indent(
									`script.crossOrigin = ${JSON.stringify(crossOriginLoading)};`
								),
								"}"
						  ])
						: "",
					"onScriptComplete = function (event) {",
					Template.indent([
						"// avoid mem leaks in IE.",
						"script.onerror = script.onload = null;",
						"clearTimeout(timeout);",
						"var chunk = installedChunks[chunkId];",
						"if(chunk !== 0) {",
						Template.indent([
							"if(chunk) {",
							Template.indent([
								"var errorType = event && (event.type === 'load' ? 'missing' : event.type);",
								"var realSrc = event && event.target && event.target.src;",
								"var error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');",
								"error.type = errorType;",
								"error.request = realSrc;",
								"chunk[1](error);"
							]),
							"}",
							"installedChunks[chunkId] = undefined;"
						]),
						"}"
					]),
					"};",
					"var timeout = setTimeout(function(){",
					Template.indent([
						"onScriptComplete({ type: 'timeout', target: script });"
					]),
					`}, ${chunkLoadTimeout});`,
					"script.onerror = script.onload = onScriptComplete;"
				]);
			}
		);
		mainTemplate.hooks.linkPreload.tap(
			"JsonpMainTemplatePlugin",
			(_, chunk, hash) => {
				const crossOriginLoading =
					mainTemplate.outputOptions.crossOriginLoading;
				const jsonpScriptType = mainTemplate.outputOptions.jsonpScriptType;

				return Template.asString([
					"var link = document.createElement('link');",
					jsonpScriptType
						? `link.type = ${JSON.stringify(jsonpScriptType)};`
						: "",
					"link.charset = 'utf-8';",
					`if (${mainTemplate.requireFn}.nc) {`,
					Template.indent(
						`link.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`
					),
					"}",
					'link.rel = "preload";',
					'link.as = "script";',
					"link.href = jsonpScriptSrc(chunkId);",
					crossOriginLoading
						? Template.asString([
								"if (link.href.indexOf(window.location.origin + '/') !== 0) {",
								Template.indent(
									`link.crossOrigin = ${JSON.stringify(crossOriginLoading)};`
								),
								"}"
						  ])
						: ""
				]);
			}
		);
		mainTemplate.hooks.linkPrefetch.tap(
			"JsonpMainTemplatePlugin",
			(_, chunk, hash) => {
				const crossOriginLoading =
					mainTemplate.outputOptions.crossOriginLoading;

				return Template.asString([
					"var link = document.createElement('link');",
					crossOriginLoading
						? `link.crossOrigin = ${JSON.stringify(crossOriginLoading)};`
						: "",
					`if (${mainTemplate.requireFn}.nc) {`,
					Template.indent(
						`link.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`
					),
					"}",
					'link.rel = "prefetch";',
					'link.as = "script";',
					"link.href = jsonpScriptSrc(chunkId);"
				]);
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			"JsonpMainTemplatePlugin load",
			(source, chunk, hash) => {
				return Template.asString([
					source,
					"",
					"// JSONP chunk loading for javascript",
					"",
					"var installedChunkData = installedChunks[chunkId];",
					'if(installedChunkData !== 0) { // 0 means "already installed".',
					Template.indent([
						"",
						'// a Promise means "currently loading".',
						"if(installedChunkData) {",
						Template.indent(["promises.push(installedChunkData[2]);"]),
						"} else {",
						Template.indent([
							"// setup Promise in chunk cache",
							"var promise = new Promise(function(resolve, reject) {",
							Template.indent([
								"installedChunkData = installedChunks[chunkId] = [resolve, reject];"
							]),
							"});",
							"promises.push(installedChunkData[2] = promise);",
							"",
							"// start chunk loading",
							mainTemplate.hooks.jsonpScript.call("", chunk, hash),
							"document.head.appendChild(script);"
						]),
						"}"
					]),
					"}"
				]);
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			{
				name: "JsonpMainTemplatePlugin preload",
				stage: 10
			},
			(source, chunk, hash) => {
				const chunkMap = chunk.getChildIdsByOrdersMap().preload;
				if (!chunkMap || Object.keys(chunkMap).length === 0) return source;
				return Template.asString([
					source,
					"",
					"// chunk preloadng for javascript",
					"",
					`var chunkPreloadMap = ${JSON.stringify(chunkMap, null, "\t")};`,
					"",
					"var chunkPreloadData = chunkPreloadMap[chunkId];",
					"if(chunkPreloadData) {",
					Template.indent([
						"chunkPreloadData.forEach(function(chunkId) {",
						Template.indent([
							"if(installedChunks[chunkId] === undefined) {",
							Template.indent([
								"installedChunks[chunkId] = null;",
								mainTemplate.hooks.linkPreload.call("", chunk, hash),
								"document.head.appendChild(link);"
							]),
							"}"
						]),
						"});"
					]),
					"}"
				]);
			}
		);
		mainTemplate.hooks.requireExtensions.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk) => {
				if (!needChunkOnDemandLoadingCode(chunk)) return source;

				return Template.asString([
					source,
					"",
					"// on error function for async loading",
					`${
						mainTemplate.requireFn
					}.oe = function(err) { console.error(err); throw err; };`
				]);
			}
		);
		mainTemplate.hooks.bootstrap.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				if (needChunkLoadingCode(chunk)) {
					const withDefer = needEntryDeferringCode(chunk);
					const withPrefetch = needPrefetchingCode(chunk);
					return Template.asString([
						source,
						"",
						"// install a JSONP callback for chunk loading",
						"function webpackJsonpCallback(data) {",
						Template.indent([
							"var chunkIds = data[0];",
							"var moreModules = data[1];",
							withDefer ? "var executeModules = data[2];" : "",
							withPrefetch ? "var prefetchChunks = data[3] || [];" : "",
							'// add "moreModules" to the modules object,',
							'// then flag all "chunkIds" as loaded and fire callback',
							"var moduleId, chunkId, i = 0, resolves = [];",
							"for(;i < chunkIds.length; i++) {",
							Template.indent([
								"chunkId = chunkIds[i];",
								"if(installedChunks[chunkId]) {",
								Template.indent("resolves.push(installedChunks[chunkId][0]);"),
								"}",
								"installedChunks[chunkId] = 0;"
							]),
							"}",
							"for(moduleId in moreModules) {",
							Template.indent([
								"if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {",
								Template.indent(
									mainTemplate.renderAddModule(
										hash,
										chunk,
										"moduleId",
										"moreModules[moduleId]"
									)
								),
								"}"
							]),
							"}",
							"if(parentJsonpFunction) parentJsonpFunction(data);",
							withPrefetch
								? Template.asString([
										"// chunk prefetching for javascript",
										"prefetchChunks.forEach(function(chunkId) {",
										Template.indent([
											"if(installedChunks[chunkId] === undefined) {",
											Template.indent([
												"installedChunks[chunkId] = null;",
												mainTemplate.hooks.linkPrefetch.call("", chunk, hash),
												"document.head.appendChild(link);"
											]),
											"}"
										]),
										"});"
								  ])
								: "",
							"while(resolves.length) {",
							Template.indent("resolves.shift()();"),
							"}",
							withDefer
								? Template.asString([
										"",
										"// add entry modules from loaded chunk to deferred list",
										"deferredModules.push.apply(deferredModules, executeModules || []);",
										"",
										"// run deferred modules when all chunks ready",
										"return checkDeferredModules();"
								  ])
								: ""
						]),
						"};",
						withDefer
							? Template.asString([
									"function checkDeferredModules() {",
									Template.indent([
										"var result;",
										"for(var i = 0; i < deferredModules.length; i++) {",
										Template.indent([
											"var deferredModule = deferredModules[i];",
											"var fulfilled = true;",
											"for(var j = 1; j < deferredModule.length; j++) {",
											Template.indent([
												"var depId = deferredModule[j];",
												"if(installedChunks[depId] !== 0) fulfilled = false;"
											]),
											"}",
											"if(fulfilled) {",
											Template.indent([
												"deferredModules.splice(i--, 1);",
												"result = " +
													mainTemplate.requireFn +
													"(" +
													mainTemplate.requireFn +
													".s = deferredModule[0]);"
											]),
											"}"
										]),
										"}",
										"return result;"
									]),
									"}"
							  ])
							: ""
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.beforeStartup.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				if (needChunkLoadingCode(chunk)) {
					var jsonpFunction = mainTemplate.outputOptions.jsonpFunction;
					var globalObject = mainTemplate.outputOptions.globalObject;
					return Template.asString([
						`var jsonpArray = ${globalObject}[${JSON.stringify(
							jsonpFunction
						)}] = ${globalObject}[${JSON.stringify(jsonpFunction)}] || [];`,
						"var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);",
						"jsonpArray.push = webpackJsonpCallback;",
						"jsonpArray = jsonpArray.slice();",
						"for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);",
						"var parentJsonpFunction = oldJsonpFunction;",
						"",
						source
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.beforeStartup.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				const prefetchChunks = chunk.getChildIdsByOrders().prefetch;
				if (
					needChunkLoadingCode(chunk) &&
					prefetchChunks &&
					prefetchChunks.length
				) {
					return Template.asString([
						source,
						`webpackJsonpCallback([[], {}, 0, ${JSON.stringify(
							prefetchChunks
						)}]);`
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.startup.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				if (needEntryDeferringCode(chunk)) {
					if (chunk.hasEntryModule()) {
						const entries = [chunk.entryModule].filter(Boolean).map(m =>
							[m.id].concat(
								Array.from(chunk.groupsIterable)[0]
									.chunks.filter(c => c !== chunk)
									.map(c => c.id)
							)
						);
						return Template.asString([
							"// add entry module to deferred list",
							`deferredModules.push(${entries
								.map(e => JSON.stringify(e))
								.join(", ")});`,
							"// run deferred modules when ready",
							"return checkDeferredModules();"
						]);
					} else {
						return Template.asString([
							"// run deferred modules from other chunks",
							"checkDeferredModules();"
						]);
					}
				}
				return source;
			}
		);
		mainTemplate.hooks.hotBootstrap.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				const globalObject = mainTemplate.outputOptions.globalObject;
				const hotUpdateChunkFilename =
					mainTemplate.outputOptions.hotUpdateChunkFilename;
				const hotUpdateMainFilename =
					mainTemplate.outputOptions.hotUpdateMainFilename;
				const crossOriginLoading =
					mainTemplate.outputOptions.crossOriginLoading;
				const hotUpdateFunction = mainTemplate.outputOptions.hotUpdateFunction;
				const currentHotUpdateChunkFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateChunkFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
						chunk: {
							id: '" + chunkId + "'
						}
					}
				);
				const currentHotUpdateMainFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateMainFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
					}
				);
				const runtimeSource = Template.getFunctionContent(
					__webpack_require__(/*! ./JsonpMainTemplate.runtime */ "./node_modules/webpack/lib/web/JsonpMainTemplate.runtime.js")
				)
					.replace(/\/\/\$semicolon/g, ";")
					.replace(/\$require\$/g, mainTemplate.requireFn)
					.replace(
						/\$crossOriginLoading\$/g,
						crossOriginLoading ? JSON.stringify(crossOriginLoading) : "null"
					)
					.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
					.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename)
					.replace(/\$hash\$/g, JSON.stringify(hash));
				return `${source}
function hotDisposeChunk(chunkId) {
	delete installedChunks[chunkId];
}
var parentHotUpdateCallback = ${globalObject}[${JSON.stringify(
					hotUpdateFunction
				)}];
${globalObject}[${JSON.stringify(hotUpdateFunction)}] = ${runtimeSource}`;
			}
		);
		mainTemplate.hooks.hash.tap("JsonpMainTemplatePlugin", hash => {
			hash.update("jsonp");
			hash.update("6");
		});
	}
}
module.exports = JsonpMainTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/web/JsonpTemplatePlugin.js":
/*!************************************************!*\
  !*** (webpack)/lib/web/JsonpTemplatePlugin.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const JsonpMainTemplatePlugin = __webpack_require__(/*! ./JsonpMainTemplatePlugin */ "./node_modules/webpack/lib/web/JsonpMainTemplatePlugin.js");
const JsonpChunkTemplatePlugin = __webpack_require__(/*! ./JsonpChunkTemplatePlugin */ "./node_modules/webpack/lib/web/JsonpChunkTemplatePlugin.js");
const JsonpHotUpdateChunkTemplatePlugin = __webpack_require__(/*! ./JsonpHotUpdateChunkTemplatePlugin */ "./node_modules/webpack/lib/web/JsonpHotUpdateChunkTemplatePlugin.js");

class JsonpTemplatePlugin {
	apply(compiler) {
		compiler.hooks.thisCompilation.tap("JsonpTemplatePlugin", compilation => {
			new JsonpMainTemplatePlugin().apply(compilation.mainTemplate);
			new JsonpChunkTemplatePlugin().apply(compilation.chunkTemplate);
			new JsonpHotUpdateChunkTemplatePlugin().apply(
				compilation.hotUpdateChunkTemplate
			);
		});
	}
}

module.exports = JsonpTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/webpack.js":
/*!********************************!*\
  !*** (webpack)/lib/webpack.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Compiler = __webpack_require__(/*! ./Compiler */ "./node_modules/webpack/lib/Compiler.js");
const MultiCompiler = __webpack_require__(/*! ./MultiCompiler */ "./node_modules/webpack/lib/MultiCompiler.js");
const NodeEnvironmentPlugin = __webpack_require__(/*! ./node/NodeEnvironmentPlugin */ "./node_modules/webpack/lib/node/NodeEnvironmentPlugin.js");
const WebpackOptionsApply = __webpack_require__(/*! ./WebpackOptionsApply */ "./node_modules/webpack/lib/WebpackOptionsApply.js");
const WebpackOptionsDefaulter = __webpack_require__(/*! ./WebpackOptionsDefaulter */ "./node_modules/webpack/lib/WebpackOptionsDefaulter.js");
const validateSchema = __webpack_require__(/*! ./validateSchema */ "./node_modules/webpack/lib/validateSchema.js");
const WebpackOptionsValidationError = __webpack_require__(/*! ./WebpackOptionsValidationError */ "./node_modules/webpack/lib/WebpackOptionsValidationError.js");
const webpackOptionsSchema = __webpack_require__(/*! ../schemas/WebpackOptions.json */ "./node_modules/webpack/schemas/WebpackOptions.json");
const RemovedPluginError = __webpack_require__(/*! ./RemovedPluginError */ "./node_modules/webpack/lib/RemovedPluginError.js");
const version = __webpack_require__(/*! ../package.json */ "./node_modules/webpack/package.json").version;

/** @typedef {import("../declarations/WebpackOptions").WebpackOptions} WebpackOptions */

/**
 * @param {WebpackOptions} options options object
 * @param {function(Error=, Stats=): void=} callback callback
 * @returns {Compiler | MultiCompiler} the compiler object
 */
const webpack = (options, callback) => {
	const webpackOptionsValidationErrors = validateSchema(
		webpackOptionsSchema,
		options
	);
	if (webpackOptionsValidationErrors.length) {
		throw new WebpackOptionsValidationError(webpackOptionsValidationErrors);
	}
	let compiler;
	if (Array.isArray(options)) {
		compiler = new MultiCompiler(options.map(options => webpack(options)));
	} else if (typeof options === "object") {
		options = new WebpackOptionsDefaulter().process(options);

		compiler = new Compiler(options.context);
		compiler.options = options;
		new NodeEnvironmentPlugin().apply(compiler);
		if (options.plugins && Array.isArray(options.plugins)) {
			for (const plugin of options.plugins) {
				if (typeof plugin === "function") {
					plugin.call(compiler, compiler);
				} else {
					plugin.apply(compiler);
				}
			}
		}
		compiler.hooks.environment.call();
		compiler.hooks.afterEnvironment.call();
		compiler.options = new WebpackOptionsApply().process(options, compiler);
	} else {
		throw new Error("Invalid argument: options");
	}
	if (callback) {
		if (typeof callback !== "function") {
			throw new Error("Invalid argument: callback");
		}
		if (
			options.watch === true ||
			(Array.isArray(options) && options.some(o => o.watch))
		) {
			const watchOptions = Array.isArray(options)
				? options.map(o => o.watchOptions || {})
				: options.watchOptions || {};
			return compiler.watch(watchOptions, callback);
		}
		compiler.run(callback);
	}
	return compiler;
};

exports = module.exports = webpack;
exports.version = version;

webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter;
webpack.WebpackOptionsApply = WebpackOptionsApply;
webpack.Compiler = Compiler;
webpack.MultiCompiler = MultiCompiler;
webpack.NodeEnvironmentPlugin = NodeEnvironmentPlugin;
// @ts-ignore Global @this directive is not supported
webpack.validate = validateSchema.bind(this, webpackOptionsSchema);
webpack.validateSchema = validateSchema;
webpack.WebpackOptionsValidationError = WebpackOptionsValidationError;

const exportPlugins = (obj, mappings) => {
	for (const name of Object.keys(mappings)) {
		Object.defineProperty(obj, name, {
			configurable: false,
			enumerable: true,
			get: mappings[name]
		});
	}
};

exportPlugins(exports, {
	AutomaticPrefetchPlugin: () => __webpack_require__(/*! ./AutomaticPrefetchPlugin */ "./node_modules/webpack/lib/AutomaticPrefetchPlugin.js"),
	BannerPlugin: () => __webpack_require__(/*! ./BannerPlugin */ "./node_modules/webpack/lib/BannerPlugin.js"),
	CachePlugin: () => __webpack_require__(/*! ./CachePlugin */ "./node_modules/webpack/lib/CachePlugin.js"),
	ContextExclusionPlugin: () => __webpack_require__(/*! ./ContextExclusionPlugin */ "./node_modules/webpack/lib/ContextExclusionPlugin.js"),
	ContextReplacementPlugin: () => __webpack_require__(/*! ./ContextReplacementPlugin */ "./node_modules/webpack/lib/ContextReplacementPlugin.js"),
	DefinePlugin: () => __webpack_require__(/*! ./DefinePlugin */ "./node_modules/webpack/lib/DefinePlugin.js"),
	Dependency: () => __webpack_require__(/*! ./Dependency */ "./node_modules/webpack/lib/Dependency.js"),
	DllPlugin: () => __webpack_require__(/*! ./DllPlugin */ "./node_modules/webpack/lib/DllPlugin.js"),
	DllReferencePlugin: () => __webpack_require__(/*! ./DllReferencePlugin */ "./node_modules/webpack/lib/DllReferencePlugin.js"),
	EnvironmentPlugin: () => __webpack_require__(/*! ./EnvironmentPlugin */ "./node_modules/webpack/lib/EnvironmentPlugin.js"),
	EvalDevToolModulePlugin: () => __webpack_require__(/*! ./EvalDevToolModulePlugin */ "./node_modules/webpack/lib/EvalDevToolModulePlugin.js"),
	EvalSourceMapDevToolPlugin: () => __webpack_require__(/*! ./EvalSourceMapDevToolPlugin */ "./node_modules/webpack/lib/EvalSourceMapDevToolPlugin.js"),
	ExtendedAPIPlugin: () => __webpack_require__(/*! ./ExtendedAPIPlugin */ "./node_modules/webpack/lib/ExtendedAPIPlugin.js"),
	ExternalsPlugin: () => __webpack_require__(/*! ./ExternalsPlugin */ "./node_modules/webpack/lib/ExternalsPlugin.js"),
	HashedModuleIdsPlugin: () => __webpack_require__(/*! ./HashedModuleIdsPlugin */ "./node_modules/webpack/lib/HashedModuleIdsPlugin.js"),
	HotModuleReplacementPlugin: () => __webpack_require__(/*! ./HotModuleReplacementPlugin */ "./node_modules/webpack/lib/HotModuleReplacementPlugin.js"),
	IgnorePlugin: () => __webpack_require__(/*! ./IgnorePlugin */ "./node_modules/webpack/lib/IgnorePlugin.js"),
	LibraryTemplatePlugin: () => __webpack_require__(/*! ./LibraryTemplatePlugin */ "./node_modules/webpack/lib/LibraryTemplatePlugin.js"),
	LoaderOptionsPlugin: () => __webpack_require__(/*! ./LoaderOptionsPlugin */ "./node_modules/webpack/lib/LoaderOptionsPlugin.js"),
	LoaderTargetPlugin: () => __webpack_require__(/*! ./LoaderTargetPlugin */ "./node_modules/webpack/lib/LoaderTargetPlugin.js"),
	MemoryOutputFileSystem: () => __webpack_require__(/*! ./MemoryOutputFileSystem */ "./node_modules/webpack/lib/MemoryOutputFileSystem.js"),
	Module: () => __webpack_require__(/*! ./Module */ "./node_modules/webpack/lib/Module.js"),
	ModuleFilenameHelpers: () => __webpack_require__(/*! ./ModuleFilenameHelpers */ "./node_modules/webpack/lib/ModuleFilenameHelpers.js"),
	NamedChunksPlugin: () => __webpack_require__(/*! ./NamedChunksPlugin */ "./node_modules/webpack/lib/NamedChunksPlugin.js"),
	NamedModulesPlugin: () => __webpack_require__(/*! ./NamedModulesPlugin */ "./node_modules/webpack/lib/NamedModulesPlugin.js"),
	NoEmitOnErrorsPlugin: () => __webpack_require__(/*! ./NoEmitOnErrorsPlugin */ "./node_modules/webpack/lib/NoEmitOnErrorsPlugin.js"),
	NormalModuleReplacementPlugin: () =>
		__webpack_require__(/*! ./NormalModuleReplacementPlugin */ "./node_modules/webpack/lib/NormalModuleReplacementPlugin.js"),
	PrefetchPlugin: () => __webpack_require__(/*! ./PrefetchPlugin */ "./node_modules/webpack/lib/PrefetchPlugin.js"),
	ProgressPlugin: () => __webpack_require__(/*! ./ProgressPlugin */ "./node_modules/webpack/lib/ProgressPlugin.js"),
	ProvidePlugin: () => __webpack_require__(/*! ./ProvidePlugin */ "./node_modules/webpack/lib/ProvidePlugin.js"),
	SetVarMainTemplatePlugin: () => __webpack_require__(/*! ./SetVarMainTemplatePlugin */ "./node_modules/webpack/lib/SetVarMainTemplatePlugin.js"),
	SingleEntryPlugin: () => __webpack_require__(/*! ./SingleEntryPlugin */ "./node_modules/webpack/lib/SingleEntryPlugin.js"),
	SourceMapDevToolPlugin: () => __webpack_require__(/*! ./SourceMapDevToolPlugin */ "./node_modules/webpack/lib/SourceMapDevToolPlugin.js"),
	Stats: () => __webpack_require__(/*! ./Stats */ "./node_modules/webpack/lib/Stats.js"),
	Template: () => __webpack_require__(/*! ./Template */ "./node_modules/webpack/lib/Template.js"),
	UmdMainTemplatePlugin: () => __webpack_require__(/*! ./UmdMainTemplatePlugin */ "./node_modules/webpack/lib/UmdMainTemplatePlugin.js"),
	WatchIgnorePlugin: () => __webpack_require__(/*! ./WatchIgnorePlugin */ "./node_modules/webpack/lib/WatchIgnorePlugin.js")
});
exportPlugins((exports.dependencies = {}), {
	DependencyReference: () => __webpack_require__(/*! ./dependencies/DependencyReference */ "./node_modules/webpack/lib/dependencies/DependencyReference.js")
});
exportPlugins((exports.optimize = {}), {
	AggressiveMergingPlugin: () => __webpack_require__(/*! ./optimize/AggressiveMergingPlugin */ "./node_modules/webpack/lib/optimize/AggressiveMergingPlugin.js"),
	AggressiveSplittingPlugin: () =>
		__webpack_require__(/*! ./optimize/AggressiveSplittingPlugin */ "./node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"),
	ChunkModuleIdRangePlugin: () =>
		__webpack_require__(/*! ./optimize/ChunkModuleIdRangePlugin */ "./node_modules/webpack/lib/optimize/ChunkModuleIdRangePlugin.js"),
	LimitChunkCountPlugin: () => __webpack_require__(/*! ./optimize/LimitChunkCountPlugin */ "./node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"),
	MinChunkSizePlugin: () => __webpack_require__(/*! ./optimize/MinChunkSizePlugin */ "./node_modules/webpack/lib/optimize/MinChunkSizePlugin.js"),
	ModuleConcatenationPlugin: () =>
		__webpack_require__(/*! ./optimize/ModuleConcatenationPlugin */ "./node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.js"),
	OccurrenceOrderPlugin: () => __webpack_require__(/*! ./optimize/OccurrenceOrderPlugin */ "./node_modules/webpack/lib/optimize/OccurrenceOrderPlugin.js"),
	OccurrenceModuleOrderPlugin: () =>
		__webpack_require__(/*! ./optimize/OccurrenceModuleOrderPlugin */ "./node_modules/webpack/lib/optimize/OccurrenceModuleOrderPlugin.js"),
	OccurrenceChunkOrderPlugin: () =>
		__webpack_require__(/*! ./optimize/OccurrenceChunkOrderPlugin */ "./node_modules/webpack/lib/optimize/OccurrenceChunkOrderPlugin.js"),
	RuntimeChunkPlugin: () => __webpack_require__(/*! ./optimize/RuntimeChunkPlugin */ "./node_modules/webpack/lib/optimize/RuntimeChunkPlugin.js"),
	SideEffectsFlagPlugin: () => __webpack_require__(/*! ./optimize/SideEffectsFlagPlugin */ "./node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"),
	SplitChunksPlugin: () => __webpack_require__(/*! ./optimize/SplitChunksPlugin */ "./node_modules/webpack/lib/optimize/SplitChunksPlugin.js")
});
exportPlugins((exports.web = {}), {
	FetchCompileWasmTemplatePlugin: () =>
		__webpack_require__(/*! ./web/FetchCompileWasmTemplatePlugin */ "./node_modules/webpack/lib/web/FetchCompileWasmTemplatePlugin.js"),
	JsonpTemplatePlugin: () => __webpack_require__(/*! ./web/JsonpTemplatePlugin */ "./node_modules/webpack/lib/web/JsonpTemplatePlugin.js")
});
exportPlugins((exports.webworker = {}), {
	WebWorkerTemplatePlugin: () => __webpack_require__(/*! ./webworker/WebWorkerTemplatePlugin */ "./node_modules/webpack/lib/webworker/WebWorkerTemplatePlugin.js")
});
exportPlugins((exports.node = {}), {
	NodeTemplatePlugin: () => __webpack_require__(/*! ./node/NodeTemplatePlugin */ "./node_modules/webpack/lib/node/NodeTemplatePlugin.js"),
	ReadFileCompileWasmTemplatePlugin: () =>
		__webpack_require__(/*! ./node/ReadFileCompileWasmTemplatePlugin */ "./node_modules/webpack/lib/node/ReadFileCompileWasmTemplatePlugin.js")
});
exportPlugins((exports.debug = {}), {
	ProfilingPlugin: () => __webpack_require__(/*! ./debug/ProfilingPlugin */ "./node_modules/webpack/lib/debug/ProfilingPlugin.js")
});
exportPlugins((exports.util = {}), {
	createHash: () => __webpack_require__(/*! ./util/createHash */ "./node_modules/webpack/lib/util/createHash.js")
});

const defineMissingPluginError = (namespace, pluginName, errorMessage) => {
	Object.defineProperty(namespace, pluginName, {
		configurable: false,
		enumerable: true,
		get() {
			throw new RemovedPluginError(errorMessage);
		}
	});
};

// TODO remove in webpack 5
defineMissingPluginError(
	exports.optimize,
	"UglifyJsPlugin",
	"webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead."
);

// TODO remove in webpack 5
defineMissingPluginError(
	exports.optimize,
	"CommonsChunkPlugin",
	"webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead."
);


/***/ }),

/***/ "./node_modules/webpack/lib/webworker/WebWorkerChunkTemplatePlugin.js":
/*!***************************************************************!*\
  !*** (webpack)/lib/webworker/WebWorkerChunkTemplatePlugin.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

class WebWorkerChunkTemplatePlugin {
	apply(chunkTemplate) {
		chunkTemplate.hooks.render.tap(
			"WebWorkerChunkTemplatePlugin",
			(modules, chunk) => {
				const chunkCallbackName = chunkTemplate.outputOptions.chunkCallbackName;
				const globalObject = chunkTemplate.outputOptions.globalObject;
				const source = new ConcatSource();
				source.add(
					`${globalObject}[${JSON.stringify(
						chunkCallbackName
					)}](${JSON.stringify(chunk.ids)},`
				);
				source.add(modules);
				source.add(")");
				return source;
			}
		);
		chunkTemplate.hooks.hash.tap("WebWorkerChunkTemplatePlugin", hash => {
			hash.update("webworker");
			hash.update("3");
			hash.update(`${chunkTemplate.outputOptions.chunkCallbackName}`);
			hash.update(`${chunkTemplate.outputOptions.globalObject}`);
		});
	}
}
module.exports = WebWorkerChunkTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/webworker/WebWorkerHotUpdateChunkTemplatePlugin.js":
/*!************************************************************************!*\
  !*** (webpack)/lib/webworker/WebWorkerHotUpdateChunkTemplatePlugin.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const { ConcatSource } = __webpack_require__(/*! webpack-sources */ "./node_modules/webpack-sources/lib/index.js");

class WebWorkerHotUpdateChunkTemplatePlugin {
	apply(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.hooks.render.tap(
			"WebWorkerHotUpdateChunkTemplatePlugin",
			(modulesSource, modules, removedModules, hash, id) => {
				const hotUpdateFunction =
					hotUpdateChunkTemplate.outputOptions.hotUpdateFunction;
				const globalObject = hotUpdateChunkTemplate.outputOptions.globalObject;
				const source = new ConcatSource();
				source.add(
					`${globalObject}[${JSON.stringify(
						hotUpdateFunction
					)}](${JSON.stringify(id)},`
				);
				source.add(modulesSource);
				source.add(")");
				return source;
			}
		);
		hotUpdateChunkTemplate.hooks.hash.tap(
			"WebWorkerHotUpdateChunkTemplatePlugin",
			hash => {
				hash.update("WebWorkerHotUpdateChunkTemplatePlugin");
				hash.update("3");
				hash.update(
					hotUpdateChunkTemplate.outputOptions.hotUpdateFunction + ""
				);
				hash.update(hotUpdateChunkTemplate.outputOptions.globalObject + "");
			}
		);
	}
}
module.exports = WebWorkerHotUpdateChunkTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/webworker/WebWorkerMainTemplate.runtime.js":
/*!****************************************************************!*\
  !*** (webpack)/lib/webworker/WebWorkerMainTemplate.runtime.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*globals installedChunks hotAddUpdateChunk parentHotUpdateCallback importScripts XMLHttpRequest $require$ $hotChunkFilename$ $hotMainFilename$ */
module.exports = function() {
	// eslint-disable-next-line no-unused-vars
	function webpackHotUpdateCallback(chunkId, moreModules) {
		hotAddUpdateChunk(chunkId, moreModules);
		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
	} //$semicolon

	// eslint-disable-next-line no-unused-vars
	function hotDownloadUpdateChunk(chunkId) {
		importScripts($require$.p + $hotChunkFilename$);
	}

	// eslint-disable-next-line no-unused-vars
	function hotDownloadManifest(requestTimeout) {
		requestTimeout = requestTimeout || 10000;
		return new Promise(function(resolve, reject) {
			if (typeof XMLHttpRequest === "undefined") {
				return reject(new Error("No browser support"));
			}
			try {
				var request = new XMLHttpRequest();
				var requestPath = $require$.p + $hotMainFilename$;
				request.open("GET", requestPath, true);
				request.timeout = requestTimeout;
				request.send(null);
			} catch (err) {
				return reject(err);
			}
			request.onreadystatechange = function() {
				if (request.readyState !== 4) return;
				if (request.status === 0) {
					// timeout
					reject(
						new Error("Manifest request to " + requestPath + " timed out.")
					);
				} else if (request.status === 404) {
					// no update available
					resolve();
				} else if (request.status !== 200 && request.status !== 304) {
					// other failure
					reject(new Error("Manifest request to " + requestPath + " failed."));
				} else {
					// success
					try {
						var update = JSON.parse(request.responseText);
					} catch (e) {
						reject(e);
						return;
					}
					resolve(update);
				}
			};
		});
	}

	//eslint-disable-next-line no-unused-vars
	function hotDisposeChunk(chunkId) {
		delete installedChunks[chunkId];
	}
};


/***/ }),

/***/ "./node_modules/webpack/lib/webworker/WebWorkerMainTemplatePlugin.js":
/*!**************************************************************!*\
  !*** (webpack)/lib/webworker/WebWorkerMainTemplatePlugin.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Template = __webpack_require__(/*! ../Template */ "./node_modules/webpack/lib/Template.js");

class WebWorkerMainTemplatePlugin {
	apply(mainTemplate) {
		const needChunkOnDemandLoadingCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.getNumberOfChildren() > 0) return true;
			}
			return false;
		};
		mainTemplate.hooks.localVars.tap(
			"WebWorkerMainTemplatePlugin",
			(source, chunk) => {
				if (needChunkOnDemandLoadingCode(chunk)) {
					return Template.asString([
						source,
						"",
						"// object to store loaded chunks",
						'// "1" means "already loaded"',
						"var installedChunks = {",
						Template.indent(
							chunk.ids.map(id => `${JSON.stringify(id)}: 1`).join(",\n")
						),
						"};"
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			"WebWorkerMainTemplatePlugin",
			(_, chunk, hash) => {
				const chunkFilename = mainTemplate.outputOptions.chunkFilename;
				const chunkMaps = chunk.getChunkMaps();
				return Template.asString([
					"promises.push(Promise.resolve().then(function() {",
					Template.indent([
						'// "1" is the signal for "already loaded"',
						"if(!installedChunks[chunkId]) {",
						Template.indent([
							"importScripts(" +
								mainTemplate.getAssetPath(JSON.stringify(chunkFilename), {
									hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
									hashWithLength: length =>
										`" + ${mainTemplate.renderCurrentHashCode(
											hash,
											length
										)} + "`,
									chunk: {
										id: '" + chunkId + "',
										hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
										hashWithLength(length) {
											const shortChunkHashMap = Object.create(null);
											for (const chunkId of Object.keys(chunkMaps.hash)) {
												if (typeof chunkMaps.hash[chunkId] === "string") {
													shortChunkHashMap[chunkId] = chunkMaps.hash[
														chunkId
													].substr(0, length);
												}
											}
											return `" + ${JSON.stringify(
												shortChunkHashMap
											)}[chunkId] + "`;
										},
										contentHash: {
											javascript: `" + ${JSON.stringify(
												chunkMaps.contentHash.javascript
											)}[chunkId] + "`
										},
										contentHashWithLength: {
											javascript: length => {
												const shortContentHashMap = {};
												const contentHash = chunkMaps.contentHash.javascript;
												for (const chunkId of Object.keys(contentHash)) {
													if (typeof contentHash[chunkId] === "string") {
														shortContentHashMap[chunkId] = contentHash[
															chunkId
														].substr(0, length);
													}
												}
												return `" + ${JSON.stringify(
													shortContentHashMap
												)}[chunkId] + "`;
											}
										},
										name: `" + (${JSON.stringify(
											chunkMaps.name
										)}[chunkId]||chunkId) + "`
									},
									contentHashType: "javascript"
								}) +
								");"
						]),
						"}"
					]),
					"}));"
				]);
			}
		);
		mainTemplate.hooks.bootstrap.tap(
			"WebWorkerMainTemplatePlugin",
			(source, chunk, hash) => {
				if (needChunkOnDemandLoadingCode(chunk)) {
					const chunkCallbackName =
						mainTemplate.outputOptions.chunkCallbackName;
					const globalObject = mainTemplate.outputOptions.globalObject;
					return Template.asString([
						source,
						`${globalObject}[${JSON.stringify(
							chunkCallbackName
						)}] = function webpackChunkCallback(chunkIds, moreModules) {`,
						Template.indent([
							"for(var moduleId in moreModules) {",
							Template.indent(
								mainTemplate.renderAddModule(
									hash,
									chunk,
									"moduleId",
									"moreModules[moduleId]"
								)
							),
							"}",
							"while(chunkIds.length)",
							Template.indent("installedChunks[chunkIds.pop()] = 1;")
						]),
						"};"
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.hotBootstrap.tap(
			"WebWorkerMainTemplatePlugin",
			(source, chunk, hash) => {
				const hotUpdateChunkFilename =
					mainTemplate.outputOptions.hotUpdateChunkFilename;
				const hotUpdateMainFilename =
					mainTemplate.outputOptions.hotUpdateMainFilename;
				const hotUpdateFunction = mainTemplate.outputOptions.hotUpdateFunction;
				const globalObject = mainTemplate.outputOptions.globalObject;
				const currentHotUpdateChunkFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateChunkFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
						chunk: {
							id: '" + chunkId + "'
						}
					}
				);
				const currentHotUpdateMainFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateMainFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
					}
				);

				return (
					source +
					"\n" +
					`var parentHotUpdateCallback = ${globalObject}[${JSON.stringify(
						hotUpdateFunction
					)}];\n` +
					`${globalObject}[${JSON.stringify(hotUpdateFunction)}] = ` +
					Template.getFunctionContent(
						__webpack_require__(/*! ./WebWorkerMainTemplate.runtime */ "./node_modules/webpack/lib/webworker/WebWorkerMainTemplate.runtime.js")
					)
						.replace(/\/\/\$semicolon/g, ";")
						.replace(/\$require\$/g, mainTemplate.requireFn)
						.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
						.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename)
						.replace(/\$hash\$/g, JSON.stringify(hash))
				);
			}
		);
		mainTemplate.hooks.hash.tap("WebWorkerMainTemplatePlugin", hash => {
			hash.update("webworker");
			hash.update("4");
		});
	}
}
module.exports = WebWorkerMainTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/lib/webworker/WebWorkerTemplatePlugin.js":
/*!**********************************************************!*\
  !*** (webpack)/lib/webworker/WebWorkerTemplatePlugin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const WebWorkerMainTemplatePlugin = __webpack_require__(/*! ./WebWorkerMainTemplatePlugin */ "./node_modules/webpack/lib/webworker/WebWorkerMainTemplatePlugin.js");
const WebWorkerChunkTemplatePlugin = __webpack_require__(/*! ./WebWorkerChunkTemplatePlugin */ "./node_modules/webpack/lib/webworker/WebWorkerChunkTemplatePlugin.js");
const WebWorkerHotUpdateChunkTemplatePlugin = __webpack_require__(/*! ./WebWorkerHotUpdateChunkTemplatePlugin */ "./node_modules/webpack/lib/webworker/WebWorkerHotUpdateChunkTemplatePlugin.js");

class WebWorkerTemplatePlugin {
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"WebWorkerTemplatePlugin",
			compilation => {
				new WebWorkerMainTemplatePlugin().apply(compilation.mainTemplate);
				new WebWorkerChunkTemplatePlugin().apply(compilation.chunkTemplate);
				new WebWorkerHotUpdateChunkTemplatePlugin().apply(
					compilation.hotUpdateChunkTemplate
				);
			}
		);
	}
}
module.exports = WebWorkerTemplatePlugin;


/***/ }),

/***/ "./node_modules/webpack/node_modules/schema-utils/src/ValidationError.js":
/*!******************************************************************!*\
  !*** (webpack)/node_modules/schema-utils/src/ValidationError.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable
  strict
*/



class ValidationError extends Error {
  constructor(errors, name) {
    super();

    this.name = 'ValidationError';

    this.message = `${name || ''} Invalid Options\n\n`;

    errors.forEach((err) => {
      this.message += `options${err.dataPath} ${err.message}\n`;
    });

    this.errors = errors;

    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = ValidationError;


/***/ }),

/***/ "./node_modules/webpack/node_modules/schema-utils/src/index.js":
/*!********************************************************!*\
  !*** (webpack)/node_modules/schema-utils/src/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable
  strict
*/



const validateOptions = __webpack_require__(/*! ./validateOptions */ "./node_modules/webpack/node_modules/schema-utils/src/validateOptions.js");

module.exports = validateOptions;


/***/ }),

/***/ "./node_modules/webpack/node_modules/schema-utils/src/validateOptions.js":
/*!******************************************************************!*\
  !*** (webpack)/node_modules/schema-utils/src/validateOptions.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable
  strict,
  no-param-reassign
*/



const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");

const Ajv = __webpack_require__(/*! ajv */ "ajv");
const ajvKeywords = __webpack_require__(/*! ajv-keywords */ "ajv-keywords");

const ValidationError = __webpack_require__(/*! ./ValidationError */ "./node_modules/webpack/node_modules/schema-utils/src/ValidationError.js");

const ajv = new Ajv({
  allErrors: true,
  useDefaults: true,
  errorDataPath: 'property',
});

ajvKeywords(ajv, ['instanceof', 'typeof']);

const validateOptions = (schema, options, name) => {
  if (typeof schema === 'string') {
    schema = fs.readFileSync(path.resolve(schema), 'utf8');
    schema = JSON.parse(schema);
  }

  if (!ajv.validate(schema, options)) {
    throw new ValidationError(ajv.errors, name);
  }

  return true;
};

module.exports = validateOptions;


/***/ }),

/***/ "./node_modules/webpack/package.json":
/*!******************************!*\
  !*** (webpack)/package.json ***!
  \******************************/
/*! exports provided: name, version, author, description, license, dependencies, devDependencies, engines, repository, homepage, main, web, bin, files, scripts, husky, lint-staged, jest, default */
/***/ (function(module) {

module.exports = {"name":"webpack","version":"4.29.0","author":"Tobias Koppers @sokra","description":"Packs CommonJs/AMD modules for the browser. Allows to split your codebase into multiple bundles, which can be loaded on demand. Support loaders to preprocess files, i.e. json, jsx, es7, css, less, ... and your custom stuff.","license":"MIT","dependencies":{"@webassemblyjs/ast":"1.7.11","@webassemblyjs/helper-module-context":"1.7.11","@webassemblyjs/wasm-edit":"1.7.11","@webassemblyjs/wasm-parser":"1.7.11","acorn":"^6.0.5","acorn-dynamic-import":"^4.0.0","ajv":"^6.1.0","ajv-keywords":"^3.1.0","chrome-trace-event":"^1.0.0","enhanced-resolve":"^4.1.0","eslint-scope":"^4.0.0","json-parse-better-errors":"^1.0.2","loader-runner":"^2.3.0","loader-utils":"^1.1.0","memory-fs":"~0.4.1","micromatch":"^3.1.8","mkdirp":"~0.5.0","neo-async":"^2.5.0","node-libs-browser":"^2.0.0","schema-utils":"^0.4.4","tapable":"^1.1.0","terser-webpack-plugin":"^1.1.0","watchpack":"^1.5.0","webpack-sources":"^1.3.0"},"devDependencies":{"@types/node":"^9.6.4","@types/tapable":"^1.0.1","@types/webpack-sources":"^0.1.4","benchmark":"^2.1.1","bundle-loader":"~0.5.0","codacy-coverage":"^2.0.1","coffee-loader":"^0.9.0","coffeescript":"^1.10.0","coveralls":"^3.0.2","css-loader":"^0.28.3","es6-promise-polyfill":"^1.1.1","eslint":"^5.8.0","eslint-config-prettier":"^3.1.0","eslint-plugin-jest":"^21.26.2","eslint-plugin-node":"^8.0.0","eslint-plugin-prettier":"^3.0.0","express":"~4.13.1","file-loader":"^1.1.6","glob":"^7.1.3","husky":"^1.1.3","i18n-webpack-plugin":"^1.0.0","istanbul":"^0.4.5","jade":"^1.11.0","jade-loader":"~0.8.0","jest":"24.0.0-alpha.1","jest-junit":"^5.2.0","json-loader":"^0.5.7","json-schema-to-typescript":"^6.0.1","less":"^2.5.1","less-loader":"^4.0.3","lint-staged":"^8.0.4","lodash":"^4.17.4","prettier":"^1.14.3","pug":"^2.0.3","pug-loader":"^2.4.0","raw-loader":"~0.5.0","react":"^15.2.1","react-dom":"^15.2.1","rimraf":"^2.6.2","script-loader":"~0.7.0","simple-git":"^1.65.0","style-loader":"^0.19.1","typescript":"^3.0.0-rc","url-loader":"^0.6.2","val-loader":"^1.0.2","vm-browserify":"~0.0.0","wast-loader":"^1.5.5","webpack-dev-middleware":"^1.9.0","worker-loader":"^1.1.1","xxhashjs":"^0.2.1"},"engines":{"node":">=6.11.5"},"repository":{"type":"git","url":"https://github.com/webpack/webpack.git"},"homepage":"https://github.com/webpack/webpack","main":"lib/webpack.js","web":"lib/webpack.web.js","bin":"./bin/webpack.js","files":["lib/","bin/","buildin/","declarations/","hot/","web_modules/","schemas/","SECURITY.md"],"scripts":{"setup":"node ./setup/setup.js","test":"node --max-old-space-size=4096 --trace-deprecation node_modules/jest-cli/bin/jest","test:update-snapshots":"yarn jest -u","test:integration":"node --max-old-space-size=4096 --trace-deprecation node_modules/jest-cli/bin/jest --testMatch \"<rootDir>/test/*.test.js\"","test:basic":"node --max-old-space-size=4096 --trace-deprecation node_modules/jest-cli/bin/jest --testMatch \"<rootDir>/test/{TestCasesNormal,StatsTestCases,ConfigTestCases}.test.js\"","test:unit":"node --max-old-space-size=4096 --trace-deprecation node_modules/jest-cli/bin/jest --testMatch \"<rootDir>/test/*.unittest.js\"","travis:integration":"yarn cover:init && yarn cover:integration --ci $JEST","travis:basic":"yarn test:basic --ci $JEST","travis:lint-unit":"yarn lint && yarn cover:init && yarn cover:unit --ci $JEST","travis:benchmark":"yarn benchmark --ci","appveyor:integration":"yarn cover:init && yarn cover:integration --ci %JEST%","appveyor:unit":"yarn cover:init && yarn cover:unit --ci %JEST%","appveyor:benchmark":"yarn benchmark --ci","build:examples":"cd examples && node buildAll.js","pretest":"yarn lint","prelint":"yarn setup","lint":"yarn code-lint && yarn schema-lint && yarn type-lint && yarn special-lint","code-lint":"eslint --cache \"{setup,lib,bin,hot,buildin,benchmark,tooling,schemas}/**/*.js\" \"test/*.js\" \"test/{configCases,watchCases,statsCases,hotCases}/**/webpack.config.js\" \"examples/**/webpack.config.js\"","type-lint":"tsc --pretty","special-lint":"node tooling/inherit-types && node tooling/format-schemas && node tooling/compile-to-definitions","special-lint-fix":"node tooling/inherit-types --write --override && node tooling/format-schemas --write && node tooling/compile-to-definitions --write","fix":"yarn code-lint --fix && yarn special-lint-fix","pretty":"prettier --loglevel warn --write \"*.{ts,js,json,yml,yaml}\" \"{setup,lib,bin,hot,buildin,benchmark,tooling,schemas}/**/*.{js,json}\" \"test/*.js\" \"test/{configCases,watchCases,statsCases,hotCases}/**/webpack.config.js\" \"examples/**/webpack.config.js\"","schema-lint":"node --max-old-space-size=4096 node_modules/jest-cli/bin/jest --testMatch \"<rootDir>/test/*.lint.js\" --no-verbose","benchmark":"node --max-old-space-size=4096 --trace-deprecation node_modules/jest-cli/bin/jest --testMatch \"<rootDir>/test/*.benchmark.js\" --runInBand","cover":"yarn cover:init && yarn cover:all && yarn cover:report","cover:init":"rimraf coverage","cover:all":"node --max-old-space-size=4096 node_modules/jest-cli/bin/jest --coverage","cover:integration":"node --max-old-space-size=4096 node_modules/jest-cli/bin/jest --testMatch \"<rootDir>/test/*.test.js\" --coverage","cover:unit":"node --max-old-space-size=4096 node_modules/jest-cli/bin/jest --testMatch \"<rootDir>/test/*.unittest.js\" --coverage","cover:report":"istanbul report"},"husky":{"hooks":{"pre-commit":"lint-staged"}},"lint-staged":{"*.js|{lib,setup,bin,hot,buildin,tooling,schemas}/**/*.js|test/*.js|{test,examples}/**/webpack.config.js}":["eslint --cache"]},"jest":{"forceExit":true,"setupFilesAfterEnv":["<rootDir>/test/setupTestFramework.js"],"testMatch":["<rootDir>/test/*.test.js","<rootDir>/test/*.unittest.js"],"watchPathIgnorePatterns":["<rootDir>/.git","<rootDir>/node_modules","<rootDir>/test/js","<rootDir>/test/browsertest/js","<rootDir>/test/fixtures/temp-cache-fixture","<rootDir>/test/fixtures/temp-","<rootDir>/benchmark","<rootDir>/examples/*/dist","<rootDir>/coverage","<rootDir>/.eslintcache"],"modulePathIgnorePatterns":["<rootDir>/.git","<rootDir>/node_modules/webpack/node_modules","<rootDir>/test/js","<rootDir>/test/browsertest/js","<rootDir>/test/fixtures/temp-cache-fixture","<rootDir>/test/fixtures/temp-","<rootDir>/benchmark","<rootDir>/examples/*/dist","<rootDir>/coverage","<rootDir>/.eslintcache"],"transformIgnorePatterns":["<rootDir>"],"coverageDirectory":"<rootDir>/coverage","coveragePathIgnorePatterns":["\\.runtime\\.js$","<rootDir>/test","<rootDir>/schemas","<rootDir>/node_modules"],"testEnvironment":"node","coverageReporters":["json"]}};

/***/ }),

/***/ "./node_modules/webpack/schemas/WebpackOptions.json":
/*!*********************************************!*\
  !*** (webpack)/schemas/WebpackOptions.json ***!
  \*********************************************/
/*! exports provided: definitions, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"definitions":{"ArrayOfStringOrStringArrayValues":{"type":"array","items":{"description":"string or array of strings","anyOf":[{"type":"string","minLength":1},{"type":"array","items":{"description":"A non-empty string","type":"string","minLength":1}}]}},"ArrayOfStringValues":{"type":"array","items":{"description":"A non-empty string","type":"string","minLength":1}},"Entry":{"anyOf":[{"$ref":"#/definitions/EntryDynamic"},{"$ref":"#/definitions/EntryStatic"}]},"EntryDynamic":{"description":"A Function returning an entry object, an entry string, an entry array or a promise to these things.","instanceof":"Function","tsType":"(() => EntryStatic | Promise<EntryStatic>)"},"EntryItem":{"oneOf":[{"description":"An entry point without name. The string is resolved to a module which is loaded upon startup.","type":"string","minLength":1},{"description":"An entry point without name. All modules are loaded upon startup. The last one is exported.","anyOf":[{"$ref":"#/definitions/NonEmptyArrayOfUniqueStringValues"}]}]},"EntryObject":{"description":"Multiple entry bundles are created. The key is the chunk name. The value can be a string or an array.","type":"object","additionalProperties":{"description":"An entry point with name","oneOf":[{"description":"The string is resolved to a module which is loaded upon startup.","type":"string","minLength":1},{"description":"All modules are loaded upon startup. The last one is exported.","anyOf":[{"$ref":"#/definitions/NonEmptyArrayOfUniqueStringValues"}]}]},"minProperties":1},"EntryStatic":{"oneOf":[{"$ref":"#/definitions/EntryObject"},{"$ref":"#/definitions/EntryItem"}]},"ExternalItem":{"anyOf":[{"description":"An exact matched dependency becomes external. The same string is used as external dependency.","type":"string"},{"description":"If an dependency matches exactly a property of the object, the property value is used as dependency.","type":"object","additionalProperties":{"description":"The dependency used for the external","anyOf":[{"type":"string"},{"type":"object"},{"$ref":"#/definitions/ArrayOfStringValues"},{"type":"boolean"}]}},{"description":"Every matched dependency becomes external.","instanceof":"RegExp","tsType":"RegExp"}]},"Externals":{"anyOf":[{"description":"`function(context, request, callback(err, result))` The function is called on each dependency.","instanceof":"Function","tsType":"((context: string, request: string, callback: (err?: Error, result?: string) => void) => void)"},{"$ref":"#/definitions/ExternalItem"},{"type":"array","items":{"description":"External configuration","anyOf":[{"description":"`function(context, request, callback(err, result))` The function is called on each dependency.","instanceof":"Function","tsType":"((context: string, request: string, callback: (err?: Error, result?: string) => void) => void)"},{"$ref":"#/definitions/ExternalItem"}]}}]},"FilterItemTypes":{"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"FilterTypes":{"anyOf":[{"$ref":"#/definitions/FilterItemTypes"},{"type":"array","items":{"description":"Rule to filter","anyOf":[{"$ref":"#/definitions/FilterItemTypes"}]}}]},"LibraryCustomUmdObject":{"type":"object","additionalProperties":false,"properties":{"amd":{"description":"Name of the exposed AMD library in the UMD","type":"string"},"commonjs":{"description":"Name of the exposed commonjs export in the UMD","type":"string"},"root":{"description":"Name of the property exposed globally by a UMD library","anyOf":[{"type":"string"},{"$ref":"#/definitions/ArrayOfStringValues"}]}}},"ModuleOptions":{"type":"object","additionalProperties":false,"properties":{"defaultRules":{"description":"An array of rules applied by default for modules.","anyOf":[{"$ref":"#/definitions/RuleSetRules"}]},"exprContextCritical":{"description":"Enable warnings for full dynamic dependencies","type":"boolean"},"exprContextRecursive":{"description":"Enable recursive directory lookup for full dynamic dependencies","type":"boolean"},"exprContextRegExp":{"description":"Sets the default regular expression for full dynamic dependencies","anyOf":[{"type":"boolean"},{"instanceof":"RegExp","tsType":"RegExp"}]},"exprContextRequest":{"description":"Set the default request for full dynamic dependencies","type":"string"},"noParse":{"description":"Don't parse files matching. It's matched against the full resolved request.","anyOf":[{"type":"array","items":{"description":"A regular expression, when matched the module is not parsed","instanceof":"RegExp","tsType":"RegExp"},"minItems":1},{"instanceof":"RegExp","tsType":"RegExp"},{"instanceof":"Function","tsType":"Function"},{"type":"array","items":{"description":"An absolute path, when the module starts with this path it is not parsed","type":"string","absolutePath":true},"minItems":1},{"type":"string","absolutePath":true}]},"rules":{"description":"An array of rules applied for modules.","anyOf":[{"$ref":"#/definitions/RuleSetRules"}]},"strictExportPresence":{"description":"Emit errors instead of warnings when imported names don't exist in imported module","type":"boolean"},"strictThisContextOnImports":{"description":"Handle the this context correctly according to the spec for namespace objects","type":"boolean"},"unknownContextCritical":{"description":"Enable warnings when using the require function in a not statically analyse-able way","type":"boolean"},"unknownContextRecursive":{"description":"Enable recursive directory lookup when using the require function in a not statically analyse-able way","type":"boolean"},"unknownContextRegExp":{"description":"Sets the regular expression when using the require function in a not statically analyse-able way","anyOf":[{"type":"boolean"},{"instanceof":"RegExp","tsType":"RegExp"}]},"unknownContextRequest":{"description":"Sets the request when using the require function in a not statically analyse-able way","type":"string"},"unsafeCache":{"description":"Cache the resolving of module requests","anyOf":[{"type":"boolean"},{"instanceof":"Function","tsType":"Function"}]},"wrappedContextCritical":{"description":"Enable warnings for partial dynamic dependencies","type":"boolean"},"wrappedContextRecursive":{"description":"Enable recursive directory lookup for partial dynamic dependencies","type":"boolean"},"wrappedContextRegExp":{"description":"Set the inner regular expression for partial dynamic dependencies","instanceof":"RegExp","tsType":"RegExp"}}},"NodeOptions":{"type":"object","additionalProperties":{"description":"Include a polyfill for the node.js module","enum":[false,true,"mock","empty"]},"properties":{"Buffer":{"description":"Include a polyfill for the 'Buffer' variable","enum":[false,true,"mock"]},"__dirname":{"description":"Include a polyfill for the '__dirname' variable","enum":[false,true,"mock"]},"__filename":{"description":"Include a polyfill for the '__filename' variable","enum":[false,true,"mock"]},"console":{"description":"Include a polyfill for the 'console' variable","enum":[false,true,"mock"]},"global":{"description":"Include a polyfill for the 'global' variable","type":"boolean"},"process":{"description":"Include a polyfill for the 'process' variable","enum":[false,true,"mock"]}}},"NonEmptyArrayOfUniqueStringValues":{"type":"array","items":{"description":"A non-empty string","type":"string","minLength":1},"minItems":1,"uniqueItems":true},"OptimizationOptions":{"description":"Enables/Disables integrated optimizations","type":"object","additionalProperties":false,"properties":{"checkWasmTypes":{"description":"Check for incompatible wasm types when importing/exporting from/to ESM","type":"boolean"},"chunkIds":{"description":"Define the algorithm to choose chunk ids (named: readable ids for better debugging, size: numeric ids focused on minimal initial download size, total-size: numeric ids focused on minimal total download size, false: no algorithm used, as custom one can be provided via plugin)","enum":["natural","named","size","total-size",false]},"concatenateModules":{"description":"Concatenate modules when possible to generate less modules, more efficient code and enable more optimizations by the minimizer","type":"boolean"},"flagIncludedChunks":{"description":"Also flag chunks as loaded which contain a subset of the modules","type":"boolean"},"hashedModuleIds":{"description":"Use hashed module id instead module identifiers for better long term caching (deprecated, used moduleIds: hashed instead)","type":"boolean"},"mangleWasmImports":{"description":"Reduce size of WASM by changing imports to shorter strings.","type":"boolean"},"mergeDuplicateChunks":{"description":"Merge chunks which contain the same modules","type":"boolean"},"minimize":{"description":"Enable minimizing the output. Uses optimization.minimizer.","type":"boolean"},"minimizer":{"description":"Minimizer(s) to use for minimizing the output","type":"array","items":{"description":"Plugin of type object or instanceof Function","anyOf":[{"$ref":"#/definitions/WebpackPluginInstance"},{"$ref":"#/definitions/WebpackPluginFunction"}]}},"moduleIds":{"description":"Define the algorithm to choose module ids (natural: numeric ids in order of usage, named: readable ids for better debugging, hashed: short hashes as ids for better long term caching, size: numeric ids focused on minimal initial download size, total-size: numeric ids focused on minimal total download size, false: no algorithm used, as custom one can be provided via plugin)","enum":["natural","named","hashed","size","total-size",false]},"namedChunks":{"description":"Use readable chunk identifiers for better debugging (deprecated, used chunkIds: named instead)","type":"boolean"},"namedModules":{"description":"Use readable module identifiers for better debugging (deprecated, used moduleIds: named instead)","type":"boolean"},"noEmitOnErrors":{"description":"Avoid emitting assets when errors occur","type":"boolean"},"nodeEnv":{"description":"Set process.env.NODE_ENV to a specific value","anyOf":[{"enum":[false]},{"type":"string"}]},"occurrenceOrder":{"description":"Figure out a order of modules which results in the smallest initial bundle","type":"boolean"},"portableRecords":{"description":"Generate records with relative paths to be able to move the context folder","type":"boolean"},"providedExports":{"description":"Figure out which exports are provided by modules to generate more efficient code","type":"boolean"},"removeAvailableModules":{"description":"Removes modules from chunks when these modules are already included in all parents","type":"boolean"},"removeEmptyChunks":{"description":"Remove chunks which are empty","type":"boolean"},"runtimeChunk":{"description":"Create an additional chunk which contains only the webpack runtime and chunk hash maps","oneOf":[{"type":"boolean"},{"enum":["single","multiple"]},{"type":"object","additionalProperties":false,"properties":{"name":{"description":"The name or name factory for the runtime chunks","oneOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]}}}]},"sideEffects":{"description":"Skip over modules which are flagged to contain no side effects when exports are not used","type":"boolean"},"splitChunks":{"description":"Optimize duplication and caching by splitting chunks by shared modules and cache group","oneOf":[{"enum":[false]},{"$ref":"#/definitions/OptimizationSplitChunksOptions"}]},"usedExports":{"description":"Figure out which exports are used by modules to mangle export names, omit unused exports and generate more efficient code","type":"boolean"}}},"OptimizationSplitChunksOptions":{"type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks","type":"string","minLength":1},"cacheGroups":{"description":"Assign modules to a cache group (modules from different cache groups are tried to keep in separate chunks)","type":"object","additionalProperties":{"description":"Configuration for a cache group","anyOf":[{"enum":[false]},{"instanceof":"Function","tsType":"Function"},{"type":"string"},{"instanceof":"RegExp","tsType":"RegExp"},{"type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks","type":"string","minLength":1},"automaticNamePrefix":{"description":"Sets the name prefix for created chunks","type":"string"},"chunks":{"description":"Select chunks for determining cache group content (defaults to \"initial\", \"initial\" and \"all\" requires adding these chunks to the HTML)","oneOf":[{"enum":["initial","async","all"]},{"instanceof":"Function","tsType":"Function"}]},"enforce":{"description":"Ignore minimum size, minimum chunks and maximum requests and always create chunks for this cache group","type":"boolean"},"filename":{"description":"Sets the template for the filename for created chunks (Only works for initial chunks)","type":"string","minLength":1},"maxAsyncRequests":{"description":"Maximum number of requests which are accepted for on-demand loading","type":"number","minimum":1},"maxInitialRequests":{"description":"Maximum number of initial chunks which are accepted for an entry point","type":"number","minimum":1},"maxSize":{"description":"Maximal size hint for the created chunks","type":"number","minimum":0},"minChunks":{"description":"Minimum number of times a module has to be duplicated until it's considered for splitting","type":"number","minimum":1},"minSize":{"description":"Minimal size for the created chunk","type":"number","minimum":0},"name":{"description":"Give chunks for this cache group a name (chunks with equal name are merged)","oneOf":[{"type":"boolean"},{"instanceof":"Function","tsType":"Function"},{"type":"string"}]},"priority":{"description":"Priority of this cache group","type":"number"},"reuseExistingChunk":{"description":"Try to reuse existing chunk (with name) when it has matching modules","type":"boolean"},"test":{"description":"Assign modules to a cache group","oneOf":[{"instanceof":"Function","tsType":"Function"},{"type":"string"},{"instanceof":"RegExp","tsType":"RegExp"}]}}}]}},"chunks":{"description":"Select chunks for determining shared modules (defaults to \"async\", \"initial\" and \"all\" requires adding these chunks to the HTML)","oneOf":[{"enum":["initial","async","all"]},{"instanceof":"Function","tsType":"Function"}]},"fallbackCacheGroup":{"description":"Options for modules not selected by any other cache group","type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks","type":"string","minLength":1},"maxSize":{"description":"Maximal size hint for the created chunks","type":"number","minimum":0},"minSize":{"description":"Minimal size for the created chunk","type":"number","minimum":0}}},"filename":{"description":"Sets the template for the filename for created chunks (Only works for initial chunks)","type":"string","minLength":1},"hidePathInfo":{"description":"Prevents exposing path info when creating names for parts splitted by maxSize","type":"boolean"},"maxAsyncRequests":{"description":"Maximum number of requests which are accepted for on-demand loading","type":"number","minimum":1},"maxInitialRequests":{"description":"Maximum number of initial chunks which are accepted for an entry point","type":"number","minimum":1},"maxSize":{"description":"Maximal size hint for the created chunks","type":"number","minimum":0},"minChunks":{"description":"Minimum number of times a module has to be duplicated until it's considered for splitting","type":"number","minimum":1},"minSize":{"description":"Minimal size for the created chunks","type":"number","minimum":0},"name":{"description":"Give chunks created a name (chunks with equal name are merged)","oneOf":[{"type":"boolean"},{"instanceof":"Function","tsType":"Function"},{"type":"string"}]}}},"OutputOptions":{"type":"object","additionalProperties":false,"properties":{"auxiliaryComment":{"description":"Add a comment in the UMD wrapper.","anyOf":[{"description":"Append the same comment above each import style.","type":"string"},{"description":"Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.","type":"object","additionalProperties":false,"properties":{"amd":{"description":"Set comment for `amd` section in UMD","type":"string"},"commonjs":{"description":"Set comment for `commonjs` (exports) section in UMD","type":"string"},"commonjs2":{"description":"Set comment for `commonjs2` (module.exports) section in UMD","type":"string"},"root":{"description":"Set comment for `root` (global variable) section in UMD","type":"string"}}}]},"chunkCallbackName":{"description":"The callback function name used by webpack for loading of chunks in WebWorkers.","type":"string"},"chunkFilename":{"description":"The filename of non-entry chunks as relative path inside the `output.path` directory.","type":"string","absolutePath":false},"chunkLoadTimeout":{"description":"Number of milliseconds before chunk request expires","type":"number"},"crossOriginLoading":{"description":"This option enables cross-origin loading of chunks.","enum":[false,"anonymous","use-credentials"]},"devtoolFallbackModuleFilenameTemplate":{"description":"Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"devtoolLineToLine":{"description":"Enable line to line mapped mode for all/specified modules. Line to line mapped mode uses a simple SourceMap where each line of the generated source is mapped to the same line of the original source. It’s a performance optimization. Only use it if your performance need to be better and you are sure that input lines match which generated lines.","anyOf":[{"description":"`true` enables it for all modules (not recommended)","type":"boolean"},{"description":"An object similar to `module.loaders` enables it for specific files.","type":"object"}]},"devtoolModuleFilenameTemplate":{"description":"Filename template string of function for the sources array in a generated SourceMap.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"devtoolNamespace":{"description":"Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It's useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.","type":"string"},"filename":{"description":"Specifies the name of each output file on disk. You must **not** specify an absolute path here! The `output.path` option determines the location on disk the files are written to, filename is used solely for naming the individual files.","anyOf":[{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"Function"}]},"futureEmitAssets":{"description":"Use the future version of asset emitting logic, which is allows freeing memory of assets after emitting. It could break plugins which assume that assets are still readable after emitting. Will be the new default in the next major version.","type":"boolean"},"globalObject":{"description":"An expression which is used to address the global object/scope in runtime code","type":"string","minLength":1},"hashDigest":{"description":"Digest type used for the hash","type":"string"},"hashDigestLength":{"description":"Number of chars which are used for the hash","type":"number","minimum":1},"hashFunction":{"description":"Algorithm used for generation the hash (see node.js crypto package)","anyOf":[{"type":"string","minLength":1},{"instanceof":"Function","tsType":"(new () => import('../lib/util/createHash').Hash)"}]},"hashSalt":{"description":"Any string which is added to the hash to salt it","type":"string","minLength":1},"hotUpdateChunkFilename":{"description":"The filename of the Hot Update Chunks. They are inside the output.path directory.","anyOf":[{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"Function"}]},"hotUpdateFunction":{"description":"The JSONP function used by webpack for async loading of hot update chunks.","type":"string"},"hotUpdateMainFilename":{"description":"The filename of the Hot Update Main File. It is inside the `output.path` directory.","anyOf":[{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"Function"}]},"jsonpFunction":{"description":"The JSONP function used by webpack for async loading of chunks.","type":"string"},"jsonpScriptType":{"description":"This option enables loading async chunks via a custom script type, such as script type=\"module\"","enum":[false,"text/javascript","module"]},"library":{"description":"If set, export the bundle as library. `output.library` is the name.","anyOf":[{"type":"string"},{"type":"array","items":{"description":"A part of the library name","type":"string"}},{"$ref":"#/definitions/LibraryCustomUmdObject"}]},"libraryExport":{"description":"Specify which export should be exposed as library","anyOf":[{"type":"string"},{"$ref":"#/definitions/ArrayOfStringValues"}]},"libraryTarget":{"description":"Type of library","enum":["var","assign","this","window","self","global","commonjs","commonjs2","commonjs-module","amd","amd-require","umd","umd2","jsonp"]},"path":{"description":"The output directory as **absolute path** (required).","type":"string","absolutePath":true},"pathinfo":{"description":"Include comments with information about the modules.","type":"boolean"},"publicPath":{"description":"The `publicPath` specifies the public URL address of the output files when referenced in a browser.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"sourceMapFilename":{"description":"The filename of the SourceMaps for the JavaScript files. They are inside the `output.path` directory.","type":"string","absolutePath":false},"sourcePrefix":{"description":"Prefixes every line of the source in the bundle with this string.","type":"string"},"strictModuleExceptionHandling":{"description":"Handles exceptions in module loading correctly at a performance cost.","type":"boolean"},"umdNamedDefine":{"description":"If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.","type":"boolean"},"webassemblyModuleFilename":{"description":"The filename of WebAssembly modules as relative path inside the `output.path` directory.","type":"string","absolutePath":false}}},"PerformanceOptions":{"type":"object","additionalProperties":false,"properties":{"assetFilter":{"description":"Filter function to select assets that are checked","instanceof":"Function","tsType":"Function"},"hints":{"description":"Sets the format of the hints: warnings, errors or nothing at all","enum":[false,"warning","error"]},"maxAssetSize":{"description":"Filesize limit (in bytes) when exceeded, that webpack will provide performance hints","type":"number"},"maxEntrypointSize":{"description":"Total size of an entry point (in bytes)","type":"number"}}},"ResolveOptions":{"type":"object","additionalProperties":false,"properties":{"alias":{"description":"Redirect module requests","anyOf":[{"type":"object","additionalProperties":{"description":"New request","type":"string"}},{"type":"array","items":{"description":"Alias configuration","type":"object","additionalProperties":false,"properties":{"alias":{"description":"New request","type":"string"},"name":{"description":"Request to be redirected","type":"string"},"onlyModule":{"description":"Redirect only exact matching request","type":"boolean"}}}}]},"aliasFields":{"description":"Fields in the description file (package.json) which are used to redirect requests inside the module","anyOf":[{"$ref":"#/definitions/ArrayOfStringOrStringArrayValues"}]},"cachePredicate":{"description":"Predicate function to decide which requests should be cached","instanceof":"Function","tsType":"Function"},"cacheWithContext":{"description":"Include the context information in the cache identifier when caching","type":"boolean"},"concord":{"description":"Enable concord resolving extras","type":"boolean"},"descriptionFiles":{"description":"Filenames used to find a description file","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"enforceExtension":{"description":"Enforce using one of the extensions from the extensions option","type":"boolean"},"enforceModuleExtension":{"description":"Enforce using one of the module extensions from the moduleExtensions option","type":"boolean"},"extensions":{"description":"Extensions added to the request when trying to find the file","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"fileSystem":{"description":"Filesystem for the resolver"},"mainFields":{"description":"Field names from the description file (package.json) which are used to find the default entry point","anyOf":[{"$ref":"#/definitions/ArrayOfStringOrStringArrayValues"}]},"mainFiles":{"description":"Filenames used to find the default entry point if there is no description file or main field","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"moduleExtensions":{"description":"Extensions added to the module request when trying to find the module","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"modules":{"description":"Folder names or directory paths where to find modules","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"plugins":{"description":"Plugins for the resolver","type":"array","items":{"description":"Plugin of type object or instanceof Function","anyOf":[{"$ref":"#/definitions/WebpackPluginInstance"},{"$ref":"#/definitions/WebpackPluginFunction"}]}},"resolver":{"description":"Custom resolver"},"symlinks":{"description":"Enable resolving symlinks to the original location","type":"boolean"},"unsafeCache":{"description":"Enable caching of successfully resolved requests","anyOf":[{"type":"boolean"},{"type":"object","additionalProperties":true}]},"useSyncFileSystemCalls":{"description":"Use synchronous filesystem calls for the resolver","type":"boolean"}}},"RuleSetCondition":{"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1},{"instanceof":"Function","tsType":"((value: string) => boolean)"},{"$ref":"#/definitions/RuleSetConditions"},{"type":"object","additionalProperties":false,"properties":{"and":{"description":"Logical AND","anyOf":[{"$ref":"#/definitions/RuleSetConditions"}]},"exclude":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"include":{"description":"Exclude all modules matching not any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"not":{"description":"Logical NOT","anyOf":[{"$ref":"#/definitions/RuleSetConditions"}]},"or":{"description":"Logical OR","anyOf":[{"$ref":"#/definitions/RuleSetConditions"}]},"test":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]}}}]},"RuleSetConditionAbsolute":{"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":true},{"instanceof":"Function","tsType":"((value: string) => boolean)"},{"$ref":"#/definitions/RuleSetConditionsAbsolute"},{"type":"object","additionalProperties":false,"properties":{"and":{"description":"Logical AND","anyOf":[{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"exclude":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"include":{"description":"Exclude all modules matching not any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"not":{"description":"Logical NOT","anyOf":[{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"or":{"description":"Logical OR","anyOf":[{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"test":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]}}}]},"RuleSetConditionOrConditions":{"description":"One or multiple rule conditions","anyOf":[{"$ref":"#/definitions/RuleSetCondition"},{"$ref":"#/definitions/RuleSetConditions"}]},"RuleSetConditionOrConditionsAbsolute":{"description":"One or multiple rule conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionAbsolute"},{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"RuleSetConditions":{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/RuleSetCondition"}]},"tsType":"RuleSetConditionsRecursive"},"RuleSetConditionsAbsolute":{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/RuleSetConditionAbsolute"}]},"tsType":"RuleSetConditionsAbsoluteRecursive"},"RuleSetLoader":{"type":"string","minLength":1},"RuleSetQuery":{"anyOf":[{"type":"object"},{"type":"string"}]},"RuleSetRule":{"type":"object","additionalProperties":false,"properties":{"compiler":{"description":"Match the child compiler name","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"enforce":{"description":"Enforce this rule as pre or post step","enum":["pre","post"]},"exclude":{"description":"Shortcut for resource.exclude","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"include":{"description":"Shortcut for resource.include","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"issuer":{"description":"Match the issuer of the module (The module pointing to this module)","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"loader":{"description":"Shortcut for use.loader","anyOf":[{"$ref":"#/definitions/RuleSetLoader"},{"$ref":"#/definitions/RuleSetUse"}]},"loaders":{"description":"Shortcut for use.loader","anyOf":[{"$ref":"#/definitions/RuleSetUse"}]},"oneOf":{"description":"Only execute the first matching rule in this array","anyOf":[{"$ref":"#/definitions/RuleSetRules"}]},"options":{"description":"Shortcut for use.options","anyOf":[{"$ref":"#/definitions/RuleSetQuery"}]},"parser":{"description":"Options for parsing","type":"object","additionalProperties":true},"query":{"description":"Shortcut for use.query","anyOf":[{"$ref":"#/definitions/RuleSetQuery"}]},"resolve":{"description":"Options for the resolver","type":"object","anyOf":[{"$ref":"#/definitions/ResolveOptions"}]},"resource":{"description":"Match the resource path of the module","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"resourceQuery":{"description":"Match the resource query of the module","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"rules":{"description":"Match and execute these rules when this rule is matched","anyOf":[{"$ref":"#/definitions/RuleSetRules"}]},"sideEffects":{"description":"Flags a module as with or without side effects","type":"boolean"},"test":{"description":"Shortcut for resource.test","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"type":{"description":"Module type to use for the module","enum":["javascript/auto","javascript/dynamic","javascript/esm","json","webassembly/experimental"]},"use":{"description":"Modifiers applied to the module when rule is matched","anyOf":[{"$ref":"#/definitions/RuleSetUse"}]}}},"RuleSetRules":{"type":"array","items":{"description":"A rule","anyOf":[{"$ref":"#/definitions/RuleSetRule"}]}},"RuleSetUse":{"anyOf":[{"$ref":"#/definitions/RuleSetUseItem"},{"instanceof":"Function","tsType":"Function"},{"type":"array","items":{"description":"An use item","anyOf":[{"$ref":"#/definitions/RuleSetUseItem"}]}}]},"RuleSetUseItem":{"anyOf":[{"$ref":"#/definitions/RuleSetLoader"},{"instanceof":"Function","tsType":"Function"},{"type":"object","additionalProperties":false,"properties":{"ident":{"description":"Unique loader identifier","type":"string"},"loader":{"description":"Loader name","anyOf":[{"$ref":"#/definitions/RuleSetLoader"}]},"options":{"description":"Loader options","anyOf":[{"$ref":"#/definitions/RuleSetQuery"}]},"query":{"description":"Loader query","anyOf":[{"$ref":"#/definitions/RuleSetQuery"}]}}}]},"StatsOptions":{"type":"object","additionalProperties":false,"properties":{"all":{"description":"fallback value for stats options when an option is not defined (has precedence over local webpack defaults)","type":"boolean"},"assets":{"description":"add assets information","type":"boolean"},"assetsSort":{"description":"sort the assets by that field","type":"string"},"builtAt":{"description":"add built at time information","type":"boolean"},"cached":{"description":"add also information about cached (not built) modules","type":"boolean"},"cachedAssets":{"description":"Show cached assets (setting this to `false` only shows emitted files)","type":"boolean"},"children":{"description":"add children information","type":"boolean"},"chunkGroups":{"description":"Display all chunk groups with the corresponding bundles","type":"boolean"},"chunkModules":{"description":"add built modules information to chunk information","type":"boolean"},"chunkOrigins":{"description":"add the origins of chunks and chunk merging info","type":"boolean"},"chunks":{"description":"add chunk information","type":"boolean"},"chunksSort":{"description":"sort the chunks by that field","type":"string"},"colors":{"description":"Enables/Disables colorful output","oneOf":[{"description":"`webpack --colors` equivalent","type":"boolean"},{"type":"object","additionalProperties":false,"properties":{"bold":{"description":"Custom color for bold text","type":"string"},"cyan":{"description":"Custom color for cyan text","type":"string"},"green":{"description":"Custom color for green text","type":"string"},"magenta":{"description":"Custom color for magenta text","type":"string"},"red":{"description":"Custom color for red text","type":"string"},"yellow":{"description":"Custom color for yellow text","type":"string"}}}]},"context":{"description":"context directory for request shortening","type":"string","absolutePath":true},"depth":{"description":"add module depth in module graph","type":"boolean"},"entrypoints":{"description":"Display the entry points with the corresponding bundles","type":"boolean"},"env":{"description":"add --env information","type":"boolean"},"errorDetails":{"description":"add details to errors (like resolving log)","type":"boolean"},"errors":{"description":"add errors","type":"boolean"},"exclude":{"description":"Please use excludeModules instead.","anyOf":[{"$ref":"#/definitions/FilterTypes"},{"type":"boolean"}]},"excludeAssets":{"description":"Suppress assets that match the specified filters. Filters can be Strings, RegExps or Functions","anyOf":[{"$ref":"#/definitions/FilterTypes"}]},"excludeModules":{"description":"Suppress modules that match the specified filters. Filters can be Strings, RegExps, Booleans or Functions","anyOf":[{"$ref":"#/definitions/FilterTypes"},{"type":"boolean"}]},"hash":{"description":"add the hash of the compilation","type":"boolean"},"maxModules":{"description":"Set the maximum number of modules to be shown","type":"number"},"moduleAssets":{"description":"add information about assets inside modules","type":"boolean"},"moduleTrace":{"description":"add dependencies and origin of warnings/errors","type":"boolean"},"modules":{"description":"add built modules information","type":"boolean"},"modulesSort":{"description":"sort the modules by that field","type":"string"},"nestedModules":{"description":"add information about modules nested in other modules (like with module concatenation)","type":"boolean"},"optimizationBailout":{"description":"show reasons why optimization bailed out for modules","type":"boolean"},"outputPath":{"description":"Add output path information","type":"boolean"},"performance":{"description":"add performance hint flags","type":"boolean"},"providedExports":{"description":"show exports provided by modules","type":"boolean"},"publicPath":{"description":"Add public path information","type":"boolean"},"reasons":{"description":"add information about the reasons why modules are included","type":"boolean"},"source":{"description":"add the source code of modules","type":"boolean"},"timings":{"description":"add timing information","type":"boolean"},"usedExports":{"description":"show exports used by modules","type":"boolean"},"version":{"description":"add webpack version information","type":"boolean"},"warnings":{"description":"add warnings","type":"boolean"},"warningsFilter":{"description":"Suppress warnings that match the specified filters. Filters can be Strings, RegExps or Functions","anyOf":[{"$ref":"#/definitions/FilterTypes"}]}}},"WebpackPluginFunction":{"description":"Function acting as plugin","instanceof":"Function","tsType":"(this: import('../lib/Compiler'), compiler: import('../lib/Compiler')) => void"},"WebpackPluginInstance":{"description":"Plugin instance","type":"object","additionalProperties":true,"properties":{"apply":{"description":"The run point of the plugin, required method.","instanceof":"Function","tsType":"(compiler: import('../lib/Compiler')) => void"}},"required":["apply"]}},"type":"object","additionalProperties":false,"properties":{"amd":{"description":"Set the value of `require.amd` and `define.amd`."},"bail":{"description":"Report the first error as a hard error instead of tolerating it.","type":"boolean"},"cache":{"description":"Cache generated modules and chunks to improve performance for multiple incremental builds.","anyOf":[{"description":"You can pass `false` to disable it.","type":"boolean"},{"description":"You can pass an object to enable it and let webpack use the passed object as cache. This way you can share the cache object between multiple compiler calls.","type":"object"}]},"context":{"description":"The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.","type":"string","absolutePath":true},"dependencies":{"description":"References to other configurations to depend on.","type":"array","items":{"description":"References to another configuration to depend on.","type":"string"}},"devServer":{"description":"Options for the webpack-dev-server","type":"object"},"devtool":{"description":"A developer tool to enhance debugging.","anyOf":[{"type":"string"},{"enum":[false]}]},"entry":{"description":"The entry point(s) of the compilation.","anyOf":[{"$ref":"#/definitions/Entry"}]},"externals":{"description":"Specify dependencies that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.","anyOf":[{"$ref":"#/definitions/Externals"}]},"loader":{"description":"Custom values available in the loader context.","type":"object"},"mode":{"description":"Enable production optimizations or development hints.","enum":["development","production","none"]},"module":{"description":"Options affecting the normal modules (`NormalModuleFactory`).","anyOf":[{"$ref":"#/definitions/ModuleOptions"}]},"name":{"description":"Name of the configuration. Used when loading multiple configurations.","type":"string"},"node":{"description":"Include polyfills or mocks for various node stuff.","anyOf":[{"enum":[false]},{"$ref":"#/definitions/NodeOptions"}]},"optimization":{"description":"Enables/Disables integrated optimizations","anyOf":[{"$ref":"#/definitions/OptimizationOptions"}]},"output":{"description":"Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.","anyOf":[{"$ref":"#/definitions/OutputOptions"}]},"parallelism":{"description":"The number of parallel processed modules in the compilation.","type":"number","minimum":1},"performance":{"description":"Configuration for web performance recommendations.","anyOf":[{"enum":[false]},{"$ref":"#/definitions/PerformanceOptions"}]},"plugins":{"description":"Add additional plugins to the compiler.","type":"array","items":{"description":"Plugin of type object or instanceof Function","anyOf":[{"$ref":"#/definitions/WebpackPluginInstance"},{"$ref":"#/definitions/WebpackPluginFunction"}]}},"profile":{"description":"Capture timing information for each module.","type":"boolean"},"recordsInputPath":{"description":"Store compiler state to a json file.","type":"string","absolutePath":true},"recordsOutputPath":{"description":"Load compiler state from a json file.","type":"string","absolutePath":true},"recordsPath":{"description":"Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks. An absolute path is expected. `recordsPath` is used for `recordsInputPath` and `recordsOutputPath` if they left undefined.","type":"string","absolutePath":true},"resolve":{"description":"Options for the resolver","anyOf":[{"$ref":"#/definitions/ResolveOptions"}]},"resolveLoader":{"description":"Options for the resolver when resolving loaders","anyOf":[{"$ref":"#/definitions/ResolveOptions"}]},"serve":{"description":"Options for webpack-serve","type":"object"},"stats":{"description":"Used by the webpack CLI program to pass stats options.","anyOf":[{"$ref":"#/definitions/StatsOptions"},{"type":"boolean"},{"enum":["none","errors-only","minimal","normal","detailed","verbose"]}]},"target":{"description":"Environment to build for","anyOf":[{"enum":["web","webworker","node","async-node","node-webkit","electron-main","electron-renderer"]},{"instanceof":"Function","tsType":"((compiler: import('../lib/Compiler')) => void)"}]},"watch":{"description":"Enter watch mode, which rebuilds on file change.","type":"boolean"},"watchOptions":{"description":"Options for the watcher","type":"object","additionalProperties":false,"properties":{"aggregateTimeout":{"description":"Delay the rebuilt after the first change. Value is a time in ms.","type":"number"},"ignored":{"description":"Ignore some files from watching"},"poll":{"description":"Enable polling mode for watching","anyOf":[{"description":"`true`: use polling.","type":"boolean"},{"description":"`number`: use polling with specified interval.","type":"number"}]},"stdin":{"description":"Stop watching when stdin stream has ended","type":"boolean"}}}}};

/***/ }),

/***/ "./node_modules/webpack/schemas/ajv.absolutePath.js":
/*!*********************************************!*\
  !*** (webpack)/schemas/ajv.absolutePath.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const errorMessage = (schema, data, message) => ({
	keyword: "absolutePath",
	params: { absolutePath: data },
	message: message,
	parentSchema: schema
});

const getErrorFor = (shouldBeAbsolute, data, schema) => {
	const message = shouldBeAbsolute
		? `The provided value ${JSON.stringify(data)} is not an absolute path!`
		: `A relative path is expected. However, the provided value ${JSON.stringify(
				data
		  )} is an absolute path!`;

	return errorMessage(schema, data, message);
};

module.exports = ajv =>
	ajv.addKeyword("absolutePath", {
		errors: true,
		type: "string",
		compile(expected, schema) {
			function callback(data) {
				let passes = true;
				const isExclamationMarkPresent = data.includes("!");
				const isCorrectAbsoluteOrRelativePath =
					expected === /^(?:[A-Za-z]:\\|\/)/.test(data);

				if (isExclamationMarkPresent) {
					callback.errors = [
						errorMessage(
							schema,
							data,
							`The provided value ${JSON.stringify(
								data
							)} contains exclamation mark (!) which is not allowed because it's reserved for loader syntax.`
						)
					];
					passes = false;
				}

				if (!isCorrectAbsoluteOrRelativePath) {
					callback.errors = [getErrorFor(expected, data, schema)];
					passes = false;
				}

				return passes;
			}
			callback.errors = [];

			return callback;
		}
	});


/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/BannerPlugin.json":
/*!***************************************************!*\
  !*** (webpack)/schemas/plugins/BannerPlugin.json ***!
  \***************************************************/
/*! exports provided: definitions, title, oneOf, default */
/***/ (function(module) {

module.exports = {"definitions":{"BannerFunction":{"description":"The banner as function, it will be wrapped in a comment","instanceof":"Function","tsType":"(data: { hash: string, chunk: import('../../lib/Chunk'), filename: string, basename: string, query: string}) => string"},"Rule":{"oneOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"Rules":{"oneOf":[{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/Rule"}]}},{"$ref":"#/definitions/Rule"}]}},"title":"BannerPluginArgument","oneOf":[{"title":"BannerPluginOptions","type":"object","additionalProperties":false,"properties":{"banner":{"description":"Specifies the banner","anyOf":[{"$ref":"#/definitions/BannerFunction"},{"type":"string"}]},"entryOnly":{"description":"If true, the banner will only be added to the entry chunks","type":"boolean"},"exclude":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/Rules"}]},"include":{"description":"Include all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/Rules"}]},"raw":{"description":"If true, banner will not be wrapped in a comment","type":"boolean"},"test":{"description":"Include all modules that pass test assertion","anyOf":[{"$ref":"#/definitions/Rules"}]}},"required":["banner"]},{"$ref":"#/definitions/BannerFunction"},{"description":"The banner as string, it will be wrapped in a comment","type":"string","minLength":1}]};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/DllPlugin.json":
/*!************************************************!*\
  !*** (webpack)/schemas/plugins/DllPlugin.json ***!
  \************************************************/
/*! exports provided: title, type, additionalProperties, properties, required, default */
/***/ (function(module) {

module.exports = {"title":"DllPluginOptions","type":"object","additionalProperties":false,"properties":{"context":{"description":"Context of requests in the manifest file (defaults to the webpack context)","type":"string","minLength":1},"entryOnly":{"description":"If true, only entry points will be exposed","type":"boolean"},"format":{"description":"If true, manifest json file (output) will be formatted","type":"boolean"},"name":{"description":"Name of the exposed dll function (external name, use value of 'output.library')","type":"string","minLength":1},"path":{"description":"Absolute path to the manifest json file (output)","type":"string","minLength":1},"type":{"description":"Type of the dll bundle (external type, use value of 'output.libraryTarget')","type":"string","minLength":1}},"required":["path"]};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/DllReferencePlugin.json":
/*!*********************************************************!*\
  !*** (webpack)/schemas/plugins/DllReferencePlugin.json ***!
  \*********************************************************/
/*! exports provided: definitions, title, anyOf, default */
/***/ (function(module) {

module.exports = {"definitions":{"DllReferencePluginOptionsContent":{"description":"The mappings from request to module info","type":"object","additionalProperties":{"description":"Module info","type":"object","additionalProperties":false,"properties":{"buildMeta":{"description":"Meta information about the module","type":"object"},"exports":{"description":"Information about the provided exports of the module","anyOf":[{"description":"Exports unknown/dynamic","enum":[true]},{"description":"List of provided exports of the module","type":"array","items":{"description":"Name of the export","type":"string","minLength":1}}]},"id":{"description":"Module ID","anyOf":[{"type":"number"},{"type":"string","minLength":1}]}},"required":["id"]},"minProperties":1},"DllReferencePluginOptionsManifest":{"description":"An object containing content, name and type","type":"object","additionalProperties":false,"properties":{"content":{"description":"The mappings from request to module info","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsContent"}]},"name":{"description":"The name where the dll is exposed (external name)","type":"string","minLength":1},"type":{"description":"The type how the dll is exposed (external type)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]}},"required":["content"]},"DllReferencePluginOptionsSourceType":{"description":"The type how the dll is exposed (external type)","enum":["var","assign","this","window","global","commonjs","commonjs2","commonjs-module","amd","amd-require","umd","umd2","jsonp"]}},"title":"DllReferencePluginOptions","anyOf":[{"type":"object","additionalProperties":false,"properties":{"context":{"description":"(absolute path) context of requests in the manifest (or content property)","type":"string","absolutePath":true},"extensions":{"description":"Extensions used to resolve modules in the dll bundle (only used when using 'scope')","type":"array","items":{"description":"An extension","type":"string"}},"manifest":{"description":"An object containing content and name or a string to the absolute path of the JSON manifest to be loaded upon compilation","oneOf":[{"$ref":"#/definitions/DllReferencePluginOptionsManifest"},{"type":"string","absolutePath":true}]},"name":{"description":"The name where the dll is exposed (external name, defaults to manifest.name)","type":"string","minLength":1},"scope":{"description":"Prefix which is used for accessing the content of the dll","type":"string","minLength":1},"sourceType":{"description":"How the dll is exposed (libraryTarget, defaults to manifest.type)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]},"type":{"description":"The way how the export of the dll bundle is used","enum":["require","object"]}},"required":["manifest"]},{"type":"object","additionalProperties":false,"properties":{"content":{"description":"The mappings from request to module info","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsContent"}]},"context":{"description":"(absolute path) context of requests in the manifest (or content property)","type":"string","absolutePath":true},"extensions":{"description":"Extensions used to resolve modules in the dll bundle (only used when using 'scope')","type":"array","items":{"description":"An extension","type":"string"}},"name":{"description":"The name where the dll is exposed (external name)","type":"string","minLength":1},"scope":{"description":"Prefix which is used for accessing the content of the dll","type":"string","minLength":1},"sourceType":{"description":"How the dll is exposed (libraryTarget)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]},"type":{"description":"The way how the export of the dll bundle is used","enum":["require","object"]}},"required":["content","name"]}]};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/HashedModuleIdsPlugin.json":
/*!************************************************************!*\
  !*** (webpack)/schemas/plugins/HashedModuleIdsPlugin.json ***!
  \************************************************************/
/*! exports provided: title, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"title":"HashedModuleIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"context":{"description":"The context directory for creating names.","type":"string","absolutePath":true},"hashDigest":{"description":"The encoding to use when generating the hash, defaults to 'base64'. All encodings from Node.JS' hash.digest are supported.","enum":["hex","latin1","base64"]},"hashDigestLength":{"description":"The prefix length of the hash digest to use, defaults to 4.","type":"number","minimum":1},"hashFunction":{"description":"The hashing algorithm to use, defaults to 'md5'. All functions from Node.JS' crypto.createHash are supported.","type":"string","minLength":1}}};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/IgnorePlugin.json":
/*!***************************************************!*\
  !*** (webpack)/schemas/plugins/IgnorePlugin.json ***!
  \***************************************************/
/*! exports provided: title, oneOf, default */
/***/ (function(module) {

module.exports = {"title":"IgnorePluginOptions","oneOf":[{"type":"object","additionalProperties":false,"properties":{"contextRegExp":{"description":"A RegExp to test the context (directory) against","instanceof":"RegExp","tsType":"RegExp"},"resourceRegExp":{"description":"A RegExp to test the request against","instanceof":"RegExp","tsType":"RegExp"}}},{"type":"object","additionalProperties":false,"properties":{"checkContext":{"description":"A filter function for context","instanceof":"Function","tsType":"((context: string) => boolean)"},"checkResource":{"description":"A filter function for resource and context","instanceof":"Function","tsType":"((resource: string, context: string) => boolean)"}}}]};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/LoaderOptionsPlugin.json":
/*!**********************************************************!*\
  !*** (webpack)/schemas/plugins/LoaderOptionsPlugin.json ***!
  \**********************************************************/
/*! exports provided: title, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"title":"LoaderOptionsPluginOptions","type":"object","additionalProperties":true,"properties":{"debug":{"description":"Whether loaders should be in debug mode or not. debug will be removed as of webpack 3","type":"boolean"},"minimize":{"description":"Where loaders can be switched to minimize mode","type":"boolean"},"options":{"description":"A configuration object that can be used to configure older loaders","type":"object","additionalProperties":true,"properties":{"context":{"description":"The context that can be used to configure older loaders","type":"string","absolutePath":true}}}}};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/ProgressPlugin.json":
/*!*****************************************************!*\
  !*** (webpack)/schemas/plugins/ProgressPlugin.json ***!
  \*****************************************************/
/*! exports provided: definitions, title, oneOf, default */
/***/ (function(module) {

module.exports = {"definitions":{"HandlerFunction":{"description":"Function that executes for every progress step","instanceof":"Function","tsType":"((percentage: number, msg: string, ...args: string[]) => void)"},"ProgressPluginOptions":{"type":"object","additionalProperties":false,"properties":{"activeModules":{"description":"Show active modules count and one active module in progress message","type":"boolean"},"entries":{"description":"Show entries count in progress message","type":"boolean"},"handler":{"description":"Function that executes for every progress step","anyOf":[{"$ref":"#/definitions/HandlerFunction"}]},"modules":{"description":"Show modules count in progress message","type":"boolean"},"modulesCount":{"description":"Minimum modules count to start with. Only for mode=modules. Default: 500","type":"number"},"profile":{"description":"Collect profile data for progress steps. Default: false","enum":[true,false,null]}}}},"title":"ProgressPluginArgument","oneOf":[{"$ref":"#/definitions/ProgressPluginOptions"},{"$ref":"#/definitions/HandlerFunction"}]};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/SourceMapDevToolPlugin.json":
/*!*************************************************************!*\
  !*** (webpack)/schemas/plugins/SourceMapDevToolPlugin.json ***!
  \*************************************************************/
/*! exports provided: definitions, title, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"definitions":{"rule":{"oneOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"rules":{"oneOf":[{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/rule"}]}},{"$ref":"#/definitions/rule"}]}},"title":"SourceMapDevToolPluginOptions","type":"object","additionalProperties":false,"properties":{"append":{"description":"Appends the given value to the original asset. Usually the #sourceMappingURL comment. [url] is replaced with a URL to the source map file. false disables the appending","oneOf":[{"description":"Append no SourceMap comment to the bundle, but still generate SourceMaps","enum":[false,null]},{"type":"string","minLength":1}]},"columns":{"description":"Indicates whether column mappings should be used (defaults to true)","type":"boolean"},"exclude":{"description":"Exclude modules that match the given value from source map generation","anyOf":[{"$ref":"#/definitions/rules"}]},"fallbackModuleFilenameTemplate":{"description":"Generator string or function to create identifiers of modules for the 'sources' array in the SourceMap used only if 'moduleFilenameTemplate' would result in a conflict","oneOf":[{"description":"Custom function generating the identifer","instanceof":"Function","tsType":"Function"},{"type":"string","minLength":1}]},"fileContext":{"description":"Path prefix to which the [file] placeholder is relative to","type":"string"},"filename":{"description":"Defines the output filename of the SourceMap (will be inlined if no value is provided)","oneOf":[{"description":"Disable separate SourceMap file and inline SourceMap as DataUrl","enum":[false,null]},{"type":"string","absolutePath":false,"minLength":1}]},"include":{"description":"Include source maps for module paths that match the given value","anyOf":[{"$ref":"#/definitions/rules"}]},"lineToLine":{"description":"(deprecated) try to map original files line to line to generated files","anyOf":[{"type":"boolean"},{"description":"Simplify and speed up source mapping by using line to line source mappings for matched modules","type":"object","additionalProperties":false,"properties":{"exclude":{"description":"Exclude modules that match the given value from source map generation","anyOf":[{"$ref":"#/definitions/rules"}]},"include":{"description":"Include source maps for module paths that match the given value","anyOf":[{"$ref":"#/definitions/rules"}]},"test":{"description":"Include source maps for modules based on their extension (defaults to .js and .css)","anyOf":[{"$ref":"#/definitions/rules"}]}}}]},"module":{"description":"Indicates whether SourceMaps from loaders should be used (defaults to true)","type":"boolean"},"moduleFilenameTemplate":{"description":"Generator string or function to create identifiers of modules for the 'sources' array in the SourceMap","oneOf":[{"description":"Custom function generating the identifer","instanceof":"Function","tsType":"Function"},{"type":"string","minLength":1}]},"namespace":{"description":"Namespace prefix to allow multiple webpack roots in the devtools","type":"string"},"noSources":{"description":"Omit the 'sourceContents' array from the SourceMap","type":"boolean"},"publicPath":{"description":"Provide a custom public path for the SourceMapping comment","type":"string"},"sourceRoot":{"description":"Provide a custom value for the 'sourceRoot' property in the SourceMap","type":"string"},"test":{"description":"Include source maps for modules based on their extension (defaults to .js and .css)","anyOf":[{"$ref":"#/definitions/rules"}]}}};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/WatchIgnorePlugin.json":
/*!********************************************************!*\
  !*** (webpack)/schemas/plugins/WatchIgnorePlugin.json ***!
  \********************************************************/
/*! exports provided: title, description, type, items, minItems, default */
/***/ (function(module) {

module.exports = {"title":"WatchIgnorePluginOptions","description":"A list of RegExps or absolute paths to directories or files that should be ignored","type":"array","items":{"description":"RegExp or absolute path to directories or files that should be ignored","oneOf":[{"type":"string"},{"instanceof":"RegExp","tsType":"RegExp"}]},"minItems":1};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/debug/ProfilingPlugin.json":
/*!************************************************************!*\
  !*** (webpack)/schemas/plugins/debug/ProfilingPlugin.json ***!
  \************************************************************/
/*! exports provided: title, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"title":"ProfilingPluginOptions","type":"object","additionalProperties":false,"properties":{"outputPath":{"description":"Path to the output file e.g. `profiling/events.json`. Defaults to `events.json`.","type":"string","absolutePath":false,"minLength":4}}};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/optimize/AggressiveSplittingPlugin.json":
/*!*************************************************************************!*\
  !*** (webpack)/schemas/plugins/optimize/AggressiveSplittingPlugin.json ***!
  \*************************************************************************/
/*! exports provided: title, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"title":"AggressiveSplittingPluginOptions","type":"object","additionalProperties":false,"properties":{"chunkOverhead":{"description":"Default: 0","type":"number"},"entryChunkMultiplicator":{"description":"Default: 1","type":"number"},"maxSize":{"description":"Byte, maxsize of per file. Default: 51200","type":"number"},"minSize":{"description":"Byte, split point. Default: 30720","type":"number"}}};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/optimize/LimitChunkCountPlugin.json":
/*!*********************************************************************!*\
  !*** (webpack)/schemas/plugins/optimize/LimitChunkCountPlugin.json ***!
  \*********************************************************************/
/*! exports provided: title, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"title":"LimitChunkCountPluginOptions","type":"object","additionalProperties":false,"properties":{"maxChunks":{"description":"Limit the maximum number of chunks using a value greater greater than or equal to 1","type":"number","minimum":1},"minChunkSize":{"description":"Set a minimum chunk size","type":"number"}}};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/optimize/MinChunkSizePlugin.json":
/*!******************************************************************!*\
  !*** (webpack)/schemas/plugins/optimize/MinChunkSizePlugin.json ***!
  \******************************************************************/
/*! exports provided: title, type, additionalProperties, properties, required, default */
/***/ (function(module) {

module.exports = {"title":"MinChunkSizePluginOptions","type":"object","additionalProperties":false,"properties":{"minChunkSize":{"description":"Minimum number of characters","type":"number"}},"required":["minChunkSize"]};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/optimize/OccurrenceOrderChunkIdsPlugin.json":
/*!*****************************************************************************!*\
  !*** (webpack)/schemas/plugins/optimize/OccurrenceOrderChunkIdsPlugin.json ***!
  \*****************************************************************************/
/*! exports provided: title, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"title":"OccurrenceOrderChunkIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"prioritiseInitial":{"description":"Prioritise initial size over total size","type":"boolean"}}};

/***/ }),

/***/ "./node_modules/webpack/schemas/plugins/optimize/OccurrenceOrderModuleIdsPlugin.json":
/*!******************************************************************************!*\
  !*** (webpack)/schemas/plugins/optimize/OccurrenceOrderModuleIdsPlugin.json ***!
  \******************************************************************************/
/*! exports provided: title, type, additionalProperties, properties, default */
/***/ (function(module) {

module.exports = {"title":"OccurrenceOrderModuleIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"prioritiseInitial":{"description":"Prioritise initial size over total size","type":"boolean"}}};

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits */ "./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! styled-components */ "styled-components");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react_delayed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-delayed */ "react-delayed");
/* harmony import */ var react_delayed__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_delayed__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react_ga__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-ga */ "react-ga");
/* harmony import */ var react_ga__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react_ga__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _components_Navigation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../components/Navigation */ "./components/Navigation.jsx");
/* harmony import */ var _components_About__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../components/About */ "./components/About.jsx");
/* harmony import */ var _components_Work__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../components/Work */ "./components/Work.jsx");
/* harmony import */ var _components_Colophon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../components/Colophon */ "./components/Colophon.jsx");






var _jsxFileName = "/Users/jasonmandel/Queue/jm-site/pages/index.js";

function _templateObject3() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n  visibility: ", ";\n  animation: ", " 0.5s linear;\n  transition: visibility 1s linear;\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n  from {\n    opacity: 1;\n  }\n\n  to {\n    opacity: 0;\n  }\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__["default"])(["\n  from {\n    opacity: 0;\n  }\n\n  to {\n    opacity: 1;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}










var Home =
/*#__PURE__*/
function (_React$Component) {
  Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__["default"])(Home, _React$Component);

  function Home() {
    var _this;

    Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Home);

    _this = Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Home).call(this));
    _this.state = {
      visible: true
    };
    return _this;
  }

  Object(_Users_jasonmandel_Queue_jm_site_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(Home, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      setTimeout(function () {
        _this2.setState({
          visible: true
        });
      }, 1000);
    }
  }, {
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement("div", {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 30
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(react_delayed__WEBPACK_IMPORTED_MODULE_8___default.a, {
        mounted: true,
        mountAfter: 350,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 31
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(Fade, {
        out: !this.state.visible,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 32
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(_components_Navigation__WEBPACK_IMPORTED_MODULE_10__["default"], {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 33
        },
        __self: this
      }))), react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(react_delayed__WEBPACK_IMPORTED_MODULE_8___default.a, {
        mounted: true,
        mountAfter: 700,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 36
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(Fade, {
        out: !this.state.visible,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 37
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(_components_About__WEBPACK_IMPORTED_MODULE_11__["default"], {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 38
        },
        __self: this
      }))), react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(react_delayed__WEBPACK_IMPORTED_MODULE_8___default.a, {
        mounted: true,
        mountAfter: 900,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 41
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(Fade, {
        out: !this.state.visible,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 42
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(_components_Work__WEBPACK_IMPORTED_MODULE_12__["default"], {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 43
        },
        __self: this
      }))), react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(react_delayed__WEBPACK_IMPORTED_MODULE_8___default.a, {
        mounted: true,
        mountAfter: 1000,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 46
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(Fade, {
        out: !this.state.visible,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 47
        },
        __self: this
      }, react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(_components_Colophon__WEBPACK_IMPORTED_MODULE_13__["default"], {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 48
        },
        __self: this
      }))));
    }
  }]);

  return Home;
}(react__WEBPACK_IMPORTED_MODULE_6___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (Home);
var fadeIn = Object(styled_components__WEBPACK_IMPORTED_MODULE_7__["keyframes"])(_templateObject());
var fadeOut = Object(styled_components__WEBPACK_IMPORTED_MODULE_7__["keyframes"])(_templateObject2());
var Fade = styled_components__WEBPACK_IMPORTED_MODULE_7___default.a.div(_templateObject3(), function (props) {
  return props.out ? 'hidden' : 'visible';
}, function (props) {
  return props.out ? fadeOut : fadeIn;
});
react_ga__WEBPACK_IMPORTED_MODULE_9___default.a.initialize('UA-68238638-2');
react_ga__WEBPACK_IMPORTED_MODULE_9___default.a.pageview(window.location.pathname + window.location.search);

/***/ }),

/***/ "./process":
/*!****************************!*\
  !*** external "./process" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./process");

/***/ }),

/***/ "./process.js":
/*!*******************************!*\
  !*** external "./process.js" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./process.js");

/***/ }),

/***/ "./punycode":
/*!*****************************!*\
  !*** external "./punycode" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./punycode");

/***/ }),

/***/ "./punycode.js":
/*!********************************!*\
  !*** external "./punycode.js" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./punycode.js");

/***/ }),

/***/ "./tls":
/*!************************!*\
  !*** external "./tls" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./tls");

/***/ }),

/***/ "./tls.js":
/*!***************************!*\
  !*** external "./tls.js" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./tls.js");

/***/ }),

/***/ "./tty":
/*!************************!*\
  !*** external "./tty" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./tty");

/***/ }),

/***/ "./tty.js":
/*!***************************!*\
  !*** external "./tty.js" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./tty.js");

/***/ }),

/***/ 3:
/*!******************************!*\
  !*** multi ./pages/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Users/jasonmandel/Queue/jm-site/pages/index.js */"./pages/index.js");


/***/ }),

/***/ "@webassemblyjs/ast":
/*!*************************************!*\
  !*** external "@webassemblyjs/ast" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("@webassemblyjs/ast");

/***/ }),

/***/ "@webassemblyjs/helper-module-context":
/*!*******************************************************!*\
  !*** external "@webassemblyjs/helper-module-context" ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("@webassemblyjs/helper-module-context");

/***/ }),

/***/ "@webassemblyjs/wasm-edit":
/*!*******************************************!*\
  !*** external "@webassemblyjs/wasm-edit" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("@webassemblyjs/wasm-edit");

/***/ }),

/***/ "@webassemblyjs/wasm-parser":
/*!*********************************************!*\
  !*** external "@webassemblyjs/wasm-parser" ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("@webassemblyjs/wasm-parser");

/***/ }),

/***/ "acorn":
/*!************************!*\
  !*** external "acorn" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("acorn");

/***/ }),

/***/ "acorn-dynamic-import":
/*!***************************************!*\
  !*** external "acorn-dynamic-import" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("acorn-dynamic-import");

/***/ }),

/***/ "ajv":
/*!**********************!*\
  !*** external "ajv" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("ajv");

/***/ }),

/***/ "ajv-keywords":
/*!*******************************!*\
  !*** external "ajv-keywords" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("ajv-keywords");

/***/ }),

/***/ "ansi-colors":
/*!******************************!*\
  !*** external "ansi-colors" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("ansi-colors");

/***/ }),

/***/ "autodll-webpack-plugin":
/*!*****************************************!*\
  !*** external "autodll-webpack-plugin" ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("autodll-webpack-plugin");

/***/ }),

/***/ "cacache":
/*!**************************!*\
  !*** external "cacache" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("cacache");

/***/ }),

/***/ "case-sensitive-paths-webpack-plugin":
/*!******************************************************!*\
  !*** external "case-sensitive-paths-webpack-plugin" ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("case-sensitive-paths-webpack-plugin");

/***/ }),

/***/ "chalk":
/*!************************!*\
  !*** external "chalk" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("chalk");

/***/ }),

/***/ "chrome-trace-event":
/*!*************************************!*\
  !*** external "chrome-trace-event" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("chrome-trace-event");

/***/ }),

/***/ "core-js/library/fn/array/is-array":
/*!****************************************************!*\
  !*** external "core-js/library/fn/array/is-array" ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("core-js/library/fn/array/is-array");

/***/ }),

/***/ "core-js/library/fn/get-iterator":
/*!**************************************************!*\
  !*** external "core-js/library/fn/get-iterator" ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("core-js/library/fn/get-iterator");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "del":
/*!**********************!*\
  !*** external "del" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("del");

/***/ }),

/***/ "enhanced-resolve":
/*!***********************************!*\
  !*** external "enhanced-resolve" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("enhanced-resolve");

/***/ }),

/***/ "enhanced-resolve/lib/AliasPlugin":
/*!***************************************************!*\
  !*** external "enhanced-resolve/lib/AliasPlugin" ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("enhanced-resolve/lib/AliasPlugin");

/***/ }),

/***/ "enhanced-resolve/lib/CachedInputFileSystem":
/*!*************************************************************!*\
  !*** external "enhanced-resolve/lib/CachedInputFileSystem" ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("enhanced-resolve/lib/CachedInputFileSystem");

/***/ }),

/***/ "enhanced-resolve/lib/NodeJsInputFileSystem":
/*!*************************************************************!*\
  !*** external "enhanced-resolve/lib/NodeJsInputFileSystem" ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("enhanced-resolve/lib/NodeJsInputFileSystem");

/***/ }),

/***/ "eslint-scope":
/*!*******************************!*\
  !*** external "eslint-scope" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("eslint-scope");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "find-cache-dir":
/*!*********************************!*\
  !*** external "find-cache-dir" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("find-cache-dir");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "glob":
/*!***********************!*\
  !*** external "glob" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("glob");

/***/ }),

/***/ "grid-styled":
/*!******************************!*\
  !*** external "grid-styled" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("grid-styled");

/***/ }),

/***/ "inspector":
/*!****************************!*\
  !*** external "inspector" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("inspector");

/***/ }),

/***/ "json-parse-better-errors":
/*!*******************************************!*\
  !*** external "json-parse-better-errors" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("json-parse-better-errors");

/***/ }),

/***/ "launch-editor":
/*!********************************!*\
  !*** external "launch-editor" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("launch-editor");

/***/ }),

/***/ "loader-runner":
/*!********************************!*\
  !*** external "loader-runner" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("loader-runner");

/***/ }),

/***/ "memory-fs":
/*!****************************!*\
  !*** external "memory-fs" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("memory-fs");

/***/ }),

/***/ "micromatch":
/*!*****************************!*\
  !*** external "micromatch" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("micromatch");

/***/ }),

/***/ "mkdirp":
/*!*************************!*\
  !*** external "mkdirp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("mkdirp");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("module");

/***/ }),

/***/ "neo-async":
/*!****************************!*\
  !*** external "neo-async" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("neo-async");

/***/ }),

/***/ "next-server":
/*!******************************!*\
  !*** external "next-server" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next-server");

/***/ }),

/***/ "next-server/constants":
/*!****************************************!*\
  !*** external "next-server/constants" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next-server/constants");

/***/ }),

/***/ "next-server/dist/server/next-server":
/*!******************************************************!*\
  !*** external "next-server/dist/server/next-server" ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next-server/dist/server/next-server");

/***/ }),

/***/ "next-server/dist/server/normalize-page-path":
/*!**************************************************************!*\
  !*** external "next-server/dist/server/normalize-page-path" ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next-server/dist/server/normalize-page-path");

/***/ }),

/***/ "next-server/dist/server/require":
/*!**************************************************!*\
  !*** external "next-server/dist/server/require" ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next-server/dist/server/require");

/***/ }),

/***/ "next-server/dist/server/router":
/*!*************************************************!*\
  !*** external "next-server/dist/server/router" ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next-server/dist/server/router");

/***/ }),

/***/ "next-server/head":
/*!***********************************!*\
  !*** external "next-server/head" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next-server/head");

/***/ }),

/***/ "node-libs-browser":
/*!************************************!*\
  !*** external "node-libs-browser" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("node-libs-browser");

/***/ }),

/***/ "node-libs-browser/mock/empty":
/*!***********************************************!*\
  !*** external "node-libs-browser/mock/empty" ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("node-libs-browser/mock/empty");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),

/***/ "range-parser":
/*!*******************************!*\
  !*** external "range-parser" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("range-parser");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),

/***/ "react-delayed":
/*!********************************!*\
  !*** external "react-delayed" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-delayed");

/***/ }),

/***/ "react-ga":
/*!***************************!*\
  !*** external "react-ga" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-ga");

/***/ }),

/***/ "react-p5-wrapper":
/*!***********************************!*\
  !*** external "react-p5-wrapper" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-p5-wrapper");

/***/ }),

/***/ "react-router-dom":
/*!***********************************!*\
  !*** external "react-router-dom" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-router-dom");

/***/ }),

/***/ "readline":
/*!***************************!*\
  !*** external "readline" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("readline");

/***/ }),

/***/ "rebass":
/*!*************************!*\
  !*** external "rebass" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("rebass");

/***/ }),

/***/ "resolve":
/*!**************************!*\
  !*** external "resolve" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("resolve");

/***/ }),

/***/ "serialize-javascript":
/*!***************************************!*\
  !*** external "serialize-javascript" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("serialize-javascript");

/***/ }),

/***/ "source-list-map":
/*!**********************************!*\
  !*** external "source-list-map" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("source-list-map");

/***/ }),

/***/ "source-map":
/*!*****************************!*\
  !*** external "source-map" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("source-map");

/***/ }),

/***/ "styled-components":
/*!************************************!*\
  !*** external "styled-components" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),

/***/ "tapable":
/*!**************************!*\
  !*** external "tapable" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tapable");

/***/ }),

/***/ "terser":
/*!*************************!*\
  !*** external "terser" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("terser");

/***/ }),

/***/ "terser-webpack-plugin":
/*!****************************************!*\
  !*** external "terser-webpack-plugin" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("terser-webpack-plugin");

/***/ }),

/***/ "unistore":
/*!***************************!*\
  !*** external "unistore" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("unistore");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "uuid/v4":
/*!**************************!*\
  !*** external "uuid/v4" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("uuid/v4");

/***/ }),

/***/ "vm":
/*!*********************!*\
  !*** external "vm" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("vm");

/***/ }),

/***/ "watchpack":
/*!****************************!*\
  !*** external "watchpack" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("watchpack");

/***/ }),

/***/ "worker-farm":
/*!******************************!*\
  !*** external "worker-farm" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("worker-farm");

/***/ })

/******/ });
//# sourceMappingURL=index.js.map